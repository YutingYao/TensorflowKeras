<!-- vscode-markdown-toc -->
* 1. [经验](#)
* 2. [算法](#-1)
* 3. [题目](#-1)
	* 3.1. [1 Two Sum](#TwoSum)
	* 3.2. [2. Add Two Numbers](#AddTwoNumbers)
	* 3.3. [3. 【滑动窗口🔹】数组中重复的数字 Longest Substring Without Repeating Characters](#LongestSubstringWithoutRepeatingCharacters)
	* 3.4. [4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays](#MedianofTwoSortedArrays)
	* 3.5. [5. 【回文🌈】Longest Palindromic Substring -最长回文🌈子串](#LongestPalindromicSubstring-)
	* 3.6. [6. ZigZag Conversion](#ZigZagConversion)
	* 3.7. [7 Reverse Integer](#ReverseInteger)
	* 3.8. [8. String to Integer(atoi)](#StringtoIntegeratoi)
	* 3.9. [9-【回文🌈】Palindrome](#Palindrome)
	* 3.10. [11. Container With Most Water](#ContainerWithMostWater)
	* 3.11. [12. Integer to Roman](#IntegertoRoman)
	* 3.12. [13. 机器人的运动范围](#-1)
	* 3.13. [13. Roman to Integer](#RomantoInteger)
	* 3.14. [14-Longest common prefix](#Longestcommonprefix)
	* 3.15. [15. 3Sum](#Sum)
	* 3.16. [16. 3Sum Closest](#SumClosest)
	* 3.17. [17. Letter Combinations of a Phone Number](#LetterCombinationsofaPhoneNumber)
	* 3.18. [19-Remove Nth Node From End of List](#RemoveNthNodeFromEndofList)
	* 3.19. [20-Valid parentheses](#Validparentheses)
	* 3.20. [21-Merge two sorted lists](#Mergetwosortedlists)
	* 3.21. [22. Generate Parentheses](#GenerateParentheses)
	* 3.22. [23. 【最小堆🌵】Merge k Sorted Lists](#MergekSortedLists)
	* 3.23. [24-Swap Nodes in Pairs](#SwapNodesinPairs)
	* 3.24. [26-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray)
	* 3.25. [27-python-Remove element](#python-Removeelement)
	* 3.26. [28-Implement str](#Implementstr)
	* 3.27. [31 Next Permutation](#NextPermutation)
	* 3.28. [32 Longest Valid Parentheses](#LongestValidParentheses)
	* 3.29. [33. Search in Rotated Sorted Array](#SearchinRotatedSortedArray)
	* 3.30. [34-在排序数组中查找元素的第一个](#-1)
	* 3.31. [35-搜索插入位置](#-1)
	* 3.32. [36-有效的数独](#-1)
	* 3.33. [37. Sudoku Solver 解数独](#SudokuSolver)
	* 3.34. [38-Count and say](#Countandsay)
	* 3.35. [39. Combination Sum 39-组合总和](#CombinationSum39-)
	* 3.36. [40. Combination Sum II 40-组合总和 II](#CombinationSumII40-II)
	* 3.37. [41 First Missing Positive](#FirstMissingPositive)
	* 3.38. [42. Trapping Rain Water](#TrappingRainWater)
	* 3.39. [45 Jump Game II](#JumpGameII)
	* 3.40. [46-把数字翻译成字符串](#-1)
	* 3.41. [46-全排列](#-1)
	* 3.42. [47-全排列 II-剪枝版](#II-)
	* 3.43. [48. 旋转图像 Rotate Image](#RotateImage)
	* 3.44. [49 Group Anagrams](#GroupAnagrams)
	* 3.45. [50 Pow(x, n)](#Powxn)
	* 3.46. [51. 数组中的逆序对](#-1)
	* 3.47. [53-【贪心🧡】Maximum subarray](#Maximumsubarray)
	* 3.48. [54. Spiral Matrix](#SpiralMatrix)
	* 3.49. [55 Jump Game](#JumpGame)
	* 3.50. [56-I. 数组中数字出现的次数](#I.)
	* 3.51. [56. Merge Intervals](#MergeIntervals)
	* 3.52. [57. Insert Interval](#InsertInterval)
	* 3.53. [58. Lengh of Last Words](#LenghofLastWords)
	* 3.54. [59 - II. 队列的最大值 LCOF](#II.LCOF)
	* 3.55. [59. Spiral Matrix II](#SpiralMatrixII)
	* 3.56. [61. Rotate List](#RotateList)
	* 3.57. [62-不同路径](#-1)
	* 3.58. [63 Unique Paths II](#UniquePathsII)
	* 3.59. [64. Minimum Path Sum 64-最小路径和](#MinimumPathSum64-)
	* 3.60. [65 Valid Number](#ValidNumber)
	* 3.61. [66 Plus one](#Plusone)
	* 3.62. [67-Add Binary](#AddBinary)
	* 3.63. [69 Sqrt(x)](#Sqrtx)
	* 3.64. [70. Climbing Stairs](#ClimbingStairs)
	* 3.65. [71. Simplify Path](#SimplifyPath)
	* 3.66. [72. Edit Distance 72-编辑距离](#EditDistance72-)
	* 3.67. [73. Set Matrix Zeroes](#SetMatrixZeroes)
	* 3.68. [74 Search a 2D Matrix](#Searcha2DMatrix)
	* 3.69. [75. Sort Colors](#SortColors)
	* 3.70. [76-【滑动窗口🔹】最小覆盖子串](#-1)
	* 3.71. [77. 组合](#-1)
	* 3.72. [78. 【位运算😜】Subsets 子集](#Subsets)
	* 3.73. [79. Word Search](#WordSearch)
	* 3.74. [80 Remove Duplicates from Sorted Array II](#RemoveDuplicatesfromSortedArrayII)
	* 3.75. [82. 删除排序链表中的重复元素 II(Remove Duplicates from Sorted List](#IIRemoveDuplicatesfromSortedList)
	* 3.76. [83-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray-1)
	* 3.77. [84. 柱状图中最大的矩形 Largest Rectangle in Histogram](#LargestRectangleinHistogram)
	* 3.78. [86. 分隔链表(Partition List)](#PartitionList)
	* 3.79. [87. Scramble String](#ScrambleString)
	* 3.80. [88-Merge sorted array](#Mergesortedarray)
	* 3.81. [ 89. 格雷编码](#89.)
	* 3.82. [90-子集 II](#II)
	* 3.83. [91. Decode Ways](#DecodeWays)
	* 3.84. [92-Reverse Linked List II](#ReverseLinkedListII)
	* 3.85. [ 93. 复原 IP 地址](#93.IP)
	* 3.86. [94-Inorder wih stack](#Inorderwihstack)
	* 3.87. [94-Binary Tree Inorder Traversal](#BinaryTreeInorderTraversal)
	* 3.88. [95. 不同的二叉搜索树 II](#II-1)
	* 3.89. [96. Unique Binary Search Trees](#UniqueBinarySearchTrees)
	* 3.90. [98. Validate Binary Search Tree 98-验证二叉搜索树](#ValidateBinarySearchTree98-)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
##  1. <a name=''></a>经验

[花花酱](https://www.bilibili.com/video/BV14E411R7Wa?spm_id_from=333.999.0.0)

[Leetcode刷题阶段性总结（一些建议与思考）哈哈哈](https://www.bilibili.com/video/BV14K4y1a7Yk?spm_id_from=333.999.0.0)

[LeetCode题库过千，刷题改如何规划？【刷题规划系列】](https://www.bilibili.com/video/BV1Xp4y1a7Z3?spm_id_from=333.999.0.0)

[如何正确刷题？LeetCode刷题误区和刷题方法论分享](https://www.bilibili.com/video/BV1nz4y197U3?spm_id_from=333.999.0.0)

[算法新手如何刷力扣（LeetCode）？【干货分享】](https://www.bilibili.com/video/BV17K411J7yR?spm_id_from=333.999.0.0)

[硅谷资深技术面试官教你拿顶级科技公司 Offer【面试篇】](https://www.bilibili.com/video/BV1fV411y743?spm_id_from=333.999.0.0)

[ACM 金牌大神是如何学算法的？【LeetCode 干货】](https://www.bilibili.com/video/BV1gv411179E?spm_id_from=333.999.0.0)

[硅谷资深技术面试官教你拿顶级科技公司 Offer【准备篇】](https://www.bilibili.com/video/BV1Kf4y197Rk?spm_id_from=333.999.0.0)

[BAT 大厂 Offer 收割机是怎样炼成的？技术面试通关全攻略](https://www.bilibili.com/video/BV1E5411h7Jr?spm_id_from=333.999.0.0)

##  2. <a name='-1'></a>算法

[图灵星球 - 什么是数据结构和算法？二分搜索剖析](https://www.bilibili.com/video/BV1H7411n79u?spm_id_from=333.999.0.0)

[图灵星球 - 时间复杂度和空间复杂度，大O表示法](https://www.bilibili.com/video/BV14j411f7DJ?spm_id_from=333.999.0.0)

[图灵星球 - 排序算法：插入排序，快排，归并排序](https://www.bilibili.com/video/BV1QE41177ST?spm_id_from=333.999.0.0)

[图灵星球 - 链表 Linked List【数据结构和算法入门4】](https://www.bilibili.com/video/BV1rE411g788?spm_id_from=333.999.0.0)

[图灵星球 - 堆栈Stack, 队列Queue【数据结构和算法入门5】](https://www.bilibili.com/video/BV1QE41137tw?spm_id_from=333.999.0.0)

[图灵星球 - 哈希表HashMap【数据结构和算法入门6】](https://www.bilibili.com/video/BV1si4y1b7Rs?spm_id_from=333.999.0.0)

[图灵星球 - 二叉搜索树（排序二叉树），树的遍历（前序、中序、后序）](https://www.bilibili.com/video/BV1qQ4y1M7Z4?spm_id_from=333.999.0.0)

[图灵星球 - 优先队列PriorityQueue，堆Heap](https://www.bilibili.com/video/BV1ti4y1879c?spm_id_from=333.999.0.0)

[图灵星球 - 图Graph, 深度优先遍历(DFS), 广度优先遍历(BFS)](https://www.bilibili.com/video/BV1254y1976m?spm_id_from=333.999.0.0)

[图灵星球 - Array题型：双指针Two Pointers套路](https://www.bilibili.com/video/BV1V54y1Q7bd?spm_id_from=333.999.0.0)

[图灵星球 - 二分查找Binary Search套路和解题模板](https://www.bilibili.com/video/BV1Ng4y1q7E3?spm_id_from=333.999.0.0)

[图灵星球 - Linked List链表题型解题套路和模板](https://www.bilibili.com/video/BV1QD4y1D7av?spm_id_from=333.999.0.0)

[图灵星球 - Stack堆栈解题套路](https://www.bilibili.com/video/BV1Hi4y1x7fX?spm_id_from=333.999.0.0)

[图灵星球 - Heap堆解题套路](https://www.bilibili.com/video/BV1XZ4y1M799?spm_id_from=333.999.0.0)

[图灵星球 - 哈希表HashMap解题套路](https://www.bilibili.com/video/BV1KC4y1h7zV?spm_id_from=333.999.0.0)

[图灵星球 - 树Tree题型广度优先搜索BFS套路](https://www.bilibili.com/video/BV1T5411e7D2?spm_id_from=333.999.0.0)

[图灵星球 - 树Tree深度优先搜索DFS解题套路](https://www.bilibili.com/video/BV1xT4y1E7TD?spm_id_from=333.999.0.0)

[图灵星球 - Graph图BFS广度优先搜索套路](https://www.bilibili.com/video/BV1HA411v753?spm_id_from=333.999.0.0)

[图灵星球 - Graph图Best-First Search题型套路](https://www.bilibili.com/video/BV1NK4y1v75h?spm_id_from=333.999.0.0)

[图灵星球 - Graph图DFS深度优先搜索题型套路](https://www.bilibili.com/video/BV1vv411q769?spm_id_from=333.999.0.0)

[图灵星球 - Search, Dynamic Programming1](https://www.bilibili.com/video/BV1hf4y197w3?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming1D解题套路](https://www.bilibili.com/video/BV1CD4y127CZ?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D解题套路](https://www.bilibili.com/video/BV1sk4y1y7Dv?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D进阶解题套路](https://www.bilibili.com/video/BV12k4y127nP?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D高级解题套路](https://www.bilibili.com/video/BV14z4y1f7hH?spm_id_from=333.999.0.0)

[图灵星球 - Backtracking回溯解题套路](https://www.bilibili.com/video/BV1Ty4y1E7RM?spm_id_from=333.999.0.0)

[哈哈哈 DSU(并查集实现)-Python](https://www.bilibili.com/video/BV19K4y1b7vT?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(广度优先遍历BFS)(1)](https://www.bilibili.com/video/BV1H7411D7Nm?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(深度优先遍历DFS)(2)](https://www.bilibili.com/video/BV1H7411D73V?spm_id_from=333.999.0.0)

[哈哈哈 二分查找(Binary Search)合集](https://www.bilibili.com/video/BV1254y1B7xK?spm_id_from=333.999.0.0)

[哈哈哈 Bubble_sort(用Python实现冒泡排序)(1)](https://www.bilibili.com/video/BV19E411E7df?spm_id_from=333.999.0.0)

[哈哈哈 Selected_sort(用Python实现选择排序)(2)](https://www.bilibili.com/video/BV1AE411t7Pr?spm_id_from=333.999.0.0)

[哈哈哈 Single linked list-Python(链表功能扩展-有条件翻转链表)（2）](https://www.bilibili.com/video/BV1n7411G7rc?spm_id_from=333.999.0.0)

[哈哈哈 Inserted_sort(用Python实现插入排序)(3)](https://www.bilibili.com/video/BV1SE411p7zn?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(深度优先遍历的迭代实现)(3)](https://www.bilibili.com/video/BV1V54y197qo?spm_id_from=333.999.0.0)

[哈哈哈 Shell_sort(用Python实现希尔排序)(4)](https://www.bilibili.com/video/BV1SE411T7t1?spm_id_from=333.999.0.0)

[哈哈哈 Quick_sort(用Python实现快速排序)(5)](https://www.bilibili.com/video/BV1d7411R75g?spm_id_from=333.999.0.0)

[哈哈哈 Merge_sort(用Python实现合并排序)(6)](https://www.bilibili.com/video/BV1gE411c7PR?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV16b411N7o7?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV1hb411P7C2?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV1wb4y1b7df?spm_id_from=333.999.0.0)

[Maximum Subarray DP 花花酱](https://www.bilibili.com/video/BV1yg411A7D4?spm_id_from=333.999.0.0)

[Maximum Product Subarray DP 花花酱](https://www.bilibili.com/video/BV18q4y1z7TC?spm_id_from=333.999.0.0)

[Fast Power for DP 花花酱](https://www.bilibili.com/video/BV1Je411s7NM?spm_id_from=333.999.0.0)

[Best Time to Buy and Sell Stock DP 花花酱](https://www.bilibili.com/video/BV1Tg411P7S9?spm_id_from=333.999.0.0)

[Disjoint-set/Union-find Forest 花花酱](https://www.bilibili.com/video/BV1jW411d7vi?spm_id_from=333.999.0.0)

[Best Time to Buy and Sell Stock with  DP 花花酱](https://www.bilibili.com/video/BV1sq4y1q768?spm_id_from=333.999.0.0)

[二叉树 花花酱](https://www.bilibili.com/video/BV1Gt411e7zm?spm_id_from=333.999.0.0)

[背包问题 花花酱](https://www.bilibili.com/video/BV1ot411m7wv?spm_id_from=333.999.0.0)

[背包问题 2 花花酱](https://www.bilibili.com/video/BV1Dt411U7eM?spm_id_from=333.999.0.0)

[最小生成树 (Minimum Spanning Tree)  花花酱](https://www.bilibili.com/video/BV1A7411Y7mT?spm_id_from=333.999.0.0)

[Binary Search 花花酱](https://www.bilibili.com/video/BV1yW411Z7um?spm_id_from=333.999.0.0)

[Binary Search II 花花酱](https://www.bilibili.com/video/BV1ub411V7gs?spm_id_from=333.999.0.0)

[Fenwick Tree / Binary Indexed Tree 花花酱](https://www.bilibili.com/video/BV1EW411d75F?spm_id_from=333.999.0.0)

[Input Size V.S. Time Complexity 花花酱](https://www.bilibili.com/video/BV1jW411d7a2?spm_id_from=333.999.0.0)

[Time/Space Complexity of Recursive Algorithms 花花酱](https://www.bilibili.com/video/BV1JW411d714?spm_id_from=333.999.0.0)

[Segment Tree 花花酱](https://www.bilibili.com/video/BV1bb411y78M?spm_id_from=333.999.0.0)

[Min Heap 花花酱](https://www.bilibili.com/video/BV1cy4y1q7P1?spm_id_from=333.999.0.0)

[Amortized Analysis 均摊分析 花花酱](https://www.bilibili.com/video/BV1NW411C7v7?spm_id_from=333.999.0.0)

[Recursion unrolling and performance measurement](https://www.bilibili.com/video/BV1Gt411r7MS?spm_id_from=333.999.0.0)


##  3. <a name='-1'></a>题目

###  3.1. <a name='TwoSum'></a>1 Two Sum

[哈哈哈](https://www.bilibili.com/video/BV1rE411Y7UN?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV19b411v7qp?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zf4y1G7W4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rv411k7VY?spm_id_from=333.999.0.0)

暴力求解：

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i] + nums [j] == target:
                    return [i,j]
```

查找表法:

* 哈希表(不需要维护表的顺序性)

* 平衡二叉搜素树

* 时间复杂度:O(n)

* 时间复杂度:O(n)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i,n in enumerate(nums):
            if n in dic:
                return [dic[n],i]
            dic[target - n] = i
```

```scala
object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        val nums_map = scala.collection.mutable.HashMap[Int, Int]()
        var result: Array[Int] = Array(0,0)
        var i = 0
        while(result.sum == 0) {
            val complement = target - nums(i)
            if (nums_map.contains(complement)) {
                result(0) = i
                result(1) = nums_map(complement)
            } else {
                nums_map(nums(i)) = i
            }
            i += 1
        }
        result     
    }
}



// Brute-force method, which takes more than two times of running time than the method above
object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        
        val result = for {i <- 0 until (nums.length - 1);
            j <- (i+1) until nums.length
            if nums(i) + nums(j) == target} yield Array(i, j)
        
        result(0)
        
    }
}

/**
* chosen solution
* time complexity: O(N)
*/


object Solution0 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}

/**
* HashTable
* time complexity: O(N)
*/

object Solution1 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    val ret = collection.mutable.ArrayBuffer[Int]()

    for ((n, idx) <- nums.zipWithIndex; if ret.length < 2) {
      val v2 = target - n
      value2Idx.get(v2) match {
        case Some(v2Idx) if v2Idx != idx =>
          ret ++= Array(idx, v2Idx)
        case _ =>
      }
    }
    ret.toArray
  }
}


/**
* more elegant
*/


object Solution1-2 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}
```

```scala
object leetcode01_two_sum extends App {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val sorted = nums.zipWithIndex.sortWith(_._1 < _._1)
    var left = 0
    var right = sorted.length - 1
    while(left < right) {
      val cal = sorted(left)._1 + sorted(right)._1
      if(cal > target) {
        right = right - 1
      } else if (cal < target) {
        left = left + 1
      } else {
        return Array(sorted(left)._2, sorted(right)._2)
      }
    }
    return Array.emptyIntArray
  }

  twoSum(Array(3,2,4), 6)
}


object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        var map = Map.empty[Int, Int]
        var result = Array.empty[Int]
        (0 until nums.length) foreach { i =>
            val v = nums(i)
            map.get(target - v) match {
                case Some(x)  =>
                    if (x != i){
                    result = Array(x, i)
                    }
                case _ => map += v -> i
            }
        }
        result
    }
}

```

###  3.2. <a name='AddTwoNumbers'></a>2. Add Two Numbers

[花花酱](https://www.bilibili.com/video/BV1EJ411h72z?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1gJ411V7gJ?spm_id_from=333.999.0.0)

[小梦想](https://www.bilibili.com/video/BV1Wb411e77s?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1rZ4y1j7V3?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DA411L7YQ?spm_id_from=333.999.0.0)

* 时间复杂度:O(max(m,n))

* 时间复杂度:O(max(m,n))

特殊情况：

两个链表的长度不同。

进位

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = pointer = ListNode(0) # 易错点：定义一个dummy和一个pointer，都指向ListNode(0)
        carry = 0 # 易错点：carry需要先赋值
        while l1 or l2 or carry: # 易错点：carry要存在
            # 易错点：l1,l2不一定存在，所以不能写成：sumNode = l1 + l2
            # 易错点：调用listnode要有.val
            sumNode = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            tail = sumNode % 10
            carry = sumNode // 10
            pointer.next = ListNode(tail)
            pointer = pointer.next
            # # l1,l2不一定存在，所以不能写成：l1 = l1.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */

 /**
 * my first commitment
 * time complexity O(max(l1.length, l2.length))
 */
object Solution1 {
    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
      val dummyHead = ListNode()
      var current = dummyHead
      var (p1, p2) = (l1, l2)
      var carry = 0
      while(p1 != null && p2 != null) {
        val sum = carry + p1.x + p2.x
        carry = sum / 10
        
        current.next = ListNode(sum % 10)
        current = current.next
        p1 = p1.next
        p2 = p2.next
      }
      
      while(p1 != null) {
        val sum = carry + p1.x
        carry = sum / 10
        current.next = ListNode(sum % 10)  
        current = current.next
        p1 = p1.next
      }
      while(p2 != null) {
        val sum = carry + p2.x
        carry = sum / 10
        current.next = ListNode(sum % 10)
        current = current.next
        p2 = p2.next
      }
      if (carry > 0)
        current.next = ListNode(carry)
      dummyHead.next
    }
}

object Solution {
    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
      var cur1 = l1
      var cur2 = l2
      val dummy = ListNode(0)
      var prev=dummy
      var carry = 0
      while (cur1!=null ||  cur2!=null || carry !=0) {
        val (s1,next1) = cur1 match {
          case null => (0,null)
          case _=> (cur1.x, cur1.next)
        }
        val (s2,next2) = cur2 match {
          case null => (0,null)
          case _=> (cur2.x,cur2.next)
        }
        val s = s1+s2+carry
        val node = ListNode(s % 10)
        prev.next = node
        prev=node
        carry=s/10
        cur1 = next1
        cur2=next2
      }
      dummy.next
    }
  }
```

###  3.3. <a name='LongestSubstringWithoutRepeatingCharacters'></a>3. 【滑动窗口🔹】数组中重复的数字 Longest Substring Without Repeating Characters

[哈哈哈](https://www.bilibili.com/video/BV1h54y1B7No?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1CJ411G7Nn?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1va4y1J7Gx?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ob411n7mv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K411M7d2?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DK4y1b7xp?spm_id_from=333.999.0.0)

方法一：暴力解法

* 时间复杂度: 2个指针遍历字符串O(n2) + hashset判断是否重复O(n) = O(n3)

* 时间复杂度: O(m), m 为所有可能出现的情况

方法二：涉及 sub 的问题，可以使用 “滑动窗口”

特殊情况：

* 字符串为空
  
* 字符串均为重复字符串

* 时间复杂度: O(n) + hashset判断是否重复O(n) = O(n3)

* 时间复杂度: O(m), m 为所有可能出现的情况

```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dic = {}
        start = 0
        res = 0
        for i, char in enumerate(s):
            if char in dic and start <= dic[char]:
                # 易错点: and start <= dic[char]: 
                # 含义为"tmmzuxt",
                # start在m，当有新的t进来时，上一个t在start的前面，所以，此时的start不需要修改
                start = dic[char] + 1 # 易错点: 这里的dic[char]还是前一个,且 +1
            else:
                res = max(res,i-start+1) # 易错点: +1
            dic[char] = i # 易错点: dic[char]滞后更新
        return res
```

```scala
/**
* chosen solution
* two pointer to control sliding window
*   1. two pointer: left and right to control substring window
*   2. counter and hashmap to record whether current window is valid or not
* time  complexity: O(N), worst: O(2N) -> each char was visited twice
*/

object Solution0 {
  def lengthOfLongestSubstring(s: String): Int = {
    val sMap = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0)).toMap
    var left = 0
    var right = 0
    var counter = 0
    var length = 0
    while (right < s.length) {
      val rightChar = s(right)
      sMap.get(rightChar) match {
        case Some(v) if v >= 1 =>
          sMap.update(rightChar, v + 1)
          counter += 1
        case Some(v) =>
          sMap.update(rightChar, v + 1)
      }
      right += 1
      while (counter > 0) {
        val leftChar = s(left)
        sMap.get(leftChar) match {
          case Some(v) if v > 1 =>
            sMap.update(leftChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(leftChar, v - 1)
        }

        left += 1

      }
      length = length max (right - left)
    }
    length
  }
}


/**
* my first commit
* sliding windows
*  time  complexity: O(N), worst: O(2N) -> each char was visited twice
*/
object Solution1 {
    def lengthOfLongestSubstring(s: String): Int = {
        var right = 0
        var left = 0
        var current = ""
        var ret = ""
        
        while(right < s.length) {
            val char = s(right)
            if (current.contains(char)){
                current = current.drop(1)
                left += 1
                 
            }else {
                right += 1
                current += char
            }     
            if(current.length > ret.length) ret = current
        }
        ret.length
    }
}


/**
* sliding windows, slower than solution1
*   memo
*     1. using hashmap to record whether the current right char is duplicated or not
*/
object Solution1-2 {
    def lengthOfLongestSubstring(s: String): Int = {
        val map = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0))
        var left = 0
        var right = 0
        var length = 0
        
        while(right < s.length){
            val rightChar = s(right)
        
            map.update(rightChar, map(rightChar) + 1)
            right += 1
            
            /* iterate until meet condition */
            while(map(rightChar) > 1){
                val leftChar = s(left)
                
                map.get(leftChar) match {
                    case Some(v) if v > 0 =>  map.update(leftChar,  v - 1)
                    case _ =>
                }
                
                left += 1
            }

            length = length max (right - left)  // update minimum
               
        }
        length
    }
}

/**
* using substring problem template
*   1. two pointer: left and right to control substring window
*   2. counter and hashmap to record whether current window is valid or not
*/
object Solution1-3 {
  def lengthOfLongestSubstring(s: String): Int = {
    val sMap = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0)).toMap
    var left = 0
    var right = 0
    var counter = 0
    var length = 0
    while (right < s.length) {
      val rightChar = s(right)
      sMap.get(rightChar) match {
        case Some(v) if v >= 1 =>
          sMap.update(rightChar, v + 1)
          counter += 1
        case Some(v) =>
          sMap.update(rightChar, v + 1)
      }
      right += 1
      while (counter > 0) {
        val leftChar = s(left)
        sMap.get(leftChar) match {
          case Some(v) if v > 1 =>
            sMap.update(leftChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(leftChar, v - 1)
        }

        left += 1

      }
      length = length max (right - left)
    }
    length
  }
}

object Solution {
    //s.zipWithIndex.foreach(println) // =>tuple
    //   def foldLeft[B](z: B)(op: (B, A) => B): B = {
    // 解释 z: 初始值,
    // op (B,A) => B前一个结果，A本次输入,返回作为下一个输入
    def lengthOfLongestSubstring(s: String): Int = {
      s.zipWithIndex.foldLeft((0, -1, Map[Char, Int]())) {
        case ((len, start_pos, map), (char, i)) => {
          // 初始值len=0,start_pos=-1,map为空; case A,B; 前者为累加值，后者为index
          // 如果char不存在,last_pos=-1,更新map中的idx,len=i-start_pos
          // 如果last_pos已存在,例如abca,第一个a为0,第二个a为3,则len=3-0,跟新start_pos
          val last_pos = map.getOrElse(char, -1)
          if (last_pos >= start_pos) (len.max(i - last_pos), last_pos, map + (char -> i))
          else (len.max(i - start_pos), start_pos, map + (char -> i))
        }
      }._1
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.lengthOfLongestSubstring("abcabcbb")==3)
    }
    val name = "003 Longest Non repeat str"
  }
```

###  3.4. <a name='MedianofTwoSortedArrays'></a>4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays

[官方](https://www.bilibili.com/video/BV1Xv411z76J?spm_id_from=333.999.0.0)

###  3.5. <a name='LongestPalindromicSubstring-'></a>5. 【回文🌈】Longest Palindromic Substring -最长回文🌈子串

[花花酱](https://www.bilibili.com/video/BV18J411j7Pb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1ra4y1Y7Gx?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7P6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1so4y1o765?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1L54y1D7pa?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n3),在两个for循环里面，还做了一次遍历

* 时间复杂度:O(1)

中心扩散法：

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.4sfvjkqc4qo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ur1lzo89kk0.png)

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        strLen = len(s)
        if strLen == 1:
            return s

        mid = 0
        strStart = strEnd = 0
        maxLen = 1



        while mid < strLen:

            # 优化：
            if strLen - mid <= maxLen/2:
                break

            start = end = mid
            
            # 第一步：
            while end + 1 < strLen and s[end] == s[end+1]: # 注意边界
                end += 1

            # 第二步：
            while  end + 1 < strLen and start > 0 and s[start-1] == s[end+1]: # 注意边界
                start -= 1
                end += 1
            
            # 第三步：
            if end - start + 1 > maxLen:
                maxLen = end - start + 1
                strStart = start
                strEnd = end

            mid += 1

        return s[strStart:strEnd+1]
```

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s


        def getLen(l,r) -> int:
            while l>=0 and r<lenStr and s[l] == s[r]: # 注意：边界
                l -= 1
                r += 1
            return r - l - 1 # 注意：是 “-1”

        start = 0  
        end = 1 # 注意：在第一次的时候，end = 1
        maxmaxLen = maxLen = 1

        for mid in range(lenStr):
            maxLen = max(getLen(mid,mid),getLen(mid,mid+1))
            
            if maxLen > maxmaxLen:
                maxmaxLen = maxLen
                start = mid - (maxLen-1) // 2 #易错点：-1，最好背一背
                end = start + maxLen
        return s[start:end]
```

动态规划法：

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.67y5euem0vo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.90ngy2t8j3k.png)

* 时间复杂度:O(n2)

* 时间复杂度:O(n2)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)
        maxlen = maxmaxlen = 1
        start = 0

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s

        dp = [[False for _ in range(lenStr)] for _ in range(lenStr)]
        for i in range(lenStr):
            dp[1][1] = True 
            # dp[1][1]是正确写法，dp[1,1]是错误写法

        for j in range(1,lenStr): # 把三角形画出来，先j，再i，
            for i in range(j):
                if s[i] == s[j]:
                    if j-i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i+1][j-1]
                if dp[i][j]:
                    maxlen = j-i+1
                    if maxlen > maxmaxlen:
                        maxmaxlen = maxlen
                        start = i
        return s[start:start+maxmaxlen]
```

Manacher算法：

不要求

```scala
/**
* chosen solution
* expand around center
* time complexity: O(N * 2 * N) = O(N^2)
*        expandLengths: O(N)
* space complexity: O(1)
*/

object Solution0 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty) return ""
        
        // 0 1 2 3 4 5 6 7
        // r a c e c a r
        // r a c e e c a r
        // b b c e c a a
        val (head, maxlen) = s.indices.foldLeft((0, 1)){
            case ((h, maxlen), i) => 
                val oddlen =  expandLengths(s, i, i)
                val evenlen = expandLengths(s, i, i + 1)
                val len = oddlen max evenlen
                if(len > maxlen)  (i -  (len - 1) / 2, len)
                else (h, maxlen)
        }
        s.slice(head, head + maxlen)
    }
    // return length
    @annotation.tailrec
    def expandLengths(s: String, left: Int, right: Int): Int = {
        if(0 <= left && right < s.length && s(left) == s(right)) expandLengths(s, left - 1, right + 1)
        else right - left - 1
    }
}

/**
* my first commitment
* it's kind of brute force
* time complexity: O(N^3):
*    getPalindromeLength: O(N^2)
* space complexity: O(N)
*/

object Solution1 {
  def longestPalindrome(s: String): String = {
    /* palindromeLength(i) means  the maximum palindrome length ending at string s's index i
    *   ex:
    *     input
    *         "b a b a d"
    *          0 1 2 3 4
    *     palindromeLength(0) = 1: "b"'s max palindrome length must contains the last char => "b"
    *     palindromeLength(1) = 2: "ba"'s max palindrome length must contains the last char => "a"
    *     palindromeLength(2) = 3: "bab"'s max palindrome length must contains the last char => "bab"
    *     palindromeLength(3) = 3: "baba"'s max palindrome length must contains the last char => "baba"
    *     palindromeLength(4) = 1: "babad"'s max palindrome length must contains the last char => "babad"
    * 
    * */
    val palindromeLength = Array.ofDim[Int](s.length)
    for(right <- s.indices){

      palindromeLength(right) = getPalindromeLength(s.slice(0, right + 1))
      // println("---", right, s.slice(0, right + 1).mkString(""), cache(right))
    }
    // println(cache.mkString(","))
    val maxIdx = palindromeLength.indices.maxBy(palindromeLength)

    s.slice(maxIdx - palindromeLength(maxIdx) + 1, maxIdx + 1)

  }

  /**
    * find the letter part may contains palindrome
    * iterate left2right from 0 s.length. right2left decreases 1 if s(left2right) == s(right2left)
    * the result value of right2left is the index dividing s into two part, the latter part may contains palindrome
    * ex:
    *    input:
    *         "b a a c b a b c"
    *          0 1 2 3 4 5 6 7
    *    the splitIdx would be 2, so s[3: 7) may contains palindrome and we should recursively input s[3: 7) to check it
    */
  @annotation.tailrec
  def getPalindromeLength(s: String): Int = {
    if(s == null || s.isEmpty) return 0

    val splitIdx = s.indices.foldLeft(s.length - 1){
      case (right2left, left2right) =>
        if(s(right2left) == s(left2right)) right2left - 1
        else right2left
    }
    // println(s, splitIdx)
    if(splitIdx == -1) /* find the palindrome! */
      s.length
    else
      getPalindromeLength(s.slice(splitIdx + 1, s.length))
  }
}


/**
* brute force
* time complexity: O(N^3)
* space complexity: O(M) M is the length of longest palindrome
*/

object Solution2 {
    def longestPalindrome(s: String): String = {
        (for(i <- s.indices; j <- i until s.length) yield (i, j)).foldLeft("") {
            // pruning
            case (best, (i, j)) if best.length < (j - i + 1) && isPalindrome(s, i, j) => s.slice(i, j + 1)
            case (best, _) => best
        }

    }
    // r a c e e c a r
    // 0 1 2 3 4 5 6 7
    
    @annotation.tailrec
    def isPalindrome(s: String, l: Int, r: Int): Boolean = {
    
        if(s == null || s.isEmpty) false
        else if(l >= r) true
        else { // l < r
            // println(l, s(l), r, s(r))
            if(s(l) != s(r)) false
            else isPalindrome(s, l + 1, r - 1)
        }
        
    } 
}

/**
* dynamic programming
* state definition
*     dp(i)(j) represents wether substring s(i: j) is palindromic
*     ex: 
*       s: "r a c e c a r"
*           0 1 2 3 4 5 6
*       dp(1)(5) is true due to "a c e c a" is palindrome
* state transformation
*      1.dp(i)(j) = (s(i) == s(j)) && dp(i + 1)(j - 1) if  (j - i) - (i + 1) + 1 < 2 
*         due to dp(i + 1)(j - 1) exceeds the edge 
*         ex:
*         s: "l e e t c o d e"
*             0 1 2 3 4 5 6 7
*         let i = 3, j = 4 => i + 1 = 4, j - 1 = 3 => dp(i + 1)(j - 1) = dp(4)(3) => it doesn't make sense
*   
* time complexity: O(N^2)
* space complexity: O(N^2)
*/
object Solution3 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty ) return ""
        if(s.length < 2) return s
        
        /**
        * if we initial the dp table dp(i)(j) with iterating all of element, it's time consuming
        */
        // val dp = Array.tabulate(s.length, s.length){
        //     case (i, j) if i == j => true
        //     case _ => false
        // }
        val dp = Array.ofDim[Boolean](s.length, s.length)
        var maxLen = 1
        var head = 0
        /** dp(i)(j) = (s(i) == s(j)) && dp(i + 1)(j - 1)
        * dp(i)(j)  depends on dp(i + 1)(j - 1), so we need calculate dp(i + 1)(j - 1) before we calculate dp(i)(j)
        *    0 1 2 3 4 5 6
        *          j
        *   0  A B D G K P
        *   1    C E H L Q
        *   2      F I M R
        * i 3        J N S
        *   4          O T
        *   5            U 
        *   6
        *  the iterative order would be 
        *     * A -> B -> C -> D -> E -> F .... => (0, 1) -> (0, 2) -> (1, 2) -> (0, 3) -> (1, 3) -> (2, 3) ... and so on
        *      
        *     
        */
        for(j <- 1 until s.length; i <- 0 until j){
            val currentLen = j - i + 1
            if(s(i) != s(j))  dp(i)(j) = false
            else if(currentLen < 4)  dp(i)(j) = true // currentLen - 2 < 2
            else dp(i)(j) = dp(i + 1)(j - 1)
            
            
            if(dp(i)(j) && currentLen > maxLen){
                maxLen = currentLen
                head = i

            }
        }
        
        s.slice(head, head + maxLen)
    }
}


/**
* expand around center
* time complexity: O(N^2)
*        expandLengths: O(N)
* space complexity: O(1)
*/

object Solution4 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty) return ""
        
        // 0 1 2 3 4 5 6 7
        // r a c e c a r
        // r a c e e c a r
        // b b c e c a a

        // var head = 0
        // var maxlen = 1
        // for(i <- s.indices) {
        //     val oddlen =  expand(s, i, i)
        //     val evenlen = expand(s, i, i + 1)
        //     val len = oddlen max evenlen
        //     if(len > maxlen){
        //         head = i -  (len - 1) / 2
        //         maxlen = len
        //     }
        // }
        val (head, maxlen) = s.indices.foldLeft((0, 1)){
            case ((h, maxlen), i) => 
                val oddlen =  expandLengths(s, i, i)
                val evenlen = expandLengths(s, i, i + 1)
                val len = oddlen max evenlen
                if(len > maxlen)  (i - (len - 1) / 2, len)
                else (h, maxlen)
        }
        s.slice(head, head + maxlen)
    }
    // return length
    @annotation.tailrec
    def expandLengths(s: String, left: Int, right: Int): Int = {
        if(0 <= left && right < s.length && s(left) == s(right)) expandLengths(s, left - 1, right + 1)
        else right - left - 1
    }
}

```

###  3.6. <a name='ZigZagConversion'></a>6. ZigZag Conversion

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7uH?spm_id_from=333.999.0.0)

###  3.7. <a name='ReverseInteger'></a>7 Reverse Integer

[哈哈哈](https://www.bilibili.com/video/BV1sE411e73m?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7bM?spm_id_from=333.999.0.0)

* 时间复杂度:O(log10(n)), 每次迭代都会除以10

* 时间复杂度:O(1)

```py
class Solution:
    def reverse(self, x: int) -> int:
        res = 0 
        a = abs(x)

        if a < 10:
            return x

        while a != 0:
            tmp = a % 10
            res = res * 10 + tmp
            a = a // 10
        # 要注意return和while的相对位置
        # 不要写在while循环内部

        if x > 0 and res < 1<<31:
            return res 
        elif x<0 and res <= 1<<31:
            return -res
        else:
            return 0
```

```scala
object Solution {
    def reverse(x: Int): Int = {
        
        // METHOD-1
        if (x == 0) {
            0
        } else { 
            val xx = math.abs(x).toString.reverse
            var start_to_record = false
            val temp = collection.mutable.ArrayBuffer[Char]()

            for (x <- xx) {

                if (start_to_record == false && x != '0') {
                    start_to_record = true
                }

                if (start_to_record) {
                    temp += x
                }

            }

            try {
                ({if (x >= 0) "" else "-"} + temp.mkString).toInt    
            } catch {
                case e: java.lang.NumberFormatException => 0
            } 
        }
        
        
        // METHOD-2
        if (x == 0) {
            0
        } else {
            
            val xx = math.abs(x).toString.reverse
            
            // find the first element not equaling to 0
            // Here I used method `.find`. It finds and returns the first element of the list satisfying a predicate, if any.
            // `.find` returns Some(*), so need to use `.get`
            val intermediate_result = xx.slice(xx.zipWithIndex.find(_._1 != '0').get._2, xx.length)
            
            // 1. Use if-else to handle possible negative integers.
            // 2. use try-catch to handle cases like "1534236469"
            //      which will cause exception java.lang.NumberFormatException: For input string: "9646324351"
            //      due to Int.MaxValue is 2147483647
            try {
                ({if (x >= 0) "" else "-"} + intermediate_result).toInt    
            } catch {
                case e: java.lang.NumberFormatException => 0
            }

        }  
    }
}
```

```scala
object Solution {
    def reverse(x: Int): Int = {
        if(x == 0){
            0
        }else{
            var output = 0L
            var num = x
            var flag = false
            
            if(x < 0){
                num = Math.abs(num)
                flag = true
            }
            
        
            while(num!=0){
                var mod = num%10
            
                output = (output*10) + mod
            
                num = num/10
            }
            
            val res = if(flag){
                output * (-1)
            }else{
                output
            }
            //To avoid overflow
            if(res < Int.MinValue || res > Int.MaxValue) 0 else res.toInt
        }
    }
}
```

###  3.8. <a name='StringtoIntegeratoi'></a>8. String to Integer(atoi)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7pz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1AZ4y1s7TD?spm_id_from=333.999.0.0)

* 时间复杂度:O(n)

* 时间复杂度:O(1)

|模式|描述|
|---|---|
|^|匹配字符串的开头|
|[...]|用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'|
|*|匹配0个或多个的表达式。|
|?|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式|
|+|匹配1个或多个的表达式。|
|\d|匹配任意数字，等价于 [0-9]。|
|\D|匹配任意非数字，等价于 [^0-9]。|

[正则表达式中小括号、中括号、大括号的作用](https://blog.csdn.net/weixin_45621662/article/details/103921232)

```py
class Solution:
    def myAtoi(self, s: str) -> int:
        import re
        at_oi_re = re.compile('^[ ]*([+-]?\d+)')
        # 易错点：要注意中括号[]和小括号()的区别
        # 易错点：要注意小括号()的位置，小括号的作用是匹配并提取，所以+-要包括起来
        # 易错点：不能漏掉*？

        # 字符串的 开头 匹配 0个或多个[空格]
        # 匹配 0个或多个[+-]
        # 匹配 0个或多个[0-9]
        if not at_oi_re.search(s):
            return 0
        res = int(at_oi_re.findall(s)[0])
        # 易错点：findall返回一个列表，所以必须有[0]
        # 易错点：必须有int()
        return min(max(res, -(1<<31)), (1<<31) - 1) # 在两者之间，背一背
        # 要加小括号(1<<31)
```

###  3.9. <a name='Palindrome'></a>9-【回文🌈】Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1hJ411S7kt?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7YG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Af4y1m7kk?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return True if str(x) == str(x)[::-1] else False
```

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False

        if x < 10:
            return True

        bkp = x
        res = 0

        while x != 0:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return bkp == res
```

翻转一半字符法：

* 时间复杂度:O(log10(n)), 每次迭代都会除以10

* 时间复杂度:O(1)

经过尝试，这个方法在边界处理上容易出错，不推荐。

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 10 and x >= 0:
            return True

        if x < 0 or x % 10 == 0:
            return False

        res = 0

        # 翻转一半字符串

        while x > res:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return x == res or x == res//10
```

```scala
package lc009 {
  object Solution {
    def isPalindrome(x: Int): Boolean = {
      if (x<0) return false
      if (x==0) return true
      if (x%10==0) return false
      val y=x.toString.reverse
      return y==x.toString
    }
  }
}
```

###  3.10. <a name='ContainerWithMostWater'></a>11. Container With Most Water 

[花花酱](https://www.bilibili.com/video/BV1CW41167qB?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Gn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1A5411E7oM?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1TK41157jH?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

双指针法：

由于盛水面积由较短边控制，所以，指针放在两端，每次只移动较短边。因为，移动较长边的话。一定仍然是不变的。

* 时间复杂度:O(n)

* 时间复杂度:O(1)



```py
# 这个写起来超级简单！
# NO BUG
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        maxRes = res = 0
        while left < right:
            res = (right - left)*min(height[left],height[right])
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
            maxRes = max(maxRes,res)
        return maxRes
```

```scala
/**
* brute force not AC
* time complexity: O(n^2)
*/

object Solution1 {
    def maxArea(height: Array[Int]): Int = {
      
      var currentMax = 0

      for(left <- height.indices; right <- (left + 1) until height.length) {
        val limit = height(right) min height(left)
        val width =  (right - left)
        val volume = limit * width

        currentMax = currentMax max volume
      }
      currentMax
    }  
}


/**
* two pointer version
* memo
*  1. fix left side,, the volume is bounded by left side if left side is shorter 
*  2. fix right side. the volume is bounded by right side if right side is shorter
*/

object Solution2 {
    def maxArea(height: Array[Int]): Int = {
      
      var left = 0
      var right = height.length - 1
      var volume = 0
      
      while(left < right) {
        val current = (right - left) * (height(right) min height(left))
        volume = volume max current
        
        if (height(left) < height(right)) // left is shorter
          left += 1
        else // right is shorter
          right -= 1
      }
      volume
    }
         
}

/**
* two - pointer version recursive version
*/
object Solution2-1 {
    def maxArea(height: Array[Int]): Int = {
  
     maxArea(height, 0, height.length - 1, 0)
    }
  
    @annotation.tailrec
    def maxArea(height: Array[Int], left: Int, right: Int, maxVolume: Int): Int = {
      if (left >= right)  maxVolume
      else {
        val currentVolume = (right - left) * (height(right) min height(left))
        var newMaxVolume = currentVolume max maxVolume
        
        if (height(right) > height(left)) 
          maxArea(height, left + 1, right, newMaxVolume)
        else
          maxArea(height, left, right - 1, newMaxVolume)
      }
    }
}
```

###  3.11. <a name='IntegertoRoman'></a>12. Integer to Roman

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Wf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hN411Q7ka?spm_id_from=333.999.0.0)

```py
# 这个写起来超级简单！
# NO BUG
class Solution:
    def intToRoman(self, num: int) -> str:
        strlist = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        numlist = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        res = ''
        for i in range(len(numlist)):
            while num >= numlist[i]:
                num -= numlist[i]
                res = res + strlist[i]
        return res
```

```py
# 其他方法
class Solution:

    VALUE_SYMBOLS = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]
    print(type(VALUE_SYMBOLS))
    def intToRoman(self, num: int) -> str:
        roman = list()
        for value, symbol in Solution.VALUE_SYMBOLS:
            while num >= value:
                print("-"*20)
                print(num)
                num -= value
                roman.append(symbol)
                print(roman)
            if num == 0:
                break
        return "".join(roman)
```

```scala
package com.zhourui.leetcode

//class Solution {
//  public:
//    string intToRoman(int num) {
//      vector<int> t1{1000,900,500,400,100,90,50,40,10,9,5,4,1};
//      vector<string> t2{"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
//      string ret="";
//      for (int i=0;i<t1.size();i++) {
//      if (num>=t1[i]) {
//      int c = num/t1[i];
//      for (int j=0;j<c;j++) {
//      ret+=t2[i];
//    }
//      num=num%t1[i];
//    } else if (num==0) {
//      break;
//    }
//    }
//      return ret;
//    }
//};


//object Solution {
//  case class RomanNumber(decValue: Int, romanStr: String)
//  val numbers = Seq(
//    RomanNumber(1000, "M"),
//    RomanNumber(900, "CM"),
//    RomanNumber(500, "D"),
//    RomanNumber(400, "CD"),
//    RomanNumber(100, "C"),
//    RomanNumber(90, "XC"),
//    RomanNumber(50, "L"),
//    RomanNumber(40, "XL"),
//    RomanNumber(10, "X"),
//    RomanNumber(9, "IX"),
//    RomanNumber(5, "V"),
//    RomanNumber(4, "IV"),
//    RomanNumber(1, "I")
//  )
//  def intToRoman(num: Int): String = {
//    def loop(num:Int, romans: Seq[RomanNumber]): String = {
//      romans match {
//        case RomanNumber(x, romanStr) :: _ if x < num => romanStr + loop(num-x, romans)
//        case RomanNumber(x, romanStr) :: _ if x == num => romanStr
//        case RomanNumber(x, _) :: tail if x > num => loop(num, tail)
//      }
//    }
//    loop(num, numbers)
//  }
//}
package lc0012_integertoroman {
  object Solution {
    case class RomanNumber(s:String, i: Int)
    def intToRoman(num: Int): String = {
      val numbers:Seq[RomanNumber] = Seq(
        RomanNumber("M",1000),
        RomanNumber("CM",900),
        RomanNumber("D",500),
        RomanNumber("CD",400),
        RomanNumber("C",100),
        RomanNumber("XC",90),
        RomanNumber("L",50),
        RomanNumber("XL",40),
        RomanNumber("X",10),
        RomanNumber("IX",9),
        RomanNumber("V",5),
        RomanNumber("IV",4),
        RomanNumber("I",1)
      )
      // 很巧妙 利用seq的head 和tail 递归调用
      // :: 相当于拼接

      def loop(num:Int, romans:Seq[RomanNumber]): String = {
        romans match {
          case RomanNumber(romanStr, v) :: lst if v == num => romanStr
          case RomanNumber(romanStr, v) :: lst if v < num => romanStr+loop(num-v,romans)
          case RomanNumber(romanStr, v) :: tail => loop(num,tail)
        }
      }
      loop(num, numbers)
    }
  }
}

```

###  3.12. <a name='-1'></a>13. 机器人的运动范围 

[官方](https://www.bilibili.com/video/BV1dz411B7rt?spm_id_from=333.999.0.0)

###  3.13. <a name='RomantoInteger'></a>13. Roman to Integer

[花花酱](https://www.bilibili.com/video/BV1vJ411J7Up?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1hJ411S7kQ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7ue?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1cp4y1H75L?spm_id_from=333.999.0.0)

```py
# 看不懂下方代码，就看小明的讲解
class Solution:
    def romanToInt(self, s: str) -> int:
        dic = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
        res = 0
        for i in range(len(s)-1):
            if dic[s[i]] < dic[s[i+1]]:
                res -= dic[s[i]]
            else:
                res += dic[s[i]]
        res += dic[s[-1]]
        return res
```

```scala
object Solution {
    def romanToInt(s: String): Int = {
        val exceptionsMap = Map(
            ('I' -> List('V', 'X')),
            ('X' -> List('L', 'C')),
            ('C' -> List('D', 'M'))
                     )
        
        val valuesMap = Map(
            ('I' -> 1),
            ('V' -> 5),
            ('X' -> 10),
            ('L' -> 50),
            ('C' -> 100),
            ('D' -> 500),
            ('M' -> 1000)
        )
        
        val exceptionalValues = Map(
            ("IV" -> 4),
            ("IX" -> 9),
            ("XL" -> 40),
            ("XC" -> 90),
            ("CD" -> 400),
            ("CM" -> 900)
        )
        
        var sum = 0
        var i = 0
        val len = s.length
        while(i < len){
            var c1 = s.charAt(i) 
            c1 match{
                case 'I' | 'X' | 'C' => {
                    if(i+1 < s.size && exceptionsMap.get(c1).get.contains(s.charAt(i+1))){
                        sum += exceptionalValues.get(c1.toString + s.charAt(i+1)).get
                        i+=2
                    }else{
                        sum += valuesMap.get(c1).get
                        i += 1
                    }
                }
                case _ => {
                    sum += valuesMap.get(c1).get
                    i += 1
                }
            }
        }
        sum
    }
}


//Alternate SCALA solution
object Solution {
	def convert(c: Char) = c match{
		case 'I' => 1
		case 'V' => 5
		case 'X' => 10
		case 'L' => 50
		case 'C' => 100
		case 'D' => 500
		case 'M' => 1000
		case _ => throw new UnsupportedOperationException("This case should not be called unless the input is invalid")
	}

	def romanToInt(s: String): Int = s.foldRight(0){
		(v, sum) => (convert(v), sum) match{
			case (add, _) if sum < 5*add => add + sum
			case (sub, _) => sum - sub
		}
	}
	
}

```

```scala
package com.zhourui.leetcode

/*
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.
 */
package lc0013_romantointeger {

  object Solution {
    def romanToInt(s: String): Int = {
      val m:Map[Char,Int] = Map(
        'I' -> 1,
        'V' -> 5,
        'X' -> 10,
        'L' -> 50,
        'C' -> 100,
        'D' -> 500,
        'M' -> 1000
      )

      def loop(p:Seq[Char], m:Map[Char,Int]): Int = p match {
        case Seq(a, b, t@_*) if m(a) < m(b) => m(b) - m(a) + loop(t, m)
        case Seq(a, t@_*) => m(a) + loop(t,m)
        case _ => 0
      }
      return loop(s,m)
    }
  }
}


/*
//case Seq(xs @ _*) // Identifier xs is bound to the whole matched sequence.
 def romanToInt(s: Seq[Char]): Int = s match {
      case Seq(a, b, t@_*) if dict(a) < dict(b)  =>  dict(b) - dict(a) + romanToInt(t)
      case Seq(a, t@_*) => dict(a) + romanToInt(t)
      case _ => 0
    }
 */
```

###  3.14. <a name='Longestcommonprefix'></a>14-Longest common prefix

[哈哈哈](https://www.bilibili.com/video/BV1cJ411D7qU?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Eb411i7QN?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1tV411k7GY?spm_id_from=333.999.0.0)

* 时间复杂度:O(mn),m是字符串平均长度,n是字符串数量

* 时间复杂度:O(1)

```py
# 参考了小梦想家,首次学习while true循环:
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        lookup = set()
        res = ''
        i = 0
        while True:
            # 由于string的长度是不确定的，所以
            try:
                lookup = set(string[i] for string in strs)
                if len(lookup) == 1:
                    res += lookup.pop()
                    i += 1
                else:
                    break
            except Exception as e:
                break
        return res
```

```py
# 如果不使用try catch
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if strs == [""]:
            return strs[0]
        lookup = set()
        res = ''
        i = 0
        minlen = min(len(string) for string in strs)
        while i< minlen:
            lookup = set(string[i] for string in strs)
            if len(lookup) == 1:
                res += lookup.pop()
                i += 1
            else:
                break
        return res
```

```scala
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var flag = true
            var count = 1
            var output = ""
        
            var minLength = strs.map(_.length).min
        
        while(flag && count <= minLength){
            
            /**
            lst.forall(_ == lst.head)  // true  if empty or all the same
            lst.exists(_ != lst.head)  // false if empty or all the same
            */
            
            if(strs.map(s => s.substring(0, count)).distinct.length == 1){
                output = strs(0).substring(0, count)
                count += 1
            }else{
                flag = false
            }
        }
        
        output
        }
    }
}

//Alternate solution (better complexity)
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var prefix = strs(0)
            
            (1 until strs.length).map(i => {
                
                while(strs(i).indexOf(prefix) != 0){
                    prefix = prefix.substring(0, prefix.length - 1)
                }
                
            })
            
            prefix
        }
    }
}

```

###  3.15. <a name='Sum'></a>15. 3Sum

[花花酱](https://www.bilibili.com/video/BV1wp4y1W72o?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Tb411578b?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19K4y1s7co?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19i4y1s7VZ?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n3)

* 时间复杂度:O(1)

双指针法：

先排序：时间复杂度:O(n log(n)) + O(n2)

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        # nums.sort() # 另一种写法
        nums = sorted(nums)
        res = []
        for i in range(n-2):
            # 优化部分：
            if nums[i] > 0: break
            if nums[i] + nums[i+1] + nums[i+2] > 0: break
            # 这个写法不对：if i+1 < n-2 and nums[i] == nums[i+1]: continue
            # 这样可能直接跳过了[-1,-1,2,3]的前三个
            # 这个写法是正确的↓：
            if i - 1 >= 0 and nums[i] == nums[i-1]: continue
            if nums[i] + nums[n-2] + nums[n-1] < 0:continue
            # 双指针部分：
            left = i + 1
            right = n - 1
            while left < right: 
                if nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                elif nums[i] + nums[left] + nums[right] < 0:
                    left += 1
                else:
                    res.append([nums[i],nums[left],nums[right]])
                    # 去重：
                    while nums[left] == nums[left + 1] and left + 1 < right: # 注意边界
                        left += 1
                    left +=1
                    while nums[right] == nums[right - 1] and left < right - 1: # 注意边界
                        right -= 1
                    right -=1
        return res
```

```scala
/**
* chosen solution
* 1. two pointer in twoSum
* 2. result storing in hashSet to avoid duplicate pairs
* time complexity: O(N^2)
* space complexity: O(N): due to sorted list 
*/
object Solution0 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(Set[List[Int]]()) {
          /* only send value less than zero and those num which was duplicated only once into twoSum */
      case (ans, idx) if l(idx) <= 0 && (idx == 0 || (idx >= 1 && l(idx) != l(idx - 1))) =>
        twoSum(-l(idx), l, idx + 1, ans)
      case (set, _) => set

    }.toList

  }

  def twoSum(target: Int, nums: Array[Int], from: Int, ans: Set[List[Int]]): Set[List[Int]] = {

    @annotation.tailrec
    def loop(i: Int, j: Int, ans: Set[List[Int]]): Set[List[Int]] = {

      if(i < j) {
        val sum = nums(i) + nums(j)
        if(sum > target) loop(i, j - 1, ans)
        else if(sum < target) loop(i + 1, j, ans)
        else loop(i + 1, j - 1, ans + List(-target, nums(i), nums(j)))
      }else {
        ans
      }
    }
    loop(from, nums.length - 1, ans)
  }
}
/**
* my first commit
* hashset in twoSum
* a very time consuming version
* O(N^2)
*/
object Solution1 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {

      val l = nums.groupBy(identity).mapValues(aa => if(aa.length >=3) aa.take(3) else aa ).values.flatten.toList

     l.zipWithIndex.flatMap {
      case (value, index) =>
        val ll = collection.mutable.ListBuffer(l: _*)
        ll.remove(index)

        twoSum(ll.toList, -value).filter(_.nonEmpty)
          .map(_ :+ value)
    }.map(pair => (pair.toSet, pair)).toMap.values.toList

  }

   def twoSum(nums: List[Int], target: Int): List[List[Int]] = {
    val valueCounter = nums.groupBy(identity).mapValues(_.length)

    nums.collect {
      case value if target - value == value && valueCounter.get(target - value).exists(_ >= 2) =>
        List(value, target - value)
      case value if target - value != value && valueCounter.contains(target - value) =>
        List(value, target - value)

    }
  }

}

/**
* hashset in twoSum
* sorted nums and not to run duplicate num twice into twoSum
* O(N^2)
*/
object Solution1-2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
   
    val l = nums.sorted
    val ret = for((value, index) <- l.zipWithIndex; if index >= 1 && l(index) != l(index - 1)) yield  {
      val ll = l.toBuffer
      ll.remove(index)
      twoSum(ll.toArray, -value).filter(_.nonEmpty).map(_ :+ value)
    }

    l.slice(0, 3) match {
      case Array(0, 0, 0 ) =>  ret.flatten.map(l => (l.toSet, l)).toMap.values.toList :+ List(0, 0, 0) // edge case (0, 0, 0)
      case _ => ret.flatten.map(l => (l.toSet, l)).toMap.values.toList
    }

  }

  def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collect {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>

        List(value, target - value)
    }.map(l => (l.toSet, l)).toMap.values.toList
  }

/**
* improvement:
*   1. only call twoSum when  l(idx) under zero,  because the array was sorted, there won't be any chance the next entries sum to 0.
*   2. only send the remaining nums which were after idx into twoSum
* O(N^2)
*/

  object Solution1-3 {
    def threeSum(nums: Array[Int]): List[List[Int]] = {
        val l = nums.sorted
        l.indices.foldLeft(collection.mutable.ListBuffer.empty[List[Int]]){
        case (r, idx) if l(idx) <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx-1))) =>
            r ++= twoSum(l.slice(idx + 1, l.length), -l(idx)).map(_ :+ l(idx))
        case (r, idx)  => r

        }.toList
        
    }

    def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {

        val value2Idx = nums.zipWithIndex.toMap
        nums.zipWithIndex.collect {
        case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
            List(value, target - value)
        }.map(l => (l.toSet, l)).toMap.values.toList
    }
  
}


/**
*  Using a hashset to erase duplicate in twoSum
*/
object Solution1-3-2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(collection.mutable.ListBuffer.empty[List[Int]]){
      case (r, idx) if l(idx) <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx-1))) =>
        r ++= twoSum(l.slice(idx + 1, l.length), -l(idx))
      case (r, idx)  => r

    }.toList

  }

  def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {

    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.foldLeft(Set[List[Int]]()) {
      case (s, (value, index)) if value2Idx.get(target - value).exists(_ != index) =>
        val t_sub_v = target - value
        if(index < value2Idx(t_sub_v)) {
          s + List(-target, value, t_sub_v)
        } else {
          s + List(-target, t_sub_v, value)
        }
      case (s, _) => s

    }.toList
  }
}
/**
* more readable and simpler
*/
object Solution1-3-3 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted

    l.zipWithIndex.foldLeft(Set[List[Int]]()) {
      /* only send value less than zero and those num which was duplicated only once into twoSum */
      case (set, (v, idx)) if v <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx - 1)))  =>
        set ++ twoSum(-v, l.slice(idx + 1, l.length))
      case (set, _) => set
    }.toList

  }

  def twoSum(target: Int, nums: Array[Int]): List[List[Int]] = {
    val map = nums.zipWithIndex.toMap
    nums.zipWithIndex.foldLeft(Set[List[Int]]()){
      case (set, (n, idx)) =>
        val n2 = target - n
        map.get(n2) match {
          case Some(e) if e != idx =>
            /* using  n n2 order to help hashset to eliminate duplicate */
            if(n < n2)
              set + List(-target, n, n2)
            else
              set + List(-target, n2, n)
          case _ => set
        }
    }.toList
  }
}

/**
* two pointer in twoSum
* time complexity: O(N^2)
* space complexity: O(N): due to sorted list 
*/

object Solution2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(Set[List[Int]]()) {
      case (ans, idx) if l(idx) <= 0 && (idx == 0 || (idx >= 1 && l(idx) != l(idx - 1))) =>
        twoSum(-l(idx), l, idx + 1, ans)
      case (set, _) => set

    }.toList

  }

  def twoSum(target: Int, nums: Array[Int], from: Int, ans: Set[List[Int]]): Set[List[Int]] = {

    @annotation.tailrec
    def loop(i: Int, j: Int, ans: Set[List[Int]]): Set[List[Int]] = {

      if(i < j) {
        val sum = nums(i) + nums(j)
        if(sum > target) loop(i, j - 1, ans)
        else if(sum < target) loop(i + 1, j, ans)
        else loop(i + 1, j - 1, ans + List(-target, nums(i), nums(j)))
      }else {
        ans
      }
    }
    loop(from, nums.length - 1, ans)
  }
}
```

###  3.16. <a name='SumClosest'></a>16. 3Sum Closest

[小梦想家](https://www.bilibili.com/video/BV11441187Rr?spm_id_from=333.999.0.0)

```py
# 和上一题差不多
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        minAim = sum(nums[0:3]) - target
        n = len(nums)
        for i in range(n-2):
            left = i+1
            right = n-1
            while left<right:
                aim = nums[i] + nums[left] + nums[right] - target
                if abs(aim) < abs(minAim): minAim = aim
                if aim == 0: 
                    return target
                elif aim > 0:
                    right -= 1
                else:
                    left += 1
        return minAim + target
```

```py
# （python）三重暴力破解 O(n**3)

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        result=1000
        for i in range(0,len(nums)):
            for j in range(i+1,len(nums)):
                for k in range(j+1,len(nums)):
                    a=nums[i]+nums[j]+nums[k]-target
                    if abs(a) < result:
                        result=abs(a)
                        end=nums[i]+nums[j]+nums[k]
        return end
```

```scala

/**
* my first commitment
* two pointer approximate
* 
* time complexity: O(N^2)
*/
object Solution1 {
  def threeSumClosest(nums: Array[Int], target: Int): Int = {
    val l = nums.sorted
    // slice(0, 3) is slower 
    l.indices.foldLeft(l.take(3).sum){
      case (closestSum, idx) => twoSum(l, target, idx, closestSum)
    }

  }

  def twoSum(nums: Array[Int], target: Int, from: Int, closestSum: Int): Int = {
    val fromValue = nums(from)

    @annotation.tailrec
    def _twoSum(left: Int, right: Int, previousSum: Int): Int = {
      if(left >= right) return previousSum


      val currentSum = fromValue + nums(left) + nums(right)

      val currentDiff = math.abs(target - currentSum)
      val previousDiff = math.abs(target - previousSum)

      val newClosest = if(currentDiff > previousDiff) previousSum else currentSum


      if(currentSum < target) _twoSum(left + 1, right, newClosest)
      else if(currentSum > target) _twoSum(left, right - 1, newClosest)
      else _twoSum(left + 1, right - 1, newClosest)

    }

    _twoSum(from + 1, nums.length - 1, closestSum)
  }
}
```

###  3.17. <a name='LetterCombinationsofaPhoneNumber'></a>17. Letter Combinations of a Phone Number 

[花花酱](https://www.bilibili.com/video/BV1PW411y7r2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7sL?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ti4y1A73M?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Sp4y1r7YP?spm_id_from=333.999.0.0)

深度优先 or 广度优先

* 时间复杂度:O(3m × 4n), m是对应3个字母的数字, n是对应4个字母的数字

* 时间复杂度:O(3m × 4n), m是对应3个字母的数字, n是对应4个字母的数字

```py
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: # 易错点：一定要判断判断字符串是否为空
            return [] 
        dic = {'2':'abc','3':'def','4':'ghi','5':'kjl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        res = [char for char in dic[digits[0]]] # 前面的排在前面
        for num in digits[1:]:
            res = [string + char for string in res for char in dic[num]]
        return res
```

```py
class Solution:
    def letterCombinations(self, digits):
        if not digits:
            return list()
        
        phoneMap = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }

        groups = (phoneMap[digit] for digit in digits)
        return ["".join(combination) for combination in itertools.product(*groups)]
```

###  3.18. <a name='RemoveNthNodeFromEndofList'></a>19-Remove Nth Node From End of List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7DQ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1eL411n7KE?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1654y1R7Xe?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1KK4y1E7st?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Z5411c79y?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ccdr2kcw7c0.png)

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast = ListNode(0)
        slow = ListNode(0)
        fast.next = head
        slow.next = head
        for _ in range(n):
            fast = fast.next

        # 易错点：
        # 要考虑特殊情况，比如说，链表长度和n一样时

        if fast.next == None: # 易错点：== 千万不要写错
            return head.next

        while fast.next != None:
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next

        return head
```

```scala
/**
* my first commitment - fast & slow pointer
* time complexity O(N + N / 2)
*/

object Solution1 {
    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
      val dummyHead = ListNode(0, head)
      var slow = dummyHead
      var fast = dummyHead
      var counter = 0
      
      while(fast != null && fast.next != null) {
        slow = slow.next
        fast = fast.next.next
        counter += 1
      }
      
      val length = if (fast == null) counter * 2 - 1 else counter * 2
      val targetNodeIndex = length - n + 1
      val slowNodeIndex = counter
      // println(length, targetNodeIndex, slowNodeIndex)
      if (counter < targetNodeIndex) {
        removeIdx(slow, slowNodeIndex, targetNodeIndex)
      }else {
        removeIdx(dummyHead, 0, targetNodeIndex)
      }
      dummyHead.next
    }
  
    def removeIdx(node: ListNode, nodeIdx: Int, targetIdx: Int) {
      var nodeT = node
      var nodeIdxV = nodeIdx
      var preNodeindex = targetIdx - 1
     
      while (nodeIdxV < preNodeindex) {
        nodeIdxV += 1
        nodeT = nodeT.next
      }
      var preNode = nodeT
      var nextNode = nodeT.next.next
      preNode.next = nextNode
    }
}


/**
* two pointer fast & slow 
* memo
*   1. keep fast pointer is n + 1 ahead to slow pointer
*   2. if fast == null, slow pointer would points to the  preNode of target removing node
*
*           t 
*   0 1 2 3 4 5
*   s     f
*     s     f
*       s     f
*         s     f
*/
object Solution1-2 {
    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
      val dummyHead = ListNode(0, head)
      var slow = dummyHead
      var fast = dummyHead
      
      for (i <- 0 until (n + 1) if fast != null) {
        fast = fast.next
      }
      
      while(fast != null) {
        slow = slow.next
        fast = fast.next
      }
      
      slow.next = slow.next.next
      dummyHead.next
    }
  
}
```

###  3.19. <a name='Validparentheses'></a>20-Valid parentheses

[哈哈哈](https://www.bilibili.com/video/BV1DJ41127uA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7ek?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Hr4y1M7Sc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1sC4y1H7Hs?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1QA411L7y7?spm_id_from=333.999.0.0)

先进后出，所以用栈

* 时间复杂度:O(n)

* 时间复杂度:O(n)

```py
# 这道题背一背！
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{':'}','[':']','(':')'}
        stack = [] # stack 要提前定义好
        for char in s:
            if char in dic: # 是“key”
                stack.append(char) # 一个char进来，要么被append
            elif not stack or dic[stack.pop()] != char: 
                # 如果上一步不被append就是不对的
                # 如果这一步不匹配也是不对的
                return False
        return not stack # 如果append上了，但没有被完全pop也是不对的
```

```scala
/**
* chosen solution
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution0 {
    def isValid(s: String): Boolean = {

        val parenthesesMap = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        val stack = scala.collection.mutable.ArrayStack[Char]()
        s.forall{ c =>
            if(parenthesesMap.contains(c)){
              stack.push(c)
              true
            }else{
               stack.nonEmpty && parenthesesMap(stack.pop).equals(c)
            }
        } && stack.isEmpty
    }
}


/**
* my first commitment
* using stack
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def isValid(s: String): Boolean = {
        if(s.isEmpty || s.length % 2 != 0) return false
        val stack = scala.collection.mutable.Stack[Char]()
        
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')

        s.foreach{c => 
            
            if (mapping.contains(c)){
                stack push c
            }else{
                if(stack.isEmpty || mapping(stack.pop) != c) return false 
             
            }
        }
        stack.isEmpty
        
    }
}

/**
* stack and avoid return in foreach block
*/
object Solution1-2 {
    def isValid(s: String): Boolean = {

        val parenthesesMap = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        val stack = scala.collection.mutable.ArrayStack[Char]()
        s.forall{ c =>
            if(parenthesesMap.contains(c)){
              stack.push(c)
              true
            }else{
               stack.nonEmpty && parenthesesMap(stack.pop).equals(c)
            }
        } && stack.isEmpty
    }
}

/**
* using stack X FP
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1-3 {
    def isValid(s: String): Boolean = {
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        s.foldLeft(List.empty[Char]){ (stack, c) => 
            stack match {
                case pop :: stackAfterPop if  c.equals(mapping.getOrElse(pop, None)) => stackAfterPop
                case _ => c +: stack
            }
           
        }.isEmpty
        
    }
}

```

```scala
object Solution {
    def isValid(s: String): Boolean = {
        if(s.length % 2 != 0){
            false
        }else{
        import scala.collection.mutable._
        val openingHashSet: HashSet[Char] = HashSet('(', '{', '[')
        val closingMap: Map[Char, Char] = Map(
             (')' -> '('),
             ('}' -> '{'),
             (']' -> '[')
         )                                                       
        val stack = Stack.empty[Char]
                       
        var output = true               
        import scala.util.control.Breaks._
        
        breakable{
            for(c <- s){
                if(stack.isEmpty){
                    if(openingHashSet.contains(c)){
                        stack.push(c)
                    }else{
                        output = false
                        break
                    }
                }else{
                    if(openingHashSet.contains(c)){
                        stack.push(c)
                    }else{
                        closingMap.get(c) match{
                            case Some(v) =>{
                                val top = stack.top
                                if(v == top){
                                    stack.pop()
                                }else{
                                    output = false
                                    break
                                }
                            }
                            case None =>{
                                output = false
                                break
                            }
                        }
                    }
                }
            }
        }               
        
        if(stack.isEmpty) output else false
    }
    }
}

```

###  3.20. <a name='Mergetwosortedlists'></a>21-Merge two sorted lists

[哈哈哈](https://www.bilibili.com/video/BV1rJ41127ry?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7D7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1my4y127bK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1qZ4y1j7Jb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ck4y1k7J9?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(M+N)

* 时间复杂度:O(1)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        cur = dummy # dummy是固定节点，cur是移动指针
        while list1 and list2: # 这里是and
            if list1.val < list2.val: # 易错点：这里是list.val，而不是list
                cur.next = list1
                list1 = list1.next # 向后进一位
            else:
                cur.next = list2
                list2 = list2.next # 向后进一位
            cur = cur.next # 向后进一位
        cur.next = list1 or list2 # 易错点：这里是cur.next，而不是cur。这里是or
        # 等效于：
        # if list1:
        #     cur.next = list1
        # else:
        #     cur.next = list2
        return dummy.next
```

递归解法：

* 时间复杂度:O(M+N)

* 时间复杂度:O(M+N)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        elif not list2:
            return list1
        elif list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next,list2) # 找到较小头结点，提取出来
            return list1
        else:
            list2.next = self.mergeTwoLists(list1,list2.next) # 找到较小头结点，提取出来
            return list2
```

```scala
/**
* chosen solution
* time complexity: O(N + M), N is the length of l1, M is the length of l2
*/

object Solution0 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        val headNode = new ListNode(-1, null)
        var cur = headNode
        
        var no1 = l1;
        var no2 = l2;
        
        while(no1 != null && no2 != null) {
            if (no1.x >= no2.x){
                
                cur.next = no2
                no2 = no2.next
            }else {
                cur.next = no1
                no1 = no1.next
            }
            cur = cur.next
        }
        (no1, no2) match {
            case (_, null) => cur.next = no1
            case (null, _) => cur.next = no2
            case _ => throw new RuntimeException()
        }
        
        headNode.next
    }
}



/**
* iterative version
* time complexity: O(N + M), N is the length of l1, M is the length of l2
*/
object Solution1 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        val headNode = new ListNode(-1, null)
        var cur = headNode
        
        var no1 = l1;
        var no2 = l2;
        
        while(no1 != null && no2 != null) {
            if (no1.x >= no2.x){
                
                cur.next = no2
                no2 = no2.next
            }else {
                cur.next = no1
                no1 = no1.next
            }
            cur = cur.next
        }
        (no1, no2) match {
            case (_, null) => cur.next = no1
            case (null, _) => cur.next = no2
            case _ => throw new RuntimeException()
        }
        
        headNode.next
    }
}



/**
* recursive version
*/

object Solution1-2 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        (l1, l2) match {
            case (null, _) => l2
            case (_, null) => l1
            case (a, b) => 
                if (a.x >= b.x){
                    b.next = mergeTwoLists(b.next, a)
                    b
                } else {
                    a.next = mergeTwoLists(a.next, b)
                    a   
                }
        }
    }
}
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        if(l1 == null){
            l2
        } else if(l2 == null){
            l1
        }else{
            var (ll1, ll2) = (l1, l2)
            var firstNext = if(ll1.x < ll2.x) ll1 else ll2
            var head = ListNode(0, firstNext)
            var curr = head
            
            
            while(ll1 != null && ll2 != null){
                if(ll1.x < ll2.x){
                    curr.next = ll1
                    curr = ll1
                    ll1 = ll1.next
                } else{
                    curr.next = ll2
                    curr = ll2
                    ll2 = ll2.next
                }
            }
            
            if(ll1 == null){
                curr.next = ll2
            }else{
                curr.next = ll1
            }
            
            head.next
        }
    }
}


//Alternate & Simpler solution
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
    if(l1 == null) return l2
    if(l2 == null) return l1

    if (l1.x < l2.x) {
      l1.next = mergeTwoLists(l1.next, l2)
      l1
    } else {
      l2.next = mergeTwoLists(l1, l2.next)
      l2
    }
  }
}

```

###  3.21. <a name='GenerateParentheses'></a>22. Generate Parentheses

[小梦想家](https://www.bilibili.com/video/BV1hb411i7t7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vK4y1b744?spm_id_from=333.999.0.0)

回溯法：

* 时间复杂度:O($\frac{4^n}{\sqrt{n}}$)

* 时间复杂度:O($\frac{4^n}{\sqrt{n}}$)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.ud5vx6kpbvk.png" width="50%">

```py
# 基于小梦想家
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm,res):
            if left == 0 and right == 0:
                res.append(itm)
                # 错误写法：return res = res.append(itm)，这里不需要return
            if left > right: # 相当于n-left<n-right,表示残余的部分
                return
            if left > 0:
                helper(left-1,right,itm + '(',res)
                # 错误写法：return item = '(' + helper(left-1,right,itm,res)，这里不需要return
            if right > 0:
                helper(left,right-1,itm + ')',res)
                # 错误写法：return item = ')' + helper(left,right-1,itm,res)，这里不需要return
        
        res = []
        helper(n,n,'',res)
        return res
```

```py
# 基于上方答案修改
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm,res):
            if left == 0 and right == 0:
                res.append(itm)
                return # 这里return写不写居然都ac了，可能是因为没有循环吧
            if left > 0:
                helper(left-1,right,itm + '(',res)
            if right > left:
                helper(left,right-1,itm + ')',res)
        
        res = []
        helper(n,n,'',res)
        return res
```

```py
# 基于上方答案修改，helper中的删除res

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm):
            if left == 0 and right == 0:
                res.append(itm)
                return # 这里return写不写居然都ac了，可能是因为没有循环吧
            if left > 0:
                helper(left-1,right,itm + '(')
            if right > left:
                helper(left,right-1,itm + ')')
        
        res = []
        helper(n,n,'')
        return res
```

```py
class Solution:
    def generateParenthesis(self, n):
        ans = []
        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(''.join(S))
                return
            if left < n:
                S.append('(')
                backtrack(S, left+1, right)
                S.pop()
                # 参考上方，可以直接把'('写到递归函数里面，这样就不需要还原现场。
            if right < left:
                S.append(')')
                backtrack(S, left, right+1)
                S.pop()

        backtrack([], 0, 0)
        return ans
# 上方答案，修改后如下：
```

```py
# 上方答案，修改后如下：
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(S)
                return
            if left < n:
                backtrack(S + '(', left+1, right)
            if right < left:
                backtrack(S + ')', left, right+1)

        ans = []
        backtrack('', 0, 0)
        return ans
```

```py
# 作者说：头皮发麻。我感觉我是天才，
# 作者说：你们不知道用最基本的单位“()”进行组装吗。
# 作者说：绝对是原创一次过

class Solution:
    def generateParenthesis(self, n):
        if n == 1:
            return list({'()'})
        res = set()
        for i in self.generateParenthesis(n - 1):
            for j in range(len(i) + 2):
                res.add(i[0:j] + '()' + i[j:])
        return list(res)


# 我的模仿😐
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 这是我写的愚蠢的结束条件：
        # if len(res[0]) == n:
        #     return
        if n == 1:
            return ['()']

        res = set()
        for itm in self.generateParenthesis(n-1):
            for j in range(len(itm)+1): # 如果item的长度为4，那么就有5个可以插入的位置
                # 错误写法：
                # itm = itm[:j] + '()' + itm[j:]
                # res = res.add(itm)
                # 错误写法：
                # res = res.add(itm[:j] + '()' + itm[j:])
                # 正确写法：
                res.add(itm[:j] + '()' + itm[j:])
        return list(res)
```

```py
# 相当于比上一层少了一层循环。
# 不懂是不是动态规划，每新增一对括号，
# 就是在上一次的结果的各个位置插入一个"()"，用集合防止重复

class Solution:
    def generateParenthesis(self, n):
        result = {''}
        for i in range(n):
            temp = set()
            for s in result:  # 在上一次的结果的所有字符串的各个位置上插入'()'
                for j in range(len(s) + 1):
                    temp.add(s[:j] + '()' + s[j:])
            result = temp
        return list(result)
```

```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        stack=[('',0,0)]
        ans=[]
        while stack:
            print("stack: ",stack)

            p,left,right=stack.pop() # 先把p弹出来
            
            if left==right==n: #如果符合条件,就回收
                ans.append(p)
                continue
            
            if left<n: #如果符合条件,就加left
                stack.append((p+'(',left+1,right))
            if right<n and right<left: #如果符合条件,就加right
                stack.append((p+')',left,right+1))
        return ans

# 我的模仿😐 
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack = [('',0,0)]
        res = []
        while stack:
            itm, left, right = stack.pop()
            if left == right == n:
                # 错误写法：res = res.append(itm)
                res.append(itm)
                # continue 写或者不写都能ac，我迷惑了

            if left < n:
                # 错误写法：itm, left, right = itm + '(', left + 1, right
                # 错误写法：stack.append(itm + '(', left + 1, right),应该要有双层括号
                stack.append((itm + '(', left + 1, right))
            if right < left:
                # 错误写法：itm, left, right = itm + ')', left, right + 1
                # 错误写法：stack.append(itm + ')', left, right + 1),应该要有双层括号
                stack.append((itm + ')', left, right + 1))
        return res
```

```py
# 比较费脑子，可以不看😐 
class Solution:
    def generateParenthesis(self, n):
        if n == 0:
            return [""]
        if n == 1:
            return ["()"]
        # 这两行其实可有可无：
        # elif n == 2: 
        #     return ["()()", "(())"] 
        result = []
        for i in range(n):
            j = n - 1 - i
            temp1 = self.generateParenthesis(i)
            temp2 = self.generateParenthesis(j)
            result.extend(["(%s)%s" % (p, q) for p in temp1 for q in temp2])
        return result
# result.extend(["(%s)%s" % (p, q) for p in temp1 for q in temp2]) 这句是什么意思呀？
# %是格式化字符串输出，extend是把结果凑起来。这行代码干的事其实是递归生成括号。
# 如果把所有的情况分解拆开，发现最底层的形式无非n=0, 1这2种情况，
# 那么我们其实可以让括号一层一层包裹起来。这行代码其实就是一层一层包裹括号。
# for循环里面存在重复计算吧，比如说n=7的时候，i=2,j=4计算了2和4个括号的全排列，i=4，j=2的时候又计算了一遍，其实可以只计算一半，然后全排列的时候p和q调一下位置就行了。

# 我的模仿😐 
class Solution:
    def generateParenthesis(self, n):
        res = []
        if n == 0:
            return ['']
        if n == 1:
            return ['()']
        for i in range(n):
            j = n-1-i
            tmplist1 = self.generateParenthesis(i)
            tmplist2 = self.generateParenthesis(j)
            # 错误写法：return res.extend(['(%s)%s' for item1 in tmplist1 for item2 in temlist2])
            res.extend(['(%s)%s' % (item1,item2) for item1 in tmplist1 for item2 in tmplist2])
        return res
```

```scala
/**
* my first commitment 
* DFS + backtracking
* time complexity： O(4^n / square(n))
*     n-th Catalan number
*/

object Solution1 {
  def generateParenthesis(n: Int): List[String] = {
    val buffer = scala.collection.mutable.ListBuffer[String]()
    val l = "("
    val r = ")"

    def _generateParenthesis(right: Int, left: Int, n: Int, pair: String) {

      if (right == n && left == n) {
        buffer += pair
      } else {
        if (left < n) _generateParenthesis(right, left + 1, n, pair + l) // you can add open whenever you want if it's smaller then n
        if (left > right && right < n) _generateParenthesis(right + 1, left, n, pair + r)
      }
    }
    _generateParenthesis(0, 0, n, "")
    buffer.toList
  }
}

/**
* closure number
* a very genius and beautiful sol
*/
object Solution2 {
  def generateParenthesis(n: Int): List[String] =
    n match {
      case 0 => List("")
      case _ =>
        for{
          m <- (0 until n).toList  // ensure yield type is List instead of indexSeq
          leftString <- generateParenthesis(m)
          rightString <- generateParenthesis(n - m - 1)
        } yield "(" ++ leftString ++ ")" ++ rightString
    }
}

```

```scala
//Backtracking approach
//Memory limit exceeds from n=6
//works till n=5

object Solution {
    var output = scala.collection.mutable.Set.empty[String]
    var qualified = scala.collection.mutable.Set.empty[String]
    
    def isBalanced(chars: Array[Char]): Boolean = {
        var count = 0
        var flag = true
        var stack = scala.collection.mutable.Stack[Char]()
        
        stack.pushAll(chars)
        
        import scala.util.control.Breaks._
        
        breakable{
            while(!stack.isEmpty){
                val pop = stack.pop()
                if(count <= 0 && pop == '('){
                    flag = false
                    break
                }else if(pop == ')'){
                    count += 1
                }else{
                    count -= 1
                }
            }
        }
         
        if(flag && count == 0){
            true
        }else{
            false
        }
    }
    
    def backtrack(chars: Array[Char], l: Int, r: Int): Unit = {
        
        def swap(a: Int, b: Int) = {
            val temp = chars(a)
            chars(a) = chars(b)
            chars(b) = temp
        }
        
        
        if(l == r){
            val str = chars.mkString
            if(! qualified.contains(str)){
                qualified.add(str)
                if(isBalanced(chars)){
                    output.add(str)
                }
            }
        }else{
                (l to r).map(i => {
                swap(l, i)
                backtrack(chars, l+1, r)
                swap(l, i) //backtrack step
                })
        }
    }
    
    def generateParenthesis(n: Int): List[String] = {
        output = scala.collection.mutable.Set.empty[String]
        qualified = scala.collection.mutable.Set.empty[String]
        
        val inputString = (1 to n).map(_ => '(').mkString + (1 to n).map(_ => ')').mkString
        var inputCharArray = inputString.toCharArray
        
        backtrack(inputCharArray, 0, n+n-1)
        
        output.toList
    }
}


/**
In the above approach, what we are basically doing is getting all possible combinations and then filtering the ones that are balanced.
that is kinda brute force actually
In the below approach (also backtracking), we apply constraints, during forming the string itself
*/

object Solution {
    
    def generateParenthesis(n: Int): List[String] = {
        import scala.collection.mutable._
        def backtrack(acc: ListBuffer[String], curr: String, left: Int, right: Int): Unit = {
            if (left == 0 && right == 0) acc.append(curr)
            else {
                if (left > 0) backtrack(acc, curr + "(", left-1, right)
                if (right > left) backtrack(acc, curr + ")", left, right-1)
            }
        }
      
        val acc = ListBuffer[String]()
        backtrack(acc, "", n, n)
        acc.toList
    }
}

```

###  3.22. <a name='MergekSortedLists'></a>23. 【最小堆🌵】Merge k Sorted Lists

[花花酱](https://www.bilibili.com/video/BV1X4411u7xF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1178e?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK41157mu?spm_id_from=333.999.0.0)

暴力求解法：

* 时间复杂度: O(N) + O(N logN) + O(N)

* 空间复杂度: O(N) + O(N)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.65tcjjz2oy80.png" width="50%">

```py
# so easy，一遍过
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        arr = []
        for listhead in lists:
            while listhead:
                arr.append(listhead.val)
                listhead = listhead.next
        arr.sort()
        dummy = ListNode(0)
        cur = dummy
        for value in arr:
            cur.next = ListNode(value)
            cur = cur.next
        return dummy.next
```

优先队列：

* 时间复杂度: O(N logk) 

* 空间复杂度: O(N) + O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3tftyqf2g4s0.png" width="50%">

```py
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        q = []  # 易错点：先要定义一个空
        dummy = ListNode(0)
        cur = dummy
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(q,(lists[i].val,i))  # 易错点：要可以排序的
                lists[i] = lists[i].next # 易错点：注意，向后一位
        while q: # 易错点：注意这个循环条件
            val, idx = heapq.heappop(q)
            cur.next = ListNode(val)
            cur = cur.next
            if lists[idx]:
                heapq.heappush(q,(lists[idx].val,idx))
                lists[idx] = lists[idx].next # 易错点：注意，向后一位
        return dummy.next
```

两两合并：

* 时间复杂度: O(N logk) 

* 空间复杂度: O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.60itjgowwpo0.png" width="50%">

```py
class Solution:
    def merge2Lists(self, list1, list2):
        dummy = ListNode(0)
        cur = dummy # dummy是固定节点，cur是移动指针
        while list1 and list2: # 这里是and
            if list1.val < list2.val: # 易错点：这里是list.val，而不是list
                cur.next = list1
                list1 = list1.next # 向后进一位
            else:
                cur.next = list2
                list2 = list2.next # 向后进一位
            cur = cur.next # 向后进一位
        cur.next = list1 or list2 # 易错点：这里是cur.next，而不是cur。这里是or
        return dummy.next

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:     
        amount = len(lists)
        interval = 1
        while amount > interval:
            for i in range(0,amount-interval,2*interval):
                lists[i] = self.merge2Lists(lists[i], lists[i+interval]) # 易错点：方括号和小括号不要用错
            interval *= 2
        return lists[0] if amount>0 else None
```

###  3.23. <a name='SwapNodesinPairs'></a>24-Swap Nodes in Pairs

[哈哈哈](https://www.bilibili.com/video/BV1M7411n7FT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV13J411V7hG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ih411f7YK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1VC4y1s75E?spm_id_from=333.999.0.0)

```py
# 方法一：递归
class Solution(object):
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # 这样写也可以：
        # if not head or not head.next:
        #     return head
        if not head:
            return None
        if not head.next:
            return head
        tmp = head.next
        head.next = self.swapPairs(head.next.next)
        tmp.next = head
        return tmp # 易错点：注意，新的头已经变成了tmp
``` 

```py
# 方法二：迭代
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head # 易错点：这句话不要漏
        cur = dummy
        while cur.next and cur.next.next:

            first = cur.next
            second = cur.next.next
            
            # 把图画出来
            first.next = second.next
            second.next = first
            cur.next = second

            cur = cur.next.next
        return dummy.next
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */

/**
* chosen solution
* iterative version
* memo
*   1. dummyHead
*   2. need two pointer: pre node and current node
*  time complexity: O(N), each node only visit once
*/
object Solution0 {
    def swapPairs(head: ListNode): ListNode = {
        val nHead = new ListNode(0, head)
        var pre: ListNode  = nHead
        var curr = pre.next

        while (curr != null && curr.next != null) {
            val (pos1, pos2, next) = (curr, curr.next, curr.next.next)
            pre.next = pos2
            pos2.next = pos1
            pos1.next = next

            pre = pre.next.next
            curr = pre.next  
        }
        
        nHead.next
    }
}


/**
* iterative version
* memo
*   1. dummyHead
*   2. need two pointer: pre node and current node
*  time complexity: O(N), each node only visit once
*/
object Solution1 {
    def swapPairs(head: ListNode): ListNode = {
        val nHead = new ListNode(0, head)
        var pre: ListNode  = nHead
        var curr = pre.next

        while (curr != null && curr.next != null) {
            val (pos1, pos2, next) = (curr, curr.next, curr.next.next)
            pre.next = pos2
            pos2.next = pos1
            pos1.next = next

            pre = pre.next.next
            curr = pre.next  
        }
        
        nHead.next
    }
}


/**
* recursive version
*/
object Solution2 {
    def swapPairs(head: ListNode): ListNode = {
        _swap(head)
    }   
    
    def _swap(n: ListNode): ListNode = {
        if(n == null) n
        else {
            (n, n.next) match {
                case (a, null) => a
                case (a: ListNode, b: ListNode) => 
                    /** a b 要交換位子
                     */
                    a.next = _swap(b.next) // a 指向 b 的 next (已交換完成）
                    b.next = a // b 的 next 接上 a 就交換完成
                    b
            }
        } 
    }
}
```

###  3.24. <a name='Removeduplicatesfromsortedarray'></a>26-Remove duplicates from sorted array

[哈哈哈](https://www.bilibili.com/video/BV1UJ411m7Pz?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i77e?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV13V41177Mq?spm_id_from=333.999.0.0)

> for循环法：

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if n == 0: return 0
        left = 0
        for right in range(1, n):
            if nums[right] != nums[left]:
                left += 1
                nums[left] = nums[right]
        return left + 1

# 😁我的模仿
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        count = 0 #注意：count是从0开始的
        for i in range(len(nums)):
            if nums[i] != nums[count]:
                count += 1
                nums[count] = nums[i]
        return count + 1
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.xxd39w8j94g.png" width="30%">

> while循环法

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i = 0
        while i < (len(nums) - 1):
            if nums[i] == nums[i+1]:
                nums.remove(nums[i])
                等效于：nums.pop(i)
            else:
                i += 1
        return len(nums)

# 😁我的模仿：
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        while i < len(nums) - 1:
            if nums[i] == nums[i+1]:
                nums.pop(i)
                i -= 1 # 当pop以后，i指针不应该变化
            i += 1
        return len(nums)
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6zs7v6d4w740.png" width="60%">

```scala

object Solution {
    def removeDuplicates(nums: Array[Int]): Int = {
        
        // Two-pointer idea
        
        if (nums.length == 0){
            0
        } else {
            // if the Array is not empty, we start from index 1 rather than 0
            // since the 1st element (at index 0) will be included for sure.
            // For the same reason, the initial value of `count` is 1 instead of 0
            
            var count = 1
            
            // NOTE: start from 1 rathr than 0 here
            for (i <- 1 until nums.length) {
                if (nums(i) != nums(count-1)) {
                    nums(count) = nums(i)
                    count += 1
                }
            }
            
            count
        }
         
    }
}
```

```scala
object Solution {
    def removeDuplicates(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var head = 0
            var find = 1
            while(find < nums.length){
                if(nums(find) != nums(head)){
                    head += 1
                    nums(head) = nums(find)
                }
                find += 1
            }
            head + 1
        }
    }
}

```

###  3.25. <a name='python-Removeelement'></a>27-python-Remove element

[哈哈哈](https://www.bilibili.com/video/BV1mJ411m7ir?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7hZ?spm_id_from=333.999.0.0)

和上面一体差不多，很简单

```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        while i < len(nums):
            if nums[i] == val:
                nums.pop(i)
            else:
                i += 1
        return len(nums)
```

###  3.26. <a name='Implementstr'></a>28-Implement str

[哈哈哈](https://www.bilibili.com/video/BV1eL411n7YS?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1BJ41117d6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1UK411K7zB?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7cG?spm_id_from=333.999.0.0)

解法一：直接用.index()

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "":
            return 0
        if needle in haystack:
            return haystack.index(needle)
        else:
            return -1
```

解法二：在对整个needle字符串比较

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        for i in range(len(haystack)-len(needle)+1):
            if haystack[i:i+len(needle)] == needle:
                return i 
        return -1
```

```scala
object Solution {
    def strStr(haystack: String, needle: String): Int = {
        if(needle.isEmpty){
            0
        }else if(haystack.isEmpty){
            -1
        }else{
            var needleLength = needle.length
            var head = 0
            var end = head + needleLength
            var flag = true
            
            while(flag && (end <= haystack.length)){
                if(needle.equals(haystack.substring(head, end))){
                    flag = false
                }else{
                    head += 1
                    end += 1
                }
            }
            
            if(flag) -1 else head
        }
    }
}

```

###  3.27. <a name='NextPermutation'></a>31 Next Permutation

[小明](https://www.bilibili.com/video/BV1Uz4y1m72N?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1SK4y1V7ch?spm_id_from=333.999.0.0)

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # 关键在于从后往前，找到非递减序列
        i = len(nums) - 2
        while i >= 0:
            if nums[i] >= nums[i+1]:
                i -= 1
            else:
                # 寻找i后面比i大的数，交换位置,并且排序
                for j in range(len(nums)-1,i,-1): # 易错点:len(nums)-1,i的区间
                    # 12(3)5(4)
                    if nums[j] > nums[i]:
                        nums[i],nums[j] = nums[j],nums[i]
                        nums[i+1:] = sorted(nums[i+1:])
                        return
        nums.reverse() # 易错点:对于[3,2,1]这种情况，i = 0
```

```scala
/**
* my first commitment
* memo
* 1. find the first index i which breaks the increasing order
* 2. find the last index  j which is larger than index i
* 3. swap(i, j)
* 4. sorting: reverse sequence from i + 1 to the end 
* time complexity: O(n)
*/

object Solution1 {
    def nextPermutation(nums: Array[Int]): Unit = {
        /**
        * find the first index i which breaks the increasing order
        * 0 1 2 3 4 5 6
        * 5 4 7 6 5 4 3
        *   i     j 
        */
      ((nums.length - 2) to 0 by -1).find(idx => nums(idx) < nums(idx + 1)) match {
        case Some(idx) => 
          /* 
          * find the last index  j which  is larger than index i
          */
          val j = ((idx + 1) until nums.length).findLast(i => nums(idx) < nums(i)).getOrElse(idx)
          swap(nums, idx, j)
          reverse(nums, idx + 1, nums.length - 1)
        case None => reverse(nums, 0, nums.length - 1)
      }
    }
    @annotation.tailrec
    def reverse(nums: Array[Int], from: Int, to: Int) {
      if (from < to) {
        swap(nums, from, to)
        reverse(nums, from + 1, to - 1)
      }
    }
  
    def swap(nums: Array[Int], index1: Int, index2: Int) {
      val tmp = nums(index2)
      nums(index2) = nums(index1)
      nums(index1) = tmp
    }
}


```

###  3.28. <a name='LongestValidParentheses'></a>32 Longest Valid Parentheses

[小明](https://www.bilibili.com/video/BV1RZ4y1F7nJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1yi4y1G74d?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n) 

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6dkova4yjvk0.png)

```py
# 背一背吧，好难。
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0]*n
        if n == 0: return 0
        for i in range(n):
            if s[i] == ')' and s[i-dp[i-1]-1] == '(' and i - dp[i-1] - 1 >= 0:
                dp[i] = 2 + dp[i-1] + dp[i-dp[i-1]-2]
        return max(dp)
```

栈：

* 时间复杂度: O(n) 

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1dgqk0ervhb4.png)

```py
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = maxlength = 0
        for i,c in enumerate(s):
            if c == '(':
                stack.append(i)
            if c == ')':
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    length = i - stack[-1]
                    maxlength = max(maxlength,length)
        return maxlength

```

```scala



/**
* using stack to record the char index in oder to calculate the valid length
* memo:
* 1. always only have one invalid symbol at stack and its position index is 0
* time complexity O(n)
* space complexity O(n)
*/
object Solution1 {

  import collection.mutable

  def longestValidParentheses(s: String): Int = {
    val mapping = Map('(' -> ')')
    val stack = mutable.Stack[Int]()
    stack.push(-1)
    s.indices.foldLeft(0) {
      case (maxLength, idx) =>
        val char = s(idx)
        if (mapping.contains(char)) {
          stack push idx
          maxLength
        } else {
          stack.pop()
          if (stack.isEmpty) {
            stack push idx
            maxLength
          } else {
            (idx - stack.head) max maxLength
          }
        }
    }
  }
}
```

###  3.29. <a name='SearchinRotatedSortedArray'></a>33. Search in Rotated Sorted Array

[小梦想家](https://www.bilibili.com/video/BV1gJ411V7Sq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV14t4y127hK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16A41147Fp?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # 定义第一个元素和最后一个元素
        left, right = 0, len(nums) - 1
        while left <= right:
            # 找到二分的位置：
            # mid = l + ((r - l) >> 2)
            # mid = (l + r) // 2
            mid = (right + left) // 2
            # 第一步
            if nums[mid] == target:
                return mid

            # --------------第二步：核心代码--------------
            # 只存在一个上升序列
            if nums[mid] < nums[right]:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            # --------------第二步：核心代码--------------
        return -1

# 我的模仿！啊😋

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1

        while l <= r:
            m = (l+r) // 2
            if nums[m] == target:
                return m
            if nums[l] <= nums[m]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else: 
                    l = m + 1
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else: 
                    r = m - 1
        
        return -1
```

```py
# 这道题简直是在跟我开玩笑（狗头）

class Solution(object):
    def search(self, nums, target):
        return nums.index(target) if target in nums else -1
```

```scala


/**
* my first commitment
* binary search
* memo
* 1. check if it is sorted side first. if side is sorted, using the normal binary search function , or else using the search function 
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
        search(nums, target, 0 , nums.length - 1)
    }
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      
      val mid = left + (right - left) / 2
      val midValue = nums(mid)
      
      if (midValue == target) return mid
      
      val leftAns = if (nums(left) < midValue)  
        searchOrder(nums, target, left, mid - 1)
      else 
        search(nums, target, left, mid - 1)
      
      if (leftAns != -1) 
        leftAns
      else {
        if (midValue < nums(right))
           searchOrder(nums, target, mid + 1, right)
        else
          search(nums, target, mid + 1, right)
      } 
    }
  
    def searchOrder (nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      val mid = left + (right - left) / 2
      val midValue = nums(mid)
      if (midValue == target) 
       mid
      else if (target > midValue)
        searchOrder(nums, target, mid + 1, right)
      else 
        searchOrder(nums, target, left, mid - 1)
    }
}


/**
* binary search - iterative version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      
      var ans = -1
      while(ans == -1 && left <= right) {
        val mid = left + (right - left) / 2

        if (target == nums(mid) ){
          ans = mid

        } else if (nums(left) <= nums(mid)){ // left part is in order
          if (nums(mid) > target && target >= nums(left)) { // target is in left part
            right = mid - 1
          } else {
            left = mid + 1
          }
        } else { // right part is in order
          if (nums(mid) < target && target <= nums(right)) { // target is in right part
            left = mid + 1
          } else {
            right = mid - 1
          }
        } 
      }
      ans
    }
}


```

###  3.30. <a name='-1'></a>34-在排序数组中查找元素的第一个

[哈哈哈](https://www.bilibili.com/video/BV1Zv411y71t?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1GU4y1j7dq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ef4y1v7Vz?spm_id_from=333.999.0.0)

```py
# Python 二分法

class Solution:
    def searchRange(self, nums, target):
        left = 0
        right = len(nums)-1
        res = [0,0]
        
        if target not in nums:
            return [-1,-1]

        # 寻找左侧边界
        while(left<=right):
            mid = (right + left) // 2
            if nums[mid] == target:
                right = mid - 1 # 结束条件
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[0] = left

        # 寻找右侧边界
        right = len(nums)-1
        while left<=right:
            mid = (right + left) // 2
            if nums[mid] == target:
                left = mid + 1 # 结束条件
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[1] = right

        return res
```

```py
# 二分搜索算法返回首个不小于（即：等于或大于）target的元素的下标，这样只需进行两次相似的二分搜索即可

# 这种方法很漂亮，但是很容易出错，不推荐。

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = self.binarySearch(nums, target)
        end = self.binarySearch(nums, target+1)
        if start < end:
            return [start,end-1]
        else:
            return [-1,-1]
    
    def binarySearch(self, nums, target):
        l = 0
        r = len(nums)  # 精华,千万不能-1，
        while l < r: # 精华,千万不能包括==，
            m = (l + r) // 2
            # 由于这里存在多个重复数字，所以简单的二分查找不顶用
            # 这里的思想是找到left
            if target > nums[m]: # 精华,千万不能包括==，不然left不能移动
                l = m + 1 # 精华
            else:
                r = m
        return l

```

```scala


/**
* my first commitment
*
*/
object Solution1 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val hit = search(nums, target, 0, nums.length - 1)
      if (hit == -1)
        Array(-1, -1)
      else  {
        var left = hit
        while (left - 1 >= 0 && nums(left) == nums(left - 1)){
          left -= 1
        }
        var right = hit
        while(right + 1 < nums.length && nums(right) == nums(right + 1)){
          right += 1
        }
        Array(left, right)
      }
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if (left > right) return -1
      
      val mid = left + (right - left) / 2
       
      if (nums(mid) == target)
        mid
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1)
      else 
        search(nums, target, mid + 1, right)
      
      
    }
 }

/**
* function programming
*/

 object Solution1-2 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val hit = search(nums, target, 0, nums.length - 1)
      if (hit == -1)
        Array(-1, -1)
      else {
        val left = (hit to 0 by -1 ).findLast(l => nums(l) == nums(hit)).getOrElse(-1)
        val right = (hit to (nums.length - 1)).findLast(r => nums(r) == nums(hit)).getOrElse(-1)
        Array(left, right)
      } 
    }
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if (left > right) return -1
      val mid = left + (right - left) / 2
       
      if (nums(mid) == target)
        mid
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1)
      else 
        search(nums, target, mid + 1, right)
    }
 }

/**
* modify binary search template
* memo
*  1. search first and last the the same function
*  2. if nums(mid) == target we could move left to check if left part exists target number
*  3. finding last by target + 1,  then we could get last position of target by first position of (target + 1) - 1
* tricky:
*  1. ans = nums.length
*  2. first > last  means that target doesn't exists
*
* time complexity: O(2logN)
*/
 
 object Solution2 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
        val first = search(nums, target)
        val last = search(nums, target + 1) - 1
        if (first > last) Array(-1, -1) else Array(first, last)
    }

    def search(nums: Array[Int], target: Int): Int = {
      var ans = nums.length
      var left = 0
      var right = nums.length - 1
      while (left <= right) {
        val mid = left + (right - left) / 2
        if (nums(mid) >= target) {
          ans = mid
          right = mid - 1
        }else {
          left = mid + 1
        } 
      }
      ans
    }
}

/**
* recursive version
*/
object Solution2-1 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val first = search(nums, target, 0, nums.length - 1, nums.length)
      val last = search(nums, target + 1, 0, nums.length - 1, nums.length) - 1
      if (first > last) Array(-1, -1) else Array(first, last)
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int, ans: Int): Int = {
      if (left > right) return ans
      val mid = left + (right - left) / 2
      
      if (nums(mid) == target)
        search(nums, target, left, mid - 1, mid)
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1, mid)
      else
        search(nums, target, mid + 1, right, ans)
      
    }
}

```

###  3.31. <a name='-1'></a>35-搜索插入位置

[哈哈哈](https://www.bilibili.com/video/BV1HD4y1m7U2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411i7Aj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1dA411a7CB?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1wf4y1m7Ue?spm_id_from=333.999.0.0)

* 时间复杂度: O(logn) 

* 空间复杂度: O(1)

```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if target == nums[m]:
                return m
            elif target < nums[m]:
                r = m - 1
            else: 
                l = m + 1
        return l #易错点：记住，这里需要输出，且输出left
```

```scala

/**
* my first commitment
*/
object Solution1 {
    def searchInsert(nums: Array[Int], target: Int): Int = {
        search(nums, target)
    }
    
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        val mid = left + (right - left) / 2
        
        if (nums(mid) == target)
          ans = mid
        else if (nums(mid) > target)
          right = mid - 1
        else
          left = mid + 1
        
      }
      if (ans == -1) left else ans
    }
}
```

###  3.32. <a name='-1'></a>36-有效的数独

[哈哈哈](https://www.bilibili.com/video/BV1Cf4y1R7PR?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1MJ411p7FT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ZL4y1e7oo?spm_id_from=333.999.0.0)

```py
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        cols = [set() for _ in range(9)]
        rows = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if board[i][j] in cols[j] or \
                    board[i][j] in rows[i] or \
                    board[i][j] in grids[i//3][j//3]:
                        return False
                    else:
                        cols[j].add(board[i][j])
                        rows[i].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])
        return True
```

```scala
object Solution {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        
        
        import util.control.Breaks._
        
        def check_a_single_array(l: Array[Char]): Boolean = {
            // input: Array of char, an Array of 9 elments to check using the three rules
            // return: Boolean, if the array given can pass the exam
            val temp = l.filter(_ != '.')
            if (temp.length != temp.distinct.length) {
                false
            } else {
                true
            }
        }
        
        
        var error_flag = 0
        
        breakable {
            
            // check rule-1
            for (i <- 0 until 9) {
                if (check_a_single_array(board(i)) ==  false) {
                    error_flag += 1
                    break
                }
              }

            // check rule-2
            for (i <- 0 until 9) {
                val temp_list = board.map(_(i))
                
                if (check_a_single_array(temp_list) == false) {
                    error_flag += 1
                    break
                }
            }
            
            // check rule-3
            for (i <- 0 until 3; j <- 0 until 3) {
                // get each 3x3 sub-boxes and flatten it to a 9-length Array
                val temp_list = board.slice(i * 3, i * 3 + 3).flatMap(_.slice(j * 3, j*3 + 3))
                
                if (check_a_single_array(temp_list) == false) {
                    error_flag += 1
                    break
                }
            }
 
        }

 
        if (error_flag > 0) false else true
         
    }
}
```

```scala

/**
* chosen solution
* memo
*   1. three array recording whether current value is valid
*        1. rows array
*        2. columns array
*        3. blocks array
* time complexity: O(1), just one iteration
* space complexity: O(3), all sudoku are 9 x 9 
*/
object Solution0 {
  def isValidSudoku(board: Array[Array[Char]]): Boolean = {
      val size = board.length
      val rows = Array.ofDim[Boolean](size, size)
      val cols =  Array.ofDim[Boolean](size, size)
      val blocks =  Array.ofDim[Boolean](size, size)
      
      val coords = for(i <- board.indices.view; j <- board.indices.view; if board(i)(j) != '.') yield (i, j)
      
      coords.forall{ case (i, j) => 
          val num = board(i)(j).asDigit - 1
          val blockIdx = (i / 3) * 3 + (j / 3)
          if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
            rows(i)(num) = true
            cols(j)(num) = true
            blocks(blockIdx)(num) = true
            true
        
          } else false
      }
  }
}

  
  /**
  *  recursive version : DFS
  *  memo
  *    1. three array recording whether current value is valid
  *        1. rows array
  *        2. columns array
  *        3. blocks array
  * time complexity: O(1), just one iteration
  * space complexity: O(3), all sudoku are 9 x 9
  */
  object Solution1 {

    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
      def _isValidSudoku(currentRow: Int, currentCol: Int, cols: Array[collection.mutable.Set[Char]], rows: Set[Char], blocks: Array[collection.mutable.Set[Char]]): Boolean = {
        (currentRow < board.length, currentCol < board.length) match {
          case (false, _) => true
          case (true, true) => // current line next position
            val v = board(currentRow)(currentCol)
            val blockIndex = 3 * (currentRow / 3) + currentCol / 3
            if (v == '.') {
              _isValidSudoku(currentRow, currentCol + 1, cols, rows, blocks)

            } else {
              if (cols(currentCol).contains(v) || rows.contains(v) || blocks(blockIndex).contains(v)) {
                false
              }
              else {
                blocks(blockIndex) += v
                cols(currentCol) += v
                _isValidSudoku(currentRow, currentCol + 1, cols, rows + v, blocks)
              }
            }
          case (true, false) => _isValidSudoku(currentRow + 1, 0, cols, Set[Char](), blocks) // next line
        }
      }
      _isValidSudoku(0, 0, Array.fill(board.length)(collection.mutable.Set[Char]()), Set[Char](), Array.fill(board.length)(collection.mutable.Set[Char]()))
    }

  }



/**
* iterative
* memo
*   1. three array recording whether current value is valid
*        1. rows array
*        2. columns array
*        3. blocks array
* time complexity: O(1), just one iteration
* space complexity: O(3), all sudoku are 9 x 9
*/
object Solution2 {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        val rows = Array.ofDim[Boolean](board.length, board.length)
        val cols = Array.ofDim[Boolean](board.length, board.length)
        val blocks = Array.ofDim[Boolean](board.length, board.length)
        var result = true
        for {
            (row, rowIndex) <- board.zipWithIndex
            (v, colIndex) <- row.zipWithIndex
            if result
        } {
            if (v != '.') {
            val blockIndex = 3 * (rowIndex / 3) + (colIndex / 3)
            val value = v.asDigit - 1
            if (rows(rowIndex)(value) || cols(colIndex)(value) || blocks(blockIndex)(value)) {
                result = false
            } else {
                rows(rowIndex)(value) = true
                cols(colIndex)(value) = true
                blocks(blockIndex)(value) = true
            }
            }

        }
            result
        }
}

/**
* it's no need for zipWithIndex: faster
*/
object Solution2-2 {
  def isValidSudoku(board: Array[Array[Char]]): Boolean = {
    val size = board.length
    val rows = Array.ofDim[Boolean](size, size)
    val cols =  Array.ofDim[Boolean](size, size)
    val blocks =  Array.ofDim[Boolean](size, size)


    var result = true
    for(i <- 0 until size; j <- 0 until size; if board(i)(j) != '.' && result) {
       val num = board(i)(j).asDigit - 1
       val blockIdx = (i / 3) * 3 + (j / 3)
      if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
          rows(i)(num) = true
          cols(j)(num) = true
          blocks(blockIdx)(num) = true
          
      }else {
          result = false
      }

    }
    result
  }
}

/**
* function programming way without key word return in loop block
*/

object Solution2-3 {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        val size = board.length
        val rows = Array.ofDim[Boolean](size, size)
        val cols =  Array.ofDim[Boolean](size, size)
        val blocks =  Array.ofDim[Boolean](size, size)
        
        val coords = for(i <- board.indices.view; j <- board.indices.view; if board(i)(j) != '.') yield (i, j)
        
        coords.forall{ case (i, j) => 
            val num = board(i)(j).asDigit - 1
            val blockIdx = (i / 3) * 3 + (j / 3)
            if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
              rows(i)(num) = true
              cols(j)(num) = true
              blocks(blockIdx)(num) = true
              true
          
            } else false
        }
    }
}


```

###  3.33. <a name='SudokuSolver'></a>37. Sudoku Solver 解数独

[花花酱](https://www.bilibili.com/video/BV1Tt41137Xr?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1f5411h7er?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3k462gpgb5k0.png)

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if  board[i][j] not in rows[i] and \
                        board[i][j] not in cols[j] and \
                        board[i][j] not in grids[i//3][j//3]:
                        rows[i].add(board[i][j])
                        cols[j].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])

        def dfs(i,j):
            if board[i][j] != '.': # 被数字填满

                if i == 8 and j == 8:
                    self.flag = True
                    return
                if j < 8:
                    dfs(i,j+1)
                if j == 8:
                    dfs(i+1,0)
                    
            else:
                for num in range(1,10):
                    item = str(num)
                    if  item not in rows[i] and \
                        item not in cols[j] and \
                        item not in grids[i//3][j//3]:
                        board[i][j] = item
                        rows[i].add(item)
                        cols[j].add(item)
                        grids[i//3][j//3].add(item)

                        # 易错点:注意缩进关系
                        if i == 8 and j == 8:
                            self.flag = True
                            return
                        if j < 8:
                            dfs(i,j+1)
                        if j == 8:
                            dfs(i+1,0)
                        if self.flag:
                            return
                            
                        board[i][j] = '.'
                        rows[i].remove(item)
                        cols[j].remove(item)
                        grids[i//3][j//3].remove(item)

        self.flag = False
        dfs(0,0)

```

```scala
/**
* chosen solution
* DFS + pruning + queue
* time complexity: O(N^2)
*/

object Solution0 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val coords = for(i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)
    if (!solveSudoku(board.map(_.clone), coords, board))
      println("cannot solve under this condition")
  }

  private def solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)] , ansBoard: Array[Array[Char]]): Boolean = {
    coordQueue match {
      case coord :: newQueue if coordQueue.nonEmpty =>
        ('1' to '9').filter(isValid(board, coord, _)).exists{ char =>
          board(coord._1)(coord._2) = char
          val ret = solveSudoku(board, newQueue, ansBoard)
          board(coord._1)(coord._2) = '.'
          ret
        }
      case _ if coordQueue.isEmpty =>
        board.zipWithIndex.foreach{case (arr: Array[Char], idx: Int) => ansBoard(idx) = arr.clone()}
        true
      case _ =>
        false
    }
  }

  private def isValid(board: Array[Array[Char]], coord: (Int, Int), value: Char): Boolean = {
    val (rowIdx, colIdx) = coord
    val rowValid = ! board(rowIdx).contains(value)
    val columnValid = board.forall(row => row(colIdx) != value)
    val blockValid = generateBlockIdx(rowIdx, colIdx) forall  {case (r, c) => board(r)(c) != value}

    rowValid && columnValid && blockValid
  }

  private def generateBlockIdx(rowIdx: Int, colIdx: Int): Iterator[(Int, Int)] = {
    val blockRowIdx = (rowIdx / 3) * 3
    val blockColIdx = (colIdx / 3) * 3
    for(i <- (blockRowIdx until blockRowIdx + 3).toIterator ; j <- blockColIdx until blockColIdx + 3) yield (i,j)
  }
}



/**
* my first commitment
* DFS + pruning
*/
object Solution1 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    _solveSudoku(board)
  }
  def _solveSudoku(board: Array[Array[Char]]): Boolean = {

    for {
      (rows, rowIdx) <- board.zipWithIndex
      (v, colIdx) <- rows.zipWithIndex
    } {
      if (v == '.') {
        for (c <- '1' to '9') {

          if (_isValid(rowIdx, colIdx, c, board)) {
            board(rowIdx)(colIdx) = c
            if (_solveSudoku(board)) return true
            else board(rowIdx)(colIdx) = '.'
          }
        }
        return false
      }
    }
    true
  }

  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || board.slice(boardRowIndex, boardRowIndex + 3).map(_.slice(boardColIndex, boardColIndex + 3)).exists(r => r.contains(char))) false
    else true
  }
}



/**
*  DFS + pruning + queue
*  memo:
*    using a queue storing unfilled index
*/
object Solution1-2 {

  import scala.collection.immutable.Queue

  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val indexes = scala.collection.mutable.Queue[(Int, Int)]()
    for {
      (row, rowIdx) <- board.zipWithIndex
      (value, colIdx) <- row.zipWithIndex
    } {
      if (value == '.') {
        indexes.enqueue((rowIdx, colIdx))
      }
    }
    _solveSudoku(Queue(indexes.dequeueAll(_  => true): _*), board.map(_.clone()), board)
  }


  def _solveSudoku(indexes: Queue[(Int, Int)], currentBoard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    if (indexes.isEmpty) {
      // end condition
      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      true
    } else {
      val ((row, col), newIndexes) = indexes.dequeue
      ('1' to '9').filter(_isValid(row, col, _, currentBoard)).find ( c =>_solveSudoku(newIndexes, copyBoard(currentBoard)(row, col, c), finalBoard))
       match {
        case Some(_) => true
        case None => false
      }
    }

  }
  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val checkBoardExits = (rr: Int, cc: Int, c: Char) => {
      var result = false
      for {
        i <- 0 until 3
        j <- 0 until 3
        if !result
      } {
        if (board(i + rr)(j + cc) == c) result = true
      }
      result
    }
    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || checkBoardExits(boardRowIndex, boardColIndex, char)) {
      false
    } else {
      true
    }
  }

  val copyBoard = (b: Array[Array[Char]]) => (row: Int, col: Int, c: Char) => {
    val newB = b.map(_.clone())
    newB(row)(col) = c
    newB
  }
}


/**
*  DFS + pruning + queue
*/
object Solution1-3 {

  import scala.collection.immutable.Queue

  def solveSudoku(board: Array[Array[Char]]): Unit = {
    val indices = scala.collection.mutable.Queue[(Int, Int)]()

    for (i <- 0 until board.length; j <- 0 until board.length) {
      val v = board(i)(j)
      if (v == '.') indices.enqueue((i, j))
    }
    _solveSudoku(Queue(indices.dequeueAll(_ => true): _*), board.map(_.clone()), board)
  }


  def _solveSudoku(indices: Queue[(Int, Int)], currentBoard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    if (indices.isEmpty) {
      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      return true
    }

    val ((row, col), newIndices) = indices.dequeue
    ('1' to '9').filter(_checkValid(_, (row, col), currentBoard)).find { // find: 找出第一個合法數字，代表其後的迭代有解
      c =>
        currentBoard(row)(col) = c
        if (_solveSudoku(newIndices, currentBoard, finalBoard)) true
        else {
          currentBoard(row)(col) = '.'
          false
        }
    } match {
      case Some(_) => true
      case None => false  // 這個盤勢不管填什麼後續都無解
    }
  }

  def _checkValid(c: Char, index: (Int, Int), currentBoard: Array[Array[Char]]): Boolean = {
    val (row, col) = index
    val blockRowIdx = 3 * (row / 3)
    val blockColIdx = 3 * (col / 3)
    val checkBoard = (rowAnchar: Int, colAnchar: Int) => {
      val pairs = for (i <- 0 until 3; j <- 0 until 3) yield (rowAnchar + i, colAnchar + j)
      pairs.exists { case (i, j) => currentBoard(i)(j) == c }
    }
    if (currentBoard(row).contains(c) || currentBoard.exists(a => a(col) == c) || checkBoard(blockRowIdx, blockColIdx)) false
    else true
  }
}

/**
*  DFS + pruning + queue
*    improvement: isValid is more concise
*/
object Solution1-4 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val coords = for(i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)
    if (!solveSudoku(board.map(_.clone), coords, board))
      println("cannot solve under this condition")
  }

  private def solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)] , ansBoard: Array[Array[Char]]): Boolean = {
    coordQueue match {
      case coord :: newQueue if coordQueue.nonEmpty =>
        ('1' to '9').filter(isValid(board, coord, _)).exists{ char =>
          board(coord._1)(coord._2) = char
          val ret = solveSudoku(board, newQueue, ansBoard)
          board(coord._1)(coord._2) = '.'
          ret
        }
      case _ if coordQueue.isEmpty =>
        board.zipWithIndex.foreach{case (arr: Array[Char], idx: Int) => ansBoard(idx) = arr.clone()}
        true
      case _ =>
        false
    }
  }

  private def isValid(board: Array[Array[Char]], coord: (Int, Int), value: Char): Boolean = {
    val (rowIdx, colIdx) = coord
    val rowValid = ! board(rowIdx).contains(value)
    val columnValid = board.forall(row => row(colIdx) != value)
    val blockValid = generateBlockIdx(rowIdx, colIdx) forall  {case (r, c) => board(r)(c) != value}

    rowValid && columnValid && blockValid
  }

  private def generateBlockIdx(rowIdx: Int, colIdx: Int): Iterator[(Int, Int)] = {
    val blockRowIdx = (rowIdx / 3) * 3
    val blockColIdx = (colIdx / 3) * 3
    for(i <- (blockRowIdx until blockRowIdx + 3).toIterator ; j <- blockColIdx until blockColIdx + 3) yield (i,j)
  }
}



object Solution2 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    _solveSudoku(0, 0, board.map(_.clone()), board)
  }

  def _solveSudoku(currentRow: Int, currentCol: Int, currenBboard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    (currentRow < finalBoard.length, currentCol < finalBoard.length) match {
      case (false, _) => // end condition
        currenBboard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
        true
      case (true, false) => // next line (row)
        _solveSudoku(currentRow + 1, 0, currenBboard, finalBoard)
      
      case (true, true) if currenBboard(currentRow)(currentCol) == '.' => 
        ('1' to '9').filter(c => _isValid(currentRow, currentCol, c, currenBboard))
          .find(c => _solveSudoku(currentRow , currentCol + 1, copyBoard(currenBboard)(currentRow, currentCol, c), finalBoard)) match { // fix row shift col
          case Some(_) => true
          case None => false
        }

      case _ => _solveSudoku(currentRow, currentCol + 1, currenBboard, finalBoard) // fix row, next col 
    }
  }

  val copyBoard = (b: Array[Array[Char]]) => (row: Int, col: Int, c: Char) => {
    val newB = b.map(_.clone())
    newB(row)(col) = c
    newB
  }

  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val checkBoardExits = (rr: Int, cc: Int, c: Char) => {
      var result = false
      for {
        i <- 0 until 3
        j <- 0 until 3
        if !result
      } {
        if (board(i + rr)(j + cc) == c) result = true
      }
      result
    }
    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || checkBoardExits(boardRowIndex, boardColIndex, char)) {
      false
    } else {
      true
    }
  }

}


/**
* DFS + pruning + extra space
* using extra three two dimension array to store col row and block's information
* a mutable collection method
*/


object Solution4 {
  import scala.reflect.ClassTag
  import scala.collection.immutable.Queue
  def solveSudoku(board: Array[Array[Char]]): Unit = {
    val indexes = scala.collection.mutable.Queue[(Int, Int)]()
    val rows = Array.ofDim[Boolean](board.length, board.length)
    val cols = Array.ofDim[Boolean](board.length, board.length)
    val blocks = Array.ofDim[Boolean](board.length, board.length)
    for {
      (row, rowIdx) <- board.zipWithIndex
      (value, colIdx) <- row.zipWithIndex
    } {
      if (value == '.') {
        indexes.enqueue((rowIdx, colIdx))
      } else {
        val blockIdx = 3 * (rowIdx / 3) + (colIdx / 3)
        val v = value.asDigit - 1
        rows(rowIdx)(v) = true
        cols(colIdx)(v) = true
        blocks(blockIdx)(v) = true

      }

    }

    _solveSudoku( Queue(indexes.dequeueAll(_ => true): _*),
      rows,
      cols,
      blocks,
      board
    )

  }

  def _solveSudoku(indexes: Queue[(Int, Int)],
                   rows: Array[Array[Boolean]],
                   cols: Array[Array[Boolean]],
                   blocks: Array[Array[Boolean]],
                   currentBoard: Array[Array[Char]]
                  ): Boolean = {
    if (indexes.isEmpty) {
//      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      true
    } else {
      val ((row, col), newIndexes) = indexes.dequeue
      ('1' to '9').filter(_isValid((row, col), _, rows, cols, blocks))
        .find { c =>
          val v = c.asDigit - 1
          rows(row).update(v, true)
          cols(col).update(v, true)
          blocks( 3 * (row / 3) + (col / 3)).update(v, true)
          currentBoard(row)(col) = c
          if (_solveSudoku(newIndexes,
            rows,
            cols,
            blocks,
            currentBoard
            //            copyBoard(rows)(row, v, true),
            //            copyBoard(cols)(col, v, true),
            //            copyBoard(blocks)(3 * (row / 3) + (col / 3), v, true),
            //            copyBoard(currentBoard)(row, col, c),
          //  finalBoard
          )) {
            true
          } else {
            rows(row).update(v, false)
            cols(col).update(v, false)
            blocks( 3 * (row / 3) + (col / 3)).update(v, false)
            currentBoard(row)(col) = '.'
            false
          }
        } match {
        case Some(_) => true
        case None => false
      }
    }
  }
  def _isValid(index: (Int, Int),
               char: Char,
               rows: Array[Array[Boolean]],
               cols: Array[Array[Boolean]],
               blocks: Array[Array[Boolean]]): Boolean = {


    val (row, col) = index
    val v = char.asDigit - 1
    val blockIdx = 3 * (row / 3) + (col / 3)

    if (rows(row)(v) || cols(col)(v) || blocks(blockIdx)(v)) false
    else true
  }

//  def copyBoard[T](b: Array[Array[T]])(row: Int, col: Int, c: T)(implicit ctg: ClassTag[T]): Array[Array[T]] = {
//    val newB = b.map(_.clone())
//    newB(row)(col) = c
//    newB
//  }
}

object Solution4-2 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {
    /* three extra tables to record whether coordinate is occupied */
    val columns = Array.ofDim[Boolean](board.length, board.length)
    val rows = Array.ofDim[Boolean](board.length, board.length)
    /**
      * block index:
      *     1 2 3
      *     4 5 6
      *     7 8 9
      * convert (rowIndex, columnIndex) to blockIndex:  ( rowIndex / 3 ) * 3 + ( columnIndex / 3)
      */
    val blocks = Array.ofDim[Boolean](board.length, board.length)

    /* DFS worker*/
    def _solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)], ans: Array[Array[Char]], checkValid: ((Int, Int), Char) => Boolean): Boolean = {
      coordQueue match {
          /* DFS not complete case : coordinate queue non empty */
        case coord :: newQueue if coordQueue.nonEmpty =>
          ('1' to '9').filter(checkValid(coord, _)).exists { char =>
            val (rowIdx, colIdx) = coord

            /* set board with char value by coordinate */
            board(rowIdx)(colIdx) = char
            rows(rowIdx)(char.asDigit - 1) = true
            columns(colIdx)(char.asDigit - 1) = true
            blocks((rowIdx / 3) * 3 + (colIdx / 3))(char.asDigit - 1) = true

            val ret = _solveSudoku(board, newQueue, ans, checkValid)

            /* recover to status before calling  _solveSudoku 
            *  reset board table, rows table, columns table and blocks table
            * */
            board(rowIdx)(colIdx) = '.'
            rows(rowIdx)(char.asDigit - 1) = false
            columns(colIdx)(char.asDigit - 1) = false
            blocks((rowIdx / 3) * 3 + (colIdx / 3))(char.asDigit - 1) = false
            ret
          }

          /* coordinate queue ran out, answer should shows up */
        case _ if coordQueue.isEmpty =>
          board.zipWithIndex.foreach { case (r, idx) => ans(idx) = r.clone }
          true

        case _ => false
      }
    }

    /* generate all empty coordinates */
    val coords = for (i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)

    /* initial rows table, columns table, blocks table */
    for (i <- board.indices.toList; j <- board.indices; if board(i)(j) != '.') {
      val charIdx = board(i)(j).asDigit - 1  // index range from 0 to 9
      rows(i)(charIdx) = true
      columns(j)(charIdx) = true
      blocks((i / 3) * 3 + (j / 3))(charIdx) = true
    }
    val isValidFunc = isValid(_, _, rows, columns, blocks)

    _solveSudoku(board.map(_.clone), coords, board, isValidFunc)
  }

  /* check input char value is valid at the coordinate */
  def isValid(coord: (Int, Int), value: Char, rows: Array[Array[Boolean]], columns: Array[Array[Boolean]], blocks: Array[Array[Boolean]]): Boolean = {
    val (row, col) = coord
    val charIdx = value.asDigit - 1
    val blockIdx = (row / 3) * 3 + (col / 3)
    !rows(row)(charIdx) && !columns(col)(charIdx) && !blocks(blockIdx)(charIdx)
  }
}
```

###  3.34. <a name='Countandsay'></a>38-Count and say

[哈哈哈](https://www.bilibili.com/video/BV1QJ411R7MF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i717?spm_id_from=333.999.0.0)

```py
import itertools
class Solution:
    def countAndSay(self, n: int) -> str:
        res = '1'
        for _ in range(n-1):
            res = ''.join([str(len(list(g))) + k for k,g in itertools.groupby(res)])
        return res
```

```py
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1: 
            return '1'

        res = ''
        count = 1
        s = self.countAndSay(n-1)
        for i in range(len(s)):
            if i+1 < len(s) and s[i] == s[i+1]:
                count += 1
            else:
                res += str(count) + s[i]
                count = 1
        return res
```

```py
# 我的模仿😋

class Solution:
    def countAndSay(self, n: int) -> str:
        s = '1'
        for _ in range(n-1):
            tmp = ''
            count = 1  # 易错点：count的位置
            for j in range(len(s)):
                if j+1 < len(s) and s[j] == s[j+1]:
                    count += 1
                else:
                    tmp += str(count) + s[j]
                    count = 1  # 易错点：count重新置为1
            s = tmp
        return s
```

```scala
object Solution {
    def countAndSay(n: Int): String = {
        if(n == 1){
            "1"
        }else{
            val prev = countAndSay(n-1)
            val prevIntArray = prev.toCharArray.map(x => x - '0')
            
            var output = ""
            var count = 0
            if(!prevIntArray.isEmpty){
                var element = prevIntArray(0)
            
                for(elem <- prevIntArray){
                    if(elem == element){
                        count += 1
                    }else{
                        output = output + count + element
                        element = elem
                        count = 1
                    }
                }
                output = output + count + element
            }
            
            output
        }
    }
}


//Just using StringBuilder put the solution from 16% -> 93.5% in terms of time efficiency

object Solution {
    def countAndSay(n: Int): String = {
        if(n == 1){
            "1"
        }else{
            val prev = countAndSay(n-1)
            val prevIntArray = prev.toCharArray.map(x => x - '0')
            
            var output = new scala.collection.mutable.StringBuilder()
            var count = 0
            if(!prevIntArray.isEmpty){
                var element = prevIntArray(0)
            
                for(elem <- prevIntArray){
                    if(elem == element){
                        count += 1
                    }else{
                        output.append(count)
                        output.append(element)
                        element = elem
                        count = 1
                    }
                }
                output.append(count)
                output.append(element)
            }
            
            output.toString
        }
    }
}

```


###  3.35. <a name='CombinationSum39-'></a>39. Combination Sum 39-组合总和

[花花酱](https://www.bilibili.com/video/BV1gb411u7dy?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Wz411e79d?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12Z4y157nE?spm_id_from=333.999.0.0)

![Snipaste_2021-12-18_11-30-10](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/Snipaste_2021-12-18_11-30-10.5b1q5zh7t4w0.png)

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []

        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:]) 
                # 易错点，这里是res.append(path[:])，而不是res.append(path)
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    path.append(candidates[i])
                    dfs(i)
                    path.pop()
        dfs(0)
        return res
```

```scala
/**
* chosen solution - backtracking + dfs + pruning
* time complexity: O(N^target)
* space complexity: O(target)
*/

object Solution0 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(arr: Array[Int], idx: Int, currentSum: Int, list: List[Int], ans: mutable.ListBuffer[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += list
          return
        }
        val diff = target - currentSum
        (idx until arr.length).filter(i => arr(i) <= diff).foreach(i => dfs(arr, i, currentSum + arr(i), list :+ arr(i), ans)) 
      }
      
      val ans = mutable.ListBuffer.empty[List[Int]]
      
      dfs(candidates, 0, 0, List.empty, ans)
      ans.toList
        
    }
}

/**
* my first commitment: dfs - backtracking
*/

object Solution1-1 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(combination: List[Int], ans: mutable.Set[List[Int]]): Unit = {
        val currentSum = combination.sum
        
        if (currentSum == target) {
          ans += combination.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          candidates.filter(n => n <= diff).foreach{ case n => dfs(n :: combination, ans)}
        }
      }
      val ans = mutable.Set.empty[List[Int]]
      dfs(List.empty[Int], ans)
      ans.map(l => l.groupBy(identity).mapValues(_.length).toMap -> l).toMap.values.toList // distinct 
    }
}

/**
* optimize from 1-1: sort combination before appending to ans
*/
object Solution1-2 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(combination: List[Int], currentSum: Int, ans: mutable.Set[List[Int]]): Unit = {
        
        if (currentSum == target) {
          ans += combination.sorted.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          candidates.filter(n => n <= diff).foreach{ case n => dfs(n :: combination, currentSum + n, ans)}
        }
      }
      val ans = mutable.Set.empty[List[Int]]
      dfs(List.empty[Int], 0, ans)
      ans.toList
    }
}

/**
* optimize from 1-2: pruning some case- recording candidates array index i 
*/
object Solution1-3{
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(i: Int, combination: List[Int], currentSum: Int, ans: mutable.Set[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += combination.sorted.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          (i until candidates.length).filter(idx => candidates(idx) <= diff).foreach{ case idx => dfs(idx, candidates(idx) :: combination, currentSum + candidates(idx), ans)}
        }
      }
      
      val ans = mutable.Set.empty[List[Int]]
      dfs(0, List.empty[Int], 0, ans)
      ans.toList
    }
}

/**
* using ListBuffer instead of Set
* memo
* 1.candidates array should be in ascending order
* time complexity: O(N^target)
* space complexity: O(target)
*/
object Solution1-4 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(arr: Array[Int], idx: Int, currentSum: Int, list: List[Int], ans: mutable.ListBuffer[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += list
          return
        }
        val diff = target - currentSum
        (idx until arr.length).filter(i => arr(i) <= diff).foreach(i => dfs(arr, i, currentSum + arr(i), list :+ arr(i), ans)) 
      }
      
      val ans = mutable.ListBuffer.empty[List[Int]]
      
      dfs(candidates, 0, 0, List.empty, ans)
      ans.toList
        
    }
}
```

```scala
package com.zhourui.leetcode
import scala.util.control.Breaks._
import scala.collection.mutable.Stack

package lc0039_combinationsum {
  object Solution {
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      var arr = candidates
      scala.util.Sorting.quickSort(arr)
      var ans = Vector[List[Int]]()
      var subset  = Stack[Int]()

      def helper(nums:Array[Int], start:Int, rest:Int): Unit = {
        if (rest == 0) {
          ans = ans :+ subset.toList
          return
        }
        breakable {
          for (i<- start until nums.length) {
            if (rest>=nums(i)) {
              subset.push(nums(i))
              helper(nums,i,rest-nums(i))
              subset.pop
            } else {
              break()
            }
          }
        }
      }
      helper(arr,0,target)
      ans.toList
    }
  }
}


```

###  3.36. <a name='CombinationSumII40-II'></a>40. Combination Sum II 40-组合总和 II

[花花酱](https://www.bilibili.com/video/BV1Pb411u7Yd?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gT4y1J7JE?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        candidates.sort()
        # candidates.reverse()
        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:])
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    # 易错点：需要剪枝
                    if i > firstIdx and candidates[i] == candidates[i-1]: continue
                    # [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]会超时
                    path.append(candidates[i])
                    dfs(i+1)
                    path.pop()
        dfs(0)
        return res
```

###  3.37. <a name='FirstMissingPositive'></a>41 First Missing Positive

[小明](https://www.bilibili.com/video/BV1fy4y1k7pV?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums.append(0)
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0 or nums[i] >= n:
                nums[i] = 0
        # for num in nums:
            # if num >= n or num <= 0:
            #     num = 0
            # 易错点：for num in nums,其中num只能进行读操作，不能进行写操作。
            # 容易出错
        
        for num in nums:
            nums[num % n] += n  
            # 易错点：% n,一定要取余数，不然会index out of range

        for i,num in enumerate(nums):
            if num < n:
                return i

        return n
```

###  3.38. <a name='TrappingRainWater'></a>42. Trapping Rain Water

[花花酱](https://www.bilibili.com/video/BV1hJ41177gG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fi4y1t7BP?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        
        n = len(height)
        leftMax = [height[0]] + [0] * (n - 1)
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])

        rightMax = [0] * (n - 1) + [height[n - 1]]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])

        ans = sum(min(leftMax[i], rightMax[i]) - height[i] for i in range(n))
        return ans
```

栈：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)
        
        return ans
```

双指针：

* 时间复杂度: O(n)

* 空间复杂度: O(1)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans

#   😋我的模仿

class Solution:
    def trap(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        leftmax = 0
        rightmax = 0
        res = 0
        while left < right:
            if height[left] < height[right]:
                leftmax = max(leftmax,height[left])
                # 易错点：注意res和left的次序：先res，后left
                res += leftmax-height[left] 
                left += 1
            else:
                rightmax = max(rightmax,height[right])
                # 易错点：注意res和right的次序：先res，后right
                res += rightmax-height[right]
                right -= 1
        return res
```

###  3.39. <a name='JumpGameII'></a>45 Jump Game II

[小明](https://www.bilibili.com/video/BV1fb4y1Z77x?spm_id_from=333.999.0.0)

```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        maxPos, end, step = 0, 0, 0
        for i in range(n - 1):
            if maxPos >= i:
                maxPos = max(maxPos, i + nums[i])
                if i == end:
                    end = maxPos
                    step += 1
        return step

#   😋我的模仿

class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        jump = 0
        cover = 0
        stop = 0
        i = 0
        while cover >= i and i < n-1: 
            #易错点：是n-1，不是n，只要调到最后一格就算成功
            cover = max(cover,i + nums[i])
            if i == stop:
                jump += 1
                stop = cover
            i += 1
        return jump
```

###  3.40. <a name='-1'></a>46-把数字翻译成字符串

[哈哈哈](https://www.bilibili.com/video/BV1Bz411i7cs?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411W7eC?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.66thg6sgm600.png)

```py
class Solution:
    def translateNum(self, num: int) -> int:
        s = str(num)
        n = len(s)
        dp = [1]*n
        if '10' <= s[0:2] <= '25':
            dp[1] = 2
        for i in range(2,n):
            if '10' <= s[i-1:i+1] <= '25':
                dp[i] = dp[i-1] + dp[i-2]
            else:
                dp[i] = dp[i-1]
        return dp[-1]
```

###  3.41. <a name='-1'></a>46-全排列

[哈哈哈](https://www.bilibili.com/video/BV1YA411v7zF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7fm?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oa4y1v7Kz?spm_id_from=333.999.0.0)

```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        # n = len(nums)
        def dfs(nums):
            # 易错点：if len(path) == n:
            if not nums: # 判断条件应该是这个
                res.append(path[:]) # 易错点：path[:]
                return
            else:
                for i in range(len(nums)):
                    path.append(nums[i])
                    dfs(nums[:i]+nums[i+1:]) # 易错点：n是不断变小的
                    path.pop()
        dfs(nums)
        return res

# 另一种写法😋
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def dfs(nums,path):
            if not nums: 
                res.append(path[:]) 
                return
            else:
                for i in range(len(nums)):
                    dfs(nums[:i]+nums[i+1:],path + [nums[i]]) 
        dfs(nums,[])
        return res
```

```scala
object Solution {
    var output = List.empty[List[Int]]
    
    def backtrack(nums: Array[Int], l: Int, r: Int): Unit = {
        def swap(a: Int, b: Int) = {
            val temp = nums(a)
            nums(a) = nums(b)
            nums(b) = temp
        }
        
        /**
        In backtracking, we collect all the leaf nodes of the tree
        In this question, we fix the first letter and swap the others till we reach (l==r), i.e. no swap needed since its the leaf node
        So we add it to output
        */
        
        if(l == r){
            output = output :+ nums.toList
        }else{
            (l to r).map(i => {
                swap(l, i)
                backtrack(nums, l+1, r)
                swap(l, i) //backtrack step
            })
        }
    }
    
    def permute(nums: Array[Int]): List[List[Int]] = {
        output = List.empty[List[Int]]
        var input = nums
        backtrack(input, 0, input.length - 1)
        output
    }
}

```

###  3.42. <a name='II-'></a>47-全排列 II-剪枝版

[哈哈哈](https://www.bilibili.com/video/BV1Ev411672A?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1qK4y1x7Qs?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1z54y1a7rQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        def dfs(nums,path):
            if not nums:
                res.append(path[:])
            else:
                for i in range(len(nums)):
                    if i>0 and nums[i] == nums[i-1]:
                        continue
                    dfs(nums[:i]+nums[i+1:],path + [nums[i]])

        dfs(nums,[])
        return res
```

###  3.43. <a name='RotateImage'></a>48. 旋转图像 Rotate Image

[官方](https://www.bilibili.com/video/BV1mf4y1e7ox?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Wy4y1s7fs?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3kl7avrsvhi0.png" width="30%">

```py
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n//2):
            for j in range((n+1)//2):
                matrix[i][j],matrix[j][n-1-i],matrix[n-1-i][n-1-j],matrix[n-1-j][i] = \
                matrix[n-1-j][i],matrix[i][j],matrix[j][n-1-i],matrix[n-1-i][n-1-j]
        return matrix
```

```scala
/**
* my first commitment
* rotate 4 cell in each iteration
*
*   pattern:  (row, col) -> (col, n - 1- row)
*       1. (i, j) - > (j, n - 1 -i)
*       2. (j, n - 1 -i) -> (n - 1 - i, n - 1 - j)
*       3. (n - 1 - i, n - 1 - j) -> (n -1 -j, n - 1 - (n -1 - i) ) =  (n - 1 -j, i)
*       4. (n - 1 -j, i) -> (i, n - 1 - (n - 1 - j)) = (i, j)
*
* ((0,0) -> (0,3) -> (3,3) -> (3,0))
* ((0,1) -> (1,3) -> (3,2) -> (2,0))
* ((1,0) -> (0,2) -> (2,3) -> (3,1))
* ((1,1) -> (1,2) -> (2,2) -> (2,1))
* 
*/
object Solution1 {
    def rotate(matrix: Array[Array[Int]]): Unit = {
      val n = matrix.size
      printMatrix(n)
      
      for (i <- 0 until (n / 2).toInt + n % 2; j <- 0 until (n / 2).toInt){      
        val tmp = matrix(n - 1 -j)(i)
        matrix(n - 1 - j)(i) = matrix(n - 1 - i)(n - j - 1)
        matrix(n - 1 - i)(n - j - 1) = matrix(j)(n - 1 - i)
        matrix(j)(n - 1 - i) = matrix(i)(j)
        matrix(i)(j) = tmp
      }
    }
    def printMatrix(size: Int): Unit = {
      for (i <- 0 until size) {
        for (j <- 0 until size) {
          print(s"($i, $j) ")
        }
        println(" ")
      }
    }
    /**
        (0, 0) (0, 1) (0, 2) (0, 3)  
        (1, 0) (1, 1) (1, 2) (1, 3)  
        (2, 0) (2, 1) (2, 2) (2, 3)  
        (3, 0) (3, 1) (3, 2) (3, 3)  
    */
}
/**
* clockwise rotate = transpose + horizontal flip
*/
object Solution2 {
    def rotate(matrix: Array[Array[Int]]): Unit = {
        transpose(matrix)
        horizontalFlip(matrix)
    }
  
    def transpose(matrix: Array[Array[Int]]): Unit = {
      for (i <- matrix.indices; j <- i until matrix(i).length; if i != j) {
        val tmp = matrix(i)(j)
        matrix(i)(j) = matrix(j)(i)
        matrix(j)(i) = tmp
      }
    }
    def horizontalFlip(matrix: Array[Array[Int]]): Unit = {
      for(row <- matrix) {
        var from = 0 
        var to = row.length - 1 
        while(from < to) { // reverse row elements
          val tmp = row(to)
          row(to) = row(from)
          row(from) = tmp
          from += 1
          to -= 1
        }
      }
    }
}

/**
* optimize: reversArray by recursion
*/
object Solution2-1{
    def rotate(matrix: Array[Array[Int]]): Unit = {
        transpose(matrix)
        horizontalFlip(matrix)
    }
  
    def transpose(matrix: Array[Array[Int]]): Unit = {
      for (i <- matrix.indices; j <- i until matrix(i).length; if i != j) {
        val tmp = matrix(i)(j)
        matrix(i)(j) = matrix(j)(i)
        matrix(j)(i) = tmp
      }
    }
    def horizontalFlip(matrix: Array[Array[Int]]): Unit = {
      matrix.foreach(row => reverseArray(row, 0, row.length  - 1))
    }
  
    @annotation.tailrec
    def reverseArray(arr: Array[Int], from: Int, to: Int) {
      if (from > to) return
      val tmp = arr(to)
      arr(to) = arr(from)
      arr(from) = tmp
      reverseArray(arr, from + 1, to - 1)
    }
}
```

###  3.44. <a name='GroupAnagrams'></a>49 Group Anagrams

[小明](https://www.bilibili.com/video/BV1n5411t79G?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Yf4y1e7gJ?spm_id_from=333.999.0.0)

```py
# 质数对应字母 乘积哈希
# 这个思想可以学习！但我还没看
from functools import reduce
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]
        chars = "abcdefghijklmnopqrstuvwxyz"
        ch_pr = {chars[i]:prime[i] for i in range(26)}
        for s in strs:
            keys = reduce(lambda x,y :x*y,[ch_pr[i] for i in s], 1)
            if keys in dic:
                dic[keys].append(s)
            else:
                dic[keys] = [s]
        return list(dic.values())
```

```py
# python3 : 常规做法

class Solution:
    def groupAnagrams(self, strs):
        res = []
        dic = {}
        for s in strs:
            keys = "".join(sorted(s))
            if keys not in dic:
                dic[keys] = [s]
            else:
                dic[keys].append(s)
        return list(dic.values())

# 我的模仿😋

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        for s in strs:
            keys = ''.join(sorted(s)) #易错点：s被sorted以后，会变成list
            if keys not in dic:
                dic[keys] = [s] #易错点：[s],而不是s
            else:
                dic[keys].append(s)
        # print(dic.values())输出dict_values([['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']])
        return list(dic.values())
```

```py
# 更简单的写法：
class Solution:
    def groupAnagrams(self, strs):
        dic = collections.defaultdict(list)

        for s in strs:
            keys = "".join(sorted(s))
            dic[keys].append(s)
        
        return list(dic.values())
```

```scala
object Solution {
    def groupAnagrams(strs: Array[String]): List[List[String]] = {
        
        import collection.mutable.HashMap
        import collection.mutable.ListBuffer
        
        val mapping = HashMap[String, ListBuffer[String]]()
        
        for (s <- strs) {
            if (mapping.contains(s.sorted)) {
                mapping(s.sorted) += s
            } else {
                mapping(s.sorted) = ListBuffer(s)
            }
        }
        

        mapping.values.map(_.toList).toList

    }
}
```

```scala
/**
* chosen solution
* time complexity: O(N KLogK) : N: strs.length, K: the longest string in strs 
*/
object Solution0 {
    def groupAnagrams(strs: Array[String]): List[List[String]] =
        strs.groupBy(_.sorted.hashCode).values.map(_.toList).toList
}

/**
* my first commit
* convert all strs into hashmap and group them by the hash value
* time complexity:  O(N K) , but groupBy op is slower
*/
object Solution1 {
  def groupAnagrams(strs: Array[String]): List[List[String]] = {
    strs.groupBy(str => str.groupBy(identity).mapValues(_.length).toMap).values.map(_.toList).toList
  }
}

/**
* inner groupBy is hands-on
* memo:
*   1. categorize by count
*/
object Solution1-2{
  def groupAnagrams(strs: Array[String]): List[List[String]] = {
        strs.toList.groupBy{str => 
            val hashmap = scala.collection.mutable.Map.empty[Char, Int]
            str.foreach(char => hashmap.update(char, hashmap.getOrElse(char, 0) + 1))
            hashmap.hashCode
        }.values.toList
        
    }
}

/**
* sort each string and groupby the sorted list's hashvalue
* time complexity: O(N KLogK) : N: strs.length, K: the longest string in strs
*/
object Solution2 {
    def groupAnagrams(strs: Array[String]): List[List[String]] =
        strs.groupBy(_.sorted.hashCode).values.map(_.toList).toList
}


```

```scala
package com.zhourui.leetcode

import scala.collection.mutable._
//import scala.collection.immutable.{HashMap, HashSet}
package lc0049_groupanagram {



  object Solution {
    def groupAnagrams(strs: Array[String]):List [List[String]] = {
      val hm = HashMap[String,List[String]]()
      strs.foreach{
          case s if hm.contains(s.sorted) => hm(s.sorted) = hm(s.sorted) :+(s)
          case s => hm(s.sorted)=List[String](s)
      }
      hm.values.toList
    }
  }
}

```

###  3.45. <a name='Powxn'></a>50 Pow(x, n)

[小明](https://www.bilibili.com/video/BV1W54y1q7CV?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ai4y147kr?spm_id_from=333.999.0.0)

```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        res = 1

        if n < 0:
            x = 1/x
            n = -n

        if n == 0:
            return res

        while n>0:
            if n % 2 == 1:
                res *= x
            n >>= 1
            # 等价于 n //= 2
            x *= x
        return res
```

```scala
/**
* chosen solution
* recursive - bottom-up
* memo
*   1. n may be negative or positive
*   2. n may be odd or even
*   3. do not care n during recursive
* time complexity: O(logN)
*/

object Solution0 {
    def myPow(x: Double, n: Int): Double = {
      if (n == 0) return 1
      val ans = _myPow(x, math.abs(n))
      if (n < 0) 1 / ans else ans 
    }
    
    def _myPow(x: Double, n: Int): Double = {
      if (n == 1 || n == 0) x
      else if ((n & 1) == 1) _myPow(x * x, n / 2) * x
      else _myPow(x * x, n / 2)
    }
}


/**
* recursive version : bottom-up
* memo
*   1. n may be negative or positive
*   2. n may be odd or even
* O(logN) in time
*/
object Solution1 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) 1
    else if(n > 0) {
      n % 2 match{
        case 1 => myPow(x * x, n / 2) * x
        case 0 => myPow(x * x, n / 2)
      }
    }else{
      val t = myPow(x, n / 2)
      math.abs(n % 2) match{
        case 1 => t * t * (1 / x)
        case 0 => t * t
      }
    }

  }
}
/**
* recursive version : bottom-up
*/
object Solution1-2 {
    def myPow(x: Double, n: Int): Double = {
        if(n == 0) return 1
        
        val t = myPow(x, n / 2)
        
        if(n % 2  == 0){
            t * t
        }else{
            if(n < 0) t * t * (1 / x)
            else t * t * x
        }
    }
}

/**
*  bottom-up -recursive,
*   do not care n during recursive
*/
object Solution1-3 {
    def myPow(x: Double, n: Int): Double = {
      if (n == 0) return 1
      val ans = _myPow(x, math.abs(n))
      if (n < 0) 1 / ans else ans 
    }
    
    def _myPow(x: Double, n: Int): Double = {
      if (n == 1 || n == 0) x
      else if ((n & 1) == 1) _myPow(x * x, n / 2) * x
      else _myPow(x * x, n / 2)
    }
}


/**
* top-down - iterative version 
* Binary Exponentiation with negative n
*
* each iteration is calculate pow(base, nn) * ans
*   ex: input x = 2, n = 10
*    0. base: 2.0, nn: 10 ans: 1.0 => pow(2, 10) * 1 =  1024
*    1. base: 4.0, nn: 5, ans: 1.0  => pow(4, 5) * 1 = 1024
*    2. base: 16.0, nn: 2, ans: 4.0 => pow(16, 2) * 4 = 1024
*    3. base: 256.0, nn: 1, ans: 4.0 => pow(256, 1) * 4 = 1024
*    4. base: 65536.0, nn: 0, ans: 1024.0 => pow(65536, 0) * 1024 = 1024
*
* time complexity: O(logN)
*/

object Solution2 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) return 1
    var ans = 1.0
    var nn = n
    var base = x

    while (nn != 0) {
     /* nn could be -1 if nn < 0 and run nn % 2, so using nn & 1 here */
      if((nn & 1) == 1)  ans = ans * base
      nn = nn / 2
      base = base * base
    }
    // judge n to decide whether reverse ans
    if (n < 0) 1.0 / ans else ans  
  }
}

/**
*  top-down - recursive with tail recursive
*/
object Solution2-1 {
    def myPow(x: Double, n: Int): Double = {
      val ans = _myPow(1, x, n)
      if(n < 0) 1 / ans else ans
    }
    
    @annotation.tailrec
    def _myPow(current: Double, base: Double, pow: Int): Double = {
        if(pow == 0) current
        else{
            if((pow & 1) == 1) _myPow(current * base, base * base, pow / 2)
            else _myPow(current, base * base, pow / 2)
        }
    }
}


```

###  3.46. <a name='-1'></a>51. 数组中的逆序对

[官方](https://www.bilibili.com/video/BV1Qk4y1r7u5?spm_id_from=333.999.0.0)

###  3.47. <a name='Maximumsubarray'></a>53-【贪心🧡】Maximum subarray

[哈哈哈](https://www.bilibili.com/video/BV1QJ411R75H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7dn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11A41187AR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ta4y1i7Sh?spm_id_from=333.999.0.0)

贪心

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5qrso4wuc440.png)

```py
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = preSum = nums[0]
        for num in nums[1:]:
            preSum = max(preSum + num, num)
            res = max(res,preSum)
        return res
```

时间复杂度：O(n)
时间复杂度：O(1)

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        
        // IDEA:
        // Go through the whole Array,
        // and change each element into the possible maximum sum of the subarray ENDING at its index 
        
        // During each iteration, the element at i-th index will be updated into the possible maximum sum of subarray ENDING at i-th index
        // then for (i+1)th index, if updated i-th value is positive, it can be used to update (i+1)th value as well.
        
        for (i <- Range(1, nums.length)) {
            if (nums(i-1) > 0) {
                nums(i) += nums(i-1)
            }
        }
        
        nums.max
    }
}
```

```scala
/**
* chosen solution
* dynamic programming
*    dp[i] defined as the sum of subarray that ending with ith element and must contains i-th element number   *
* actually, we don't need storing all previous status of nums.length
* we just need two status: one for maximum so far, the other one for the maximum accumulated value which containing with nums[i]
*
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution0{
    def maxSubArray(nums: Array[Int]): Int = {
        if (nums == null || nums.isEmpty) return 0
        var maxSoFar = nums(0)
        var maxEndingHere = nums(0)

        for(i <- 1 until nums.length) {
           maxEndingHere = (maxEndingHere +  nums(i))  max nums(i)
           maxSoFar = maxEndingHere max  maxSoFar
        }
        maxSoFar
        
    }
}

/**
* my first commit version
* time complexity: O(N^2)
* space complexity: O(N)
*/

object Solution1 {
    def maxSubArray(nums: Array[Int]): Int = {
     
        (1 to nums.length).map(n => _maxSubArray(nums, nums(n - 1), n)).max
        
    }
    
    def _maxSubArray(nums: Array[Int], preSum: Int, currentIdx: Int): Int = {
        if(nums.length == currentIdx) return preSum
        
        val currentSum = preSum + nums(currentIdx)
        val nexLevelSum = _maxSubArray(nums, currentSum, currentIdx + 1)
        preSum max currentSum max nexLevelSum
    }
    
}

/**
* dynamic programming
* memo:
*    1. dp[i] defined as the sum of subarray that ending with ith element and must contains i-th element number   
* time complexity: O(N)
* space complexity: O(N)  due to dp array
*/

object Solution2 {
    def maxSubArray(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.ofDim[Int](nums.length, 2)  // dp(0) ... dp(i) storing each status corresponding to  nums' index, means max subarray sum ending with nums[i]
        dp(0)(0) = nums(0)  // dim0: accumulate calculator which reset while new element is larger value inside,
        dp(0)(1) = nums(0) // dim1: maximum so far
        
        for(i <- 1 until nums.length) {
            
            dp(i)(0) = (dp(i - 1)(0) + nums(i))  max nums(i)
            dp(i)(1) = dp(i)(0) max dp(i - 1)(1) 
        }
        dp.last.last
    }
}

/**
* dynamic programming
* memo
*   1. one dimension array
* time complexity O(N)
* space complexity O(N)
*/
object Solution2-1 {
    def maxSubArray(nums: Array[Int]): Int = {
      val dp  = Array.ofDim[Int](nums.length)
      dp(0) = nums(0)
      for (i <- 1 until nums.size) {
        dp(i) = nums(i) max (nums(i) + dp(i - 1))
      }
      
      dp.max
    }
}

/**
* dynamic programming
* actually, we don't need storing all previous status of nums.length
* we just need two status: one for maximum so far, the other one for the maximum accumulated value which containing with nums[i]
*
* time complexity: O(N)
* space complexity: O(1)
*/

object Solution2-2 {
    def maxSubArray(nums: Array[Int]): Int = {
        if (nums == null || nums.isEmpty) return 0
        var maxSoFar = nums(0)
        var maxEndingHere = nums(0)

        for(i <- 1 until nums.length) {
           maxEndingHere = (maxEndingHere +  nums(i))  max nums(i)
           maxSoFar = maxEndingHere max  maxSoFar
        }
        maxSoFar
        
    }
}
/**
*  functional programming: foldLeft
*/
object Solution2-3 {
    def maxSubArray(nums: Array[Int]): Int = {
      if(nums == null || nums.isEmpty) return 0
      (1 until nums.length).foldLeft((nums(0), nums(0))){
          case ((maxEndingI, maxSofar), i) => 
            val maxEndingT = nums(i) max (nums(i) + maxEndingI)
            (maxEndingT, maxSofar max maxEndingT )
      }._2
    }
}
```

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        if(nums.length == 1){
            nums(0)
        }else{
            var sum = nums(0)
            var max = nums(0)
            var i = 1
            while (i < nums.length){
                val elem = nums(i)
                sum = sum + elem
                if(sum > max){
                    max = sum
                    i += 1
                }else if(sum < elem){
                    sum = elem
                    i += 1
                }else{
                    i += 1
                }
                
                if(elem > max){
                    max = elem
                    sum = elem
                }
            }
            max
        }
    }
}

```

```scala
package com.zhourui.leetcode

import scala.math.{abs, max}
import com.zhourui.codech.BaseExtension

package lc0053_maxsubarr {




  object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
      var maxsum:Int=Int.MinValue
      nums.foldLeft(0) {
        case (a,b) => { // 第一次进入时,a=0
          val cursum = max(a+b,b)
          maxsum = max(maxsum, cursum)
          cursum
        }
      }
      return maxsum
    }
  }

  class Test extends BaseExtension {
    def init {
      val arr = Array(-2, 1, -3, 4, -1, 2, 1, -5,4)
      println(Solution.maxSubArray(arr) == 6)

    }
    val name = "053 max sub array"
  }
}



/*
[-2,1,-3,4,-1,2,1,-5,4]
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int cursum = nums[0];
        int maxsum = cursum;

        for (int i=1;i<nums.size();i++) {
            cursum = max(cursum+nums[i],nums[i]);
            maxsum = max(maxsum, cursum);
        }
        return maxsum;
    }
};
 */
```

###  3.48. <a name='SpiralMatrix'></a>54. Spiral Matrix

[小梦想家](https://www.bilibili.com/video/BV1N7411h7i1?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        # print(list(matrix.pop(0)))
        print(list(zip(*matrix)))
        print(list(zip(*matrix))[::-1])
        return matrix and list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])
        # 含义是，如果matrix为空，则返回matrix
```

```py
return a and b
 
等价于
 
return b if a else a
```

```py
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res += matrix.pop(0) # 易错点：注意是+=
            matrix = list(zip(*matrix))[::-1] # 易错点：注意[::-1]的摆放
        return res
```

```scala
/**
* my first commitment: using extra seen matrix
* memo:
*  1. check next coordination, if have seen it, increase the direction index
* time complexity : O(N)
* space complexity: O(2N): seen matrix + output list
*/
object Solution1 {
    import collection.mutable
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {
      val n = matrix.length
      val m = matrix(0).length
      val seen = Array.ofDim[Boolean](n, m)
      val ans = mutable.ListBuffer.empty[Int]
      
      @annotation.tailrec
      def run(directionIdx: Int, coord: (Int, Int), ans: mutable.ListBuffer[Int], targetSize: Int): Unit = {
        if (ans.size == targetSize) return

        val (row, col) = coord
        ans += matrix(row)(col)  
        seen(row)(col) = true


        if (checkNextCoordAvailable(coord, directionIdx, seen)) {
          val direction = getDirection(directionIdx)
          val nextCoord = (row + direction._1, col + direction._2)
          run(directionIdx, nextCoord, ans, targetSize)
        }else {
          val newD = (d + 1) % 4
          val direction = getDirection(newD)
          val nextCoord = (row + direction._1, col + direction._2)
          run(newD, nextCoord, ans, targetSize)
        }

      }

      run(0, (0, 0), ans, n * m)
      ans.toList
    }
  
    
    def checkNextCoordAvailable(coord: (Int, Int), directionIdx: Int, seen: Array[Array[Boolean]]): Boolean = {
      val (row, col) = coord
      val direction = getDirection(directionIdx)
      val nextCoord = (row + direction._1, col + direction._2)

      
      0 <= nextCoord._1 && nextCoord._1 < seen.length && 0 <= nextCoord._2 && nextCoord._2 < seen(0).length && !seen(nextCoord._1)(nextCoord._2)
    }
   
    def getDirection(idx: Int): (Int, Int) = {
      val direction = List (
        (0, 1), // right
        (1, 0), // go down
        (0, -1), // go left
        (-1, 0) // go up
      )
      direction(idx)
    }
}


/**
* counterclockwise rotate matrix
* step:
*  1. add first line to list
*  2. counter-clockwise rotate remaining matrix: transpose + entire reverse
*  
*  remaining:
*  4 5 6
*  7 8 9
* 
* transpose:
*   4 7
*   5 8
*   6 9
* 
* reverse:
*   6 9
*   5 8
*   4 7
*/

object Solution2-1 {
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { 
        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {
            case mx if mx.isEmpty => List()
            case mx if mx.length == 1 => mx.head.toList
            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse)  // counter-clockwise
        }
        dfs(matrix)

    }    
}



/**
* bounded range: 
*  memo:
*    1. direction pattern: right -> down -> left -> up
* time complexity O(N)
* space complexity O(N) : output list
*/
object Solution3-1 {
    import collection.mutable
  
    sealed trait Direction
    case object Right extends Direction
    case object Down extends Direction
    case object Left extends Direction
    case object Up extends Direction
  
    def getNextDirection(direction: Direction): Direction = 
      direction match {
        case Right => Down
        case Down => Left
        case Left => Up
        case Up => Right
      }

  
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {
      if (matrix.isEmpty) List.empty
      val n = matrix.length
      val m = matrix(0).length
      val ans = mutable.ListBuffer.empty[Int]
      run(matrix, ans, Right, 0, m - 1, 0, n - 1, n * m)
      ans.toList
    }
  
    def run(matrix: Array[Array[Int]], ans: mutable.ListBuffer[Int], direction: Direction, colLo: Int, colHi: Int, rowLo: Int, rowHi: Int, targetSize: Int): Unit = {
      if (ans.size < targetSize) {
        
        direction match {
          
          case Right => 
          /** 
          * fix rowLo and increase rowLo after traversing right
          */
            (colLo to colHi).foreach(colIdx => ans += matrix(rowLo)(colIdx))
            run(matrix, ans, getNextDirection(direction), colLo, colHi, rowLo + 1, rowHi, targetSize)
          case Down =>
           /** 
          * fix colHi and decrease colHi after traversing down
          */
            (rowLo to rowHi).foreach(rowIdx => ans += matrix(rowIdx)(colHi))
            run(matrix, ans, getNextDirection(direction), colLo, colHi - 1, rowLo, rowHi, targetSize)
          case Left =>
          /** 
          * fix rowHi and decrease rowHi after traversing left
          */
          
            (colHi to colLo by -1).foreach(colIdx => ans += matrix(rowHi)(colIdx))
            run(matrix, ans, getNextDirection(direction), colLo, colHi, rowLo, rowHi - 1, targetSize)
          case Up => 

            /** 
          * fix colLo and increase colLo after traversing up
          */
            (rowHi to rowLo by -1).foreach(rowIdx => ans += matrix(rowIdx)(colLo))
            run(matrix, ans, getNextDirection(direction), colLo + 1, colHi, rowLo, rowHi, targetSize)
          
        }
      }
    }
}
```

###  3.49. <a name='JumpGame'></a>55 Jump Game

[小明](https://www.bilibili.com/video/BV14K4y1b7Fw?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1be411s7XX?spm_id_from=333.999.0.0)

```py
# 首选while循环😁
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)
        i = 0

        while cover >= i:
            cover = max(cover, i+nums[i])
            if cover >= n -  1:
                return True
            i += 1
        return False



# 精简一下的for循环😁
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)

        for i in range(n):
            if i <= cover: # 易错点：在判断下一个cover前，先要判断i是否能够到达
                cover = max(cover, i+nums[i])
                # if cover == i:
                    # return False # 易错点：应该考虑特殊情况[0,1,2]

                if cover >= n -  1:
                    return True
        return False
```

```py
object Solution {
    def canJump(nums: Array[Int]): Boolean = {
        
        // We should look at this probelm in REVERSE ORDER:
        // The target is to check whether we can arrive at the last index,
        // then we should reversely check the elements,
        // meanwhile, update the smallest index that we must arrive (`target`) in order to arrive at the last index
        
        // For example, if the i-2 index index is 2,
        // we know we can make it as long as the earlier elements can send us to i-2 index.
        // My target should be updated to i-2 index rather than the last index.
        
        val n = nums.length 
     
        var target = n-1 // the initial target
        var i = n - 2
        
        // update the target
        while (i > 0) {
            if (nums(i) + i >= target) {
                target = i
            }
            i -= 1
        }
        
        // check if the first element can trigger the "chain effect"
        if (nums(0) >= target) {
            true
        } else {
            false
        }
 
    }
}
```

```scala


/**
* my first commitment: backtracking + dp - top-down
* memo:
*   1. cache array record which position could jump to destination
*   2. run the loop of jump step size  backward
*/

object Solution1-1 {
    sealed trait Index
    case object Good extends Index 
    case object Bad extends Index
    case object Unknown extends Index
  
    def canJump(nums: Array[Int]): Boolean = {
        val cache = Array.fill[Index](nums.length)(Unknown)
        cache(cache.length-1) = Good
        dfs(nums, 0, cache)

    }
  
    def dfs(nums: Array[Int], pos: Int, cache: Array[Index]): Boolean = {
      if (cache(pos) != Unknown) {
        return cache(pos) == Good
      }
      
      val furthestJump = ((nums.length - 1) - pos) min nums(pos) // don't jump exceed array's length
      val ret = (furthestJump to 1 by -1).collectFirst {  // 1 to  furthestJump would lead to TLE
        case j if dfs(nums, pos + j, cache) =>  true
      }.getOrElse(false)
      
      
      if (ret) cache(pos) = Good else cache(pos) = Bad
      ret
    }
}

/**
* backtracking: DP bottom-up: more simpler
* memo
* 1. solve problem from tail to head
* 2. cache value: true for GOOD position, false for Bad position
* 3. if cache(0) is true, we could jump to last position from position zero
*/

object Solution1-2 {
    def canJump(nums: Array[Int]): Boolean = {
      val cache = Array.ofDim[Boolean](nums.length)
      cache(cache.length - 1) = true
      
      (nums.length - 2 to 0 by -1).foreach { pos =>
        val furthestJump = ((nums.length - 1) - pos) min nums(pos)
        (furthestJump to 1 by -1).collectFirst {
          case step if cache(pos + step) => 
          cache(pos) = true
          cache(pos)
        }.getOrElse(false)
      }
      cache(0)
    }
}


/**
* Greedy - check each position could jump to last good position
* memo:
*  1. solve problem backward
*  2. record last good position which could jump to last position within multi-hop
*  3. check zero position could jump to last position by checking last position equals to zero
* time complexity: O(N)
*/

object Solution2-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var lastPosition = nums.length - 1
      
      (nums.length - 2 to 0 by -1).foreach{ pos =>
        if((nums(pos) +  pos) >= lastPosition) {
          lastPosition = pos
        }
        
      }
      lastPosition == 0
    }
}


/**
* Greedy: check max reach position
* memo
*  1. record max reach position: if current position is larger than max reach position, it means we couldn't jump to current position and it wouldn't be able to jump to last position
* time complexity: O(N)
*/

object Solution3-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var maxReachPos = nums(0)
      nums.indices.forall { pos =>  
          if (pos > maxReachPos) false  
          else {
            maxReachPos = maxReachPos max (pos + nums(pos))
            true
          }
        }        
    }
}

```

###  3.50. <a name='I.'></a>56-I. 数组中数字出现的次数

[官方](https://www.bilibili.com/video/BV1Qe411s7Kc?spm_id_from=333.999.0.0)

###  3.51. <a name='MergeIntervals'></a>56. Merge Intervals

[花花酱](https://www.bilibili.com/video/BV11t411J7zV?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1w7411a7Wo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411a7t4?spm_id_from=333.999.0.0)

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        # 等价于：intervals.sort(key = lambda x: x[0])
        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1],interval[1])
                # 易错点：不是interval[1]，而是max(res[-1][1],interval[1])
                # 比如，[[1,4],[2,3]]
        return res
```

```py
# 不使用额外的储存空间，直接在原矩阵上面修改的原地算法（反正排序的时候已经修改了原矩阵）：
# pop(i)操作和append()操作耗时一样吗。
# 如果你直接intervals.pop()而不是intervals.pop(i) ，那耗时一样，都是o(1)，
# 但是你指定位置pop，那就是o(n)了。

class Solution:
    def merge(self, intervals):
        intervals.sort()
        i = 1
        while(i < len(intervals)):
            if intervals[i][0] > intervals[i-1][1]:
                i += 1
            else:
                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])
                intervals.pop(i)       
        return intervals
```

```scala

/**
*  my first commitment: sort array
*  time complexity: O(nlogn) + O(n) = O(nlogn) 
*  space complexity: O(n): sorted array
*/

object Solution1-1 {
    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
      val sortedL = intervals.sortBy(_(0))
      val ans = collection.mutable.Set.empty[Array[Int]]
      
      var begin = sortedL(0)(0)
      var end = sortedL(0)(1)
      (1 to sortedL.length - 1).foreach { idx =>
        val l = sortedL(idx)
        if (end < l(0)){
          ans += Array(begin, end)
          begin = l(0)
          end = l(1) 
        }else {
          end = l(1) max end
        }
      }
      ans += Array(begin, end)
      ans.toArray
    }
}

/**
* simplify 1-1
* 1.not using Set
* 2. record uncertain (begin, end) pair in answer list
*/

object Solution1-2 {
    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
      intervals.sortBy(_(0)).foldLeft(List.empty[Array[Int]]){
        case (last::ans, arr) =>
          if (last.last < arr.head) {
            arr::last::ans
          } else {
            Array(last.head, last.last max arr.last)::ans
          }
        case (ans, arr) => arr::ans // for empty ans list
      }.toArray
    }
}
```

###  3.52. <a name='InsertInterval'></a>57. Insert Interval 

[花花酱](https://www.bilibili.com/video/BV11t411J74e?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ja4y1j7cG?spm_id_from=333.999.0.0)

```py
# 根据上一问修改。
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        intervals.append(newInterval)
        intervals.sort()
        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1],interval[1])
        return res
```

```scala
/**
* my first commitment
* memo
*  1. insert newInterval to intervals according to its first element value
*  2. combine overlapping range 
* time complexity: O(2N) = O(N)
* space complexity: O(N)
*/

object Solution1-1 {
    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {
      if (intervals.isEmpty) return Array(newInterval)
      (_insert(_, newInterval)).andThen(combine).apply(intervals).reverse.toArray
    }  
    val _insert = (intervals: Array[Array[Int]], newInterval: Array[Int]) => {
    /**
    * find the position to split intervals into two parts
    */
      val pos = intervals.indices.find(idx => intervals(idx).head > newInterval.head).getOrElse(intervals.length)
      intervals.slice(0, pos).toList ::: List(newInterval) ::: intervals.slice(pos, intervals.length).toList
    }
  
    val combine = (input: List[Array[Int]])  => input.foldLeft(List.empty[Array[Int]]) {
        case (last::ans, arr) =>
          if (last.last < arr.head) arr::last::ans
          else Array(last.head, arr.last max last.last)::ans
        case (ans, arr) => //for empty ans
            arr::ans
      }
}

/**
* optimize from 1-1
* 1.span
*/
object Solution1-2 {
    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {
      // if (intervals.isEmpty) return Array(newInterval)
      (insert(_, newInterval)).andThen(combine).apply(intervals.toList).reverse.toArray
    }
  
    val insert = (intervals: List[Array[Int]], newInterval: Array[Int]) => {
      val (a, b) = intervals.span(arr => arr.head < newInterval.head)
      a:::List(newInterval):::b
    }
  
    val combine = (input: List[Array[Int]])  => input.foldLeft(List.empty[Array[Int]]) {
        case (last::ans, arr) => if (last.last < arr.head) arr::last::ans else Array(last.head, arr.last max last.last)::ans
        case (ans, arr) => arr::ans //for empty ans
      }
}
```

###  3.53. <a name='LenghofLastWords'></a>58. Lengh of Last Words

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7so?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ay4y1y7d2?spm_id_from=333.999.0.0)

```py
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        s.strip()
        return len(s.split()[-1]) if s else 0
```

```py
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        res = 0
        tmp = 0
        for i in range(len(s)):
            if s[i] == ' ':
                tmp = 0
            else:
                tmp += 1
                res = tmp # 易错点：用res存储tmp变量，防止末尾的空格
        return res
```

###  3.54. <a name='II.LCOF'></a>59 - II. 队列的最大值 LCOF

[官方](https://www.bilibili.com/video/BV1L54y1z7ae?spm_id_from=333.999.0.0)

###  3.55. <a name='SpiralMatrixII'></a>59. Spiral Matrix II 

[小梦想家](https://www.bilibili.com/video/BV1J741157Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1q5411G7MY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0 for _ in range(n)] for _ in range(n)]
        x,y,dx,dy = 0,0,0,1 
        # 0,1 -> 1,0 -> 0,-1 -> -1,0
        for num in range(1,n*n + 1):
            res[x][y] = num

            if not 0 <= x+dx < n or not 0 <= y+dy < n or res[x+dx][y+dy] != 0:
            # 易错点：or res[x+dx][y+dy] != 0 顺序很重要，一定要在最后
                dx,dy = dy, -dx

            x += dx
            y += dy
        return res
```

###  3.56. <a name='RotateList'></a>61. Rotate List

[花花酱](https://www.bilibili.com/video/BV14y4y1r728?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV117411L7UG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jK411N7e6?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Xk4y1d7gF?spm_id_from=333.999.0.0)

```py
# python 解法 思路：先把链表首尾相连，再找到位置断开循环
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 易错点：要排除一些特殊情况
        if not head or not head.next:
            return head
            
        cur = head
        nodeNum = 1
        # 链接成一个环
        while cur.next:
            cur = cur.next
            nodeNum += 1
        cur.next = head


        # cur指针指向开头
        cur = cur.next
        # steps到达new head的前一个node
        steps = nodeNum - k % nodeNum - 1
        for _ in range(steps):
            cur = cur.next


        res = cur.next
        cur.next = None
        return res
```

###  3.57. <a name='-1'></a>62-不同路径

[哈哈哈](https://www.bilibili.com/video/BV1mC4y1W7Je?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sg4y1v7PM?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1cp4y167qx?spm_id_from=333.999.0.0)

二维动态规划：

时间复杂度：O(mn)

空间复杂度：O(mn)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 易错点：dp千万不要写错
        # 其他写法：dp = [[1 for i in range(n)] for j in range(m)]
        # 其他写法：dp = [[1]*n]*m
        dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

一维动态规划：

时间复杂度：O(mn)

空间复杂度：O(n)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 易错点：dp千万不要写错
        dp = [1]*n
        for i in range(1,m):
            for j in range(1,n):
                dp[j] += dp[j-1]
        return dp[-1]
```

```scala

/**
* my first commitment: math combination
* memo:
*  1. the total walk steps is (m-1) + (n -1) : (m-1) steps go down and (n-1) steps go right
*  2. unique paths is calculated by C^{m - 1 + n - 1}_{ m - 1} * C^{n-1}_{n-1}
*/
object Solution1 {
    def uniquePaths(m: Int, n: Int): Int = {
      val allStep = (m - 1)  +  (n - 1)
      calCombination(allStep, (m - 1))     
    }
    def calCombination(a: Int, b: Int): Int = {
      val c = a - b
      val max = c max b
      val min = c min b
      val numerator = (BigInt(a) until max by -1).product
      val denominator = (BigInt(min) to 1 by -1).product
      (numerator / denominator).toInt
    }
}

/**
* long type
*/
object Solution1-2 {
    def uniquePaths(m: Int, n: Int): Int = {
      val allStep = (m - 1)  + (n - 1)
      calCombination(allStep.toLong, (m - 1).toLong).toInt 
    }
    def calCombination(a: Long, b: Long): Long = {
      val c = a - b
      val max = c max b
      val min = c min b
      val numerator = (a until max by -1).product
      val denominator = (min to 1 by -1).product
      (numerator / denominator)
    }
}

/**
* dynamic programming
* time complexity: O(N *M)
* space complexity: O(N * M)
*/
object Solution2 {
    def uniquePaths(m: Int, n: Int): Int = {
      val dp = Array.tabulate[Int](m, n) {
        case (0, j) => 1
        case (i, 0) => 1
        case _ => 0
      }
      for (i <- 1 until m; j <- 1 until n) {
        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
      }
      
      dp.last.last
    }
}

/**
* fill dp array with 1
*/
object Solution2-1{
    def uniquePaths(m: Int, n: Int): Int = {
      val dp = Array.fill[Int](m, n)(1)
      for (i <- 1 until m; j <- 1 until n) {
        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
      }
      
      dp.last.last
    }
}
```

###  3.58. <a name='UniquePathsII'></a>63 Unique Paths II

[小明](https://www.bilibili.com/video/BV1Sv411L7qe?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pp4y1v7KR?spm_id_from=333.999.0.0)

```py
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        # 易错点：注意边界上也可能有obstacle
        # 易错点：dp = [[0]*(n+1)]*(m+1)这些写法是错误的
        dp = [[0]*(n+1) for _ in range(m+1)]
        # 易错点：dp[1][1] = 1,这个数字会被重新计算，所以应该写成：
        dp[0][1] = 1
        # 构建了一个大一圈的矩阵，但实际计算的时候，仍然是mn的大小
        for i in range(1,m+1):
            for j in range(1,n+1):
                if not obstacleGrid[i-1][j-1]:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        print(dp)
        return dp[-1][-1]
```

###  3.59. <a name='MinimumPathSum64-'></a>64. Minimum Path Sum 64-最小路径和

[花花酱](https://www.bilibili.com/video/BV12W411679S?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ka4y1i7Vu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1JC4y1x7j1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vi4y1u7a6?spm_id_from=333.999.0.0)

```py
# 可以直接在原数组上进行记忆，不需要额外的空间
# so easy,直接AC
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0:
                    continue
                if i == 0:
                    grid[i][j] += grid[i][j-1]
                if j == 0:
                    grid[i][j] += grid[i-1][j]
                if i > 0 and j > 0:
                    grid[i][j] += min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
```

###  3.60. <a name='ValidNumber'></a>65 Valid Number

[小明](https://www.bilibili.com/video/BV1hK4y1975b?spm_id_from=333.999.0.0)

###  3.61. <a name='Plusone'></a>66 Plus one

[哈哈哈](https://www.bilibili.com/video/BV1jJ411d7Ry?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7b1?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gi4y137GW?spm_id_from=333.999.0.0)



```py
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        for i in range(len(digits)-1,-1,-1):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        return [1] + digits

# 简单题重拳出击，最后一位加1，
# 等于10就进位，没有进位就输出，
# 进位到头就在output前面加个1，简单易懂
```

```scala
object Solution {
    def plusOne(digits: Array[Int]): Array[Int] = {
        var size = digits.length
        var add = 1
        
        var output = List.empty[Int]
        
        (0 to (size-1)).reverse.map(i => {
            
            val x = digits(i)
            
            if(x == 9 && add == 1 && i == 0){
                output = List(1, 0) ++ output
            }else if(x == 9 && add == 1){
                output = 0 +: output
            }else{
                if(add == 1){
                    output = (x+1) +: output
                    add = 0
                }else{
                    output = x +: output
                }
            }
        })
        output.toArray
    }
}

```

###  3.62. <a name='AddBinary'></a>67-Add Binary

[哈哈哈（常规方法）](https://www.bilibili.com/video/BV1N7411F73K?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV17J411d7G1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7Bo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Q5411h7gc?spm_id_from=333.999.0.0)

常规做法:

```py
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        res = ''
        carry = 0
        i = len(a)-1
        j = len(b)-1
        while i >= 0 or j >= 0 or carry: # 易错点： 不要漏 or carry
            val = carry
            if i >= 0: val += int(a[i]) # 易错点：[i],不要写成(i)
            if j >= 0: val += int(b[j])
            carry = val // 2
            res += str(val % 2)
            i -= 1
            j -= 1
        return res[::-1]
```

###  3.63. <a name='Sqrtx'></a>69 Sqrt(x) 见 HJ107 求解立方根

[花花酱](https://www.bilibili.com/video/BV1WW411C7YN?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gJ411R7XR?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7TN?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1PK411s72g?spm_id_from=333.999.0.0)

袖珍计算器:

时间复杂度：O(1)

空间复杂度：O(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        ans = int(math.exp(0.5 * math.log(x)))
        return ans + 1 if (ans + 1) ** 2 <= x else ans
```

二分查找:

时间复杂度：O(logN)

空间复杂度：O(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r, ans = 0, x, -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans

# 二分法不需要ans
# 但是不好理解

class Solution:
    def mySqrt(self, x: int) -> int:
        l = 0
        r = x
        while l <= r:
            m = (l + r) // 2 # l和1，不要打错，哈哈哈
            if m**2 > x:
                r = m - 1
            else:
                l = m + 1
        return r
```

牛顿迭代法:

时间复杂度：O(logN)

空间复杂度：O(1)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3g2xmodb40u0.png)

```py
class Solution:
    def mySqrt(self, num: int) -> int:
        x = 1 # 背一背这个套路
        while abs(x**2 - num) > 0.001:
            x -= (x**2 - num) / (2 * x) # 注意这里是减号
        return floor(x)
```

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1:
            return x
        
        C, res = float(x), float(x)
        while True:
            xi = 0.5 * (res + C / res)
            if abs(res - xi) < 1e-7:
                break
            res = xi
        
        return int(res)

class Solution:
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        if x <= 1:
            return x
        res = x # 初始值
        c = x # 牛顿迭代法中的常数
        while res > c / res:
            res = (res + c / res) // 2
        return int(res)
```

```scala
/**
* chosen solution
* binary search - recursive
* memo:
*   1. maintain max and min
* time complexity: O(logN)
*/
object Solution0 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        _mySqrt(0, x, x, math.pow(10, -5)).toInt
    }
    
    @annotation.tailrec
    def _mySqrt(min:Double, max: Double, target:Int, precision: Double): Double = {
        val guess = min + (max - min) / 2
        val estimate = guess * guess
        if(math.abs(estimate - target) < precision) guess
        else{ 
            if(estimate > target) _mySqrt(min, guess, target, precision)
            else _mySqrt(guess, max, target, precision)
        } 
    }
}


/**
* my first commitment
* binary search- iterative
* time complexity: O(LogN)
*/
object Solution1 {
  def mySqrt(x: Int): Int = {
    if(x == 0 || x== 1) return x

    val precision = math.pow(10, -5)
    var high: Double = if (x > 1) x else 1
    var low: Double = 0

    while(true) {
      val mid: Double = low + ((high - low) / 2)
      val estimate = mid * mid

      if(math.abs(estimate - x) < precision){
        return mid.toInt

      }else if(estimate > x) {
        high = mid
      }else {
        low = mid
      }
    }
    x
  }
}
/**
* binary search - iterative
* not return while in while block
*/
object Solution1-2 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        val precision = math.pow(10, -5)
        var max: Double = if(x > 1) x.toDouble else 1.0
        var min = 0.0
        var mid = min + (max - min) / 2 
        var condition = true
        
        while(condition){
            mid = min + (max - min) / 2 
            val estimate = mid * mid
            
            if(math.abs(estimate - x) < precision){
                condition = false
            }else if(estimate > x){
              max = mid  
            } else {
              min = mid
            }
        }
        mid.toInt
    }
}


/**
* binary search - recursive - top-down
* memo:
*   1. maintain max and min
*/
object Solution1-3 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        _mySqrt(0, x, x, math.pow(10, -5)).toInt
    }
    
    @annotation.tailrec
    def _mySqrt(min:Double, max: Double, target:Int, precision: Double): Double = {
        val guess = min + (max - min) / 2
        val estimate = guess * guess
        if(math.abs(estimate - target) < precision) guess
        else{
            if(estimate > target) _mySqrt(min, guess, target, precision)
            else _mySqrt(guess, max, target, precision)
        } 
    }
}

/**
* Newton's method - iterative
* y = x^2 => f(x) = x^2 - y
* x_{k+1} = x_k - f(x_k) / f'(x_k)
* x_{k+1} = x_k - (x_k^2 - y) / (2x_k) = (x_k + y / x_k) / 2
* time complexity: O(logN)
*/

object Solution2 {
     def mySqrt(x: Int): Int = {
        val precision = math.pow(10, -5)
        
        var ans: Double = x
        while(math.abs(ans * ans - x) > precision){
            ans = (ans + x / ans) / 2
            // println(ans)
        }
        ans.toInt
    }
}

/**
*  newton-method - recursive - top-down
*/

object Solution2-1 {
    def mySqrt(x: Int): Int = {
        _mySqrt(x, x, math.pow(10, -5)).toInt
    }

    @annotation.tailrec
    def _mySqrt(guess: Double, target: Int, precision: Double): Double = {
        /* see? (guess * guess - target) is just our f(x) =  x^2 - y */
        if(math.abs(guess * guess - target) < precision) guess
        else _mySqrt((guess + (target / guess)) / 2, target, precision)
    }
}


```

```scala
object Solution {
    def mySqrt(x: Int): Int = {
        if(x == 0){
            0
        }else if(x == 1){
            1
        }else{
            var num: Int = x/2
            var flag = true
            
            while(flag){
                // val sqr = num*num
                // if(sqr == x)
                
                //If we do num*num it may exceed Int range
                //Since we want to check: num*num < x
                //we can instead do num < x/num
                
                if(num > x/num){
                    num = num/2
                }else{
                    val temp = num + 1
                    if(temp > x/temp){
                        flag = false
                    }else{
                        num += 1
                    }
                }
            }
            num
        }
    }
}

//Better solution: in the above solution we are only decreasing the range on 1 side by half, but other side by only 1 number
//This solution decreases by half for both side (binary search pattern)

object Solution {
    def mySqrt(x: Int): Int = {
        if(x == 0){
            0
        }else if(x == 1){
            1
        }else{
            var start = 1
            var end = x
            var result = 0
            
            while(start <= end){
                var mid = start + (end - start)/2
                if(mid <= x/mid){
                    result = mid
                    start = mid+1
                }else{
                    end = mid-1
                }
            }
            result
        }
    }
}

```

###  3.64. <a name='ClimbingStairs'></a>70. Climbing Stairs

[5:32 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gJ411R7X1?spm_id_from=333.999.0.0)

[哈哈哈 70(重制版)](https://www.bilibili.com/video/BV1G54y197eZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7s9?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DZ4y1H7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ki4y1u7tn?spm_id_from=333.999.0.0)

```py
class Solution:
    def climbStairs(self, n: int) -> int:
        b1, b2 = 1, 1
        for i in range(n-1):
            b1, b2 = b2, b1 + b2
        return b2

# 我的模仿

class Solution:
    def climbStairs(self, n: int) -> int:
        dp0 = 1
        dp1 = 1
        for _ in range(n-1):
            dp1, dp0 = dp0 + dp1, dp1
            # 用2个数字分别存储
        return dp1
```

```scala
/**
* chosen solution
* dynamic programming
* memo
*   1. dp(i) represent climb to i floor's distinct ways
*   2. dp(i) could be calculate from dp(i - 1) + dp(i - 2)
*           (1) taking a single step from dp(i - 1)
*           (2) taking a step of two from dp(i - 2)
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution0 {
    def climbStairs(n: Int): Int = {
        val dp = Array.ofDim[Int](n + 1)
        dp(0) = 1
        dp(1) = 1
        (2 to n).foreach(i => dp(i) = dp(i - 1) + dp(i - 2))
        dp(n)
    }
}

/**
* my first commitment
* dynamic programming
* memo:
*   1. dp(i) represent climb to i floor's distinct ways
*   2. dp(i) could be calculate from dp(i - 1) + dp(i - 2)
*           (1) taking a single step from dp(i - 1)
*           (2) taking a step of two from dp(i - 2)
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def climbStairs(n: Int): Int = {
        if(n <= 2) n
        else {
            val cache = Array.ofDim[Int](n + 1)
            cache(0) = 1
            cache(1) = 1
            (2 to n).foreach{ nn =>
                cache(nn) = cache(nn - 1) + cache(nn - 2)
            }
            cache(n)
        }
    }
}

/**
*  simplify from 1
*/
object Solution1-2 {
    def climbStairs(n: Int): Int = {
        val dp = Array.ofDim[Int](n + 1)
        dp(0) = 1
        dp(1) = 1
        (2 to n).foreach(i => dp(i) = dp(i - 1) + dp(i - 2))
        dp(n)
    }
}



/**
* DP: only use two extra space to keep previous two value
* time complexity: O(N)
* space complexity: O(1)
*/

object Solution1-3 {
    def climbStairs(n: Int): Int = {
        if(n <= 2) n
        else {
            var a = 1
            var b = 2
            (3 to n).foreach{ nn =>
                val c = a + b
                a = b
                b = c    
            }
            b
        }
    }
}

/**
* dp: index from 0 until n
*   it would be confusing with index i original meaning which is the ways of climbing to stair i
* memo:
*  1. keep two previous status
*/
object Solution1-4 {
    def climbStairs(n: Int): Int = {
        var a = 0
        var b = 1
        for (_ <- 0 until n) {
            val c = a + b
            a = b
            b = c
        }
        b
    }
}
```

```scala
object Solution {
    
    def climbStairs(n: Int): Int = {
        if(n==1){
            1
        }else if(n == 2){
            2
        }else{
            climbStairs(n-1) + climbStairs(n-2)
        }
    }
}

/**
n = 3
1 1 1
1 2
-------
2 1
==================> 2 + 1
n = 4
 1 1 1 1
 1 1 2
 1 2 1
 --------
 2 1 1
 2 2
 =================> 3 + 2
*/

/**Alternate approach:
In the above approach we are doing repeated call for some numbers
example: 
climbStairs(5) -> 4 & 3
climbStairs(4) -> 3 & 2 | climbStairs(3) -> 2 & 1
climbStairs(3) -> 2 & 1 | climbStairs(2) | climbStairs(2) | climbStairs(1)
climbStairs(2) | climbStairs(1) | climbStairs(1)

To avoid recalculation again & again we can just store the results for the previous numbers at their indexes
*/
object Solution {
    
    def climbStairs(n: Int): Int = {
        if(n == 1){
            1
        }else{
            var dpArray = Array.fill(n+1)(0)
            dpArray(1) = 1
            dpArray(2) = 2
            (3 to n).map(i => {
                dpArray(i) = dpArray(i-1) + dpArray(i-2)
            })
            dpArray(n)
        }
    }
}

```

###  3.65. <a name='SimplifyPath'></a>71. Simplify Path

[小梦想家](https://www.bilibili.com/video/BV1V7411w7jX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1D5411J72c?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def simplifyPath(self, path):
        stack = []
        for i in path.split('/'):
            if i not in ['', '.', '..']:
                stack.append(i)
            elif i == '..' and stack:
                stack.pop()
        return "/" + "/".join(stack)
```

```py
# cool
from os.path import abspath

class Solution:
    def simplifyPath(self, path: str) -> str:
        return abspath(path)

from functools import reduce
class Solution:
    def simplifyPath(self, path: str) -> str:
        return "/"+"/".join(reduce(lambda x, y: x[:-1] if y == ".." else x + [y] if y and y != "." else x, path.split("/"), []))

# 等效于:

class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        for i in path.split('/'):
            if i == '..':
                if stack:
                    stack.pop()
                else:
                    continue
            elif i and i != '.': # 注意这里是elif,而不是if
                stack.append(i)
        return "/" + "/".join(stack)
```

###  3.66. <a name='EditDistance72-'></a>72. Edit Distance 72-编辑距离

[花花酱](https://www.bilibili.com/video/BV1cb411u7uX?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wv411P7aQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13Z4y1W7UB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ea4y147FK?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5kci5ryyi3k0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7fq2ehol7rg0.png)

```py
#@author:leacoder
#@des:  动态规划  编辑距离

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
        # 初始
        for i in range(len1+1):
            DP[i][0] = i
        for j in range(len2+1):
            DP[0][j] = j
        for i in range(1,len1+1):
            for j in range(1,len2+1):
                
                if word1[i - 1] == word2[j -1]:
                    DP[i][j] =  DP[i-1][j-1]
                else:
                    DP[i][j]  =  min(DP[i-1][j] + 1,DP[i][j-1] + 1,DP[i-1][j-1]+1)
        return DP[len1][len2]

# 换个写法

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
        
        for i in range(0,len1+1):
            for j in range(0,len2+1):
                if i == 0:               # 初始化
                    DP[i][j] = j
                elif j == 0:             # 初始化
                    DP[i][j] = i
                elif word1[i - 1] == word2[j -1]:
                    DP[i][j] =  DP[i-1][j-1]
                else:
                    DP[i][j]  =  min(DP[i-1][j],DP[i][j-1],DP[i-1][j-1]) + 1
                    
        return DP[-1][-1]
```

```py
比较好理解，but会超时，哭唧唧

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        @cache
        def dp(i, j) -> int:
            if i == -1:
                return j + 1
            if j == -1:
                return i + 1
            # 做出选择
            if word1[i] == word2[j]:
                return dp(i - 1, j - 1) # 什么都不做
            else:
                return min(
                    dp(i, j-1) + 1,  # insert
                    dp(i-1, j) + 1,  # delete
                    dp(i-1, j-1) + 1 # replace
                )
        return dp(len(word1)-1, len(word2)-1)
```

```scala
/**
* dynamic programming  - Levenshtein distance
* memo
*    1. dp(i)(j) represent the minimum edit distance from the length i substring from word1 to the length j substring from word2
*    2. dp(i)(j) is solved by its sub-optimal problem 
*         1, delete op: dp(i -1)(j)
*         2. replacement op: dp(i -1)(j - 1)
*         3. insertion op: dp(i)(j - 1)
* time complexity: O(NM) N is the length of word1, N is the length of word2
* space complexity: O(NM)
*/
object Solution1 {
  def minDistance(word1: String, word2: String): Int = {
    val m = word1.length
    val n = word2.length
    /* initial  Levenshtein distance table 
    * dp(i)(j) represent the minimum distance transforming from length i of substring word1 to length j of substring word2
    */
    val dp = Array.tabulate(m + 1, n + 1) {
      case (0, j) => j
      case (i, 0) => i
      case _ => 0
    }

    for (i <- 1 to m; j <- 1 to n) {
      /* i-1 is word1 index, j-1 is word2 index */
      if (word1(i - 1) == word2(j - 1)) {
        // do nothing case
        dp(i)(j) = dp(i - 1)(j - 1)
      } else {
        /**
        *       i-1,    i
        * j-1 replace  insertion     
        *  j   delete  dp(i)(j)
        */
        val replace = dp(i - 1)(j - 1)
        val insert = dp(i)(j - 1)
        val delete = dp(i - 1)(j)
        dp(i)(j) = (replace min insert min delete) + 1
      }
    }
    dp(m)(n)
  }
}
```

###  3.67. <a name='SetMatrixZeroes'></a>73. Set Matrix Zeroes

[小梦想家](https://www.bilibili.com/video/BV1W7411T7rX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1X64y1Y7kG?spm_id_from=333.999.0.0)

```py
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        tmp = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 0:
                    tmp.append([i,j])
        for r,c in tmp:
            for j in range(len(matrix[0])):
                matrix[r][j] = 0
            for i in range(len(matrix)):
                matrix[i][c] = 0
        return matrix
```

```scala

/**
* my first commitment
* time complexity: O(N * M)
* space complexity: O(N + M)
*/
object Solution1 {
    import collection.mutable
    def setZeroes(matrix: Array[Array[Int]]): Unit = {
      val cols = mutable.Set.empty[Int]
      val rows = mutable.Set.empty[Int]
      
      for (i <- matrix.indices; j <- matrix(i).indices; if matrix(i)(j) == 0) {
        rows += i
        cols += j
      }
      
      rows.foreach(row => matrix(row).indices.foreach(matrix(row)(_) = 0))
      cols.foreach(col => matrix.indices.foreach(matrix(_)(col) = 0))
    }
}



/**
* using first column and row to record cell to be set to zero
* memo:
*  1. we should set first columns and first row in the last, otherwise we cannot distinguish the zero between set by us and originally is
* time complexity: O(NM)
* space complexity: O(1)
*/
object Solution2 {
    import collection.mutable
    def setZeroes(matrix: Array[Array[Int]]): Unit = {
      var rowZero = false
      var colZero = false
      
      /**
      * using first row and first column as flag 
      */
      for (i <- matrix.indices; j <- matrix(i).indices; if matrix(i)(j) == 0) {
        if (i == 0) rowZero = true
        if (j == 0) colZero = true
        matrix(i)(0) = 0
        matrix(0)(j) = 0
      }
    
      /**
      * set one row to zero except first cell
      */
      (1 until matrix.length).foreach {
        case rowIdx if matrix(rowIdx)(0) == 0 => matrix(rowIdx).indices.foreach(matrix(rowIdx)(_) = 0)
        case _ =>
      }
      
      /**
      * set one column to zero except first cell
      */
      (1 until matrix(0).length).foreach {
        case colIdx if matrix(0)(colIdx) == 0 => matrix.indices.foreach(matrix(_)(colIdx) = 0)
        case _ => 
      }
      
      /**
      * set first column and first row to zero if true
      */
      if(rowZero) matrix(0).indices.foreach(matrix(0)(_) = 0)
      if(colZero) matrix.indices.foreach(matrix(_)(0) = 0)
      
    }
}
```

###  3.68. <a name='Searcha2DMatrix'></a>74 Search a 2D Matrix

[小明](https://www.bilibili.com/video/BV1aK4y1h7Bb?spm_id_from=333.999.0.0)

```py
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        l = 0
        r = m*n-1
        while l <= r:
            mid = (l + r) // 2
            midRow = mid // n
            midCol = mid % n
            if matrix[midRow][midCol] == target:
                return True
            elif matrix[midRow][midCol] > target:
                r = mid - 1 # 易错点：+1,-1不要写反了
            else:
                l = mid + 1
        return False
```

###  3.69. <a name='SortColors'></a>75. Sort Colors

[小梦想家](https://www.bilibili.com/video/BV1rE411n7mL?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ua4y1v7yd?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1tz4y1o7n5?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5l1bfbznzwc0.png)

```py
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        idx, left, right = 0, 0, len(nums) - 1
        while idx <= right:
            if nums[idx] == 2 and idx < right:
                nums[idx], nums[right] = nums[right], 2
                right -= 1
            elif nums[idx] == 0 and idx > left:
                nums[idx], nums[left] = nums[left], 0
                left += 1
            else:
                idx += 1
```

###  3.70. <a name='-1'></a>76-【滑动窗口🔹】最小覆盖子串

[哈哈哈](https://www.bilibili.com/video/BV1PM4y1K7p6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK4y1t7Qd?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ud8tslp4vz4.png)

```py
class Solution:
    def minWindow(self, s: str, t: str) -> str:
    
        def isContains(windic,targetdic):
            for key in targetdic:
                if windic[key] < targetdic[key]:
                    return False # 只要有一个不满足，则不满足
            return True

        
        tdic = defaultdict(int)
        wdic = defaultdict(int)
        for char in t:
        	tdic[char] += 1
        for char in t:
            wdic[char] = 0

        minlen = len(s)
        l = 0
        res = ''

        for r in range(len(s)): 
            # 右边界移动,并把右边界加入字典
            if s[r] in tdic:
                wdic[s[r]] += 1
            while isContains(wdic,tdic):
                if r-l+1 <= minlen:
                    # 满足包含条件，并且minlen
                    minlen = r-l+1
                    res = s[l:r+1]
                if s[l] in wdic:
                    wdic[s[l]] -= 1
                l += 1 # 如果window满足条件，那就收缩左边界，但需要进行如上操作
        return res
```

```scala
/**
* chosen solution
*   time complexity: O(|S| + |T|)
*   space complexity: O(|s| + |T|)
* sliding windows: faster version
* @param
* left right : two pointer for enlarging and reducing windows size
* head and len: storing minWindow
* count: count = 0 when the range between left index and right index satisfy condition
*/
object Solution0{
    import collection.mutable
    def minWindow(s: String, t: String): String = {
      val sMap = mutable.Map.empty[Char, Int] ++ t.groupBy(identity).mapValues(_.length).toMap
      var counter = sMap.size
      
      var left = 0
      var minLength = s.length + 1
      var head = 0

      for (right <- s.indices) {
        val rightChar = s(right)
        sMap.get(rightChar) match {
          case Some(v) if v == 1 =>
            sMap.update(rightChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(rightChar, v - 1)
          case None => 
        }
        
        while(counter == 0) {

          val leftChar = s(left)
          if (minLength > (right - left  + 1)) {
            head = left
            minLength = right - left + 1
          }
          
          sMap.get(leftChar) match {
            case Some(v) if v == 0 =>
              sMap.update(leftChar, v + 1)
              counter += 1
            case Some(v) =>
              sMap.update(leftChar, v + 1)
            case None =>
          }
          
          left += 1
        }
        
      }
      if (minLength == (s.length + 1)) "" else s.slice(head, head + minLength)
      
      
    }
}
/**
* my first commitment
* sliding windows with two pointer: left and right
* time complexity: O(|S| + |T|)
*/
object Solution1 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    val tMap = t.groupBy(identity).mapValues(_.length).toMap

    /**
    * storing how far to reach t string's anagrams, the element's value could be negative. 
    * If negative, it means we could drop more char of this key from currentString
    */
    val budgetMap = scala.collection.mutable.Map() ++ tMap
    var currentString = ""
    var answer = ""

    for (char <- s) {
        budgetMap.get(char) match {

          case Some(e) => budgetMap.update(char, e - 1)
          case None =>
        }
      
      currentString += char

      while(!budgetMap.exists{case (_, v) => v > 0}) {
        /**
        *  drop first element from currentString if  currentString  still contains t string 
        */
        val tempChar = s(left)
        if(tMap.contains(tempChar)){
          budgetMap.update(tempChar, budgetMap.getOrElse(tempChar, 0) + 1)
        }

        if(answer.length > currentString.length || answer.isEmpty) {
          answer = currentString
        }
        currentString = currentString.drop(1)
        left += 1
      }
    }

    answer
  }
}


/**
* sliding windows : don't record string during process
*/
object Solution1-2 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    var head = 0
    var len = s.length + 1

    val budgetMap = scala.collection.mutable.Map() ++ t.groupBy(identity).mapValues(_.length)

    for ((char, right) <- s.zipWithIndex) {
      
        budgetMap.get(char) match {
          case Some(e) => budgetMap.update(char, e - 1)
          case None =>
        }
      
      while(!budgetMap.exists{case (_, v) => v > 0}) {
        val tempChar = s(left)
        if(budgetMap.contains(tempChar)){
          budgetMap.put(tempChar, budgetMap(tempChar) + 1)
        }
         /* update minWindow */
        if(len > (right - left)) {
          len = right - left + 1
          head  = left
        }
        left += 1
      }
    }
    // println(budgetMap)
    if(len == (s.length + 1)) "" else s.substring(head, head + len)
  }
}

/**
* sliding windows: faster version
* left right : two pointer for enlarging and reducing windows size
* head and len: storing minWindow
* count: count = 0 when the range between left index and right index satisfy condition
*/

object Solution1-3 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    var right = 0
    var head = 0
    var len = s.length + 1
    val budgetMap = scala.collection.mutable.Map() ++ t.groupBy(identity).mapValues(_.length)
    var count = budgetMap.size

    while (right < s.length) {
      val char = s(right)
     
        budgetMap.get(char) match {
            case Some(e) if e == 1 =>
            budgetMap.update(char, e - 1)
            count -= 1
            case Some(e) =>
            budgetMap.update(char, e - 1)
            case None =>
        }
      
      right += 1
      while(count == 0) {
        val tempChar = s(left)
        budgetMap.get(tempChar) match {
          case Some(e) if e == 0 =>
            budgetMap.update(tempChar, e + 1)
            count += 1
          case Some(e) =>
            budgetMap.update(tempChar, e + 1)
          case None =>
        }
        /* update minWindow*/
        if(len > (right - left)) {
          len = right - left
          head  = left
        }
        left += 1
      }
    }
    println(budgetMap)
    if(len == (s.length + 1)) "" else s.substring(head, head + len)
  }
}

/**
* 1. for loop auto increment right index
* 2. update minLength and head index before updating counter and left index
*/

object Solution1-4 {
    import collection.mutable
    def minWindow(s: String, t: String): String = {
      val sMap = mutable.Map.empty[Char, Int] ++ t.groupBy(identity).mapValues(_.length).toMap
      var counter = sMap.size
      
      var left = 0
      var minLength = s.length + 1
      var head = 0

      for (right <- s.indices) {
        val rightChar = s(right)
        sMap.get(rightChar) match {
          case Some(v) if v == 1 =>
            sMap.update(rightChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(rightChar, v - 1)
          case None => 
        }
        
        while(counter == 0) {

          val leftChar = s(left)
          if (minLength > (right - left  + 1)) {
            head = left
            minLength = right - left + 1
          }
          
          sMap.get(leftChar) match {
            case Some(v) if v == 0 =>
              sMap.update(leftChar, v + 1)
              counter += 1
            case Some(v) =>
              sMap.update(leftChar, v + 1)
            case None =>
          }
          
          left += 1
        }
        
      }
      if (minLength == (s.length + 1)) "" else s.slice(head, head + minLength)
      
      
    }
}
```

###  3.71. <a name='-1'></a>77. 组合

```py
class Solution:
    def combine(self, n, k):
            res = []
            path = []
            def backtrack(StartIndex):
                if len(path) == k:
                    res.append(path[:])
                    return
                for i in range(StartIndex, n+1):
                    path.append(i)
                    backtrack(i+1)
                    path.pop()
            backtrack(1)
            return res
```

###  3.72. <a name='Subsets'></a>78. 【位运算😜】Subsets 子集

[花花酱](https://www.bilibili.com/video/BV1jt411k7py?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1HD4y1Q7Te?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1s7pq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1154y1R72Q?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.xmmpwe7mlzk.webp)

时间复杂度：O(n·2^n)

```py

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        size = len(nums)
        n = 1 << size
        res = []
        # i = 0,1,2,3,4,5,6,7
        for i in range(n):
            cur = []
            # j = 0,1,2
            for j in range(size):
                if i >> j & 1:
                    cur.append(nums[j])
            res.append(cur)
        return res

```

```py
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = [[]]
        for num in nums:
            res.extend([tmp+[num] for tmp in res])
        return res  

# bfs
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        q=[[]]
        n=len(nums)
        for i in range(n):
            for j in range(len(q)):
                q.append(q[j]+[nums[i]])
        return q

        # 等效

        res = [[]]
        n = len(nums)
        for num in nums:
            for subres in res[:]:
                res.append(subres+[num])
        return res

# 注意代码中res[:]是必须的，因为切片是引用新的对象，
# 此时在循环中res[:]是不更新的，而res是不断有元素push进去的，很trick
```

```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  
        path = []  
        def backtrack(startIndex):
            res.append(path[:])  #收集子集，要放在终止添加的上面，否则会漏掉自己
            for i in range(startIndex,len(nums)):  #当startIndex已经大于数组的长度了，就终止了，for循环本来也结束了，所以不需要终止条件
                path.append(nums[i])
                backtrack(i+1)  #递归
                path.pop()  #回溯
        backtrack(0)
        return res
```

```scala
object Solution {
    //We either use or don't use the current item at the given index and continue until we are at the end of the array.
    
    def subsets(nums: Array[Int]): List[List[Int]] = {
        def backtrack(nums: List[Int], returnValue: List[Int]): List[List[Int]] = {
            nums
            .headOption
            .map(currentElem => 
                 backtrack(nums.tail, returnValue) ++ backtrack(nums.tail, currentElem +: returnValue))
            .getOrElse(List(returnValue))
        }
        
        backtrack(nums.toList, List.empty[Int])
    }
}

```

###  3.73. <a name='WordSearch'></a>79. Word Search

[小梦想家](https://www.bilibili.com/video/BV1yE411g7Tb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iZ4y1T78D?spm_id_from=333.999.0.0)

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def dfs(i, j, word):
            # 单词是否出现在以i，j为起点的网格中
            # word[0] 和 word[1:] 划分
            # 结束条件：
            if len(word) == 1:
                return word[0] == board[i][j]
            # 结束条件：
            if board[i][j] != word[0]:
                return False
            
            # 设置现场
            visit[i][j] = True
            for dire in direction: # 对四个方向进行搜索
                newi, newj = i + dire[0], j + dire[1]
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]) and not visit[newi][newj]:
                    if dfs(newi, newj, word[1:]): # dfs成功
                        return True
            # 还原现场
            visit[i][j] = False

        direction = [(0,1), (0, -1), (1, 0), (-1, 0)]
        m = len(board)
        n = len(board[0])
        visit = [[False]*n for _ in range(m)]
        for i in range(m): # 遍历所有格子作为单词起点
            for j in range(n):
                if dfs(i,j,word): # dfs成功
                    return True
        return False
```

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1: # k + 1等价于word[1:]
                return True
            
            visited.add((i, j)) # 用集合表示visited
            for di, dj in directions:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1): # k + 1等价于word[1:]
                            return True
            visited.remove((i, j)) # 用集合表示visited

        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        h, w = len(board), len(board[0])
        visited = set() # 用集合表示visited
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True
        
        return False
```

```scala
/**
* chosen solution
* directly compare char by char
* if there are only one word should be checked in board, brute force is a more efficient method
*/

object Solution0 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    dfs(word, board)
  }

  def dfs(word: String, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), wordIdx: Int): Boolean = {
      val char = board(coord._1)(coord._2)

      if(wordIdx >= word.length || char != word.charAt(wordIdx)) false
      else if(char == word.charAt(wordIdx) && wordIdx == word.length - 1) true
      else {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), wordIdx + 1)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      }
    }
    
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, 0))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
*  my first commitment
*    using Tries
*    watch out that uppercase is different from lower case => "POLAND" != "poland"
*/
object Solution1 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    val tries = new Tries()
    tries.insert(word)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), prePrefix: String): Boolean = {
      val char = board(coord._1)(coord._2)
      val newPrefix = prePrefix + char
      if(tries.search(newPrefix)) true

      else if(tries.startsWith(newPrefix)) {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), newPrefix)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      } else false
    }
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, ""))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
* helper class 
*   Tries Node is implemented with Map
*/
case class Node(child: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map.empty[Char, Node], var isWord: Boolean = false) {
  def update(char: Char, node: Node): Unit = child(char) = node
  def apply(char: Char): Option[Node] = child.get(char)
}

class Tries() {
  val root = Node()

  def insert(word: String): Unit = {
    var node = root
    word.foreach{
      case c if node(c).isDefined => node = node(c).get
      case c =>
        node(c) = Node()
        node = node(c).get
    }
    node.isWord = true
  }

  def search(word: String): Boolean = searchUtil(word).exists(_.isWord)

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined

  private def searchUtil(string: String): Option[Node] = {
    var node = root

    string.foreach{
      case c if node(c).isDefined => node = node(c).get
      case _ => return None
    }
    Some(node)
  }
}


/**
* directly compare with char by char
* if there are only one word should be checked in board, brute force is a more efficient method
*/

object Solution2 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    dfs(word, board)
  }

  def dfs(word: String, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), wordIdx: Int): Boolean = {
      val char = board(coord._1)(coord._2)

      if(wordIdx >= word.length || char != word.charAt(wordIdx)) false
      else if(char == word.charAt(wordIdx) && wordIdx == word.length - 1) true
      else {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), wordIdx + 1)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      }
    }
    
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, 0))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

###  3.74. <a name='RemoveDuplicatesfromSortedArrayII'></a>80 Remove Duplicates from Sorted Array II

[小明](https://www.bilibili.com/video/BV1vy4y1S7sN?spm_id_from=333.999.0.0)

###  3.75. <a name='IIRemoveDuplicatesfromSortedList'></a>82. 删除排序链表中的重复元素 II(Remove Duplicates from Sorted List

[洛阳](https://www.bilibili.com/video/BV1Fi4y187pj?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0,head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                while cur.next.next and cur.next.val == cur.next.next.val:
                    cur.next = cur.next.next # 删去重复节点的前一个
                cur.next = cur.next.next # 删去重复节点的剩余一个
            else:
                cur =  cur.next
        return dummy.next

# 另一种写法
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0,head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                x = cur.next.val
                while cur.next and cur.next.val == x:
                    cur.next = cur.next.next
            else:
                cur =  cur.next
        return dummy.next
```

###  3.76. <a name='Removeduplicatesfromsortedarray-1'></a>83-Remove duplicates from sorted array

[哈哈哈](https://www.bilibili.com/video/BV1yJ411R7FZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7s7?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1zK411L7Gg?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur =  cur.next
        return head
```

###  3.77. <a name='LargestRectangleinHistogram'></a>84. 柱状图中最大的矩形 Largest Rectangle in Histogram

[官方](https://www.bilibili.com/video/BV16D4y1D7ed?spm_id_from=333.999.0.0)

###  3.78. <a name='PartitionList'></a>86. 分隔链表(Partition List)

[洛阳](https://www.bilibili.com/video/BV1t64y1u7Ei?spm_id_from=333.999.0.0)

```py
        dummy1 = ListNode(0)
        dummy2 = ListNode(0)
        slow,fast,cur = dummy1, dummy2, head
        while cur:
            if cur.val < x:
                slow.next = cur # dummy1 指向第一个小于x的node
                slow = slow.next
            else:
                fast.next = cur # dummy2 指向第一个大于x的node
                fast = fast.next
            cur = cur.next
        slow.next = dummy2.next
        fast.next = None
        return dummy1.next
```

###  3.79. <a name='ScrambleString'></a>87. Scramble String

[花花酱](https://www.bilibili.com/video/BV1QE41137MG?spm_id_from=333.999.0.0)

###  3.80. <a name='Mergesortedarray'></a>88-Merge sorted array

[哈哈哈](https://www.bilibili.com/video/BV14J411X7JE?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7bg?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1g54y1s7ZG?spm_id_from=333.999.0.0)

直接合并后排序

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 三个指针
        cur1 = m - 1
        cur2 = n - 1
        i = m + n -1
        while cur1 >= 0 and cur2 >= 0:
            if nums1[cur1] < nums2[cur2]:
                nums1[i] = nums2[cur2]
                cur2 -= 1
            else:
                nums1[i] = nums1[cur1]
                cur1 -= 1
            i -= 1
        if cur2 >= 0:
            nums1[:cur2+1] = nums2[:cur2+1] # 易错点：不包括右边界

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()
```

```scala
object Solution {
    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {
        var trail = m+n-1
        
        var t1 = m-1
        var t2 = n-1
        
        while(t1 > -1 && t2 > -1){
            val e1 = nums1(t1)
            val e2 = nums2(t2)
            
            if(e1 > e2){
                nums1(trail) = e1
                t1 -= 1
                trail -= 1
            }else{
                nums1(trail) = e2
                t2 -= 1
                trail -= 1
            }
        }
        
        if(t1 == -1){
            while(t2 > -1){
                nums1(trail) = nums2(t2)
                t2 -= 1
                trail -= 1
            }
        }else{
            while(t1 > -1){
                nums1(trail) = nums1(t1)
                t1 -= 1
                trail -= 1
            }
        }
        
    }
}

```

###  3.81. <a name='89.'></a> 89. 格雷编码

```py
class Solution:
    def grayCode(self, n):
        # 易错点：递归部分必须是字符串部分
        def recur(i):
            if i==1:
                return ['0','1']
            else:
                lastList = recur(i-1)
                return ['0'+ x for x in lastList]+['1'+ x for x in lastList[::-1]]
            
        res = recur(n)
        return [int(x,2) for x in res] 
        # int(a,2)把二进制转化成10进制

class Solution:
    def grayCode(self, n: int) -> List[int]:
        res, head = [0], 1
        for i in range(n):
            for subres in res[::-1]: # 逆序，背一背
                res.append(head + subres)
            head <<= 1 # head就是2**i
        return res

class Solution:
    def grayCode(self, n):
        res, head = [0], 1
        for i in range(n):
            for j in range(len(res) - 1, -1, -1): # 逆序，背一背
                res.append(head + res[j])
            head <<= 1 # head就是2**i
        return res
```

###  3.82. <a name='II'></a>90-子集 II

[哈哈哈](https://www.bilibili.com/video/BV11z4y1Q7Hd?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

```py
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        n = len(nums)
        path = []
        nums.sort()
        def backtrack(startIndex):
            if startIndex == n:
                return
            else:
                for i in range(startIndex,n):
                    if i > startIndex and nums[i] == nums[i-1]: 
                        # 易错点：不是nums[i] == nums[startIndex]
                        continue
                    path.append(nums[i])
                    res.append(path[:]) # 易错点：一定要是path[:]
                    backtrack(i+1)
                    path.pop()
        backtrack(0)
        return res
```

```py
class Solution:
    def subsetsWithDup(self, nums):
        res = [[]]
        nums.sort()
        for i in range(len(nums)):
            for j in range(len(res)):
                if res[j] + [nums[i]] not in res:
                    res.append(res[j] + [nums[i]]) 
        return res

# 另一种写法
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        nums.sort()
        for num in nums:
            for subres in res[:]: # 注意：要写成 res[:]
                if subres + [num] not in res:
                    res.append(subres + [num]) 
        return res
```

###  3.83. <a name='DecodeWays'></a>91. Decode Ways

[花花酱](https://www.bilibili.com/video/BV1Lb411y7ec?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1G7M5?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        
        @cache
        def dp(i):
            if i == 0: 
                if '1' <= s[i] <= '9':
                    return 1
                else:
                    return 0
            if i == -1: 
                return 1 
                # 易错点：return 1，而不是return 0，比如‘12’，dp(i-2)应该要是1的
            if i >= 1:
                res = 0
                if '1' <= s[i] <= '9':
                    res = dp(i-1)
                if '10' <= s[i-1:i+1] <= '26':
                    res += dp(i-2)
                return res
        
        return dp(len(s) - 1)
```

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp0 = 1 # 这里dp=0或者是dp=1都可以，因为在第一轮的循环过后会更新
        dp1 = 1
        for i in range(n):
            res = 0
            if '1' <= s[i] <= '9':
                res = dp1
            if i > 0 and '10' <= s[i-1:i+1] <= '26':
                res += dp0
            dp1, dp0 = res, dp1
        return dp1
```

```scala


/**
* my first commitment dynamic programming
* memo:
* 1.subproblem dp(i) represents the decode ways of the sub-string which length is i 
* 2. dp(i) could be sum from dp(i-1) or dp(i-2) if s(i -1, i) or s(i-2, i) are valid coding
*  idx:   0 1 2 3 4 5 6 7
*  length 1 2 3 4 5 6 7 8
&  value  1 2 1 3 2 5 8 3
*   
*   dp(1) => "1"
*   dp(2) => "12" :
*            valid("12") + dp(0)
*            valid("2") + dp(1)
*   dp(3) => "121" :
*           valid("21") + dp(1)
*           valid("1) + dp(2)
*
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s.slice(idx-1, idx).toInt
        val tens = s.slice(idx-2, idx).toInt
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      
      }
      dp.last
    }
}
/**
* instead of using slice, handle single and tens by hands
* memo
*  1. char as digit
*/

object Solution1-1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s(idx-1).asDigit
        val tens = s(idx-2).asDigit * 10 + single
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      }
      
      dp.last
      
    }
}

/**
*  dp - only keep dp(i-1) and dp(i-2)
* time complexity: O(2N)
* space complexity: O(1)
*/

object Solution1-3 {
    def numDecodings(s: String): Int = {
      if (s == null && s.isEmpty) return 0
      (2 to s.length).foldLeft((1, if(s(0) == '0') 0 else 1)) {
      /**
      * pre = dp(i-1)
      * prepre = dp(i-2) 
      */
        case ((prepre, pre), idx) =>
          val decodeOne = if(decodeSingle(s, idx)) pre else 0
          val decodeTwo = if(decodeTens(s, idx)) prepre else 0
          (pre, decodeOne + decodeTwo)
      }._2
    }
  
    def decodeSingle(s: String, idx: Int): Boolean = s(idx - 1) != '0'
  
    def decodeTens(s: String, idx: Int): Boolean = (s(idx - 2) == '1' ) || (s(idx - 2) == '2' && s(idx-1) <= '6' )
    
}



```

###  3.84. <a name='ReverseLinkedListII'></a>92-Reverse Linked List II

[哈哈哈](https://www.bilibili.com/video/BV1n7411G7N4?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV19c411h7UE?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        dummy = ListNode(0,head)
        pre = dummy
        for _ in range(left-1):
            pre = pre.next

        cur = pre.next
        for _ in range(right-left):
            # 易错点：顺序不能错，中，后，前
            aft = cur.next
            cur.next = aft.next
            aft.next = pre.next
            pre.next = aft
        
        return dummy.next
```

###  3.85. <a name='93.IP'></a> 93. 复原 IP 地址

```py
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        def backtrack(s,path):
            if len(path) == 4 and len(s) == 0:
                res.append('.'.join(path))
                return # 注意点：一定要返回
            for i in range(len(s)):
                left,right = s[:i+1],s[i+1:]
                if 0 <= int(left) <= 255 and str(int(left)) ==  left:
                    backtrack(right,path + [left])  
        backtrack(s,[])    
        return res

优化一下：

class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        def backtrack(s,path):
            if len(path) == 4 and len(s) == 0:
                res.append('.'.join(path))
                return 
            if len(path) < 4: # 优化：只有在path小于4的时候，才有必要继续backtrack
                for i in range(min(3,len(s))): # 优化：s不需要遍历完，只要取出前三个看看是否符合
                    left,right = s[:i+1],s[i+1:]
                    if 0 <= int(left) <= 255 and str(int(left)) ==  left:
                        backtrack(right,path + [left])  
        backtrack(s,[])    
        return res
```

###  3.86. <a name='Inorderwihstack'></a>94-Inorder wih stack

[哈哈哈](https://www.bilibili.com/video/BV1uV411o78x?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1o54y1B7Z8?spm_id_from=333.999.0.0)



###  3.87. <a name='BinaryTreeInorderTraversal'></a>94-Binary Tree Inorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7g5?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1mV411Y7T1?spm_id_from=333.999.0.0)

```py
# 递归
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        @cache
        def dfs(root):
            if root: # 不要漏了条件判断
                dfs(root.left)
                res.append(root.val)
                dfs(root.right)
        dfs(root)
        return res
```

```py
# stack
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []

        while stack or root: # 代表res还没有填满
            while root:
                stack.append(root)
                root = root.left
            
            if stack:
                cur = stack.pop()
                res.append(cur.val)
                if cur.right:
                    root = cur.right
        
        return res

# 写啰嗦了，简化一下
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []

        while stack or root: # 代表res还没有填满
            while root:
                stack.append(root)
                root = root.left
            
            cur = stack.pop()
            res.append(cur.val)
            root = cur.right
        
        return res

# 其他更好理解的写法
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def addAllLeft(node):
            while node:
                stack.append(node)
                node = node.left

        stack, res = [], []
        addAllLeft(root)

        while stack:
            cur = stack.pop()
            res.append(cur.val)
            addAllLeft(cur.right)

        return res

# 其他更好理解的写法
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]: 
        stack, res = [], []
        cur = root
        while stack or cur:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                res.append(cur.val)
                cur = cur.right
        return res
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

/**
* chosen solution
* iterative version
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution0 {
    def inorderTraversal(root: TreeNode): List[Int] = {
      var node = root
      val stack = new collection.mutable.Stack[TreeNode]()
      val result = new collection.mutable.ListBuffer[Int]()

      while(node != null || stack.nonEmpty) {
        while(node != null){
          stack.push(node)
          node = node.left
        }

        node = stack.pop()
        result += node.value
        node = node.right

      }
      result.toList
    }
}


/**
* iterative version
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution1 {
    def inorderTraversal(root: TreeNode): List[Int] = {
      var node = root
      val stack = new collection.mutable.Stack[TreeNode]()
      val result = new collection.mutable.ListBuffer[Int]()

      while(node != null || stack.nonEmpty) {
        while(node != null){
          stack.push(node)
          node = node.left
        }

        node = stack.pop()
        result += node.value
        node = node.right

      }
      result.toList
    }
}

/**
* recursive version
* time complexity: O(N)
* space complexity: O(logN), worst: O(N)
*/
object Solution2 {
    def inorderTraversal(root: TreeNode): List[Int] = {
        _inorderTraversal(root)
    }
    
    def _inorderTraversal(node: TreeNode): List[Int] = {
        if (node == null) Nil
        else
            _inorderTraversal(node.left) ::: List(node.value) ::: _inorderTraversal(node.right)
        
    }
}
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def inorderTraversal(root: TreeNode): List[Int] = {
        if(root == null){
            List.empty[Int]
        }
        else if(root.left == null && root.right == null){
            List(root.value)
        }else if(root.left == null){
            List(root.value) ++ inorderTraversal(root.right)
        }else if(root.right == null){
            inorderTraversal(root.left) ++ List(root.value)
        }else{
            inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)
        }
    }
}

```

###  3.88. <a name='II-1'></a>95. 不同的二叉搜索树 II

```py
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:

        def backtrack(start,end) -> List[TreeNode]:
            if start > end:
                return [None]

            res = [] # res一定要写在backtrack里面
            
            for i in range(start,end+1):
                
                leftTrees = backtrack(start,i-1)
                rightTrees = backtrack(i+1,end)
                
                for left in leftTrees:
                    for right in rightTrees:
                        root = TreeNode(i) # root一定要写在for循环里面
                        root.left = left
                        root.right = right
                        res.append(root)
            return res
                    
        return backtrack(1,n)
```

###  3.89. <a name='UniqueBinarySearchTrees'></a>96. Unique Binary Search Trees

[小梦想家](https://www.bilibili.com/video/BV1xV411Y731?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1e5411W72t?spm_id_from=333.999.0.0)

```py
# 基于上一问修改
class Solution:
    def numTrees(self, n: int) -> int:

        @cache
        def backtrack(n):
            if n <= 1:
                return 1
            else:
                res = 0 # res一定要写在backtrack里面
                for i in range(n):
                    leftTrees = backtrack(i)
                    rightTrees = backtrack(n-i-1)
                    res += leftTrees*rightTrees # 易错点：一定是加号
                return res
                    
        return backtrack(n)

class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2,n+1):
            for subi in range(i):
                dp[i] += dp[subi]*dp[i-subi-1]
        return dp[-1]
```





###  3.90. <a name='ValidateBinarySearchTree98-'></a>98. Validate Binary Search Tree 98-验证二叉搜索树

[花花酱](https://www.bilibili.com/video/BV12t411Y7TP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Wz4y1R7dF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Hv411478d?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Fi4y147Ng?spm_id_from=333.999.0.0)

```py
有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

这样写是错误的，因为不仅仅左小于右就够了
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        if not root.left:
            validleft = True
        elif root.left and root.left.val < root.val and self.isValidBST(root.left):
            validleft = True
        else:
            validleft = False

        if not root.right:
            validright = True
        elif root.right and root.right.val > root.val and self.isValidBST(root.right):
            validright = True
        else:    
            validright = False
        return validleft and validright
```

中序遍历一下就行了

```py
# stack
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, res = [], float('-inf')
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if root.val <= res:
                return False
            res = root.val
            root = root.right
        return True

# 有很多易错点：
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        res = [float('-inf')] # 易错点：要有一个float('-inf')
        valid = True

        @cache
        def dfs(root):
            nonlocal valid # 易错点：valid 从外部传入内部，再传到外部
            if root: # 不要漏了条件判断
                dfs(root.left)
                if root.val <= res[-1]: valid = False
                res.append(root.val)
                dfs(root.right)
        dfs(root)

        return valid
```

定义上下界：

```py
class Solution:
    def isValidBST(self, root):
        def BFS(node, lower, upper):
            if not node:
                return True
            return lower < node.val < upper and BFS(node.left, lower, node.val) and BFS(node.right, node.val, upper)

        return fun(root, float('-inf'), float('inf'))
```

```scala
/**
* chosen solution
* inorder iterative version only keep pre node
* this is also the inorder-iterative-template
* 
* time complexity: O(N)
*/

object Solution0 {
   def isValidBST(root: TreeNode): Boolean = {
    val stack = new collection.mutable.Stack[TreeNode]()
    var node = root
    var pre: TreeNode = null
    var result = true
    while ((node != null || stack.nonEmpty) && result) {
      while (node != null) {
        stack push node
        node = node.left
      }

      node = stack.pop
      if (pre != null && node.value <= pre.value) result = false
      pre = node
      node = node.right

    }
    result
  }
}

/**
* inorder recursive traversal
* memo:
*    1. recursive version with all element storing
* Time complexity O(NlogN)  there are a distinct and sorted operation
* space complexity O(N)
*/
object Solution1 {
  def isValidBST(root: TreeNode): Boolean = {
    val inorder = traversal(root)
    inorder equals inorder.distinct.sorted // why distinct here? [1, 1] is not a BST because left tree should be smaller than root. 
  }
  def traversal(node: TreeNode): List[Int] = {
    if(node == null){
      List.empty[Int]
    }else {
      // (traversal(node.left) :+ node.value) ::: traversal(node.right) 
      traversal(node.left) ::: List(node.value) ::: traversal(node.right)
    }
  }
}



/**
* inorder recursive version only keep pre node
* time complexity: O(N)
*  ! Not recommend
*/

object Solution2 {
    def isValidBST(root: TreeNode): Boolean = {

    var prev: TreeNode = null
    def _isValidBST(node: TreeNode): Boolean = {
      if (node == null) return true
      if (!_isValidBST(node.left)) return false
      if (prev != null && node.value <= prev.value) {
        return false
      }
      prev = node
      _isValidBST(node.right)
    }
    _isValidBST(root)
  }
}

/**
* inorder iterative version only keep pre node
*   inorder iterative template
* time complexity: O(N)
*/

object Solution3 {
   def isValidBST(root: TreeNode): Boolean = {
    val stack = new collection.mutable.Stack[TreeNode]()
    var node = root
    var pre: TreeNode = null
    var result = true
    while ((node != null || stack.nonEmpty) && result) {
      while (node != null) {
        stack push node
        node = node.left
      }

      node = stack.pop
      if (pre != null && node.value <= pre.value) result = false
      pre = node
      node = node.right

    }
    result
  }
}

/**
* giving min max range when recursive
* time complexity: O(N)
*/

object Solution4 {
  def isValidBST(root: TreeNode): Boolean = {

    def _isValidBST(node: TreeNode, min: TreeNode, max: TreeNode): Boolean = {

      if(node == null) true
      else {
        if((min != null && node.value <= min.value) || (max != null  && node.value >= max.value)) false
        else {
          _isValidBST(node.lefmt, min, node) && _isValidBST(node.right, node, max)
        }
      }
    }
    _isValidBST(root, null, null)
  }

}
```