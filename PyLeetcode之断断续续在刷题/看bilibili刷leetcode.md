<!-- vscode-markdown-toc -->
* 1. [经验](#)
* 2. [算法](#-1)
* 3. [题目](#-1)
	* 3.1. [1 Two Sum](#TwoSum)
	* 3.2. [2. Add Two Numbers](#AddTwoNumbers)
	* 3.3. [3. 数组中重复的数字 Longest Substring Without Repeating Characters](#LongestSubstringWithoutRepeatingCharacters)
	* 3.4. [4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays](#MedianofTwoSortedArrays)
	* 3.5. [5. Longest Palindromic Substring -最长回文子串](#LongestPalindromicSubstring-)
	* 3.6. [6. ZigZag Conversion](#ZigZagConversion)
	* 3.7. [7 Reverse Integer](#ReverseInteger)
	* 3.8. [8. String to Integer(atoi)](#StringtoIntegeratoi)
	* 3.9. [9-Palindrome](#Palindrome)
	* 3.10. [11. Container With Most Water](#ContainerWithMostWater)
	* 3.11. [12. Integer to Roman](#IntegertoRoman)
	* 3.12. [13. 机器人的运动范围](#-1)
	* 3.13. [13. Roman to Integer](#RomantoInteger)
	* 3.14. [14-Longest common prefix](#Longestcommonprefix)
	* 3.15. [15. 3Sum](#Sum)
	* 3.16. [16. 3Sum Closest](#SumClosest)
	* 3.17. [17. Letter Combinations of a Phone Number](#LetterCombinationsofaPhoneNumber)
	* 3.18. [19-Remove Nth Node From End of List](#RemoveNthNodeFromEndofList)
	* 3.19. [20-Valid parentheses](#Validparentheses)
	* 3.20. [21-Merge two sorted lists](#Mergetwosortedlists)
	* 3.21. [22. Generate Parentheses](#GenerateParentheses)
	* 3.22. [23. Merge k Sorted Lists](#MergekSortedLists)
	* 3.23. [24-Swap Nodes in Pairs](#SwapNodesinPairs)
	* 3.24. [26-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray)
	* 3.25. [27-python-Remove element](#python-Removeelement)
	* 3.26. [28-Implement str](#Implementstr)
	* 3.27. [31 Next Permutation](#NextPermutation)
	* 3.28. [32 Longest Valid Parentheses](#LongestValidParentheses)
	* 3.29. [33. Search in Rotated Sorted Array](#SearchinRotatedSortedArray)
	* 3.30. [34-在排序数组中查找元素的第一个](#-1)
	* 3.31. [35-搜索插入位置](#-1)
	* 3.32. [36-有效的数独](#-1)
	* 3.33. [37. Sudoku Solver 解数独](#SudokuSolver)
	* 3.34. [38-Count and say](#Countandsay)
	* 3.35. [39. Combination Sum 39-组合总和](#CombinationSum39-)
	* 3.36. [40. Combination Sum II 40-组合总和 II](#CombinationSumII40-II)
	* 3.37. [41 First Missing Positive](#FirstMissingPositive)
	* 3.38. [42. Trapping Rain Water](#TrappingRainWater)
	* 3.39. [45 Jump Game II](#JumpGameII)
	* 3.40. [46-把数字翻译成字符串](#-1)
	* 3.41. [46-全排列](#-1)
	* 3.42. [47-全排列 II-剪枝版](#II-)
	* 3.43. [48. 旋转图像 Rotate Image](#RotateImage)
	* 3.44. [49 Group Anagrams](#GroupAnagrams)
	* 3.45. [50 Pow(x, n)](#Powxn)
	* 3.46. [51. 数组中的逆序对](#-1)
	* 3.47. [53-Maximum subarray](#Maximumsubarray)
	* 3.48. [54. Spiral Matrix](#SpiralMatrix)
	* 3.49. [55 Jump Game](#JumpGame)
	* 3.50. [56-I. 数组中数字出现的次数](#I.)
	* 3.51. [56. Merge Intervals](#MergeIntervals)
	* 3.52. [57. Insert Interval](#InsertInterval)
	* 3.53. [58. Lengh of Last Words](#LenghofLastWords)
	* 3.54. [59 - II. 队列的最大值 LCOF](#II.LCOF)
	* 3.55. [59. Spiral Matrix II](#SpiralMatrixII)
	* 3.56. [61. Rotate List](#RotateList)
	* 3.57. [62-不同路径](#-1)
	* 3.58. [63 Unique Paths II](#UniquePathsII)
	* 3.59. [64. Minimum Path Sum 64-最小路径和](#MinimumPathSum64-)
	* 3.60. [65 Valid Number](#ValidNumber)
	* 3.61. [66-Plus one](#Plusone)
	* 3.62. [67-Add Binary](#AddBinary)
	* 3.63. [69 Sqrt(x)](#Sqrtx)
	* 3.64. [70. Climbing Stairs](#ClimbingStairs)
	* 3.65. [71. Simplify Path](#SimplifyPath)
	* 3.66. [72. Edit Distance 72-编辑距离](#EditDistance72-)
	* 3.67. [73. Set Matrix Zeroes](#SetMatrixZeroes)
	* 3.68. [74 Search a 2D Matrix](#Searcha2DMatrix)
	* 3.69. [75. Sort Colors](#SortColors)
	* 3.70. [76-最小覆盖子串](#-1)
	* 3.71. [77. 组合](#-1)
	* 3.72. [78. Subsets 78-子集](#Subsets78-)
	* 3.73. [79. Word Search](#WordSearch)
	* 3.74. [80 Remove Duplicates from Sorted Array II](#RemoveDuplicatesfromSortedArrayII)
	* 3.75. [82. 删除排序链表中的重复元素 II(Remove Duplicates from Sorted List](#IIRemoveDuplicatesfromSortedList)
	* 3.76. [83-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray-1)
	* 3.77. [84. 柱状图中最大的矩形 Largest Rectangle in Histogram](#LargestRectangleinHistogram)
	* 3.78. [86. 分隔链表(Partition List)](#PartitionList)
	* 3.79. [87. Scramble String](#ScrambleString)
	* 3.80. [88-Merge sorted array](#Mergesortedarray)
	* 3.81. [ 89. 格雷编码](#89.)
	* 3.82. [90-子集 II](#II)
	* 3.83. [91. Decode Ways](#DecodeWays)
	* 3.84. [92-Reverse Linked List II](#ReverseLinkedListII)
	* 3.85. [ 93. 复原 IP 地址](#93.IP)
	* 3.86. [94-Inorder wih stack](#Inorderwihstack)
	* 3.87. [94-Binary Tree Inorder Traversal](#BinaryTreeInorderTraversal)
	* 3.88. [95. 不同的二叉搜索树 II](#II-1)
	* 3.89. [96. Unique Binary Search Trees](#UniqueBinarySearchTrees)
	* 3.90. [98. Validate Binary Search Tree 98-验证二叉搜索树](#ValidateBinarySearchTree98-)
	* 3.91. [100-Same Tree](#SameTree)
	* 3.92. [101-Symmetric tree](#Symmetrictree)
	* 3.93. [102-Binary Tree Level Order Traversal](#BinaryTreeLevelOrderTraversal)
	* 3.94. [103. Binary Tree Zigzag Level Order Traversal](#BinaryTreeZigzagLevelOrderTraversal)
	* 3.95. [104-Maximum Depth of Binary](#MaximumDepthofBinary)
	* 3.96. [105-从前序与中序遍历序列构](#-1)
	* 3.97. [106-从中序与后序遍历序列构造二叉树](#-1)
	* 3.98. [107-Binary Tree Level Order Traversal II](#BinaryTreeLevelOrderTraversalII)
	* 3.99. [108 Convert Sorted Array to Binary Search Tree](#ConvertSortedArraytoBinarySearchTree)
	* 3.100. [109题. 有序链表转换二叉搜索树](#-1)
	* 3.101. [110-Balanced Binary Tree](#BalancedBinaryTree)
	* 3.102. [111-Minimum Depth of Binary Tree](#MinimumDepthofBinaryTree)
	* 3.103. [112-Path Sum](#PathSum)
	* 3.104. [113. 二叉树中和为某一值的路径](#-1)
	* 3.105. [114题. 二叉树展开为链表](#-1)
	* 3.106. [115. Distinct Subsequences](#DistinctSubsequences)
	* 3.107. [116. Populating Next Right Pointers in Each Node](#PopulatingNextRightPointersinEachNode)
	* 3.108. [117 Populating Next Right Pointers in Ea](#PopulatingNextRightPointersinEa)
	* 3.109. [118-Pascal's Triangle](#PascalsTriangle)
	* 3.110. [119-Pascal's Triangle II](#PascalsTriangleII)
	* 3.111. [120 Triangle](#Triangle)
	* 3.112. [121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机](#BestTimetoBuyandSellStock121-)
	* 3.113. [122-买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II](#II122-BestTimetoBuyandSellStockII)
	* 3.114. [123-买卖股票的最佳时机 III](#III)
	* 3.115. [124. Binary Tree Maximum Path Sum](#BinaryTreeMaximumPathSum)
	* 3.116. [125-Valid Palindrome](#ValidPalindrome)
	* 3.117. [126. Word Ladder II](#WordLadderII)
	* 3.118. [127. Word Ladder](#WordLadder)
	* 3.119. [128. Longest Consecutive Sequence](#LongestConsecutiveSequence)
	* 3.120. [129 Sum Root to Leaf Numbers](#SumRoottoLeafNumbers)
	* 3.121. [130. Surrounded Regions 130-被围绕的区域](#SurroundedRegions130-)
	* 3.122. [131-分割回文串](#-1)
	* 3.123. [132. Palindrome Partitioning II](#PalindromePartitioningII)
	* 3.124. [133. Clone Graph](#CloneGraph)
	* 3.125. [134. Gas Station](#GasStation)
	* 3.126. [138 Copy List with Random Pointer](#CopyListwithRandomPointer)
	* 3.127. [136-Single Number](#SingleNumber)
	* 3.128. [137 Single Number II](#SingleNumberII)
	* 3.129. [139 Word Break](#WordBreak)
	* 3.130. [140 Word Break II](#WordBreakII)
	* 3.131. [141-Linked List Cycle](#LinkedListCycle)
	* 3.132. [142 Linked List Cycle II](#LinkedListCycleII)
	* 3.133. [143 Reorder List](#ReorderList)
	* 3.134. [144-Preorder with stack](#Preorderwithstack)
	* 3.135. [144-Binary Tree Preorder Traversal](#BinaryTreePreorderTraversal)
	* 3.136. [145-Postorder with stack](#Postorderwithstack)
	* 3.137. [145-Binary Tree Postorder Traversal](#BinaryTreePostorderTraversal)
	* 3.138. [146 LRU Cache](#LRUCache)
	* 3.139. [147 Insertion Sort List](#InsertionSortList)
	* 3.140. [148. Sort List](#SortList)
	* 3.141. [149. Max Points on a Line](#MaxPointsonaLine)
	* 3.142. [150. Evaluate Reverse Polish Notation](#EvaluateReversePolishNotation)
	* 3.143. [151. Reverse Words in a String](#ReverseWordsinaString)
	* 3.144. [152-乘积最大子数组](#-1)
	* 3.145. [153-寻找旋转排序数组中的最小值](#-1)
	* 3.146. [154 Find Minimum in Rotated Sorted Arr](#FindMinimuminRotatedSortedArr)
	* 3.147. [155-Min Stack](#MinStack)
	* 3.148. [160-Intersection of Two Linked Lists](#IntersectionofTwoLinkedLists)
	* 3.149. [162. Find Peak Element](#FindPeakElement)
	* 3.150. [165. Compare Version Numbers](#CompareVersionNumbers)
	* 3.151. [166. Fraction to Recurring Decimal](#FractiontoRecurringDecimal)
	* 3.152. [167-Two Sum II - Input array is sorted](#TwoSumII-Inputarrayissorted)
	* 3.153. [168-Excel Sheet Column Title](#ExcelSheetColumnTitle)
	* 3.154. [169. Majority Element](#MajorityElement)
	* 3.155. [171. Excel Sheet Column Number](#ExcelSheetColumnNumber)
	* 3.156. [172-Factorial Trailing Zeroes](#FactorialTrailingZeroes)
	* 3.157. [173 Binary Search Tree Iterator](#BinarySearchTreeIterator)
	* 3.158. [174 Dungeon Game](#DungeonGame)
	* 3.159. [179 Largest Number](#LargestNumber)
	* 3.160. [186. Reverse Words in a String II](#ReverseWordsinaStringII)
	* 3.161. [187 Repeated DNA Sequences](#RepeatedDNASequences)
	* 3.162. [188 Best Time to Buy and Sell Stock IV](#BestTimetoBuyandSellStockIV)
	* 3.163. [189. Rotate Array](#RotateArray)
	* 3.164. [190. Reverse Bits](#ReverseBits)
	* 3.165. [191 Number of 1 Bits](#Numberof1Bits)
	* 3.166. [198. House Robber 198-打家劫舍](#HouseRobber198-)
	* 3.167. [199 Binary Tree Right Side View](#BinaryTreeRightSideView)
	* 3.168. [200-岛屿数量](#-1)
	* 3.169. [201 Bitwise AND of Numbers Range](#BitwiseANDofNumbersRange)
	* 3.170. [202. 快乐数 Happy Number](#HappyNumber)
	* 3.171. [203. Remove Linked List Elements](#RemoveLinkedListElements)
	* 3.172. [204-Count Primes](#CountPrimes)
	* 3.173. [205. isomorphic strings](#isomorphicstrings)
	* 3.174. [206-Reverse Linked List](#ReverseLinkedList)
	* 3.175. [207-课程表](#-1)
	* 3.176. [208. Implement Trie (Prefix Tree)](#ImplementTriePrefixTree)
	* 3.177. [209-长度最小的子数组](#-1)
	* 3.178. [210. Course Schedule II 210-课程表II](#CourseScheduleII210-II)
	* 3.179. [211 Add and Search Word](#AddandSearchWord)
	* 3.180. [212. Word Search II](#WordSearchII)
	* 3.181. [213. House Robber II 213-打家劫舍II](#HouseRobberII213-II)
	* 3.182. [216. Combination Sum III 216-组合总和 III](#CombinationSumIII216-III)
	* 3.183. [217. Contains Duplicate](#ContainsDuplicate)
	* 3.184. [218. The Skyline Problem](#TheSkylineProblem)
	* 3.185. [219. Contains Duplicate II](#ContainsDuplicateII)
	* 3.186. [220 Contains Duplicate III](#ContainsDuplicateIII)
	* 3.187. [221-最大正方形](#-1)
	* 3.188. [222. Count Complete Tree Nodes](#CountCompleteTreeNodes)
	* 3.189. [223. Rectangle Area](#RectangleArea)
	* 3.190. [225-Implement Stack using Queues](#ImplementStackusingQueues)
	* 3.191. [226-翻转二叉树](#-1)
	* 3.192. [227 Basic Calculator II](#BasicCalculatorII)
	* 3.193. [228 Summary Ranges](#SummaryRanges)
	* 3.194. [229. Majority Element II](#MajorityElementII)
	* 3.195. [230 Kth Smallest Element in a B](#KthSmallestElementinaB)
	* 3.196. [231. Power of Two](#PowerofTwo)
	* 3.197. [232-Implement Queue using Stacks](#ImplementQueueusingStacks)
	* 3.198. [234. Palindrome Linked List](#PalindromeLinkedList)
	* 3.199. [235. Lowest Common Ancestor of a Binary Search Tree](#LowestCommonAncestorofaBinarySearchTree)
	* 3.200. [236-二叉树的最近公共祖先](#-1)
	* 3.201. [237. Delete Node in a Linked List](#DeleteNodeinaLinkedList)
	* 3.202. [238 Product of Array Except Self](#ProductofArrayExceptSelf)
	* 3.203. [239. Sliding Window Maximum](#SlidingWindowMaximum)
	* 3.204. [240. 二维数组的查找](#-1)
	* 3.205. [242. Valid Anagram](#ValidAnagram)
	* 3.206. [243. Shortest Word Distance](#ShortestWordDistance)
	* 3.207. [246. Strobogrammatic Number](#StrobogrammaticNumber)
	* 3.208. [257-二叉树的所有路径](#-1)
	* 3.209. [258. Add Digits](#AddDigits)
	* 3.210. [260-只出现一次的数字 III](#III-1)
	* 3.211. [263 Ugly Number](#UglyNumber)
	* 3.212. [264. Ugly Number II](#UglyNumberII)
	* 3.213. [268 Missing Number](#MissingNumber)
	* 3.214. [270. Closest Binary Search Tree Value](#ClosestBinarySearchTreeValue)
	* 3.215. [274 H-Index](#H-Index)
	* 3.216. [278. First Bad Version](#FirstBadVersion)
	* 3.217. [279 Perfect Squares](#PerfectSquares)
	* 3.218. [282. Expression Add Operators](#ExpressionAddOperators)
	* 3.219. [283. Move Zeros](#MoveZeros)
	* 3.220. [284 Peeking Iterator](#PeekingIterator)
	* 3.221. [287 Find the Duplicate Number](#FindtheDuplicateNumber)
	* 3.222. [289. Game of Life](#GameofLife)
	* 3.223. [290. Word Pattern](#WordPattern)
	* 3.224. [297. Serialize and Deserialize Binary Tree](#SerializeandDeserializeBinaryTree)
	* 3.225. [299. Bulls and Cows](#BullsandCows)
	* 3.226. [300 Longest Increasing Subsequence 最长上升子序列](#LongestIncreasingSubsequence)
	* 3.227. [301. Remove Invalid Parentheses](#RemoveInvalidParentheses)
	* 3.228. [303-区域和检索 - 数组不可变](#-1)
	* 3.229. [304. Range Sum Query 2D](#RangeSumQuery2D)
	* 3.230. [309. Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期](#BestTimetoBuyandSellStockwithCooldown309-)
	* 3.231. [310 Minimum Height Trees](#MinimumHeightTrees)
	* 3.232. [312 Burst Balloons](#BurstBalloons)
	* 3.233. [315. Count of Smaller Numbers After Self](#CountofSmallerNumbersAfterSelf)
	* 3.234. [316 Remove Duplicate Letters](#RemoveDuplicateLetters)
	* 3.235. [321. Create Maximum Number](#CreateMaximumNumber)
	* 3.236. [322. Coin Change](#CoinChange)
	* 3.237. [326. Power of Three](#PowerofThree)
	* 3.238. [328. 奇偶链表 (Odd Even Linked List)](#OddEvenLinkedList)
	* 3.239. [329. Longest Increasing Path in a Matrix](#LongestIncreasingPathinaMatrix)
	* 3.240. [332 Reconstruct Itinerary](#ReconstructItinerary)
	* 3.241. [334 Increasing Triplet Subseque](#IncreasingTripletSubseque)
	* 3.242. [337 House Robber III](#HouseRobberIII)
	* 3.243. [338 Counting Bits](#CountingBits)
	* 3.244. [342. Power of Four](#PowerofFour)
	* 3.245. [343-整数拆分](#-1)
	* 3.246. [344. Reverse String](#ReverseString)
	* 3.247. [345. Reverse Vowels of a String](#ReverseVowelsofaString)
	* 3.248. [346 Moving Average from Data Stream](#MovingAveragefromDataStream)
	* 3.249. [347. Top K Frequent Elements](#TopKFrequentElements)
	* 3.250. [349. Intersection of Two Arrays](#IntersectionofTwoArrays)
	* 3.251. [350. Intersection of Two Arrays II](#IntersectionofTwoArraysII)
	* 3.252. [355. 设计推特 Design Twitter](#DesignTwitter)
	* 3.253. [359 Logger Rate Limiter](#LoggerRateLimiter)
	* 3.254. [367. Valid Perfect Square](#ValidPerfectSquare)
	* 3.255. [368 Largest Divisible Subset](#LargestDivisibleSubset)
	* 3.256. [373. Find K Pairs with Smallest Sums查找和最小的k对数字](#FindKPairswithSmallestSumsk)
	* 3.257. [374. Guess Number Higher or Lower](#GuessNumberHigherorLower)
	* 3.258. [376-摆动序列](#-1)
	* 3.259. [377. Combination Sum IV](#CombinationSumIV)
	* 3.260. [378-有序矩阵中第K小的元素](#K)
	* 3.261. [380 Insert Delete GetRandom O(1)](#InsertDeleteGetRandomO1)
	* 3.262. [382 Linked List Random Node](#LinkedListRandomNode)
	* 3.263. [383 Ransom Note](#RansomNote)
	* 3.264. [387. First Unique Character in a String](#FirstUniqueCharacterinaString)
	* 3.265. [389. Find the Difference](#FindtheDifference)
	* 3.266. [391. Perfect Rectangle](#PerfectRectangle)
	* 3.267. [392. Is Subsequence](#IsSubsequence)
	* 3.268. [393. UTF-8 Validation](#UTF-8Validation)
	* 3.269. [394 Decode String](#DecodeString)
	* 3.270. [395 Longest Substring with At Least K](#LongestSubstringwithAtLeastK)
	* 3.271. [399. Evaluate Division](#EvaluateDivision)
	* 3.272. [402 Remove K Digits](#RemoveKDigits)
	* 3.273. [404. Sum of Left Leaves](#SumofLeftLeaves)
	* 3.274. [405-Convert a Number to Hexadecimal](#ConvertaNumbertoHexadecimal)
	* 3.275. [406. Queue Reconstruction by Height](#QueueReconstructionbyHeight)
	* 3.276. [408. Valid Word Abbreviation](#ValidWordAbbreviation)
	* 3.277. [409. Longest Palindrome](#LongestPalindrome)
	* 3.278. [410. Split Array Largest Sum](#SplitArrayLargestSum)
	* 3.279. [412. Fizz Buzz](#FizzBuzz)
	* 3.280. [413-等差数列划分](#-1)
	* 3.281. [414. Third Maximum Number](#ThirdMaximumNumber)
	* 3.282. [415-Add Strings](#AddStrings)
	* 3.283. [416. Partition Equal Subset Sum](#PartitionEqualSubsetSum)
	* 3.284. [417. Pacific Atlantic Water Flow](#PacificAtlanticWaterFlow)
	* 3.285. [419. Battleships in a Board](#BattleshipsinaBoard)
	* 3.286. [421 Maximum XOR of Two Numbers in an Array](#MaximumXORofTwoNumbersinanArray)
	* 3.287. [423 Reconstruct Original Digits from English](#ReconstructOriginalDigitsfromEnglish)
	* 3.288. [424. 替换后的最长重复字符 Longest Repeating Character Replacem](#LongestRepeatingCharacterReplacem)
	* 3.289. [429. N-ary Tree Level Order Traversal](#N-aryTreeLevelOrderTraversal)
	* 3.290. [430 Flatten a Multilevel Doubly Linked List](#FlattenaMultilevelDoublyLinkedList)
	* 3.291. [432. All O`one Data Structure](#AllOoneDataStructure)
	* 3.292. [435-Non-overlapping Intervals](#Non-overlappingIntervals)
	* 3.293. [436 Find Right Interval](#FindRightInterval)
	* 3.294. [437 Path Sum III](#PathSumIII)
	* 3.295. [438. Find All Anagrams in a String](#FindAllAnagramsinaString)
	* 3.296. [441 Arranging Coins](#ArrangingCoins)
	* 3.297. [442 Find All Duplicates in an Array](#FindAllDuplicatesinanArray)
	* 3.298. [443. String Compression](#StringCompression)
	* 3.299. [445-Add Two Numbers II](#AddTwoNumbersII)
	* 3.300. [447. Number of Boomerangs](#NumberofBoomerangs)
	* 3.301. [448. Find All Numbers Disappeared in an Array](#FindAllNumbersDisappearedinanArray)
	* 3.302. [449. Serialize and Deserialize BST](#SerializeandDeserializeBST)
	* 3.303. [450. Delete Node in a BST](#DeleteNodeinaBST)
	* 3.304. [451 Sort Characters By Frequency](#SortCharactersByFrequency)
	* 3.305. [454 4Sum II](#SumII)
	* 3.306. [452. Minimum Number of Arrows to Burst Balloons](#MinimumNumberofArrowstoBurstBalloons)
	* 3.307. [455-Assign Cookies](#AssignCookies)
	* 3.308. [456 132 Pattern](#Pattern)
	* 3.309. [458 Poor Pigs](#PoorPigs)
	* 3.310. [459 Repeated Substring Pattern](#RepeatedSubstringPattern)
	* 3.311. [460. LFU Cache / O(1)](#LFUCacheO1)
	* 3.312. [461 Hamming Distance](#HammingDistance)
	* 3.313. [463 Island Perimeter](#IslandPerimeter)
	* 3.314. [464. Can I Win](#CanIWin)
	* 3.315. [466. 统计重复个数 Count The Repetitions](#CountTheRepetitions)
	* 3.316. [468 Validate IP Address](#ValidateIPAddress)
	* 3.317. [470. Implement Rand10() Using Rand7()](#ImplementRand10UsingRand7)
	* 3.318. [475. Heaters](#Heaters)
	* 3.319. [476. Number Complement](#NumberComplement)
	* 3.320. [477. Total Hamming Distance](#TotalHammingDistance)
	* 3.321. [478 Generate Random Point in a Circle](#GenerateRandomPointinaCircle)
	* 3.322. [480. Sliding Window Median](#SlidingWindowMedian)
	* 3.323. [484 Find Permutation](#FindPermutation)
	* 3.324. [485. Max Consecutive Ones](#MaxConsecutiveOnes)
	* 3.325. [486. Predict the Winner](#PredicttheWinner)
	* 3.326. [490 The Maze](#TheMaze)
	* 3.327. [494. Target Sum](#TargetSum)
	* 3.328. [495 Teemo Attacking](#TeemoAttacking)
	* 3.329. [496. 下一个更大元素 I (Next Greater Element I)](#INextGreaterElementI)
	* 3.330. [497 Random Point in Non-overlapping](#RandomPointinNon-overlapping)
	* 3.331. [500. Keyboard Row](#KeyboardRow)
	* 3.332. [503-Next Greater Element II](#NextGreaterElementII)
	* 3.333. [504-Base 7](#Base7)
	* 3.334. [509. Fibonacci Number](#FibonacciNumber)
	* 3.335. [516. Longest Palindromic Subsequence](#LongestPalindromicSubsequence)
	* 3.336. [518 Coin Change 2](#CoinChange2)
	* 3.337. [520. Detect Capital](#DetectCapital)
	* 3.338. [525. Contiguous Array](#ContiguousArray)
	* 3.339. [526 Beautiful Arrangement](#BeautifulArrangement)
	* 3.340. [528 Random Pick with Weight](#RandomPickwithWeight)
	* 3.341. [530. Minimum Absolute Difference in BST](#MinimumAbsoluteDifferenceinBST)
	* 3.342. [532 K-diff Pairs in an Array](#K-diffPairsinanArray)
	* 3.343. [535. Encode and Decode TinyURL](#EncodeandDecodeTinyURL)
	* 3.344. [537 Complex Number Multiplicatin](#ComplexNumberMultiplicatin)
	* 3.345. [538 Convert BST to Greater Tree](#ConvertBSTtoGreaterTree)
	* 3.346. [540. Single Element in a Sorted Array 540-有序数组中的单一元素](#SingleElementinaSortedArray540-)
	* 3.347. [542. 01 矩阵 01 Matrix](#Matrix)
	* 3.348. [543 Diameter of Binary Tree](#DiameterofBinaryTree)
	* 3.349. [546 Remove Boxes](#RemoveBoxes)
	* 3.350. [547-朋友圈](#-1)
	* 3.351. [554 Brick Wall](#BrickWall)
	* 3.352. [556 Next Greater Element III](#NextGreaterElementIII)
	* 3.353. [560. Subarray Sum Equals K 和为K的子数组](#SubarraySumEqualsKK)
	* 3.354. [563 Binary Tree Tilt](#BinaryTreeTilt)
	* 3.355. [567. Permutation in String 567-字符串的排列](#PermutationinString567-)
	* 3.356. [572-另一个树的子树](#-1)
	* 3.357. [575 Distribute Candies](#DistributeCandies)
	* 3.358. [576. Out of Boundary Paths](#OutofBoundaryPaths)
	* 3.359. [581 Shortest Unsorted Continuous Suba](#ShortestUnsortedContinuousSuba)
	* 3.360. [589 N-ary Tree Preorder Traversal](#N-aryTreePreorderTraversal)
	* 3.361. [593 Valid Square](#ValidSquare)
	* 3.362. [594 Longest Harmonious Subsequence](#LongestHarmoniousSubsequence)
	* 3.363. [605 Can Place Flowers](#CanPlaceFlowers)
	* 3.364. [621. Task Scheduler](#TaskScheduler)
	* 3.365. [622 Design Circular Queue](#DesignCircularQueue)
	* 3.366. [623 Add One Row to Tree](#AddOneRowtoTree)
	* 3.367. [633-Sum of Square Numbers](#SumofSquareNumbers)
	* 3.368. [636. Exclusive Time of Functions](#ExclusiveTimeofFunctions)
	* 3.369. [637 Average of Levels in Binary Tree](#AverageofLevelsinBinaryTree)
	* 3.370. [639. Decode Ways II](#DecodeWaysII)
	* 3.371. [643. Maximum Average Subarray I](#MaximumAverageSubarrayI)
	* 3.372. [645-错误的集合](#-1)
	* 3.373. [646-最长数对链](#-1)
	* 3.374. [647 Palindromic Substrings](#PalindromicSubstrings)
	* 3.375. [650-只有两个键的键盘](#-1)
	* 3.376. [652. Find Duplicate Subtrees](#FindDuplicateSubtrees)
	* 3.377. [653. Two Sum IV](#TwoSumIV)
	* 3.378. [662. Maximum Width of Binary Tree](#MaximumWidthofBinaryTree)
	* 3.379. [667 Beautiful Arrangement II](#BeautifulArrangementII)
	* 3.380. [668. Kth Smallest Number in Multiplication Table](#KthSmallestNumberinMultiplicationTable)
	* 3.381. [669 Trim a Binary Search Tree](#TrimaBinarySearchTree)
	* 3.382. [673 Number of Longest Increasing Subse](#NumberofLongestIncreasingSubse)
	* 3.383. [678 Valid Parenthesis String](#ValidParenthesisString)
	* 3.384. [680-Valid Palindrome II](#ValidPalindromeII)
	* 3.385. [683. K Empty Slots](#KEmptySlots)
	* 3.386. [684. Redundant Connection 684-冗余连接](#RedundantConnection684-)
	* 3.387. [685. Redundant Connection II](#RedundantConnectionII)
	* 3.388. [687. Longest Univalue Path](#LongestUnivaluePath)
	* 3.389. [688. Knight Probability in Chessboard](#KnightProbabilityinChessboard)
	* 3.390. [690. Employee Importance](#EmployeeImportance)
	* 3.391. [692. Top K Frequent Words](#TopKFrequentWords)
	* 3.392. [695-岛屿的最大面积](#-1)
	* 3.393. [696 Count Binary Substrings](#CountBinarySubstrings)
	* 3.394. [699. Falling Squares](#FallingSquares)
	* 3.395. [700 Search in a Binary Search Tree](#SearchinaBinarySearchTree)
	* 3.396. [701 Insert into a Binary Search Tree](#InsertintoaBinarySearchTree)
	* 3.397. [703.Kth Largest Element in a Stream数据流中的第K大元素](#KthLargestElementinaStreamK)
	* 3.398. [704.Binary Search二分查找](#BinarySearch)
	* 3.399. [705 Design HashSet](#DesignHashSet)
	* 3.400. [706. Design HashMap设计哈希映射](#DesignHashMap)
	* 3.401. [707. Design Linked List](#DesignLinkedList)
	* 3.402. [712. Minimum ASCII Delete Sum for Two Strings](#MinimumASCIIDeleteSumforTwoStrings)
	* 3.403. [713 Subarray Product Less Than K](#SubarrayProductLessThanK)
	* 3.404. [714-买卖股票的最佳时机含手续费](#-1)
	* 3.405. [715. Range Module](#RangeModule)
	* 3.406. [719. Find K-th Smallest Pair Distance](#FindK-thSmallestPairDistance)
	* 3.407. [720. Longest Word in Dictionary](#LongestWordinDictionary)
	* 3.408. [724. Find Pivot Index](#FindPivotIndex)
	* 3.409. [725. Split Linked List in Parts](#SplitLinkedListinParts)
	* 3.410. [726. Number of Atoms](#NumberofAtoms)
	* 3.411. [730. Count Different Palindromic Subsequences](#CountDifferentPalindromicSubsequences)
	* 3.412. [732. My Calendar III](#MyCalendarIII)
	* 3.413. [733. 图像渲染 Flood Fill](#FloodFill)
	* 3.414. [735 Asteroid Collision](#AsteroidCollision)
	* 3.415. [737. Sentence Similarity II](#SentenceSimilarityII)
	* 3.416. [739-Daily Temperatures](#DailyTemperatures)
	* 3.417. [740. Delete and Earn](#DeleteandEarn)
	* 3.418. [741. Cherry Pickup](#CherryPickup)
	* 3.419. [743. Network Delay Time](#NetworkDelayTime)
	* 3.420. [745. Prefix and Suffix Search](#PrefixandSuffixSearch)
	* 3.421. [746. Min Cost Climbing Stairs](#MinCostClimbingStairs)
	* 3.422. [748. Shortest Completing Word](#ShortestCompletingWord)
	* 3.423. [752. Open the Lock](#OpentheLock)
	* 3.424. [763 Partition Labels](#PartitionLabels)
	* 3.425. [765. 情侣牵手 Couples Holding Hands](#CouplesHoldingHands)
	* 3.426. [769. Max Chunks To Make Sorted](#MaxChunksToMakeSorted)
	* 3.427. [771 Jewels and Stones](#JewelsandStones)
	* 3.428. [773. Sliding Puzzle](#SlidingPuzzle)
	* 3.429. [775. Global and Local Inversions](#GlobalandLocalInversions)
	* 3.430. [778. Swim in Rising Water](#SwiminRisingWater)
	* 3.431. [784. Letter Case Permutation](#LetterCasePermutation)
	* 3.432. [785-判断二分图](#-1)
	* 3.433. [786. K-th Smallest Prime Fraction](#K-thSmallestPrimeFraction)
	* 3.434. [787. Cheapest Flights Within K Stops](#CheapestFlightsWithinKStops)
	* 3.435. [790. Domino and Tromino Tiling](#DominoandTrominoTiling)
	* 3.436. [792. Number of Matching Subsequences](#NumberofMatchingSubsequences)
	* 3.437. [797 All Paths From Source to Target](#AllPathsFromSourcetoTarget)
	* 3.438. [799 Champagne Tower](#ChampagneTower)
	* 3.439. [801. Minimum Swaps To Make Sequences Increasing](#MinimumSwapsToMakeSequencesIncreasing)
	* 3.440. [803. Bricks Falling When Hit](#BricksFallingWhenHit)
	* 3.441. [804 Unique Morse Code Words](#UniqueMorseCodeWords)
	* 3.442. [813. Largest Sum of Averages](#LargestSumofAverages)
	* 3.443. [815. Bus Routes](#BusRoutes)
	* 3.444. [817. Linked List Components](#LinkedListComponents)
	* 3.445. [818. Race Car (上)](#RaceCar)
	* 3.446. [821 Shortest Distance to a Character](#ShortestDistancetoaCharacter)
	* 3.447. [823. Binary Trees With Factors](#BinaryTreesWithFactors)
	* 3.448. [824 Goat Latin](#GoatLatin)
	* 3.449. [827. Making A Large Island](#MakingALargeIsland)
	* 3.450. [832 Flipping an Image](#FlippinganImage)
	* 3.451. [835 Image Overlap](#ImageOverlap)
	* 3.452. [837. 新 21 点 New 21 Game](#New21Game)
	* 3.453. [841 Keys and Rooms](#KeysandRooms)
	* 3.454. [842. Split Array into Fibonacci Sequence](#SplitArrayintoFibonacciSequence)
	* 3.455. [844 Backspace String Compare](#BackspaceStringCompare)
	* 3.456. [845 Longest Mountain in Array](#LongestMountaininArray)
	* 3.457. [847 Shortest Path Visiting All Nodes](#ShortestPathVisitingAllNodes)
	* 3.458. [849 Maximize Distance to Closest Person](#MaximizeDistancetoClosestPerson)
	* 3.459. [856. Score of Parentheses](#ScoreofParentheses)
	* 3.460. [858 Mirror Reflection](#MirrorReflection)
	* 3.461. [859 Buddy Strings](#BuddyStrings)
	* 3.462. [863. All Nodes Distance K in Binary Tree](#AllNodesDistanceKinBinaryTree)
	* 3.463. [864. Shortest Path to Get All Keys](#ShortestPathtoGetAllKeys)
	* 3.464. [869 Reordered Power of 2](#ReorderedPowerof2)
	* 3.465. [865. Smallest Subtree with all the Deepest Nodes](#SmallestSubtreewithalltheDeepestNodes)
	* 3.466. [871. Minimum Number of Refueling Stops](#MinimumNumberofRefuelingStops)
	* 3.467. [873. Length of Longest Fibonacci Subsequence](#LengthofLongestFibonacciSubsequence)
	* 3.468. [875.Koko Eating Bananas科科吃香蕉](#KokoEatingBananas)
	* 3.469. [876.Middle of the Linked List 链表的中间结点](#MiddleoftheLinkedList)
	* 3.470. [877 Stone Game](#StoneGame)
	* 3.471. [879. Profitable Schemes](#ProfitableSchemes)
	* 3.472. [880 Decoded String at Index](#DecodedStringatIndex)
	* 3.473. [881 Boats to Save People](#BoatstoSavePeople)
	* 3.474. [882. Reachable Nodes In Subdivided Graph](#ReachableNodesInSubdividedGraph)
	* 3.475. [886. Possible Bipartition](#PossibleBipartition)
	* 3.476. [887. Super Egg Drop](#SuperEggDrop)
	* 3.477. [889. Construct Binary Tree from Preorder and Postorder](#ConstructBinaryTreefromPreorderandPostorder)
	* 3.478. [891. Sum of Subsequence Widths](#SumofSubsequenceWidths)
	* 3.479. [894. All Possible Full Binary Trees](#AllPossibleFullBinaryTrees)
	* 3.480. [895. Maximum Frequency Stack](#MaximumFrequencyStack)
	* 3.481. [898. Bitwise ORs of Subarrays](#BitwiseORsofSubarrays)
	* 3.482. [901. Online Stock Span](#OnlineStockSpan)
	* 3.483. [902 Numbers At Most N Given Digit Set](#NumbersAtMostNGivenDigitSet)
	* 3.484. [904-水果成篮](#-1)
	* 3.485. [905 Sort Array By Parity](#SortArrayByParity)
	* 3.486. [906 Super Palindromes](#SuperPalindromes)
	* 3.487. [909. Snakes and Ladders](#SnakesandLadders)
	* 3.488. [910 Smallest Range II](#SmallestRangeII)
	* 3.489. [916 Word Subsetse](#WordSubsetse)
	* 3.490. [918 Maximum Sum Circular Sub](#MaximumSumCircularSub)
	* 3.491. [923. 3Sum With Multiplicity](#SumWithMultiplicity)
	* 3.492. [926. Flip String to Monotone Increasing](#FlipStringtoMonotoneIncreasing)
	* 3.493. [930-和相同的二元子数组(滑动窗口+前缀和)](#-1)
	* 3.494. [933 Number of Recent Calls](#NumberofRecentCalls)
	* 3.495. [934. Shortest Bridge](#ShortestBridge)
	* 3.496. [936 Stamping The Sequence](#StampingTheSequence)
	* 3.497. [938 Range Sum of BST](#RangeSumofBST)
	* 3.498. [941 Valid Mountain Array](#ValidMountainArray)
	* 3.499. [943. Find the Shortest Superstring](#FindtheShortestSuperstring)
	* 3.500. [946-Python-栈的压入、弹出序列](#Python-)
	* 3.501. [946 Validate Stack Sequences](#ValidateStackSequences)
	* 3.502. [947. 移除最多的同行或同列石头 Most Stones Removed with Same](#MostStonesRemovedwithSame)
	* 3.503. [948 Bag of Tokens](#BagofTokens)
	* 3.504. [949 Largest Time for Given Digits](#LargestTimeforGivenDigits)
	* 3.505. [952 Largest Component Size by Commo](#LargestComponentSizebyCommo)
	* 3.506. [953 Verifying an Alien Dictionary](#VerifyinganAlienDictionary)
	* 3.507. [954 Array of Doubled Pairs](#ArrayofDoubledPairs)
	* 3.508. [959. 由斜杠划分区域 Regions Cut By Slashes](#RegionsCutBySlashes)
	* 3.509. [964. Least Operators to Express Number](#LeastOperatorstoExpressNumber)
	* 3.510. [966 Vowel Spellchecker](#VowelSpellchecker)
	* 3.511. [967. Numbers With Same Consecutive Differences](#NumbersWithSameConsecutiveDifferences)
	* 3.512. [968 Binary Tree Cameras](#BinaryTreeCameras)
	* 3.513. [969 Pancake Sorting](#PancakeSorting)
	* 3.514. [971 Flip Binary Tree To Match Preorder](#FlipBinaryTreeToMatchPreorder)
	* 3.515. [973 K Closest Points to Origin](#KClosestPointstoOrigin)
	* 3.516. [974. 和可被 K 整除的子数组 Subarray Sums Divisible by K](#KSubarraySumsDivisiblebyK)
	* 3.517. [975. Odd Even Jump](#OddEvenJump)
	* 3.518. [976 Middle of the Linked List](#MiddleoftheLinkedList-1)
	* 3.519. [977 Squares of a Sorted Array](#SquaresofaSortedArray)
	* 3.520. [978. 最长湍流子数组 Longest Turbulent Subarray](#LongestTurbulentSubarray)
	* 3.521. [980. Unique Paths III](#UniquePathsIII)
	* 3.522. [983 Minimum Cost For Tickets](#MinimumCostForTickets)
	* 3.523. [986 Interval List Intersections](#IntervalListIntersections)
	* 3.524. [987 Vertical Order Traversal of a Binary](#VerticalOrderTraversalofaBinary)
	* 3.525. [990. 等式方程的可满足性 Satisfiability of Equality Equations](#SatisfiabilityofEqualityEquations)
	* 3.526. [992-K 个不同整数的子数组](#K-1)
	* 3.527. [993. 二叉树的堂兄弟节点](#-1)
	* 3.528. [994-腐烂的橘子](#-1)
	* 3.529. [993, 994, 995, 996](#-1)
	* 3.530. [997 Find the Town Judge](#FindtheTownJudge)
	* 3.531. [1000. Minimum Cost to Merge Stones](#MinimumCosttoMergeStones)
	* 3.532. [1001 Grid Illumination](#GridIllumination)
	* 3.533. [1004-最大连续1的个数 III](#III-1)
	* 3.534. [1007 Minimum Domino Rotations For Eq](#MinimumDominoRotationsForEq)
	* 3.535. [1008 Construct Binary Search Tree from](#ConstructBinarySearchTreefrom)
	* 3.536. [1009 Complement of Base 10 Integer](#ComplementofBase10Integer)
	* 3.537. [1010 Pairs of Songs With Total Durations](#PairsofSongsWithTotalDurations)
	* 3.538. [1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ](#PartitionArrayIntoThreePartsWithEqu)
	* 3.539. [1015 Smallest Integer Divisible by K](#SmallestIntegerDivisiblebyK)
	* 3.540. [1019. Next Greater Node In Linked List](#NextGreaterNodeInLinkedList)
	* 3.541. [1022 Sum of Root To Leaf Binary Numbers](#SumofRootToLeafBinaryNumbers)
	* 3.542. [1025,1026,1027,1028](#-1)
	* 3.543. [1024. Video Stitching](#VideoStitching)
	* 3.544. [1026 Maximum Difference Between Nod](#MaximumDifferenceBetweenNod)
	* 3.545. [1029 Two City Scheduling](#TwoCityScheduling)
	* 3.546. [1032 Stream of Characters](#StreamofCharacters)
	* 3.547. [1035 Uncrossed Lines](#UncrossedLines)
	* 3.548. [1041 Robot Bounded In Circle](#RobotBoundedInCircle)
	* 3.549. [1043. Partition Array for Maximum Sum](#PartitionArrayforMaximumSum)
	* 3.550. [1044 Longest Duplicate Substring](#LongestDuplicateSubstring)
	* 3.551. [1046 Last Stone Weight](#LastStoneWeight)
	* 3.552. [1048 Longest String Chain](#LongestStringChain)
	* 3.553. [1055.Shortest Way to Form String 形成字符串的最短路径](#ShortestWaytoFormString)
	* 3.554. [1091-二进制矩阵中的最短路径](#-1)
	* 3.555. [1094 Car Pooling](#CarPooling)
	* 3.556. [1095. Find in Mountain Array](#FindinMountainArray)
	* 3.557. [1105. Filling Bookcase Shelves](#FillingBookcaseShelves)
	* 3.558. [1106. Parsing A Boolean Expression](#ParsingABooleanExpression)
	* 3.559. [1110. Delete Nodes And Return Forest](#DeleteNodesAndReturnForest)
	* 3.560. [1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses](#MaximumNestingDepthofTwoValidParentheses)
	* 3.561. [1114 - 1115 - 1116 - 多线程 threading](#threading)
	* 3.562. [1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖](#LowestCommonAncestorofDeepestLeaves)
	* 3.563. [1124. Longest Well-Performing Interval](#LongestWell-PerformingInterval)
	* 3.564. [1125. Smallest Sufficient Team](#SmallestSufficientTeam)
	* 3.565. [1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs](#NumberofEquivalentDominoPairs)
	* 3.566. [1129. Shortest Path with Alternating Colors](#ShortestPathwithAlternatingColors)
	* 3.567. [1137. N-th Tribonacci Number](#N-thTribonacciNumber)
	* 3.568. [1140. Stone Game II](#StoneGameII)
	* 3.569. [1143 Longest Common Subsequence](#LongestCommonSubsequence)
	* 3.570. [1145. Binary Tree Coloring Game](#BinaryTreeColoringGame)
	* 3.571. [1155. Number of Dice Rolls With Target Sum](#NumberofDiceRollsWithTargetSum)
	* 3.572. [1160. 拼写单词 Find Words That Can Be Formed by Characters](#FindWordsThatCanBeFormedbyCharacters)
	* 3.573. [1172. Dinner Plate Stacks](#DinnerPlateStacks)
	* 3.574. [1178. Number of Valid Words for Each Puzzle](#NumberofValidWordsforEachPuzzle)
	* 3.575. [1187. Make Array Strictly Increasing](#MakeArrayStrictlyIncreasing)
	* 3.576. [1191. K-Concatenation Maximum Sum](#K-ConcatenationMaximumSum)
	* 3.577. [1201. Ugly Number III](#UglyNumberIII)
	* 3.578. [1202. Smallest String With Swaps](#SmallestStringWithSwaps)
	* 3.579. [1203. 项目管理 Sort Items by Groups Respecting Dependencies](#SortItemsbyGroupsRespectingDependencies)
	* 3.580. [1206. Design Skiplist](#DesignSkiplist)
	* 3.581. [1209 Remove All Adjacent Duplicates in](#RemoveAllAdjacentDuplicatesin)
	* 3.582. [1217 Minimum Cost to Move Chips](#MinimumCosttoMoveChips)
	* 3.583. [1218. Longest Arithmetic Subsequence of Given Difference](#LongestArithmeticSubsequenceofGivenDifference)
	* 3.584. [1220. Count Vowels Permutation](#CountVowelsPermutation)
	* 3.585. [1223 Dice Roll Simulation](#DiceRollSimulation)
	* 3.586. [1240 Tiling a Rectangle with the Fewest Squares](#TilingaRectanglewiththeFewestSquares)
	* 3.587. [1248-统计「优美子数组」](#-1)
	* 3.588. [1249 Minimum Remove to Make Valid Pare](#MinimumRemovetoMakeValidPare)
	* 3.589. [1252 1253 1254 1255](#-1)
	* 3.590. [1263. Minimum Moves to Move a Box to Their Target](#MinimumMovestoMoveaBoxtoTheirTarget)
	* 3.591. [1277-统计全为1的正方形子矩阵](#-1)
	* 3.592. [1278. Palindrome Partitioning III](#PalindromePartitioningIII)
	* 3.593. [1283 Find the Smallest Divisor Given a](#FindtheSmallestDivisorGivena)
	* 3.594. [1284. Minimum Number of Flips to Convert Binary Matrix](#MinimumNumberofFlipstoConvertBinaryMatrix)
	* 3.595. [1290. 二进制链表转整数 (Convert Binary Number in a Linked List](#ConvertBinaryNumberinaLinkedList)
	* 3.596. [1291 Sequential Digits](#SequentialDigits)
	* 3.597. [1293. Shortest Path in a Grid with Obstacles Elimination](#ShortestPathinaGridwithObstaclesElimination)
	* 3.598. [1296. Divide Array in Sets of K Consecutive Numbers](#DivideArrayinSetsofKConsecutiveNumbers)
	* 3.599. [1301. Number of Paths with Max Score](#NumberofPathswithMaxScore)
	* 3.600. [1302 Deepest Leaves Sum](#DeepestLeavesSum)
	* 3.601. [1305 All Elements in Two Binary Search](#AllElementsinTwoBinarySearch)
	* 3.602. [1306 Jump Game III](#JumpGameIII)
	* 3.603. [1310. XOR Queries of a Subarray](#XORQueriesofaSubarray)
	* 3.604. [1312. Minimum Insertion Steps to Make a String Palindrom](#MinimumInsertionStepstoMakeaStringPalindrom)
	* 3.605. [1320. Minimum Distance to Type a Word Using Two Finger](#MinimumDistancetoTypeaWordUsingTwoFinger)
	* 3.606. [1329 Sort the Matrix Diagonally](#SorttheMatrixDiagonally)
	* 3.607. [1332 Remove Palindromic Subsequences](#RemovePalindromicSubsequences)
	* 3.608. [1334. Find the City With Smallest Number of Neighbors](#FindtheCityWithSmallestNumberofNeighbors)
	* 3.609. [1335. Minimum Difficulty of a Job Schedule](#MinimumDifficultyofaJobSchedule)
	* 3.610. [1337 The K Weakest Rows in a Matrix](#TheKWeakestRowsinaMatrix)
	* 3.611. [1339 Maximum Product of Splitt](#MaximumProductofSplitt)
	* 3.612. [1340. Jump Game V](#JumpGameV)
	* 3.613. [1349. Maximum Students Taking Exam](#MaximumStudentsTakingExam)
	* 3.614. [1353. Maximum Number of Events That Can Be Attended](#MaximumNumberofEventsThatCanBeAttended)
	* 3.615. [1354. Construct Target Array With Multiple Sums](#ConstructTargetArrayWithMultipleSums)
	* 3.616. [1368. Minimum Cost to Make at Least One Valid Path](#MinimumCosttoMakeatLeastOneValidPath)
	* 3.617. [1371. Find the Longest Substring Containing Vowels in Eve](#FindtheLongestSubstringContainingVowelsinEve)
	* 3.618. [1373. Maximum Sum BST in Binary Tree](#MaximumSumBSTinBinaryTree)
	* 3.619. [1377. Frog Position After T Seconds](#FrogPositionAfterTSeconds)
	* 3.620. [1379 Find Corresponding Node of Binary Tree in a Clone](#FindCorrespondingNodeofBinaryTreeinaClone)
	* 3.621. [1382. Balance a Binary Search Tree](#BalanceaBinarySearchTree)
	* 3.622. [1395. Count Number of Teams](#CountNumberofTeams)
	* 3.623. [1396 Design Underground System](#DesignUndergroundSystem)
	* 3.624. [1406. Stone Game III](#StoneGameIII)
	* 3.625. [1409. Queries on a Permutation With Key](#QueriesonaPermutationWithKey)
	* 3.626. [1416. Restore The Array](#RestoreTheArray)
	* 3.627. [1424. Diagonal Traverse II](#DiagonalTraverseII)
	* 3.628. [1425. Constrained Subset Sum](#ConstrainedSubsetSum)
	* 3.629. [1426  Counting Elements](#CountingElements)
	* 3.630. [1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie](#KidsWiththeGreatestNumberofCandie)
	* 3.631. [1437 Check If All 1's Are at Least Length](#CheckIfAll1sAreatLeastLength)
	* 3.632. [1438. Longest Continuous Subarray With Absolute](#LongestContinuousSubarrayWithAbsolute)
	* 3.633. [1441 Build an Array With Stack Operations](#BuildanArrayWithStackOperations)
	* 3.634. [1442. Count Triplets That Can Form Two Arrays of Equal](#CountTripletsThatCanFormTwoArraysofEqual)
	* 3.635. [1443. Minimum Time to Collect All Apples in a Tree](#MinimumTimetoCollectAllApplesinaTree)
	* 3.636. [1444. Number of Ways of Cutting a Pizza](#NumberofWaysofCuttingaPizza)
	* 3.637. [1446 Consecutive Characters](#ConsecutiveCharacters)
	* 3.638. [1448 Count Good Nodes in Binary Tree](#CountGoodNodesinBinaryTree)
	* 3.639. [1449. Form Largest Integer With Digits That Add](#FormLargestIntegerWithDigitsThatAdd)
	* 3.640. [1451 Rearrange Words in a Sentence](#RearrangeWordsinaSentence)
	* 3.641. [1453 Maximum Number of Darts Inside of a Circular Dartb](#MaximumNumberofDartsInsideofaCircularDartb)
	* 3.642. [1457 Pseudo-Palindromic Paths in a Bin](#Pseudo-PalindromicPathsinaBin)
	* 3.643. [1461 Check If a String Contains All Binar](#CheckIfaStringContainsAllBinar)
	* 3.644. [1463 Cherry Pickup II](#CherryPickupII)
	* 3.645. [1473. Paint House III](#PaintHouseIII)
	* 3.646. [1475. Final Prices With a Special Discount in a Sho](#FinalPricesWithaSpecialDiscountinaSho)
	* 3.647. [1483. Kth Ancestor of a Tree Node](#KthAncestorofaTreeNode)
	* 3.648. [1488. Avoid Flood in The City](#AvoidFloodinTheCity)
	* 3.649. [1489. Find Critical and Pseudo-Critical Edges in](#FindCriticalandPseudo-CriticalEdgesin)
	* 3.650. [1492 The kth Factor of n](#ThekthFactorofn)
	* 3.651. [1493. Longest Subarray of 1's After Deleting One](#LongestSubarrayof1sAfterDeletingOne)
	* 3.652. [1499. Max Value of Equation](#MaxValueofEquation)
	* 3.653. [1502 Can Make Arithmetic Progression From Sequence](#CanMakeArithmeticProgressionFromSequence)
	* 3.654. [1503 Last Moment Before All Ants Fall Out of a Plank](#LastMomentBeforeAllAntsFallOutofaPlank)
	* 3.655. [1505. Minimum Possible Integer After at Most K Adjacent](#MinimumPossibleIntegerAfteratMostKAdjacent)
	* 3.656. [1508. Range Sum of Sorted Subarray Sums](#RangeSumofSortedSubarraySums)
	* 3.657. [1510 Stone Game IV](#StoneGameIV)
	* 3.658. [1514 Path with Maximum Probability](#PathwithMaximumProbability)
	* 3.659. [1515 Best Position for a Service Centre](#BestPositionforaServiceCentre)
	* 3.660. [1520. Maximum Number of Non-Overlapping Substrings](#MaximumNumberofNon-OverlappingSubstrings)
	* 3.661. [1530. Number of Good Leaf Nodes Pairs](#NumberofGoodLeafNodesPairs)
	* 3.662. [1531. String Compression II](#StringCompressionII)
	* 3.663. [1534 Count Good Triplets](#CountGoodTriplets)
	* 3.664. [1535 Find the Winner of an Array Game](#FindtheWinnerofanArrayGame)
	* 3.665. [1537. Get the Maximum Score](#GettheMaximumScore)
	* 3.666. [1539. Kth Missing Positive Number](#KthMissingPositiveNumber)
	* 3.667. [1542. Find Longest Awesome Substring](#FindLongestAwesomeSubstring)
	* 3.668. [1546. Maximum Number of Non-Overlapping Subarrays With Sum](#MaximumNumberofNon-OverlappingSubarraysWithSum)
	* 3.669. [1550. Three Consecutive Odds](#ThreeConsecutiveOdds)
	* 3.670. [1551 Minimum Operations to Make Array](#MinimumOperationstoMakeArray)
	* 3.671. [1553. Minimum Number of Days to Eat N Oranges](#MinimumNumberofDaystoEatNOranges)
	* 3.672. [1556. Thousand Separator](#ThousandSeparator)
	* 3.673. [1558. Minimum Numbers of Function Calls to Make Target](#MinimumNumbersofFunctionCallstoMakeTarget)
	* 3.674. [1563. Stone Game V](#StoneGameV)
	* 3.675. [1569. Number of Ways to Reorder Array to Get Sa](#NumberofWaystoReorderArraytoGetSa)
	* 3.676. [1573. Number of Ways to Split a String](#NumberofWaystoSplitaString)
	* 3.677. [1585. Check If String Is Transformable With](#CheckIfStringIsTransformableWith)
	* 3.678. [1593. Split a String Into the Max Number of Unique Substri](#SplitaStringIntotheMaxNumberofUniqueSubstri)
	* 3.679. [1595. Minimum Cost to Connect Two Groups of Points](#MinimumCosttoConnectTwoGroupsofPoints)
	* 3.680. [1621. Number of Sets of K Non-Overlapping Line](#NumberofSetsofKNon-OverlappingLine)
	* 3.681. [1631. Path With Minimum Effort](#PathWithMinimumEffort)
	* 3.682. [1632 Rank Transform of a Matrix](#RankTransformofaMatrix)
	* 3.683. [1640 Check Array Formation Through](#CheckArrayFormationThrough)
	* 3.684. [1641 Count Sorted Vowel Strings](#CountSortedVowelStrings)
	* 3.685. [1642. Furthest Building You Can Reach](#FurthestBuildingYouCanReach)
	* 3.686. [1646 Get Maximum in Generated Array](#GetMaximuminGeneratedArray)
	* 3.687. [1648. Sell Diminishing-Valued Colored Balls](#SellDiminishing-ValuedColoredBalls)
	* 3.688. [1649 Create Sorted Array through Instru](#CreateSortedArraythroughInstru)
	* 3.689. [1655. Distribute Repeating Integers](#DistributeRepeatingIntegers)
	* 3.690. [1657 Determine if Two Strings Are Close](#DetermineifTwoStringsAreClose)
	* 3.691. [1658 Minimum Operations to Reduce X](#MinimumOperationstoReduceX)
	* 3.692. [1659. Maximize Grid Happiness](#MaximizeGridHappiness)
	* 3.693. [1662 Check If Two String Arrays are Equi](#CheckIfTwoStringArraysareEqui)
	* 3.694. [1663 Smallest String With A Given Numer](#SmallestStringWithAGivenNumer)
	* 3.695. [1673 Find the Most Competitive Subseq](#FindtheMostCompetitiveSubseq)
	* 3.696. [1674. Minimum Moves to Make Array Complement](#MinimumMovestoMakeArrayComplement)
	* 3.697. [1675. Minimize Deviation in Array](#MinimizeDeviationinArray)
	* 3.698. [1679 Max Number of K-Sum Pairs】](#MaxNumberofK-SumPairs)
	* 3.699. [1680 Concatenation of Consecutive Bina](#ConcatenationofConsecutiveBina)
	* 3.700. [1681. Minimum Incompatibility](#MinimumIncompatibility)
	* 3.701. [1690. Stone Game VII](#StoneGameVII)
	* 3.702. [1696. Jump Game VI](#JumpGameVI)
	* 3.703. [1704 Determine if String Halves Are Alike](#DetermineifStringHalvesAreAlike)
	* 3.704. [1707. Maximum XOR With an Element From Array](#MaximumXORWithanElementFromArray)
	* 3.705. [1713. Minimum Operations to Make a Subsequence](#MinimumOperationstoMakeaSubsequence)
	* 3.706. [1721 Swapping Nodes in a Linked List](#SwappingNodesinaLinkedList)
	* 3.707. [1727. Largest Submatrix With Rearrangements](#LargestSubmatrixWithRearrangements)
	* 3.708. [1745. Palindrome Partitioning IV](#PalindromePartitioningIV)
	* 3.709. [1760. Minimum Limit of Balls in a Bag](#MinimumLimitofBallsinaBag)
	* 3.710. [1770. Maximum Score from Performing Multiplication](#MaximumScorefromPerformingMultiplication)
	* 3.711. [1771. Maximize Palindrome Length From Subsequences](#MaximizePalindromeLengthFromSubsequences)
	* 3.712. [1775. Equal Sum Arrays With Minimum Number of Operatio](#EqualSumArraysWithMinimumNumberofOperatio)
	* 3.713. [1786. Number of Restricted Paths From First to Last Node](#NumberofRestrictedPathsFromFirsttoLastNode)
	* 3.714. [1792. Maximum Average Pass Ratio](#MaximumAveragePassRatio)
	* 3.715. [1799. Maximize Score After N Operations](#MaximizeScoreAfterNOperations)
	* 3.716. [1815. Maximum Number of Groups Getting Fresh Donuts](#MaximumNumberofGroupsGettingFreshDonuts)
	* 3.717. [1838. Frequency of the Most Frequent Element](#FrequencyoftheMostFrequentElement)
	* 3.718. [1847. Closest Room](#ClosestRoom)
	* 3.719. [1872. Stone Game VIII](#StoneGameVIII)
	* 3.720. [s](#s)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->


##  1. <a name=''></a>经验

[花花酱](https://www.bilibili.com/video/BV14E411R7Wa?spm_id_from=333.999.0.0)

[Leetcode刷题阶段性总结（一些建议与思考）哈哈哈](https://www.bilibili.com/video/BV14K4y1a7Yk?spm_id_from=333.999.0.0)

[LeetCode题库过千，刷题改如何规划？【刷题规划系列】](https://www.bilibili.com/video/BV1Xp4y1a7Z3?spm_id_from=333.999.0.0)

[如何正确刷题？LeetCode刷题误区和刷题方法论分享](https://www.bilibili.com/video/BV1nz4y197U3?spm_id_from=333.999.0.0)

[算法新手如何刷力扣（LeetCode）？【干货分享】](https://www.bilibili.com/video/BV17K411J7yR?spm_id_from=333.999.0.0)

[硅谷资深技术面试官教你拿顶级科技公司 Offer【面试篇】](https://www.bilibili.com/video/BV1fV411y743?spm_id_from=333.999.0.0)

[ACM 金牌大神是如何学算法的？【LeetCode 干货】](https://www.bilibili.com/video/BV1gv411179E?spm_id_from=333.999.0.0)

[硅谷资深技术面试官教你拿顶级科技公司 Offer【准备篇】](https://www.bilibili.com/video/BV1Kf4y197Rk?spm_id_from=333.999.0.0)

[BAT 大厂 Offer 收割机是怎样炼成的？技术面试通关全攻略](https://www.bilibili.com/video/BV1E5411h7Jr?spm_id_from=333.999.0.0)

##  2. <a name='-1'></a>算法

[图灵星球 - 什么是数据结构和算法？二分搜索剖析](https://www.bilibili.com/video/BV1H7411n79u?spm_id_from=333.999.0.0)

[图灵星球 - 时间复杂度和空间复杂度，大O表示法](https://www.bilibili.com/video/BV14j411f7DJ?spm_id_from=333.999.0.0)

[图灵星球 - 排序算法：插入排序，快排，归并排序](https://www.bilibili.com/video/BV1QE41177ST?spm_id_from=333.999.0.0)

[图灵星球 - 链表 Linked List【数据结构和算法入门4】](https://www.bilibili.com/video/BV1rE411g788?spm_id_from=333.999.0.0)

[图灵星球 - 堆栈Stack, 队列Queue【数据结构和算法入门5】](https://www.bilibili.com/video/BV1QE41137tw?spm_id_from=333.999.0.0)

[图灵星球 - 哈希表HashMap【数据结构和算法入门6】](https://www.bilibili.com/video/BV1si4y1b7Rs?spm_id_from=333.999.0.0)

[图灵星球 - 二叉搜索树（排序二叉树），树的遍历（前序、中序、后序）](https://www.bilibili.com/video/BV1qQ4y1M7Z4?spm_id_from=333.999.0.0)

[图灵星球 - 优先队列PriorityQueue，堆Heap](https://www.bilibili.com/video/BV1ti4y1879c?spm_id_from=333.999.0.0)

[图灵星球 - 图Graph, 深度优先遍历(DFS), 广度优先遍历(BFS)](https://www.bilibili.com/video/BV1254y1976m?spm_id_from=333.999.0.0)

[图灵星球 - Array题型：双指针Two Pointers套路](https://www.bilibili.com/video/BV1V54y1Q7bd?spm_id_from=333.999.0.0)

[图灵星球 - 二分查找Binary Search套路和解题模板](https://www.bilibili.com/video/BV1Ng4y1q7E3?spm_id_from=333.999.0.0)

[图灵星球 - Linked List链表题型解题套路和模板](https://www.bilibili.com/video/BV1QD4y1D7av?spm_id_from=333.999.0.0)

[图灵星球 - Stack堆栈解题套路](https://www.bilibili.com/video/BV1Hi4y1x7fX?spm_id_from=333.999.0.0)

[图灵星球 - Heap堆解题套路](https://www.bilibili.com/video/BV1XZ4y1M799?spm_id_from=333.999.0.0)

[图灵星球 - 哈希表HashMap解题套路](https://www.bilibili.com/video/BV1KC4y1h7zV?spm_id_from=333.999.0.0)

[图灵星球 - 树Tree题型广度优先搜索BFS套路](https://www.bilibili.com/video/BV1T5411e7D2?spm_id_from=333.999.0.0)

[图灵星球 - 树Tree深度优先搜索DFS解题套路](https://www.bilibili.com/video/BV1xT4y1E7TD?spm_id_from=333.999.0.0)

[图灵星球 - Graph图BFS广度优先搜索套路](https://www.bilibili.com/video/BV1HA411v753?spm_id_from=333.999.0.0)

[图灵星球 - Graph图Best-First Search题型套路](https://www.bilibili.com/video/BV1NK4y1v75h?spm_id_from=333.999.0.0)

[图灵星球 - Graph图DFS深度优先搜索题型套路](https://www.bilibili.com/video/BV1vv411q769?spm_id_from=333.999.0.0)

[图灵星球 - Search, Dynamic Programming1](https://www.bilibili.com/video/BV1hf4y197w3?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming1D解题套路](https://www.bilibili.com/video/BV1CD4y127CZ?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D解题套路](https://www.bilibili.com/video/BV1sk4y1y7Dv?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D进阶解题套路](https://www.bilibili.com/video/BV12k4y127nP?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D高级解题套路](https://www.bilibili.com/video/BV14z4y1f7hH?spm_id_from=333.999.0.0)

[图灵星球 - Backtracking回溯解题套路](https://www.bilibili.com/video/BV1Ty4y1E7RM?spm_id_from=333.999.0.0)

[哈哈哈 DSU(并查集实现)-Python](https://www.bilibili.com/video/BV19K4y1b7vT?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(广度优先遍历BFS)(1)](https://www.bilibili.com/video/BV1H7411D7Nm?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(深度优先遍历DFS)(2)](https://www.bilibili.com/video/BV1H7411D73V?spm_id_from=333.999.0.0)

[哈哈哈 二分查找(Binary Search)合集](https://www.bilibili.com/video/BV1254y1B7xK?spm_id_from=333.999.0.0)

[哈哈哈 Bubble_sort(用Python实现冒泡排序)(1)](https://www.bilibili.com/video/BV19E411E7df?spm_id_from=333.999.0.0)

[哈哈哈 Selected_sort(用Python实现选择排序)(2)](https://www.bilibili.com/video/BV1AE411t7Pr?spm_id_from=333.999.0.0)

[哈哈哈 Single linked list-Python(链表功能扩展-有条件翻转链表)（2）](https://www.bilibili.com/video/BV1n7411G7rc?spm_id_from=333.999.0.0)

[哈哈哈 Inserted_sort(用Python实现插入排序)(3)](https://www.bilibili.com/video/BV1SE411p7zn?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(深度优先遍历的迭代实现)(3)](https://www.bilibili.com/video/BV1V54y197qo?spm_id_from=333.999.0.0)

[哈哈哈 Shell_sort(用Python实现希尔排序)(4)](https://www.bilibili.com/video/BV1SE411T7t1?spm_id_from=333.999.0.0)

[哈哈哈 Quick_sort(用Python实现快速排序)(5)](https://www.bilibili.com/video/BV1d7411R75g?spm_id_from=333.999.0.0)

[哈哈哈 Merge_sort(用Python实现合并排序)(6)](https://www.bilibili.com/video/BV1gE411c7PR?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV16b411N7o7?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV1hb411P7C2?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV1wb4y1b7df?spm_id_from=333.999.0.0)

[Maximum Subarray DP 花花酱](https://www.bilibili.com/video/BV1yg411A7D4?spm_id_from=333.999.0.0)

[Maximum Product Subarray DP 花花酱](https://www.bilibili.com/video/BV18q4y1z7TC?spm_id_from=333.999.0.0)

[Fast Power for DP 花花酱](https://www.bilibili.com/video/BV1Je411s7NM?spm_id_from=333.999.0.0)

[Best Time to Buy and Sell Stock DP 花花酱](https://www.bilibili.com/video/BV1Tg411P7S9?spm_id_from=333.999.0.0)

[Disjoint-set/Union-find Forest 花花酱](https://www.bilibili.com/video/BV1jW411d7vi?spm_id_from=333.999.0.0)

[Best Time to Buy and Sell Stock with  DP 花花酱](https://www.bilibili.com/video/BV1sq4y1q768?spm_id_from=333.999.0.0)

[二叉树 花花酱](https://www.bilibili.com/video/BV1Gt411e7zm?spm_id_from=333.999.0.0)

[背包问题 花花酱](https://www.bilibili.com/video/BV1ot411m7wv?spm_id_from=333.999.0.0)

[背包问题 2 花花酱](https://www.bilibili.com/video/BV1Dt411U7eM?spm_id_from=333.999.0.0)

[最小生成树 (Minimum Spanning Tree)  花花酱](https://www.bilibili.com/video/BV1A7411Y7mT?spm_id_from=333.999.0.0)

[Binary Search 花花酱](https://www.bilibili.com/video/BV1yW411Z7um?spm_id_from=333.999.0.0)

[Binary Search II 花花酱](https://www.bilibili.com/video/BV1ub411V7gs?spm_id_from=333.999.0.0)

[Fenwick Tree / Binary Indexed Tree 花花酱](https://www.bilibili.com/video/BV1EW411d75F?spm_id_from=333.999.0.0)

[Input Size V.S. Time Complexity 花花酱](https://www.bilibili.com/video/BV1jW411d7a2?spm_id_from=333.999.0.0)

[Time/Space Complexity of Recursive Algorithms 花花酱](https://www.bilibili.com/video/BV1JW411d714?spm_id_from=333.999.0.0)

[Segment Tree 花花酱](https://www.bilibili.com/video/BV1bb411y78M?spm_id_from=333.999.0.0)

[Min Heap 花花酱](https://www.bilibili.com/video/BV1cy4y1q7P1?spm_id_from=333.999.0.0)

[Amortized Analysis 均摊分析 花花酱](https://www.bilibili.com/video/BV1NW411C7v7?spm_id_from=333.999.0.0)

[Recursion unrolling and performance measurement](https://www.bilibili.com/video/BV1Gt411r7MS?spm_id_from=333.999.0.0)


##  3. <a name='-1'></a>题目

###  3.1. <a name='TwoSum'></a>1 Two Sum

[哈哈哈](https://www.bilibili.com/video/BV1rE411Y7UN?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV19b411v7qp?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zf4y1G7W4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rv411k7VY?spm_id_from=333.999.0.0)

暴力求解：

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i] + nums [j] == target:
                    return [i,j]
```

查找表法:

* 哈希表(不需要维护表的顺序性)

* 平衡二叉搜素树

* 时间复杂度:O(n)

* 时间复杂度:O(n)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i,n in enumerate(nums):
            if n in dic:
                return [dic[n],i]
            dic[target - n] = i
```

```scala
object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        val nums_map = scala.collection.mutable.HashMap[Int, Int]()
        var result: Array[Int] = Array(0,0)
        var i = 0
        while(result.sum == 0) {
            val complement = target - nums(i)
            if (nums_map.contains(complement)) {
                result(0) = i
                result(1) = nums_map(complement)
            } else {
                nums_map(nums(i)) = i
            }
            i += 1
        }
        result     
    }
}



// Brute-force method, which takes more than two times of running time than the method above
object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        
        val result = for {i <- 0 until (nums.length - 1);
            j <- (i+1) until nums.length
            if nums(i) + nums(j) == target} yield Array(i, j)
        
        result(0)
        
    }
}

/**
* chosen solution
* time complexity: O(N)
*/


object Solution0 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}

/**
* HashTable
* time complexity: O(N)
*/

object Solution1 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    val ret = collection.mutable.ArrayBuffer[Int]()

    for ((n, idx) <- nums.zipWithIndex; if ret.length < 2) {
      val v2 = target - n
      value2Idx.get(v2) match {
        case Some(v2Idx) if v2Idx != idx =>
          ret ++= Array(idx, v2Idx)
        case _ =>
      }
    }
    ret.toArray
  }
}


/**
* more elegant
*/


object Solution1-2 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}
```

```scala
object leetcode01_two_sum extends App {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val sorted = nums.zipWithIndex.sortWith(_._1 < _._1)
    var left = 0
    var right = sorted.length - 1
    while(left < right) {
      val cal = sorted(left)._1 + sorted(right)._1
      if(cal > target) {
        right = right - 1
      } else if (cal < target) {
        left = left + 1
      } else {
        return Array(sorted(left)._2, sorted(right)._2)
      }
    }
    return Array.emptyIntArray
  }

  twoSum(Array(3,2,4), 6)
}


object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        var map = Map.empty[Int, Int]
        var result = Array.empty[Int]
        (0 until nums.length) foreach { i =>
            val v = nums(i)
            map.get(target - v) match {
                case Some(x)  =>
                    if (x != i){
                    result = Array(x, i)
                    }
                case _ => map += v -> i
            }
        }
        result
    }
}

```

###  3.2. <a name='AddTwoNumbers'></a>2. Add Two Numbers

[花花酱](https://www.bilibili.com/video/BV1EJ411h72z?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1gJ411V7gJ?spm_id_from=333.999.0.0)

[小梦想](https://www.bilibili.com/video/BV1Wb411e77s?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1rZ4y1j7V3?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DA411L7YQ?spm_id_from=333.999.0.0)

* 时间复杂度:O(max(m,n))

* 时间复杂度:O(max(m,n))

特殊情况：

两个链表的长度不同。

进位

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = pointer = ListNode(0) # 易错点：定义一个dummy和一个pointer，都指向ListNode(0)
        carry = 0 # 易错点：carry需要先赋值
        while l1 or l2 or carry: # 易错点：carry要存在
            # 易错点：l1,l2不一定存在，所以不能写成：sumNode = l1 + l2
            # 易错点：调用listnode要有.val
            sumNode = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            tail = sumNode % 10
            carry = sumNode // 10
            pointer.next = ListNode(tail)
            pointer = pointer.next
            # # l1,l2不一定存在，所以不能写成：l1 = l1.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */

 /**
 * my first commitment
 * time complexity O(max(l1.length, l2.length))
 */
object Solution1 {
    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
      val dummyHead = ListNode()
      var current = dummyHead
      var (p1, p2) = (l1, l2)
      var carry = 0
      while(p1 != null && p2 != null) {
        val sum = carry + p1.x + p2.x
        carry = sum / 10
        
        current.next = ListNode(sum % 10)
        current = current.next
        p1 = p1.next
        p2 = p2.next
      }
      
      while(p1 != null) {
        val sum = carry + p1.x
        carry = sum / 10
        current.next = ListNode(sum % 10)  
        current = current.next
        p1 = p1.next
      }
      while(p2 != null) {
        val sum = carry + p2.x
        carry = sum / 10
        current.next = ListNode(sum % 10)
        current = current.next
        p2 = p2.next
      }
      if (carry > 0)
        current.next = ListNode(carry)
      dummyHead.next
    }
}

object Solution {
    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
      var cur1 = l1
      var cur2 = l2
      val dummy = ListNode(0)
      var prev=dummy
      var carry = 0
      while (cur1!=null ||  cur2!=null || carry !=0) {
        val (s1,next1) = cur1 match {
          case null => (0,null)
          case _=> (cur1.x, cur1.next)
        }
        val (s2,next2) = cur2 match {
          case null => (0,null)
          case _=> (cur2.x,cur2.next)
        }
        val s = s1+s2+carry
        val node = ListNode(s % 10)
        prev.next = node
        prev=node
        carry=s/10
        cur1 = next1
        cur2=next2
      }
      dummy.next
    }
  }
```

###  3.3. <a name='LongestSubstringWithoutRepeatingCharacters'></a>3. 数组中重复的数字 Longest Substring Without Repeating Characters

[哈哈哈](https://www.bilibili.com/video/BV1h54y1B7No?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1CJ411G7Nn?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1va4y1J7Gx?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ob411n7mv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K411M7d2?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DK4y1b7xp?spm_id_from=333.999.0.0)

方法一：暴力解法

* 时间复杂度: 2个指针遍历字符串O(n2) + hashset判断是否重复O(n) = O(n3)

* 时间复杂度: O(m), m 为所有可能出现的情况

方法二：涉及 sub 的问题，可以使用 “滑动窗口”

特殊情况：

* 字符串为空
  
* 字符串均为重复字符串

* 时间复杂度: O(n) + hashset判断是否重复O(n) = O(n3)

* 时间复杂度: O(m), m 为所有可能出现的情况

```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dic = {}
        start = 0
        res = 0
        for i, char in enumerate(s):
            if char in dic and start <= dic[char]:
                # 易错点: and start <= dic[char]: 
                # 含义为"tmmzuxt",
                # start在m，当有新的t进来时，上一个t在start的前面，所以，此时的start不需要修改
                start = dic[char] + 1 # 易错点: 这里的dic[char]还是前一个,且 +1
            else:
                res = max(res,i-start+1) # 易错点: +1
            dic[char] = i # 易错点: dic[char]滞后更新
        return res
```

```scala
/**
* chosen solution
* two pointer to control sliding window
*   1. two pointer: left and right to control substring window
*   2. counter and hashmap to record whether current window is valid or not
* time  complexity: O(N), worst: O(2N) -> each char was visited twice
*/

object Solution0 {
  def lengthOfLongestSubstring(s: String): Int = {
    val sMap = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0)).toMap
    var left = 0
    var right = 0
    var counter = 0
    var length = 0
    while (right < s.length) {
      val rightChar = s(right)
      sMap.get(rightChar) match {
        case Some(v) if v >= 1 =>
          sMap.update(rightChar, v + 1)
          counter += 1
        case Some(v) =>
          sMap.update(rightChar, v + 1)
      }
      right += 1
      while (counter > 0) {
        val leftChar = s(left)
        sMap.get(leftChar) match {
          case Some(v) if v > 1 =>
            sMap.update(leftChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(leftChar, v - 1)
        }

        left += 1

      }
      length = length max (right - left)
    }
    length
  }
}


/**
* my first commit
* sliding windows
*  time  complexity: O(N), worst: O(2N) -> each char was visited twice
*/
object Solution1 {
    def lengthOfLongestSubstring(s: String): Int = {
        var right = 0
        var left = 0
        var current = ""
        var ret = ""
        
        while(right < s.length) {
            val char = s(right)
            if (current.contains(char)){
                current = current.drop(1)
                left += 1
                 
            }else {
                right += 1
                current += char
            }     
            if(current.length > ret.length) ret = current
        }
        ret.length
    }
}


/**
* sliding windows, slower than solution1
*   memo
*     1. using hashmap to record whether the current right char is duplicated or not
*/
object Solution1-2 {
    def lengthOfLongestSubstring(s: String): Int = {
        val map = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0))
        var left = 0
        var right = 0
        var length = 0
        
        while(right < s.length){
            val rightChar = s(right)
        
            map.update(rightChar, map(rightChar) + 1)
            right += 1
            
            /* iterate until meet condition */
            while(map(rightChar) > 1){
                val leftChar = s(left)
                
                map.get(leftChar) match {
                    case Some(v) if v > 0 =>  map.update(leftChar,  v - 1)
                    case _ =>
                }
                
                left += 1
            }

            length = length max (right - left)  // update minimum
               
        }
        length
    }
}

/**
* using substring problem template
*   1. two pointer: left and right to control substring window
*   2. counter and hashmap to record whether current window is valid or not
*/
object Solution1-3 {
  def lengthOfLongestSubstring(s: String): Int = {
    val sMap = scala.collection.mutable.Map[Char, Int]() ++ s.distinct.map(c => (c, 0)).toMap
    var left = 0
    var right = 0
    var counter = 0
    var length = 0
    while (right < s.length) {
      val rightChar = s(right)
      sMap.get(rightChar) match {
        case Some(v) if v >= 1 =>
          sMap.update(rightChar, v + 1)
          counter += 1
        case Some(v) =>
          sMap.update(rightChar, v + 1)
      }
      right += 1
      while (counter > 0) {
        val leftChar = s(left)
        sMap.get(leftChar) match {
          case Some(v) if v > 1 =>
            sMap.update(leftChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(leftChar, v - 1)
        }

        left += 1

      }
      length = length max (right - left)
    }
    length
  }
}

object Solution {
    //s.zipWithIndex.foreach(println) // =>tuple
    //   def foldLeft[B](z: B)(op: (B, A) => B): B = {
    // 解释 z: 初始值,
    // op (B,A) => B前一个结果，A本次输入,返回作为下一个输入
    def lengthOfLongestSubstring(s: String): Int = {
      s.zipWithIndex.foldLeft((0, -1, Map[Char, Int]())) {
        case ((len, start_pos, map), (char, i)) => {
          // 初始值len=0,start_pos=-1,map为空; case A,B; 前者为累加值，后者为index
          // 如果char不存在,last_pos=-1,更新map中的idx,len=i-start_pos
          // 如果last_pos已存在,例如abca,第一个a为0,第二个a为3,则len=3-0,跟新start_pos
          val last_pos = map.getOrElse(char, -1)
          if (last_pos >= start_pos) (len.max(i - last_pos), last_pos, map + (char -> i))
          else (len.max(i - start_pos), start_pos, map + (char -> i))
        }
      }._1
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.lengthOfLongestSubstring("abcabcbb")==3)
    }
    val name = "003 Longest Non repeat str"
  }
```

###  3.4. <a name='MedianofTwoSortedArrays'></a>4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays

[官方](https://www.bilibili.com/video/BV1Xv411z76J?spm_id_from=333.999.0.0)

###  3.5. <a name='LongestPalindromicSubstring-'></a>5. Longest Palindromic Substring -最长回文子串

[花花酱](https://www.bilibili.com/video/BV18J411j7Pb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1ra4y1Y7Gx?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7P6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1so4y1o765?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1L54y1D7pa?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n3),在两个for循环里面，还做了一次遍历

* 时间复杂度:O(1)

中心扩散法：

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.4sfvjkqc4qo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ur1lzo89kk0.png)

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        strLen = len(s)
        if strLen == 1:
            return s

        mid = 0
        strStart = strEnd = 0
        maxLen = 1



        while mid < strLen:

            # 优化：
            if strLen - mid <= maxLen/2:
                break

            start = end = mid
            
            # 第一步：
            while end + 1 < strLen and s[end] == s[end+1]: # 注意边界
                end += 1

            # 第二步：
            while  end + 1 < strLen and start > 0 and s[start-1] == s[end+1]: # 注意边界
                start -= 1
                end += 1
            
            # 第三步：
            if end - start + 1 > maxLen:
                maxLen = end - start + 1
                strStart = start
                strEnd = end

            mid += 1

        return s[strStart:strEnd+1]
```

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s


        def getLen(l,r) -> int:
            while l>=0 and r<lenStr and s[l] == s[r]: # 注意：边界
                l -= 1
                r += 1
            return r - l - 1 # 注意：是 “-1”

        start = 0  
        end = 1 # 注意：在第一次的时候，end = 1
        maxmaxLen = maxLen = 1

        for mid in range(lenStr):
            maxLen = max(getLen(mid,mid),getLen(mid,mid+1))
            
            if maxLen > maxmaxLen:
                maxmaxLen = maxLen
                start = mid - (maxLen-1) // 2 #易错点：-1，最好背一背
                end = start + maxLen
        return s[start:end]
```

动态规划法：

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.67y5euem0vo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.90ngy2t8j3k.png)

* 时间复杂度:O(n2)

* 时间复杂度:O(n2)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)
        maxlen = maxmaxlen = 1
        start = 0

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s

        dp = [[False for _ in range(lenStr)] for _ in range(lenStr)]
        for i in range(lenStr):
            dp[1][1] = True 
            # dp[1][1]是正确写法，dp[1,1]是错误写法

        for j in range(1,lenStr): # 把三角形画出来，先j，再i，
            for i in range(j):
                if s[i] == s[j]:
                    if j-i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i+1][j-1]
                if dp[i][j]:
                    maxlen = j-i+1
                    if maxlen > maxmaxlen:
                        maxmaxlen = maxlen
                        start = i
        return s[start:start+maxmaxlen]
```

Manacher算法：

不要求

```scala
/**
* chosen solution
* expand around center
* time complexity: O(N * 2 * N) = O(N^2)
*        expandLengths: O(N)
* space complexity: O(1)
*/

object Solution0 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty) return ""
        
        // 0 1 2 3 4 5 6 7
        // r a c e c a r
        // r a c e e c a r
        // b b c e c a a
        val (head, maxlen) = s.indices.foldLeft((0, 1)){
            case ((h, maxlen), i) => 
                val oddlen =  expandLengths(s, i, i)
                val evenlen = expandLengths(s, i, i + 1)
                val len = oddlen max evenlen
                if(len > maxlen)  (i -  (len - 1) / 2, len)
                else (h, maxlen)
        }
        s.slice(head, head + maxlen)
    }
    // return length
    @annotation.tailrec
    def expandLengths(s: String, left: Int, right: Int): Int = {
        if(0 <= left && right < s.length && s(left) == s(right)) expandLengths(s, left - 1, right + 1)
        else right - left - 1
    }
}

/**
* my first commitment
* it's kind of brute force
* time complexity: O(N^3):
*    getPalindromeLength: O(N^2)
* space complexity: O(N)
*/

object Solution1 {
  def longestPalindrome(s: String): String = {
    /* palindromeLength(i) means  the maximum palindrome length ending at string s's index i
    *   ex:
    *     input
    *         "b a b a d"
    *          0 1 2 3 4
    *     palindromeLength(0) = 1: "b"'s max palindrome length must contains the last char => "b"
    *     palindromeLength(1) = 2: "ba"'s max palindrome length must contains the last char => "a"
    *     palindromeLength(2) = 3: "bab"'s max palindrome length must contains the last char => "bab"
    *     palindromeLength(3) = 3: "baba"'s max palindrome length must contains the last char => "baba"
    *     palindromeLength(4) = 1: "babad"'s max palindrome length must contains the last char => "babad"
    * 
    * */
    val palindromeLength = Array.ofDim[Int](s.length)
    for(right <- s.indices){

      palindromeLength(right) = getPalindromeLength(s.slice(0, right + 1))
      // println("---", right, s.slice(0, right + 1).mkString(""), cache(right))
    }
    // println(cache.mkString(","))
    val maxIdx = palindromeLength.indices.maxBy(palindromeLength)

    s.slice(maxIdx - palindromeLength(maxIdx) + 1, maxIdx + 1)

  }

  /**
    * find the letter part may contains palindrome
    * iterate left2right from 0 s.length. right2left decreases 1 if s(left2right) == s(right2left)
    * the result value of right2left is the index dividing s into two part, the latter part may contains palindrome
    * ex:
    *    input:
    *         "b a a c b a b c"
    *          0 1 2 3 4 5 6 7
    *    the splitIdx would be 2, so s[3: 7) may contains palindrome and we should recursively input s[3: 7) to check it
    */
  @annotation.tailrec
  def getPalindromeLength(s: String): Int = {
    if(s == null || s.isEmpty) return 0

    val splitIdx = s.indices.foldLeft(s.length - 1){
      case (right2left, left2right) =>
        if(s(right2left) == s(left2right)) right2left - 1
        else right2left
    }
    // println(s, splitIdx)
    if(splitIdx == -1) /* find the palindrome! */
      s.length
    else
      getPalindromeLength(s.slice(splitIdx + 1, s.length))
  }
}


/**
* brute force
* time complexity: O(N^3)
* space complexity: O(M) M is the length of longest palindrome
*/

object Solution2 {
    def longestPalindrome(s: String): String = {
        (for(i <- s.indices; j <- i until s.length) yield (i, j)).foldLeft("") {
            // pruning
            case (best, (i, j)) if best.length < (j - i + 1) && isPalindrome(s, i, j) => s.slice(i, j + 1)
            case (best, _) => best
        }

    }
    // r a c e e c a r
    // 0 1 2 3 4 5 6 7
    
    @annotation.tailrec
    def isPalindrome(s: String, l: Int, r: Int): Boolean = {
    
        if(s == null || s.isEmpty) false
        else if(l >= r) true
        else { // l < r
            // println(l, s(l), r, s(r))
            if(s(l) != s(r)) false
            else isPalindrome(s, l + 1, r - 1)
        }
        
    } 
}

/**
* dynamic programming
* state definition
*     dp(i)(j) represents wether substring s(i: j) is palindromic
*     ex: 
*       s: "r a c e c a r"
*           0 1 2 3 4 5 6
*       dp(1)(5) is true due to "a c e c a" is palindrome
* state transformation
*      1.dp(i)(j) = (s(i) == s(j)) && dp(i + 1)(j - 1) if  (j - i) - (i + 1) + 1 < 2 
*         due to dp(i + 1)(j - 1) exceeds the edge 
*         ex:
*         s: "l e e t c o d e"
*             0 1 2 3 4 5 6 7
*         let i = 3, j = 4 => i + 1 = 4, j - 1 = 3 => dp(i + 1)(j - 1) = dp(4)(3) => it doesn't make sense
*   
* time complexity: O(N^2)
* space complexity: O(N^2)
*/
object Solution3 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty ) return ""
        if(s.length < 2) return s
        
        /**
        * if we initial the dp table dp(i)(j) with iterating all of element, it's time consuming
        */
        // val dp = Array.tabulate(s.length, s.length){
        //     case (i, j) if i == j => true
        //     case _ => false
        // }
        val dp = Array.ofDim[Boolean](s.length, s.length)
        var maxLen = 1
        var head = 0
        /** dp(i)(j) = (s(i) == s(j)) && dp(i + 1)(j - 1)
        * dp(i)(j)  depends on dp(i + 1)(j - 1), so we need calculate dp(i + 1)(j - 1) before we calculate dp(i)(j)
        *    0 1 2 3 4 5 6
        *          j
        *   0  A B D G K P
        *   1    C E H L Q
        *   2      F I M R
        * i 3        J N S
        *   4          O T
        *   5            U 
        *   6
        *  the iterative order would be 
        *     * A -> B -> C -> D -> E -> F .... => (0, 1) -> (0, 2) -> (1, 2) -> (0, 3) -> (1, 3) -> (2, 3) ... and so on
        *      
        *     
        */
        for(j <- 1 until s.length; i <- 0 until j){
            val currentLen = j - i + 1
            if(s(i) != s(j))  dp(i)(j) = false
            else if(currentLen < 4)  dp(i)(j) = true // currentLen - 2 < 2
            else dp(i)(j) = dp(i + 1)(j - 1)
            
            
            if(dp(i)(j) && currentLen > maxLen){
                maxLen = currentLen
                head = i

            }
        }
        
        s.slice(head, head + maxLen)
    }
}


/**
* expand around center
* time complexity: O(N^2)
*        expandLengths: O(N)
* space complexity: O(1)
*/

object Solution4 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty) return ""
        
        // 0 1 2 3 4 5 6 7
        // r a c e c a r
        // r a c e e c a r
        // b b c e c a a

        // var head = 0
        // var maxlen = 1
        // for(i <- s.indices) {
        //     val oddlen =  expand(s, i, i)
        //     val evenlen = expand(s, i, i + 1)
        //     val len = oddlen max evenlen
        //     if(len > maxlen){
        //         head = i -  (len - 1) / 2
        //         maxlen = len
        //     }
        // }
        val (head, maxlen) = s.indices.foldLeft((0, 1)){
            case ((h, maxlen), i) => 
                val oddlen =  expandLengths(s, i, i)
                val evenlen = expandLengths(s, i, i + 1)
                val len = oddlen max evenlen
                if(len > maxlen)  (i - (len - 1) / 2, len)
                else (h, maxlen)
        }
        s.slice(head, head + maxlen)
    }
    // return length
    @annotation.tailrec
    def expandLengths(s: String, left: Int, right: Int): Int = {
        if(0 <= left && right < s.length && s(left) == s(right)) expandLengths(s, left - 1, right + 1)
        else right - left - 1
    }
}

```

###  3.6. <a name='ZigZagConversion'></a>6. ZigZag Conversion

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7uH?spm_id_from=333.999.0.0)

###  3.7. <a name='ReverseInteger'></a>7 Reverse Integer

[哈哈哈](https://www.bilibili.com/video/BV1sE411e73m?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7bM?spm_id_from=333.999.0.0)

* 时间复杂度:O(log10(n)), 每次迭代都会除以10

* 时间复杂度:O(1)

```py
class Solution:
    def reverse(self, x: int) -> int:
        res = 0 
        a = abs(x)

        if a < 10:
            return x

        while a != 0:
            tmp = a % 10
            res = res * 10 + tmp
            a = a // 10
        # 要注意return和while的相对位置
        # 不要写在while循环内部

        if x > 0 and res < 1<<31:
            return res 
        elif x<0 and res <= 1<<31:
            return -res
        else:
            return 0
```

```scala
object Solution {
    def reverse(x: Int): Int = {
        
        // METHOD-1
        if (x == 0) {
            0
        } else { 
            val xx = math.abs(x).toString.reverse
            var start_to_record = false
            val temp = collection.mutable.ArrayBuffer[Char]()

            for (x <- xx) {

                if (start_to_record == false && x != '0') {
                    start_to_record = true
                }

                if (start_to_record) {
                    temp += x
                }

            }

            try {
                ({if (x >= 0) "" else "-"} + temp.mkString).toInt    
            } catch {
                case e: java.lang.NumberFormatException => 0
            } 
        }
        
        
        // METHOD-2
        if (x == 0) {
            0
        } else {
            
            val xx = math.abs(x).toString.reverse
            
            // find the first element not equaling to 0
            // Here I used method `.find`. It finds and returns the first element of the list satisfying a predicate, if any.
            // `.find` returns Some(*), so need to use `.get`
            val intermediate_result = xx.slice(xx.zipWithIndex.find(_._1 != '0').get._2, xx.length)
            
            // 1. Use if-else to handle possible negative integers.
            // 2. use try-catch to handle cases like "1534236469"
            //      which will cause exception java.lang.NumberFormatException: For input string: "9646324351"
            //      due to Int.MaxValue is 2147483647
            try {
                ({if (x >= 0) "" else "-"} + intermediate_result).toInt    
            } catch {
                case e: java.lang.NumberFormatException => 0
            }

        }  
    }
}
```

```scala
object Solution {
    def reverse(x: Int): Int = {
        if(x == 0){
            0
        }else{
            var output = 0L
            var num = x
            var flag = false
            
            if(x < 0){
                num = Math.abs(num)
                flag = true
            }
            
        
            while(num!=0){
                var mod = num%10
            
                output = (output*10) + mod
            
                num = num/10
            }
            
            val res = if(flag){
                output * (-1)
            }else{
                output
            }
            //To avoid overflow
            if(res < Int.MinValue || res > Int.MaxValue) 0 else res.toInt
        }
    }
}
```

###  3.8. <a name='StringtoIntegeratoi'></a>8. String to Integer(atoi)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7pz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1AZ4y1s7TD?spm_id_from=333.999.0.0)

* 时间复杂度:O(n)

* 时间复杂度:O(1)

|模式|描述|
|---|---|
|^|匹配字符串的开头|
|[...]|用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'|
|*|匹配0个或多个的表达式。|
|?|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式|
|+|匹配1个或多个的表达式。|
|\d|匹配任意数字，等价于 [0-9]。|
|\D|匹配任意非数字，等价于 [^0-9]。|

[正则表达式中小括号、中括号、大括号的作用](https://blog.csdn.net/weixin_45621662/article/details/103921232)

```py
class Solution:
    def myAtoi(self, s: str) -> int:
        import re
        at_oi_re = re.compile('^[ ]*([+-]?\d+)')
        # 易错点：要注意中括号[]和小括号()的区别
        # 易错点：要注意小括号()的位置，小括号的作用是匹配并提取，所以+-要包括起来
        # 易错点：不能漏掉*？

        # 字符串的 开头 匹配 0个或多个[空格]
        # 匹配 0个或多个[+-]
        # 匹配 0个或多个[0-9]
        if not at_oi_re.search(s):
            return 0
        res = int(at_oi_re.findall(s)[0])
        # 易错点：findall返回一个列表，所以必须有[0]
        # 易错点：必须有int()
        return min(max(res, -(1<<31)), (1<<31) - 1) # 在两者之间，背一背
        # 要加小括号(1<<31)
```

###  3.9. <a name='Palindrome'></a>9-Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1hJ411S7kt?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7YG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Af4y1m7kk?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return True if str(x) == str(x)[::-1] else False
```

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False

        if x < 10:
            return True

        bkp = x
        res = 0

        while x != 0:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return bkp == res
```

翻转一半字符法：

* 时间复杂度:O(log10(n)), 每次迭代都会除以10

* 时间复杂度:O(1)

经过尝试，这个方法在边界处理上容易出错，不推荐。

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 10 and x >= 0:
            return True

        if x < 0 or x % 10 == 0:
            return False

        res = 0

        # 翻转一半字符串

        while x > res:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return x == res or x == res//10
```

```scala
package lc009 {
  object Solution {
    def isPalindrome(x: Int): Boolean = {
      if (x<0) return false
      if (x==0) return true
      if (x%10==0) return false
      val y=x.toString.reverse
      return y==x.toString
    }
  }
}
```

###  3.10. <a name='ContainerWithMostWater'></a>11. Container With Most Water 

[花花酱](https://www.bilibili.com/video/BV1CW41167qB?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Gn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1A5411E7oM?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1TK41157jH?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

双指针法：

由于盛水面积由较短边控制，所以，指针放在两端，每次只移动较短边。因为，移动较长边的话。一定仍然是不变的。

* 时间复杂度:O(n)

* 时间复杂度:O(1)



```py
# 这个写起来超级简单！
# NO BUG
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        maxRes = res = 0
        while left < right:
            res = (right - left)*min(height[left],height[right])
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
            maxRes = max(maxRes,res)
        return maxRes
```

```scala
/**
* brute force not AC
* time complexity: O(n^2)
*/

object Solution1 {
    def maxArea(height: Array[Int]): Int = {
      
      var currentMax = 0

      for(left <- height.indices; right <- (left + 1) until height.length) {
        val limit = height(right) min height(left)
        val width =  (right - left)
        val volume = limit * width

        currentMax = currentMax max volume
      }
      currentMax
    }  
}


/**
* two pointer version
* memo
*  1. fix left side,, the volume is bounded by left side if left side is shorter 
*  2. fix right side. the volume is bounded by right side if right side is shorter
*/

object Solution2 {
    def maxArea(height: Array[Int]): Int = {
      
      var left = 0
      var right = height.length - 1
      var volume = 0
      
      while(left < right) {
        val current = (right - left) * (height(right) min height(left))
        volume = volume max current
        
        if (height(left) < height(right)) // left is shorter
          left += 1
        else // right is shorter
          right -= 1
      }
      volume
    }
         
}

/**
* two - pointer version recursive version
*/
object Solution2-1 {
    def maxArea(height: Array[Int]): Int = {
  
     maxArea(height, 0, height.length - 1, 0)
    }
  
    @annotation.tailrec
    def maxArea(height: Array[Int], left: Int, right: Int, maxVolume: Int): Int = {
      if (left >= right)  maxVolume
      else {
        val currentVolume = (right - left) * (height(right) min height(left))
        var newMaxVolume = currentVolume max maxVolume
        
        if (height(right) > height(left)) 
          maxArea(height, left + 1, right, newMaxVolume)
        else
          maxArea(height, left, right - 1, newMaxVolume)
      }
    }
}
```

###  3.11. <a name='IntegertoRoman'></a>12. Integer to Roman

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Wf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hN411Q7ka?spm_id_from=333.999.0.0)

```py
# 这个写起来超级简单！
# NO BUG
class Solution:
    def intToRoman(self, num: int) -> str:
        strlist = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        numlist = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        res = ''
        for i in range(len(numlist)):
            while num >= numlist[i]:
                num -= numlist[i]
                res = res + strlist[i]
        return res
```

```py
# 其他方法
class Solution:

    VALUE_SYMBOLS = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]
    print(type(VALUE_SYMBOLS))
    def intToRoman(self, num: int) -> str:
        roman = list()
        for value, symbol in Solution.VALUE_SYMBOLS:
            while num >= value:
                print("-"*20)
                print(num)
                num -= value
                roman.append(symbol)
                print(roman)
            if num == 0:
                break
        return "".join(roman)
```

```scala
package com.zhourui.leetcode

//class Solution {
//  public:
//    string intToRoman(int num) {
//      vector<int> t1{1000,900,500,400,100,90,50,40,10,9,5,4,1};
//      vector<string> t2{"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
//      string ret="";
//      for (int i=0;i<t1.size();i++) {
//      if (num>=t1[i]) {
//      int c = num/t1[i];
//      for (int j=0;j<c;j++) {
//      ret+=t2[i];
//    }
//      num=num%t1[i];
//    } else if (num==0) {
//      break;
//    }
//    }
//      return ret;
//    }
//};


//object Solution {
//  case class RomanNumber(decValue: Int, romanStr: String)
//  val numbers = Seq(
//    RomanNumber(1000, "M"),
//    RomanNumber(900, "CM"),
//    RomanNumber(500, "D"),
//    RomanNumber(400, "CD"),
//    RomanNumber(100, "C"),
//    RomanNumber(90, "XC"),
//    RomanNumber(50, "L"),
//    RomanNumber(40, "XL"),
//    RomanNumber(10, "X"),
//    RomanNumber(9, "IX"),
//    RomanNumber(5, "V"),
//    RomanNumber(4, "IV"),
//    RomanNumber(1, "I")
//  )
//  def intToRoman(num: Int): String = {
//    def loop(num:Int, romans: Seq[RomanNumber]): String = {
//      romans match {
//        case RomanNumber(x, romanStr) :: _ if x < num => romanStr + loop(num-x, romans)
//        case RomanNumber(x, romanStr) :: _ if x == num => romanStr
//        case RomanNumber(x, _) :: tail if x > num => loop(num, tail)
//      }
//    }
//    loop(num, numbers)
//  }
//}
package lc0012_integertoroman {
  object Solution {
    case class RomanNumber(s:String, i: Int)
    def intToRoman(num: Int): String = {
      val numbers:Seq[RomanNumber] = Seq(
        RomanNumber("M",1000),
        RomanNumber("CM",900),
        RomanNumber("D",500),
        RomanNumber("CD",400),
        RomanNumber("C",100),
        RomanNumber("XC",90),
        RomanNumber("L",50),
        RomanNumber("XL",40),
        RomanNumber("X",10),
        RomanNumber("IX",9),
        RomanNumber("V",5),
        RomanNumber("IV",4),
        RomanNumber("I",1)
      )
      // 很巧妙 利用seq的head 和tail 递归调用
      // :: 相当于拼接

      def loop(num:Int, romans:Seq[RomanNumber]): String = {
        romans match {
          case RomanNumber(romanStr, v) :: lst if v == num => romanStr
          case RomanNumber(romanStr, v) :: lst if v < num => romanStr+loop(num-v,romans)
          case RomanNumber(romanStr, v) :: tail => loop(num,tail)
        }
      }
      loop(num, numbers)
    }
  }
}

```

###  3.12. <a name='-1'></a>13. 机器人的运动范围 

[官方](https://www.bilibili.com/video/BV1dz411B7rt?spm_id_from=333.999.0.0)

###  3.13. <a name='RomantoInteger'></a>13. Roman to Integer

[花花酱](https://www.bilibili.com/video/BV1vJ411J7Up?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1hJ411S7kQ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7ue?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1cp4y1H75L?spm_id_from=333.999.0.0)

```py
# 看不懂下方代码，就看小明的讲解
class Solution:
    def romanToInt(self, s: str) -> int:
        dic = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
        res = 0
        for i in range(len(s)-1):
            if dic[s[i]] < dic[s[i+1]]:
                res -= dic[s[i]]
            else:
                res += dic[s[i]]
        res += dic[s[-1]]
        return res
```

```scala
object Solution {
    def romanToInt(s: String): Int = {
        val exceptionsMap = Map(
            ('I' -> List('V', 'X')),
            ('X' -> List('L', 'C')),
            ('C' -> List('D', 'M'))
                     )
        
        val valuesMap = Map(
            ('I' -> 1),
            ('V' -> 5),
            ('X' -> 10),
            ('L' -> 50),
            ('C' -> 100),
            ('D' -> 500),
            ('M' -> 1000)
        )
        
        val exceptionalValues = Map(
            ("IV" -> 4),
            ("IX" -> 9),
            ("XL" -> 40),
            ("XC" -> 90),
            ("CD" -> 400),
            ("CM" -> 900)
        )
        
        var sum = 0
        var i = 0
        val len = s.length
        while(i < len){
            var c1 = s.charAt(i) 
            c1 match{
                case 'I' | 'X' | 'C' => {
                    if(i+1 < s.size && exceptionsMap.get(c1).get.contains(s.charAt(i+1))){
                        sum += exceptionalValues.get(c1.toString + s.charAt(i+1)).get
                        i+=2
                    }else{
                        sum += valuesMap.get(c1).get
                        i += 1
                    }
                }
                case _ => {
                    sum += valuesMap.get(c1).get
                    i += 1
                }
            }
        }
        sum
    }
}


//Alternate SCALA solution
object Solution {
	def convert(c: Char) = c match{
		case 'I' => 1
		case 'V' => 5
		case 'X' => 10
		case 'L' => 50
		case 'C' => 100
		case 'D' => 500
		case 'M' => 1000
		case _ => throw new UnsupportedOperationException("This case should not be called unless the input is invalid")
	}

	def romanToInt(s: String): Int = s.foldRight(0){
		(v, sum) => (convert(v), sum) match{
			case (add, _) if sum < 5*add => add + sum
			case (sub, _) => sum - sub
		}
	}
	
}

```

```scala
package com.zhourui.leetcode

/*
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.
 */
package lc0013_romantointeger {

  object Solution {
    def romanToInt(s: String): Int = {
      val m:Map[Char,Int] = Map(
        'I' -> 1,
        'V' -> 5,
        'X' -> 10,
        'L' -> 50,
        'C' -> 100,
        'D' -> 500,
        'M' -> 1000
      )

      def loop(p:Seq[Char], m:Map[Char,Int]): Int = p match {
        case Seq(a, b, t@_*) if m(a) < m(b) => m(b) - m(a) + loop(t, m)
        case Seq(a, t@_*) => m(a) + loop(t,m)
        case _ => 0
      }
      return loop(s,m)
    }
  }
}


/*
//case Seq(xs @ _*) // Identifier xs is bound to the whole matched sequence.
 def romanToInt(s: Seq[Char]): Int = s match {
      case Seq(a, b, t@_*) if dict(a) < dict(b)  =>  dict(b) - dict(a) + romanToInt(t)
      case Seq(a, t@_*) => dict(a) + romanToInt(t)
      case _ => 0
    }
 */
```

###  3.14. <a name='Longestcommonprefix'></a>14-Longest common prefix

[哈哈哈](https://www.bilibili.com/video/BV1cJ411D7qU?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Eb411i7QN?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1tV411k7GY?spm_id_from=333.999.0.0)

* 时间复杂度:O(mn),m是字符串平均长度,n是字符串数量

* 时间复杂度:O(1)

```py
# 参考了小梦想家,首次学习while true循环:
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        lookup = set()
        res = ''
        i = 0
        while True:
            # 由于string的长度是不确定的，所以
            try:
                lookup = set(string[i] for string in strs)
                if len(lookup) == 1:
                    res += lookup.pop()
                    i += 1
                else:
                    break
            except Exception as e:
                break
        return res
```

```py
# 如果不使用try catch
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if strs == [""]:
            return strs[0]
        lookup = set()
        res = ''
        i = 0
        minlen = min(len(string) for string in strs)
        while i< minlen:
            lookup = set(string[i] for string in strs)
            if len(lookup) == 1:
                res += lookup.pop()
                i += 1
            else:
                break
        return res
```

```scala
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var flag = true
            var count = 1
            var output = ""
        
            var minLength = strs.map(_.length).min
        
        while(flag && count <= minLength){
            
            /**
            lst.forall(_ == lst.head)  // true  if empty or all the same
            lst.exists(_ != lst.head)  // false if empty or all the same
            */
            
            if(strs.map(s => s.substring(0, count)).distinct.length == 1){
                output = strs(0).substring(0, count)
                count += 1
            }else{
                flag = false
            }
        }
        
        output
        }
    }
}

//Alternate solution (better complexity)
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var prefix = strs(0)
            
            (1 until strs.length).map(i => {
                
                while(strs(i).indexOf(prefix) != 0){
                    prefix = prefix.substring(0, prefix.length - 1)
                }
                
            })
            
            prefix
        }
    }
}

```

###  3.15. <a name='Sum'></a>15. 3Sum

[花花酱](https://www.bilibili.com/video/BV1wp4y1W72o?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Tb411578b?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19K4y1s7co?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19i4y1s7VZ?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n3)

* 时间复杂度:O(1)

双指针法：

先排序：时间复杂度:O(n log(n)) + O(n2)

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        # nums.sort() # 另一种写法
        nums = sorted(nums)
        res = []
        for i in range(n-2):
            # 优化部分：
            if nums[i] > 0: break
            if nums[i] + nums[i+1] + nums[i+2] > 0: break
            # 这个写法不对：if i+1 < n-2 and nums[i] == nums[i+1]: continue
            # 这样可能直接跳过了[-1,-1,2,3]的前三个
            # 这个写法是正确的↓：
            if i - 1 >= 0 and nums[i] == nums[i-1]: continue
            if nums[i] + nums[n-2] + nums[n-1] < 0:continue
            # 双指针部分：
            left = i + 1
            right = n - 1
            while left < right: 
                if nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                elif nums[i] + nums[left] + nums[right] < 0:
                    left += 1
                else:
                    res.append([nums[i],nums[left],nums[right]])
                    # 去重：
                    while nums[left] == nums[left + 1] and left + 1 < right: # 注意边界
                        left += 1
                    left +=1
                    while nums[right] == nums[right - 1] and left < right - 1: # 注意边界
                        right -= 1
                    right -=1
        return res
```

```scala
/**
* chosen solution
* 1. two pointer in twoSum
* 2. result storing in hashSet to avoid duplicate pairs
* time complexity: O(N^2)
* space complexity: O(N): due to sorted list 
*/
object Solution0 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(Set[List[Int]]()) {
          /* only send value less than zero and those num which was duplicated only once into twoSum */
      case (ans, idx) if l(idx) <= 0 && (idx == 0 || (idx >= 1 && l(idx) != l(idx - 1))) =>
        twoSum(-l(idx), l, idx + 1, ans)
      case (set, _) => set

    }.toList

  }

  def twoSum(target: Int, nums: Array[Int], from: Int, ans: Set[List[Int]]): Set[List[Int]] = {

    @annotation.tailrec
    def loop(i: Int, j: Int, ans: Set[List[Int]]): Set[List[Int]] = {

      if(i < j) {
        val sum = nums(i) + nums(j)
        if(sum > target) loop(i, j - 1, ans)
        else if(sum < target) loop(i + 1, j, ans)
        else loop(i + 1, j - 1, ans + List(-target, nums(i), nums(j)))
      }else {
        ans
      }
    }
    loop(from, nums.length - 1, ans)
  }
}
/**
* my first commit
* hashset in twoSum
* a very time consuming version
* O(N^2)
*/
object Solution1 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {

      val l = nums.groupBy(identity).mapValues(aa => if(aa.length >=3) aa.take(3) else aa ).values.flatten.toList

     l.zipWithIndex.flatMap {
      case (value, index) =>
        val ll = collection.mutable.ListBuffer(l: _*)
        ll.remove(index)

        twoSum(ll.toList, -value).filter(_.nonEmpty)
          .map(_ :+ value)
    }.map(pair => (pair.toSet, pair)).toMap.values.toList

  }

   def twoSum(nums: List[Int], target: Int): List[List[Int]] = {
    val valueCounter = nums.groupBy(identity).mapValues(_.length)

    nums.collect {
      case value if target - value == value && valueCounter.get(target - value).exists(_ >= 2) =>
        List(value, target - value)
      case value if target - value != value && valueCounter.contains(target - value) =>
        List(value, target - value)

    }
  }

}

/**
* hashset in twoSum
* sorted nums and not to run duplicate num twice into twoSum
* O(N^2)
*/
object Solution1-2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
   
    val l = nums.sorted
    val ret = for((value, index) <- l.zipWithIndex; if index >= 1 && l(index) != l(index - 1)) yield  {
      val ll = l.toBuffer
      ll.remove(index)
      twoSum(ll.toArray, -value).filter(_.nonEmpty).map(_ :+ value)
    }

    l.slice(0, 3) match {
      case Array(0, 0, 0 ) =>  ret.flatten.map(l => (l.toSet, l)).toMap.values.toList :+ List(0, 0, 0) // edge case (0, 0, 0)
      case _ => ret.flatten.map(l => (l.toSet, l)).toMap.values.toList
    }

  }

  def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collect {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>

        List(value, target - value)
    }.map(l => (l.toSet, l)).toMap.values.toList
  }

/**
* improvement:
*   1. only call twoSum when  l(idx) under zero,  because the array was sorted, there won't be any chance the next entries sum to 0.
*   2. only send the remaining nums which were after idx into twoSum
* O(N^2)
*/

  object Solution1-3 {
    def threeSum(nums: Array[Int]): List[List[Int]] = {
        val l = nums.sorted
        l.indices.foldLeft(collection.mutable.ListBuffer.empty[List[Int]]){
        case (r, idx) if l(idx) <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx-1))) =>
            r ++= twoSum(l.slice(idx + 1, l.length), -l(idx)).map(_ :+ l(idx))
        case (r, idx)  => r

        }.toList
        
    }

    def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {

        val value2Idx = nums.zipWithIndex.toMap
        nums.zipWithIndex.collect {
        case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
            List(value, target - value)
        }.map(l => (l.toSet, l)).toMap.values.toList
    }
  
}


/**
*  Using a hashset to erase duplicate in twoSum
*/
object Solution1-3-2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(collection.mutable.ListBuffer.empty[List[Int]]){
      case (r, idx) if l(idx) <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx-1))) =>
        r ++= twoSum(l.slice(idx + 1, l.length), -l(idx))
      case (r, idx)  => r

    }.toList

  }

  def twoSum(nums: Array[Int], target: Int): List[List[Int]] = {

    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.foldLeft(Set[List[Int]]()) {
      case (s, (value, index)) if value2Idx.get(target - value).exists(_ != index) =>
        val t_sub_v = target - value
        if(index < value2Idx(t_sub_v)) {
          s + List(-target, value, t_sub_v)
        } else {
          s + List(-target, t_sub_v, value)
        }
      case (s, _) => s

    }.toList
  }
}
/**
* more readable and simpler
*/
object Solution1-3-3 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted

    l.zipWithIndex.foldLeft(Set[List[Int]]()) {
      /* only send value less than zero and those num which was duplicated only once into twoSum */
      case (set, (v, idx)) if v <=0 && (idx == 0 || (idx > 0 && l(idx) != l(idx - 1)))  =>
        set ++ twoSum(-v, l.slice(idx + 1, l.length))
      case (set, _) => set
    }.toList

  }

  def twoSum(target: Int, nums: Array[Int]): List[List[Int]] = {
    val map = nums.zipWithIndex.toMap
    nums.zipWithIndex.foldLeft(Set[List[Int]]()){
      case (set, (n, idx)) =>
        val n2 = target - n
        map.get(n2) match {
          case Some(e) if e != idx =>
            /* using  n n2 order to help hashset to eliminate duplicate */
            if(n < n2)
              set + List(-target, n, n2)
            else
              set + List(-target, n2, n)
          case _ => set
        }
    }.toList
  }
}

/**
* two pointer in twoSum
* time complexity: O(N^2)
* space complexity: O(N): due to sorted list 
*/

object Solution2 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {
    val l = nums.sorted
    l.indices.foldLeft(Set[List[Int]]()) {
      case (ans, idx) if l(idx) <= 0 && (idx == 0 || (idx >= 1 && l(idx) != l(idx - 1))) =>
        twoSum(-l(idx), l, idx + 1, ans)
      case (set, _) => set

    }.toList

  }

  def twoSum(target: Int, nums: Array[Int], from: Int, ans: Set[List[Int]]): Set[List[Int]] = {

    @annotation.tailrec
    def loop(i: Int, j: Int, ans: Set[List[Int]]): Set[List[Int]] = {

      if(i < j) {
        val sum = nums(i) + nums(j)
        if(sum > target) loop(i, j - 1, ans)
        else if(sum < target) loop(i + 1, j, ans)
        else loop(i + 1, j - 1, ans + List(-target, nums(i), nums(j)))
      }else {
        ans
      }
    }
    loop(from, nums.length - 1, ans)
  }
}
```

###  3.16. <a name='SumClosest'></a>16. 3Sum Closest

[小梦想家](https://www.bilibili.com/video/BV11441187Rr?spm_id_from=333.999.0.0)

```py
# 和上一题差不多
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        minAim = sum(nums[0:3]) - target
        n = len(nums)
        for i in range(n-2):
            left = i+1
            right = n-1
            while left<right:
                aim = nums[i] + nums[left] + nums[right] - target
                if abs(aim) < abs(minAim): minAim = aim
                if aim == 0: 
                    return target
                elif aim > 0:
                    right -= 1
                else:
                    left += 1
        return minAim + target
```

```py
# （python）三重暴力破解 O(n**3)

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        result=1000
        for i in range(0,len(nums)):
            for j in range(i+1,len(nums)):
                for k in range(j+1,len(nums)):
                    a=nums[i]+nums[j]+nums[k]-target
                    if abs(a) < result:
                        result=abs(a)
                        end=nums[i]+nums[j]+nums[k]
        return end
```

```scala

/**
* my first commitment
* two pointer approximate
* 
* time complexity: O(N^2)
*/
object Solution1 {
  def threeSumClosest(nums: Array[Int], target: Int): Int = {
    val l = nums.sorted
    // slice(0, 3) is slower 
    l.indices.foldLeft(l.take(3).sum){
      case (closestSum, idx) => twoSum(l, target, idx, closestSum)
    }

  }

  def twoSum(nums: Array[Int], target: Int, from: Int, closestSum: Int): Int = {
    val fromValue = nums(from)

    @annotation.tailrec
    def _twoSum(left: Int, right: Int, previousSum: Int): Int = {
      if(left >= right) return previousSum


      val currentSum = fromValue + nums(left) + nums(right)

      val currentDiff = math.abs(target - currentSum)
      val previousDiff = math.abs(target - previousSum)

      val newClosest = if(currentDiff > previousDiff) previousSum else currentSum


      if(currentSum < target) _twoSum(left + 1, right, newClosest)
      else if(currentSum > target) _twoSum(left, right - 1, newClosest)
      else _twoSum(left + 1, right - 1, newClosest)

    }

    _twoSum(from + 1, nums.length - 1, closestSum)
  }
}
```

###  3.17. <a name='LetterCombinationsofaPhoneNumber'></a>17. Letter Combinations of a Phone Number 

[花花酱](https://www.bilibili.com/video/BV1PW411y7r2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7sL?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ti4y1A73M?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Sp4y1r7YP?spm_id_from=333.999.0.0)

深度优先 or 广度优先

* 时间复杂度:O(3m × 4n), m是对应3个字母的数字, n是对应4个字母的数字

* 时间复杂度:O(3m × 4n), m是对应3个字母的数字, n是对应4个字母的数字

```py
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: # 易错点：一定要判断判断字符串是否为空
            return [] 
        dic = {'2':'abc','3':'def','4':'ghi','5':'kjl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        res = [char for char in dic[digits[0]]] # 前面的排在前面
        for num in digits[1:]:
            res = [string + char for string in res for char in dic[num]]
        return res
```

```py
class Solution:
    def letterCombinations(self, digits):
        if not digits:
            return list()
        
        phoneMap = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }

        groups = (phoneMap[digit] for digit in digits)
        return ["".join(combination) for combination in itertools.product(*groups)]
```

###  3.18. <a name='RemoveNthNodeFromEndofList'></a>19-Remove Nth Node From End of List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7DQ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1eL411n7KE?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1654y1R7Xe?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1KK4y1E7st?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Z5411c79y?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ccdr2kcw7c0.png)

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast = ListNode(0)
        slow = ListNode(0)
        fast.next = head
        slow.next = head
        for _ in range(n):
            fast = fast.next

        # 易错点：
        # 要考虑特殊情况，比如说，链表长度和n一样时

        if fast.next == None: # 易错点：== 千万不要写错
            return head.next

        while fast.next != None:
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next

        return head
```

```scala
/**
* my first commitment - fast & slow pointer
* time complexity O(N + N / 2)
*/

object Solution1 {
    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
      val dummyHead = ListNode(0, head)
      var slow = dummyHead
      var fast = dummyHead
      var counter = 0
      
      while(fast != null && fast.next != null) {
        slow = slow.next
        fast = fast.next.next
        counter += 1
      }
      
      val length = if (fast == null) counter * 2 - 1 else counter * 2
      val targetNodeIndex = length - n + 1
      val slowNodeIndex = counter
      // println(length, targetNodeIndex, slowNodeIndex)
      if (counter < targetNodeIndex) {
        removeIdx(slow, slowNodeIndex, targetNodeIndex)
      }else {
        removeIdx(dummyHead, 0, targetNodeIndex)
      }
      dummyHead.next
    }
  
    def removeIdx(node: ListNode, nodeIdx: Int, targetIdx: Int) {
      var nodeT = node
      var nodeIdxV = nodeIdx
      var preNodeindex = targetIdx - 1
     
      while (nodeIdxV < preNodeindex) {
        nodeIdxV += 1
        nodeT = nodeT.next
      }
      var preNode = nodeT
      var nextNode = nodeT.next.next
      preNode.next = nextNode
    }
}


/**
* two pointer fast & slow 
* memo
*   1. keep fast pointer is n + 1 ahead to slow pointer
*   2. if fast == null, slow pointer would points to the  preNode of target removing node
*
*           t 
*   0 1 2 3 4 5
*   s     f
*     s     f
*       s     f
*         s     f
*/
object Solution1-2 {
    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
      val dummyHead = ListNode(0, head)
      var slow = dummyHead
      var fast = dummyHead
      
      for (i <- 0 until (n + 1) if fast != null) {
        fast = fast.next
      }
      
      while(fast != null) {
        slow = slow.next
        fast = fast.next
      }
      
      slow.next = slow.next.next
      dummyHead.next
    }
  
}
```

###  3.19. <a name='Validparentheses'></a>20-Valid parentheses

[哈哈哈](https://www.bilibili.com/video/BV1DJ41127uA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7ek?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Hr4y1M7Sc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1sC4y1H7Hs?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1QA411L7y7?spm_id_from=333.999.0.0)

先进后出，所以用栈

* 时间复杂度:O(n)

* 时间复杂度:O(n)

```py
# 这道题背一背！
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{':'}','[':']','(':')'}
        stack = [] # stack 要提前定义好
        for char in s:
            if char in dic: # 是“key”
                stack.append(char) # 一个char进来，要么被append
            elif not stack or dic[stack.pop()] != char: 
                # 如果上一步不被append就是不对的
                # 如果这一步不匹配也是不对的
                return False
        return not stack # 如果append上了，但没有被完全pop也是不对的
```

```scala
/**
* chosen solution
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution0 {
    def isValid(s: String): Boolean = {

        val parenthesesMap = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        val stack = scala.collection.mutable.ArrayStack[Char]()
        s.forall{ c =>
            if(parenthesesMap.contains(c)){
              stack.push(c)
              true
            }else{
               stack.nonEmpty && parenthesesMap(stack.pop).equals(c)
            }
        } && stack.isEmpty
    }
}


/**
* my first commitment
* using stack
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def isValid(s: String): Boolean = {
        if(s.isEmpty || s.length % 2 != 0) return false
        val stack = scala.collection.mutable.Stack[Char]()
        
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')

        s.foreach{c => 
            
            if (mapping.contains(c)){
                stack push c
            }else{
                if(stack.isEmpty || mapping(stack.pop) != c) return false 
             
            }
        }
        stack.isEmpty
        
    }
}

/**
* stack and avoid return in foreach block
*/
object Solution1-2 {
    def isValid(s: String): Boolean = {

        val parenthesesMap = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        val stack = scala.collection.mutable.ArrayStack[Char]()
        s.forall{ c =>
            if(parenthesesMap.contains(c)){
              stack.push(c)
              true
            }else{
               stack.nonEmpty && parenthesesMap(stack.pop).equals(c)
            }
        } && stack.isEmpty
    }
}

/**
* using stack X FP
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1-3 {
    def isValid(s: String): Boolean = {
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        s.foldLeft(List.empty[Char]){ (stack, c) => 
            stack match {
                case pop :: stackAfterPop if  c.equals(mapping.getOrElse(pop, None)) => stackAfterPop
                case _ => c +: stack
            }
           
        }.isEmpty
        
    }
}

```

```scala
object Solution {
    def isValid(s: String): Boolean = {
        if(s.length % 2 != 0){
            false
        }else{
        import scala.collection.mutable._
        val openingHashSet: HashSet[Char] = HashSet('(', '{', '[')
        val closingMap: Map[Char, Char] = Map(
             (')' -> '('),
             ('}' -> '{'),
             (']' -> '[')
         )                                                       
        val stack = Stack.empty[Char]
                       
        var output = true               
        import scala.util.control.Breaks._
        
        breakable{
            for(c <- s){
                if(stack.isEmpty){
                    if(openingHashSet.contains(c)){
                        stack.push(c)
                    }else{
                        output = false
                        break
                    }
                }else{
                    if(openingHashSet.contains(c)){
                        stack.push(c)
                    }else{
                        closingMap.get(c) match{
                            case Some(v) =>{
                                val top = stack.top
                                if(v == top){
                                    stack.pop()
                                }else{
                                    output = false
                                    break
                                }
                            }
                            case None =>{
                                output = false
                                break
                            }
                        }
                    }
                }
            }
        }               
        
        if(stack.isEmpty) output else false
    }
    }
}

```

###  3.20. <a name='Mergetwosortedlists'></a>21-Merge two sorted lists

[哈哈哈](https://www.bilibili.com/video/BV1rJ41127ry?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7D7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1my4y127bK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1qZ4y1j7Jb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ck4y1k7J9?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(M+N)

* 时间复杂度:O(1)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        cur = dummy # dummy是固定节点，cur是移动指针
        while list1 and list2: # 这里是and
            if list1.val < list2.val: # 易错点：这里是list.val，而不是list
                cur.next = list1
                list1 = list1.next # 向后进一位
            else:
                cur.next = list2
                list2 = list2.next # 向后进一位
            cur = cur.next # 向后进一位
        cur.next = list1 or list2 # 易错点：这里是cur.next，而不是cur。这里是or
        # 等效于：
        # if list1:
        #     cur.next = list1
        # else:
        #     cur.next = list2
        return dummy.next
```

递归解法：

* 时间复杂度:O(M+N)

* 时间复杂度:O(M+N)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        elif not list2:
            return list1
        elif list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next,list2) # 找到较小头结点，提取出来
            return list1
        else:
            list2.next = self.mergeTwoLists(list1,list2.next) # 找到较小头结点，提取出来
            return list2
```

```scala
/**
* chosen solution
* time complexity: O(N + M), N is the length of l1, M is the length of l2
*/

object Solution0 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        val headNode = new ListNode(-1, null)
        var cur = headNode
        
        var no1 = l1;
        var no2 = l2;
        
        while(no1 != null && no2 != null) {
            if (no1.x >= no2.x){
                
                cur.next = no2
                no2 = no2.next
            }else {
                cur.next = no1
                no1 = no1.next
            }
            cur = cur.next
        }
        (no1, no2) match {
            case (_, null) => cur.next = no1
            case (null, _) => cur.next = no2
            case _ => throw new RuntimeException()
        }
        
        headNode.next
    }
}



/**
* iterative version
* time complexity: O(N + M), N is the length of l1, M is the length of l2
*/
object Solution1 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        val headNode = new ListNode(-1, null)
        var cur = headNode
        
        var no1 = l1;
        var no2 = l2;
        
        while(no1 != null && no2 != null) {
            if (no1.x >= no2.x){
                
                cur.next = no2
                no2 = no2.next
            }else {
                cur.next = no1
                no1 = no1.next
            }
            cur = cur.next
        }
        (no1, no2) match {
            case (_, null) => cur.next = no1
            case (null, _) => cur.next = no2
            case _ => throw new RuntimeException()
        }
        
        headNode.next
    }
}



/**
* recursive version
*/

object Solution1-2 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        (l1, l2) match {
            case (null, _) => l2
            case (_, null) => l1
            case (a, b) => 
                if (a.x >= b.x){
                    b.next = mergeTwoLists(b.next, a)
                    b
                } else {
                    a.next = mergeTwoLists(a.next, b)
                    a   
                }
        }
    }
}
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        if(l1 == null){
            l2
        } else if(l2 == null){
            l1
        }else{
            var (ll1, ll2) = (l1, l2)
            var firstNext = if(ll1.x < ll2.x) ll1 else ll2
            var head = ListNode(0, firstNext)
            var curr = head
            
            
            while(ll1 != null && ll2 != null){
                if(ll1.x < ll2.x){
                    curr.next = ll1
                    curr = ll1
                    ll1 = ll1.next
                } else{
                    curr.next = ll2
                    curr = ll2
                    ll2 = ll2.next
                }
            }
            
            if(ll1 == null){
                curr.next = ll2
            }else{
                curr.next = ll1
            }
            
            head.next
        }
    }
}


//Alternate & Simpler solution
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
    if(l1 == null) return l2
    if(l2 == null) return l1

    if (l1.x < l2.x) {
      l1.next = mergeTwoLists(l1.next, l2)
      l1
    } else {
      l2.next = mergeTwoLists(l1, l2.next)
      l2
    }
  }
}

```

###  3.21. <a name='GenerateParentheses'></a>22. Generate Parentheses

[小梦想家](https://www.bilibili.com/video/BV1hb411i7t7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vK4y1b744?spm_id_from=333.999.0.0)

回溯法：

* 时间复杂度:O($\frac{4^n}{\sqrt{n}}$)

* 时间复杂度:O($\frac{4^n}{\sqrt{n}}$)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.ud5vx6kpbvk.png" width="50%">

```py
# 基于小梦想家
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm,res):
            if left == 0 and right == 0:
                res.append(itm)
                # 错误写法：return res = res.append(itm)，这里不需要return
            if left > right: # 相当于n-left<n-right,表示残余的部分
                return
            if left > 0:
                helper(left-1,right,itm + '(',res)
                # 错误写法：return item = '(' + helper(left-1,right,itm,res)，这里不需要return
            if right > 0:
                helper(left,right-1,itm + ')',res)
                # 错误写法：return item = ')' + helper(left,right-1,itm,res)，这里不需要return
        
        res = []
        helper(n,n,'',res)
        return res
```

```py
# 基于上方答案修改
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm,res):
            if left == 0 and right == 0:
                res.append(itm)
                return # 这里return写不写居然都ac了，可能是因为没有循环吧
            if left > 0:
                helper(left-1,right,itm + '(',res)
            if right > left:
                helper(left,right-1,itm + ')',res)
        
        res = []
        helper(n,n,'',res)
        return res
```

```py
# 基于上方答案修改，helper中的删除res

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm):
            if left == 0 and right == 0:
                res.append(itm)
                return # 这里return写不写居然都ac了，可能是因为没有循环吧
            if left > 0:
                helper(left-1,right,itm + '(')
            if right > left:
                helper(left,right-1,itm + ')')
        
        res = []
        helper(n,n,'')
        return res
```

```py
class Solution:
    def generateParenthesis(self, n):
        ans = []
        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(''.join(S))
                return
            if left < n:
                S.append('(')
                backtrack(S, left+1, right)
                S.pop()
                # 参考上方，可以直接把'('写到递归函数里面，这样就不需要还原现场。
            if right < left:
                S.append(')')
                backtrack(S, left, right+1)
                S.pop()

        backtrack([], 0, 0)
        return ans
# 上方答案，修改后如下：
```

```py
# 上方答案，修改后如下：
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(S)
                return
            if left < n:
                backtrack(S + '(', left+1, right)
            if right < left:
                backtrack(S + ')', left, right+1)

        ans = []
        backtrack('', 0, 0)
        return ans
```

```py
# 作者说：头皮发麻。我感觉我是天才，
# 作者说：你们不知道用最基本的单位“()”进行组装吗。
# 作者说：绝对是原创一次过

class Solution:
    def generateParenthesis(self, n):
        if n == 1:
            return list({'()'})
        res = set()
        for i in self.generateParenthesis(n - 1):
            for j in range(len(i) + 2):
                res.add(i[0:j] + '()' + i[j:])
        return list(res)


# 我的模仿😐
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 这是我写的愚蠢的结束条件：
        # if len(res[0]) == n:
        #     return
        if n == 1:
            return ['()']

        res = set()
        for itm in self.generateParenthesis(n-1):
            for j in range(len(itm)+1): # 如果item的长度为4，那么就有5个可以插入的位置
                # 错误写法：
                # itm = itm[:j] + '()' + itm[j:]
                # res = res.add(itm)
                # 错误写法：
                # res = res.add(itm[:j] + '()' + itm[j:])
                # 正确写法：
                res.add(itm[:j] + '()' + itm[j:])
        return list(res)
```

```py
# 相当于比上一层少了一层循环。
# 不懂是不是动态规划，每新增一对括号，
# 就是在上一次的结果的各个位置插入一个"()"，用集合防止重复

class Solution:
    def generateParenthesis(self, n):
        result = {''}
        for i in range(n):
            temp = set()
            for s in result:  # 在上一次的结果的所有字符串的各个位置上插入'()'
                for j in range(len(s) + 1):
                    temp.add(s[:j] + '()' + s[j:])
            result = temp
        return list(result)
```

```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        stack=[('',0,0)]
        ans=[]
        while stack:
            print("stack: ",stack)

            p,left,right=stack.pop() # 先把p弹出来
            
            if left==right==n: #如果符合条件,就回收
                ans.append(p)
                continue
            
            if left<n: #如果符合条件,就加left
                stack.append((p+'(',left+1,right))
            if right<n and right<left: #如果符合条件,就加right
                stack.append((p+')',left,right+1))
        return ans

# 我的模仿😐 
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack = [('',0,0)]
        res = []
        while stack:
            itm, left, right = stack.pop()
            if left == right == n:
                # 错误写法：res = res.append(itm)
                res.append(itm)
                # continue 写或者不写都能ac，我迷惑了

            if left < n:
                # 错误写法：itm, left, right = itm + '(', left + 1, right
                # 错误写法：stack.append(itm + '(', left + 1, right),应该要有双层括号
                stack.append((itm + '(', left + 1, right))
            if right < left:
                # 错误写法：itm, left, right = itm + ')', left, right + 1
                # 错误写法：stack.append(itm + ')', left, right + 1),应该要有双层括号
                stack.append((itm + ')', left, right + 1))
        return res
```

```py
# 比较费脑子，可以不看😐 
class Solution:
    def generateParenthesis(self, n):
        if n == 0:
            return [""]
        if n == 1:
            return ["()"]
        # 这两行其实可有可无：
        # elif n == 2: 
        #     return ["()()", "(())"] 
        result = []
        for i in range(n):
            j = n - 1 - i
            temp1 = self.generateParenthesis(i)
            temp2 = self.generateParenthesis(j)
            result.extend(["(%s)%s" % (p, q) for p in temp1 for q in temp2])
        return result
# result.extend(["(%s)%s" % (p, q) for p in temp1 for q in temp2]) 这句是什么意思呀？
# %是格式化字符串输出，extend是把结果凑起来。这行代码干的事其实是递归生成括号。
# 如果把所有的情况分解拆开，发现最底层的形式无非n=0, 1这2种情况，
# 那么我们其实可以让括号一层一层包裹起来。这行代码其实就是一层一层包裹括号。
# for循环里面存在重复计算吧，比如说n=7的时候，i=2,j=4计算了2和4个括号的全排列，i=4，j=2的时候又计算了一遍，其实可以只计算一半，然后全排列的时候p和q调一下位置就行了。

# 我的模仿😐 
class Solution:
    def generateParenthesis(self, n):
        res = []
        if n == 0:
            return ['']
        if n == 1:
            return ['()']
        for i in range(n):
            j = n-1-i
            tmplist1 = self.generateParenthesis(i)
            tmplist2 = self.generateParenthesis(j)
            # 错误写法：return res.extend(['(%s)%s' for item1 in tmplist1 for item2 in temlist2])
            res.extend(['(%s)%s' % (item1,item2) for item1 in tmplist1 for item2 in tmplist2])
        return res
```

```scala
/**
* my first commitment 
* DFS + backtracking
* time complexity： O(4^n / square(n))
*     n-th Catalan number
*/

object Solution1 {
  def generateParenthesis(n: Int): List[String] = {
    val buffer = scala.collection.mutable.ListBuffer[String]()
    val l = "("
    val r = ")"

    def _generateParenthesis(right: Int, left: Int, n: Int, pair: String) {

      if (right == n && left == n) {
        buffer += pair
      } else {
        if (left < n) _generateParenthesis(right, left + 1, n, pair + l) // you can add open whenever you want if it's smaller then n
        if (left > right && right < n) _generateParenthesis(right + 1, left, n, pair + r)
      }
    }
    _generateParenthesis(0, 0, n, "")
    buffer.toList
  }
}

/**
* closure number
* a very genius and beautiful sol
*/
object Solution2 {
  def generateParenthesis(n: Int): List[String] =
    n match {
      case 0 => List("")
      case _ =>
        for{
          m <- (0 until n).toList  // ensure yield type is List instead of indexSeq
          leftString <- generateParenthesis(m)
          rightString <- generateParenthesis(n - m - 1)
        } yield "(" ++ leftString ++ ")" ++ rightString
    }
}

```

```scala
//Backtracking approach
//Memory limit exceeds from n=6
//works till n=5

object Solution {
    var output = scala.collection.mutable.Set.empty[String]
    var qualified = scala.collection.mutable.Set.empty[String]
    
    def isBalanced(chars: Array[Char]): Boolean = {
        var count = 0
        var flag = true
        var stack = scala.collection.mutable.Stack[Char]()
        
        stack.pushAll(chars)
        
        import scala.util.control.Breaks._
        
        breakable{
            while(!stack.isEmpty){
                val pop = stack.pop()
                if(count <= 0 && pop == '('){
                    flag = false
                    break
                }else if(pop == ')'){
                    count += 1
                }else{
                    count -= 1
                }
            }
        }
         
        if(flag && count == 0){
            true
        }else{
            false
        }
    }
    
    def backtrack(chars: Array[Char], l: Int, r: Int): Unit = {
        
        def swap(a: Int, b: Int) = {
            val temp = chars(a)
            chars(a) = chars(b)
            chars(b) = temp
        }
        
        
        if(l == r){
            val str = chars.mkString
            if(! qualified.contains(str)){
                qualified.add(str)
                if(isBalanced(chars)){
                    output.add(str)
                }
            }
        }else{
                (l to r).map(i => {
                swap(l, i)
                backtrack(chars, l+1, r)
                swap(l, i) //backtrack step
                })
        }
    }
    
    def generateParenthesis(n: Int): List[String] = {
        output = scala.collection.mutable.Set.empty[String]
        qualified = scala.collection.mutable.Set.empty[String]
        
        val inputString = (1 to n).map(_ => '(').mkString + (1 to n).map(_ => ')').mkString
        var inputCharArray = inputString.toCharArray
        
        backtrack(inputCharArray, 0, n+n-1)
        
        output.toList
    }
}


/**
In the above approach, what we are basically doing is getting all possible combinations and then filtering the ones that are balanced.
that is kinda brute force actually
In the below approach (also backtracking), we apply constraints, during forming the string itself
*/

object Solution {
    
    def generateParenthesis(n: Int): List[String] = {
        import scala.collection.mutable._
        def backtrack(acc: ListBuffer[String], curr: String, left: Int, right: Int): Unit = {
            if (left == 0 && right == 0) acc.append(curr)
            else {
                if (left > 0) backtrack(acc, curr + "(", left-1, right)
                if (right > left) backtrack(acc, curr + ")", left, right-1)
            }
        }
      
        val acc = ListBuffer[String]()
        backtrack(acc, "", n, n)
        acc.toList
    }
}

```

###  3.22. <a name='MergekSortedLists'></a>23. Merge k Sorted Lists

[花花酱](https://www.bilibili.com/video/BV1X4411u7xF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1178e?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK41157mu?spm_id_from=333.999.0.0)

暴力求解法：

* 时间复杂度: O(N) + O(N logN) + O(N)

* 空间复杂度: O(N) + O(N)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.65tcjjz2oy80.png" width="50%">

```py
# so easy，一遍过
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        arr = []
        for listhead in lists:
            while listhead:
                arr.append(listhead.val)
                listhead = listhead.next
        arr.sort()
        dummy = ListNode(0)
        cur = dummy
        for value in arr:
            cur.next = ListNode(value)
            cur = cur.next
        return dummy.next
```

优先队列：

* 时间复杂度: O(N logk) 

* 空间复杂度: O(N) + O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3tftyqf2g4s0.png" width="50%">

```py
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        q = []  # 易错点：先要定义一个空
        dummy = ListNode(0)
        cur = dummy
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(q,(lists[i].val,i))  # 易错点：要可以排序的
                lists[i] = lists[i].next # 易错点：注意，向后一位
        while q: # 易错点：注意这个循环条件
            val, idx = heapq.heappop(q)
            cur.next = ListNode(val)
            cur = cur.next
            if lists[idx]:
                heapq.heappush(q,(lists[idx].val,idx))
                lists[idx] = lists[idx].next # 易错点：注意，向后一位
        return dummy.next
```

两两合并：

* 时间复杂度: O(N logk) 

* 空间复杂度: O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.60itjgowwpo0.png" width="50%">

```py
class Solution:
    def merge2Lists(self, list1, list2):
        dummy = ListNode(0)
        cur = dummy # dummy是固定节点，cur是移动指针
        while list1 and list2: # 这里是and
            if list1.val < list2.val: # 易错点：这里是list.val，而不是list
                cur.next = list1
                list1 = list1.next # 向后进一位
            else:
                cur.next = list2
                list2 = list2.next # 向后进一位
            cur = cur.next # 向后进一位
        cur.next = list1 or list2 # 易错点：这里是cur.next，而不是cur。这里是or
        return dummy.next

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:     
        amount = len(lists)
        interval = 1
        while amount > interval:
            for i in range(0,amount-interval,2*interval):
                lists[i] = self.merge2Lists(lists[i], lists[i+interval]) # 易错点：方括号和小括号不要用错
            interval *= 2
        return lists[0] if amount>0 else None
```

###  3.23. <a name='SwapNodesinPairs'></a>24-Swap Nodes in Pairs

[哈哈哈](https://www.bilibili.com/video/BV1M7411n7FT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV13J411V7hG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ih411f7YK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1VC4y1s75E?spm_id_from=333.999.0.0)

```py
# 方法一：递归
class Solution(object):
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # 这样写也可以：
        # if not head or not head.next:
        #     return head
        if not head:
            return None
        if not head.next:
            return head
        tmp = head.next
        head.next = self.swapPairs(head.next.next)
        tmp.next = head
        return tmp # 易错点：注意，新的头已经变成了tmp
``` 

```py
# 方法二：迭代
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head # 易错点：这句话不要漏
        cur = dummy
        while cur.next and cur.next.next:

            first = cur.next
            second = cur.next.next
            
            # 把图画出来
            first.next = second.next
            second.next = first
            cur.next = second

            cur = cur.next.next
        return dummy.next
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */

/**
* chosen solution
* iterative version
* memo
*   1. dummyHead
*   2. need two pointer: pre node and current node
*  time complexity: O(N), each node only visit once
*/
object Solution0 {
    def swapPairs(head: ListNode): ListNode = {
        val nHead = new ListNode(0, head)
        var pre: ListNode  = nHead
        var curr = pre.next

        while (curr != null && curr.next != null) {
            val (pos1, pos2, next) = (curr, curr.next, curr.next.next)
            pre.next = pos2
            pos2.next = pos1
            pos1.next = next

            pre = pre.next.next
            curr = pre.next  
        }
        
        nHead.next
    }
}


/**
* iterative version
* memo
*   1. dummyHead
*   2. need two pointer: pre node and current node
*  time complexity: O(N), each node only visit once
*/
object Solution1 {
    def swapPairs(head: ListNode): ListNode = {
        val nHead = new ListNode(0, head)
        var pre: ListNode  = nHead
        var curr = pre.next

        while (curr != null && curr.next != null) {
            val (pos1, pos2, next) = (curr, curr.next, curr.next.next)
            pre.next = pos2
            pos2.next = pos1
            pos1.next = next

            pre = pre.next.next
            curr = pre.next  
        }
        
        nHead.next
    }
}


/**
* recursive version
*/
object Solution2 {
    def swapPairs(head: ListNode): ListNode = {
        _swap(head)
    }   
    
    def _swap(n: ListNode): ListNode = {
        if(n == null) n
        else {
            (n, n.next) match {
                case (a, null) => a
                case (a: ListNode, b: ListNode) => 
                    /** a b 要交換位子
                     */
                    a.next = _swap(b.next) // a 指向 b 的 next (已交換完成）
                    b.next = a // b 的 next 接上 a 就交換完成
                    b
            }
        } 
    }
}
```

###  3.24. <a name='Removeduplicatesfromsortedarray'></a>26-Remove duplicates from sorted array

[哈哈哈](https://www.bilibili.com/video/BV1UJ411m7Pz?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i77e?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV13V41177Mq?spm_id_from=333.999.0.0)

> for循环法：

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if n == 0: return 0
        left = 0
        for right in range(1, n):
            if nums[right] != nums[left]:
                left += 1
                nums[left] = nums[right]
        return left + 1

# 😁我的模仿
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        count = 0 #注意：count是从0开始的
        for i in range(len(nums)):
            if nums[i] != nums[count]:
                count += 1
                nums[count] = nums[i]
        return count + 1
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.xxd39w8j94g.png" width="30%">

> while循环法

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i = 0
        while i < (len(nums) - 1):
            if nums[i] == nums[i+1]:
                nums.remove(nums[i])
                等效于：nums.pop(i)
            else:
                i += 1
        return len(nums)

# 😁我的模仿：
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        while i < len(nums) - 1:
            if nums[i] == nums[i+1]:
                nums.pop(i)
                i -= 1 # 当pop以后，i指针不应该变化
            i += 1
        return len(nums)
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6zs7v6d4w740.png" width="60%">

```scala

object Solution {
    def removeDuplicates(nums: Array[Int]): Int = {
        
        // Two-pointer idea
        
        if (nums.length == 0){
            0
        } else {
            // if the Array is not empty, we start from index 1 rather than 0
            // since the 1st element (at index 0) will be included for sure.
            // For the same reason, the initial value of `count` is 1 instead of 0
            
            var count = 1
            
            // NOTE: start from 1 rathr than 0 here
            for (i <- 1 until nums.length) {
                if (nums(i) != nums(count-1)) {
                    nums(count) = nums(i)
                    count += 1
                }
            }
            
            count
        }
         
    }
}
```

```scala
object Solution {
    def removeDuplicates(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var head = 0
            var find = 1
            while(find < nums.length){
                if(nums(find) != nums(head)){
                    head += 1
                    nums(head) = nums(find)
                }
                find += 1
            }
            head + 1
        }
    }
}

```

###  3.25. <a name='python-Removeelement'></a>27-python-Remove element

[哈哈哈](https://www.bilibili.com/video/BV1mJ411m7ir?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7hZ?spm_id_from=333.999.0.0)

和上面一体差不多，很简单

```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        while i < len(nums):
            if nums[i] == val:
                nums.pop(i)
            else:
                i += 1
        return len(nums)
```

###  3.26. <a name='Implementstr'></a>28-Implement str

[哈哈哈](https://www.bilibili.com/video/BV1eL411n7YS?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1BJ41117d6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1UK411K7zB?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7cG?spm_id_from=333.999.0.0)

解法一：直接用.index()

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "":
            return 0
        if needle in haystack:
            return haystack.index(needle)
        else:
            return -1
```

解法二：在对整个needle字符串比较

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        for i in range(len(haystack)-len(needle)+1):
            if haystack[i:i+len(needle)] == needle:
                return i 
        return -1
```

```scala
object Solution {
    def strStr(haystack: String, needle: String): Int = {
        if(needle.isEmpty){
            0
        }else if(haystack.isEmpty){
            -1
        }else{
            var needleLength = needle.length
            var head = 0
            var end = head + needleLength
            var flag = true
            
            while(flag && (end <= haystack.length)){
                if(needle.equals(haystack.substring(head, end))){
                    flag = false
                }else{
                    head += 1
                    end += 1
                }
            }
            
            if(flag) -1 else head
        }
    }
}

```

###  3.27. <a name='NextPermutation'></a>31 Next Permutation

[小明](https://www.bilibili.com/video/BV1Uz4y1m72N?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1SK4y1V7ch?spm_id_from=333.999.0.0)

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # 关键在于从后往前，找到非递减序列
        i = len(nums) - 2
        while i >= 0:
            if nums[i] >= nums[i+1]:
                i -= 1
            else:
                # 寻找i后面比i大的数，交换位置,并且排序
                for j in range(len(nums)-1,i,-1): # 易错点:len(nums)-1,i的区间
                    # 12(3)5(4)
                    if nums[j] > nums[i]:
                        nums[i],nums[j] = nums[j],nums[i]
                        nums[i+1:] = sorted(nums[i+1:])
                        return
        nums.reverse() # 易错点:对于[3,2,1]这种情况，i = 0
```

```scala
/**
* my first commitment
* memo
* 1. find the first index i which breaks the increasing order
* 2. find the last index  j which is larger than index i
* 3. swap(i, j)
* 4. sorting: reverse sequence from i + 1 to the end 
* time complexity: O(n)
*/

object Solution1 {
    def nextPermutation(nums: Array[Int]): Unit = {
        /**
        * find the first index i which breaks the increasing order
        * 0 1 2 3 4 5 6
        * 5 4 7 6 5 4 3
        *   i     j 
        */
      ((nums.length - 2) to 0 by -1).find(idx => nums(idx) < nums(idx + 1)) match {
        case Some(idx) => 
          /* 
          * find the last index  j which  is larger than index i
          */
          val j = ((idx + 1) until nums.length).findLast(i => nums(idx) < nums(i)).getOrElse(idx)
          swap(nums, idx, j)
          reverse(nums, idx + 1, nums.length - 1)
        case None => reverse(nums, 0, nums.length - 1)
      }
    }
    @annotation.tailrec
    def reverse(nums: Array[Int], from: Int, to: Int) {
      if (from < to) {
        swap(nums, from, to)
        reverse(nums, from + 1, to - 1)
      }
    }
  
    def swap(nums: Array[Int], index1: Int, index2: Int) {
      val tmp = nums(index2)
      nums(index2) = nums(index1)
      nums(index1) = tmp
    }
}


```

###  3.28. <a name='LongestValidParentheses'></a>32 Longest Valid Parentheses

[小明](https://www.bilibili.com/video/BV1RZ4y1F7nJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1yi4y1G74d?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n) 

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6dkova4yjvk0.png)

```py
# 背一背吧，好难。
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0]*n
        if n == 0: return 0
        for i in range(n):
            if s[i] == ')' and s[i-dp[i-1]-1] == '(' and i - dp[i-1] - 1 >= 0:
                dp[i] = 2 + dp[i-1] + dp[i-dp[i-1]-2]
        return max(dp)
```

栈：

* 时间复杂度: O(n) 

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1dgqk0ervhb4.png)

```py
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = maxlength = 0
        for i,c in enumerate(s):
            if c == '(':
                stack.append(i)
            if c == ')':
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    length = i - stack[-1]
                    maxlength = max(maxlength,length)
        return maxlength

```

```scala



/**
* using stack to record the char index in oder to calculate the valid length
* memo:
* 1. always only have one invalid symbol at stack and its position index is 0
* time complexity O(n)
* space complexity O(n)
*/
object Solution1 {

  import collection.mutable

  def longestValidParentheses(s: String): Int = {
    val mapping = Map('(' -> ')')
    val stack = mutable.Stack[Int]()
    stack.push(-1)
    s.indices.foldLeft(0) {
      case (maxLength, idx) =>
        val char = s(idx)
        if (mapping.contains(char)) {
          stack push idx
          maxLength
        } else {
          stack.pop()
          if (stack.isEmpty) {
            stack push idx
            maxLength
          } else {
            (idx - stack.head) max maxLength
          }
        }
    }
  }
}
```

###  3.29. <a name='SearchinRotatedSortedArray'></a>33. Search in Rotated Sorted Array

[小梦想家](https://www.bilibili.com/video/BV1gJ411V7Sq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV14t4y127hK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16A41147Fp?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # 定义第一个元素和最后一个元素
        left, right = 0, len(nums) - 1
        while left <= right:
            # 找到二分的位置：
            # mid = l + ((r - l) >> 2)
            # mid = (l + r) // 2
            mid = (right + left) // 2
            # 第一步
            if nums[mid] == target:
                return mid

            # --------------第二步：核心代码--------------
            # 只存在一个上升序列
            if nums[mid] < nums[right]:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            # --------------第二步：核心代码--------------
        return -1

# 我的模仿！啊😋

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1

        while l <= r:
            m = (l+r) // 2
            if nums[m] == target:
                return m
            if nums[l] <= nums[m]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else: 
                    l = m + 1
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else: 
                    r = m - 1
        
        return -1
```

```py
# 这道题简直是在跟我开玩笑（狗头）

class Solution(object):
    def search(self, nums, target):
        return nums.index(target) if target in nums else -1
```

```scala


/**
* my first commitment
* binary search
* memo
* 1. check if it is sorted side first. if side is sorted, using the normal binary search function , or else using the search function 
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
        search(nums, target, 0 , nums.length - 1)
    }
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      
      val mid = left + (right - left) / 2
      val midValue = nums(mid)
      
      if (midValue == target) return mid
      
      val leftAns = if (nums(left) < midValue)  
        searchOrder(nums, target, left, mid - 1)
      else 
        search(nums, target, left, mid - 1)
      
      if (leftAns != -1) 
        leftAns
      else {
        if (midValue < nums(right))
           searchOrder(nums, target, mid + 1, right)
        else
          search(nums, target, mid + 1, right)
      } 
    }
  
    def searchOrder (nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      val mid = left + (right - left) / 2
      val midValue = nums(mid)
      if (midValue == target) 
       mid
      else if (target > midValue)
        searchOrder(nums, target, mid + 1, right)
      else 
        searchOrder(nums, target, left, mid - 1)
    }
}


/**
* binary search - iterative version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      
      var ans = -1
      while(ans == -1 && left <= right) {
        val mid = left + (right - left) / 2

        if (target == nums(mid) ){
          ans = mid

        } else if (nums(left) <= nums(mid)){ // left part is in order
          if (nums(mid) > target && target >= nums(left)) { // target is in left part
            right = mid - 1
          } else {
            left = mid + 1
          }
        } else { // right part is in order
          if (nums(mid) < target && target <= nums(right)) { // target is in right part
            left = mid + 1
          } else {
            right = mid - 1
          }
        } 
      }
      ans
    }
}


```

###  3.30. <a name='-1'></a>34-在排序数组中查找元素的第一个

[哈哈哈](https://www.bilibili.com/video/BV1Zv411y71t?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1GU4y1j7dq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ef4y1v7Vz?spm_id_from=333.999.0.0)

```py
# Python 二分法

class Solution:
    def searchRange(self, nums, target):
        left = 0
        right = len(nums)-1
        res = [0,0]
        
        if target not in nums:
            return [-1,-1]

        # 寻找左侧边界
        while(left<=right):
            mid = (right + left) // 2
            if nums[mid] == target:
                right = mid - 1 # 结束条件
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[0] = left

        # 寻找右侧边界
        right = len(nums)-1
        while left<=right:
            mid = (right + left) // 2
            if nums[mid] == target:
                left = mid + 1 # 结束条件
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[1] = right

        return res
```

```py
# 二分搜索算法返回首个不小于（即：等于或大于）target的元素的下标，这样只需进行两次相似的二分搜索即可

# 这种方法很漂亮，但是很容易出错，不推荐。

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = self.binarySearch(nums, target)
        end = self.binarySearch(nums, target+1)
        if start < end:
            return [start,end-1]
        else:
            return [-1,-1]
    
    def binarySearch(self, nums, target):
        l = 0
        r = len(nums)  # 精华,千万不能-1，
        while l < r: # 精华,千万不能包括==，
            m = (l + r) // 2
            # 由于这里存在多个重复数字，所以简单的二分查找不顶用
            # 这里的思想是找到left
            if target > nums[m]: # 精华,千万不能包括==，不然left不能移动
                l = m + 1 # 精华
            else:
                r = m
        return l

```

```scala


/**
* my first commitment
*
*/
object Solution1 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val hit = search(nums, target, 0, nums.length - 1)
      if (hit == -1)
        Array(-1, -1)
      else  {
        var left = hit
        while (left - 1 >= 0 && nums(left) == nums(left - 1)){
          left -= 1
        }
        var right = hit
        while(right + 1 < nums.length && nums(right) == nums(right + 1)){
          right += 1
        }
        Array(left, right)
      }
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if (left > right) return -1
      
      val mid = left + (right - left) / 2
       
      if (nums(mid) == target)
        mid
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1)
      else 
        search(nums, target, mid + 1, right)
      
      
    }
 }

/**
* function programming
*/

 object Solution1-2 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val hit = search(nums, target, 0, nums.length - 1)
      if (hit == -1)
        Array(-1, -1)
      else {
        val left = (hit to 0 by -1 ).findLast(l => nums(l) == nums(hit)).getOrElse(-1)
        val right = (hit to (nums.length - 1)).findLast(r => nums(r) == nums(hit)).getOrElse(-1)
        Array(left, right)
      } 
    }
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if (left > right) return -1
      val mid = left + (right - left) / 2
       
      if (nums(mid) == target)
        mid
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1)
      else 
        search(nums, target, mid + 1, right)
    }
 }

/**
* modify binary search template
* memo
*  1. search first and last the the same function
*  2. if nums(mid) == target we could move left to check if left part exists target number
*  3. finding last by target + 1,  then we could get last position of target by first position of (target + 1) - 1
* tricky:
*  1. ans = nums.length
*  2. first > last  means that target doesn't exists
*
* time complexity: O(2logN)
*/
 
 object Solution2 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
        val first = search(nums, target)
        val last = search(nums, target + 1) - 1
        if (first > last) Array(-1, -1) else Array(first, last)
    }

    def search(nums: Array[Int], target: Int): Int = {
      var ans = nums.length
      var left = 0
      var right = nums.length - 1
      while (left <= right) {
        val mid = left + (right - left) / 2
        if (nums(mid) >= target) {
          ans = mid
          right = mid - 1
        }else {
          left = mid + 1
        } 
      }
      ans
    }
}

/**
* recursive version
*/
object Solution2-1 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
      val first = search(nums, target, 0, nums.length - 1, nums.length)
      val last = search(nums, target + 1, 0, nums.length - 1, nums.length) - 1
      if (first > last) Array(-1, -1) else Array(first, last)
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int, ans: Int): Int = {
      if (left > right) return ans
      val mid = left + (right - left) / 2
      
      if (nums(mid) == target)
        search(nums, target, left, mid - 1, mid)
      else if (nums(mid) > target)
        search(nums, target, left, mid - 1, mid)
      else
        search(nums, target, mid + 1, right, ans)
      
    }
}

```

###  3.31. <a name='-1'></a>35-搜索插入位置

[哈哈哈](https://www.bilibili.com/video/BV1HD4y1m7U2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411i7Aj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1dA411a7CB?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1wf4y1m7Ue?spm_id_from=333.999.0.0)

* 时间复杂度: O(logn) 

* 空间复杂度: O(1)

```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if target == nums[m]:
                return m
            elif target < nums[m]:
                r = m - 1
            else: 
                l = m + 1
        return l #易错点：记住，这里需要输出，且输出left
```

```scala

/**
* my first commitment
*/
object Solution1 {
    def searchInsert(nums: Array[Int], target: Int): Int = {
        search(nums, target)
    }
    
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        val mid = left + (right - left) / 2
        
        if (nums(mid) == target)
          ans = mid
        else if (nums(mid) > target)
          right = mid - 1
        else
          left = mid + 1
        
      }
      if (ans == -1) left else ans
    }
}
```

###  3.32. <a name='-1'></a>36-有效的数独

[哈哈哈](https://www.bilibili.com/video/BV1Cf4y1R7PR?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1MJ411p7FT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ZL4y1e7oo?spm_id_from=333.999.0.0)

```py
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        cols = [set() for _ in range(9)]
        rows = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if board[i][j] in cols[j] or \
                    board[i][j] in rows[i] or \
                    board[i][j] in grids[i//3][j//3]:
                        return False
                    else:
                        cols[j].add(board[i][j])
                        rows[i].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])
        return True
```

```scala
object Solution {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        
        
        import util.control.Breaks._
        
        def check_a_single_array(l: Array[Char]): Boolean = {
            // input: Array of char, an Array of 9 elments to check using the three rules
            // return: Boolean, if the array given can pass the exam
            val temp = l.filter(_ != '.')
            if (temp.length != temp.distinct.length) {
                false
            } else {
                true
            }
        }
        
        
        var error_flag = 0
        
        breakable {
            
            // check rule-1
            for (i <- 0 until 9) {
                if (check_a_single_array(board(i)) ==  false) {
                    error_flag += 1
                    break
                }
              }

            // check rule-2
            for (i <- 0 until 9) {
                val temp_list = board.map(_(i))
                
                if (check_a_single_array(temp_list) == false) {
                    error_flag += 1
                    break
                }
            }
            
            // check rule-3
            for (i <- 0 until 3; j <- 0 until 3) {
                // get each 3x3 sub-boxes and flatten it to a 9-length Array
                val temp_list = board.slice(i * 3, i * 3 + 3).flatMap(_.slice(j * 3, j*3 + 3))
                
                if (check_a_single_array(temp_list) == false) {
                    error_flag += 1
                    break
                }
            }
 
        }

 
        if (error_flag > 0) false else true
         
    }
}
```

```scala

/**
* chosen solution
* memo
*   1. three array recording whether current value is valid
*        1. rows array
*        2. columns array
*        3. blocks array
* time complexity: O(1), just one iteration
* space complexity: O(3), all sudoku are 9 x 9 
*/
object Solution0 {
  def isValidSudoku(board: Array[Array[Char]]): Boolean = {
      val size = board.length
      val rows = Array.ofDim[Boolean](size, size)
      val cols =  Array.ofDim[Boolean](size, size)
      val blocks =  Array.ofDim[Boolean](size, size)
      
      val coords = for(i <- board.indices.view; j <- board.indices.view; if board(i)(j) != '.') yield (i, j)
      
      coords.forall{ case (i, j) => 
          val num = board(i)(j).asDigit - 1
          val blockIdx = (i / 3) * 3 + (j / 3)
          if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
            rows(i)(num) = true
            cols(j)(num) = true
            blocks(blockIdx)(num) = true
            true
        
          } else false
      }
  }
}

  
  /**
  *  recursive version : DFS
  *  memo
  *    1. three array recording whether current value is valid
  *        1. rows array
  *        2. columns array
  *        3. blocks array
  * time complexity: O(1), just one iteration
  * space complexity: O(3), all sudoku are 9 x 9
  */
  object Solution1 {

    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
      def _isValidSudoku(currentRow: Int, currentCol: Int, cols: Array[collection.mutable.Set[Char]], rows: Set[Char], blocks: Array[collection.mutable.Set[Char]]): Boolean = {
        (currentRow < board.length, currentCol < board.length) match {
          case (false, _) => true
          case (true, true) => // current line next position
            val v = board(currentRow)(currentCol)
            val blockIndex = 3 * (currentRow / 3) + currentCol / 3
            if (v == '.') {
              _isValidSudoku(currentRow, currentCol + 1, cols, rows, blocks)

            } else {
              if (cols(currentCol).contains(v) || rows.contains(v) || blocks(blockIndex).contains(v)) {
                false
              }
              else {
                blocks(blockIndex) += v
                cols(currentCol) += v
                _isValidSudoku(currentRow, currentCol + 1, cols, rows + v, blocks)
              }
            }
          case (true, false) => _isValidSudoku(currentRow + 1, 0, cols, Set[Char](), blocks) // next line
        }
      }
      _isValidSudoku(0, 0, Array.fill(board.length)(collection.mutable.Set[Char]()), Set[Char](), Array.fill(board.length)(collection.mutable.Set[Char]()))
    }

  }



/**
* iterative
* memo
*   1. three array recording whether current value is valid
*        1. rows array
*        2. columns array
*        3. blocks array
* time complexity: O(1), just one iteration
* space complexity: O(3), all sudoku are 9 x 9
*/
object Solution2 {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        val rows = Array.ofDim[Boolean](board.length, board.length)
        val cols = Array.ofDim[Boolean](board.length, board.length)
        val blocks = Array.ofDim[Boolean](board.length, board.length)
        var result = true
        for {
            (row, rowIndex) <- board.zipWithIndex
            (v, colIndex) <- row.zipWithIndex
            if result
        } {
            if (v != '.') {
            val blockIndex = 3 * (rowIndex / 3) + (colIndex / 3)
            val value = v.asDigit - 1
            if (rows(rowIndex)(value) || cols(colIndex)(value) || blocks(blockIndex)(value)) {
                result = false
            } else {
                rows(rowIndex)(value) = true
                cols(colIndex)(value) = true
                blocks(blockIndex)(value) = true
            }
            }

        }
            result
        }
}

/**
* it's no need for zipWithIndex: faster
*/
object Solution2-2 {
  def isValidSudoku(board: Array[Array[Char]]): Boolean = {
    val size = board.length
    val rows = Array.ofDim[Boolean](size, size)
    val cols =  Array.ofDim[Boolean](size, size)
    val blocks =  Array.ofDim[Boolean](size, size)


    var result = true
    for(i <- 0 until size; j <- 0 until size; if board(i)(j) != '.' && result) {
       val num = board(i)(j).asDigit - 1
       val blockIdx = (i / 3) * 3 + (j / 3)
      if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
          rows(i)(num) = true
          cols(j)(num) = true
          blocks(blockIdx)(num) = true
          
      }else {
          result = false
      }

    }
    result
  }
}

/**
* function programming way without key word return in loop block
*/

object Solution2-3 {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        val size = board.length
        val rows = Array.ofDim[Boolean](size, size)
        val cols =  Array.ofDim[Boolean](size, size)
        val blocks =  Array.ofDim[Boolean](size, size)
        
        val coords = for(i <- board.indices.view; j <- board.indices.view; if board(i)(j) != '.') yield (i, j)
        
        coords.forall{ case (i, j) => 
            val num = board(i)(j).asDigit - 1
            val blockIdx = (i / 3) * 3 + (j / 3)
            if(!rows(i)(num) && !cols(j)(num) && !blocks(blockIdx)(num)){
              rows(i)(num) = true
              cols(j)(num) = true
              blocks(blockIdx)(num) = true
              true
          
            } else false
        }
    }
}


```

###  3.33. <a name='SudokuSolver'></a>37. Sudoku Solver 解数独

[花花酱](https://www.bilibili.com/video/BV1Tt41137Xr?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1f5411h7er?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3k462gpgb5k0.png)

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if  board[i][j] not in rows[i] and \
                        board[i][j] not in cols[j] and \
                        board[i][j] not in grids[i//3][j//3]:
                        rows[i].add(board[i][j])
                        cols[j].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])

        def dfs(i,j):
            if board[i][j] != '.': # 被数字填满

                if i == 8 and j == 8:
                    self.flag = True
                    return
                if j < 8:
                    dfs(i,j+1)
                if j == 8:
                    dfs(i+1,0)
                    
            else:
                for num in range(1,10):
                    item = str(num)
                    if  item not in rows[i] and \
                        item not in cols[j] and \
                        item not in grids[i//3][j//3]:
                        board[i][j] = item
                        rows[i].add(item)
                        cols[j].add(item)
                        grids[i//3][j//3].add(item)

                        # 易错点:注意缩进关系
                        if i == 8 and j == 8:
                            self.flag = True
                            return
                        if j < 8:
                            dfs(i,j+1)
                        if j == 8:
                            dfs(i+1,0)
                        if self.flag:
                            return
                            
                        board[i][j] = '.'
                        rows[i].remove(item)
                        cols[j].remove(item)
                        grids[i//3][j//3].remove(item)

        self.flag = False
        dfs(0,0)

```

```scala
/**
* chosen solution
* DFS + pruning + queue
* time complexity: O(N^2)
*/

object Solution0 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val coords = for(i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)
    if (!solveSudoku(board.map(_.clone), coords, board))
      println("cannot solve under this condition")
  }

  private def solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)] , ansBoard: Array[Array[Char]]): Boolean = {
    coordQueue match {
      case coord :: newQueue if coordQueue.nonEmpty =>
        ('1' to '9').filter(isValid(board, coord, _)).exists{ char =>
          board(coord._1)(coord._2) = char
          val ret = solveSudoku(board, newQueue, ansBoard)
          board(coord._1)(coord._2) = '.'
          ret
        }
      case _ if coordQueue.isEmpty =>
        board.zipWithIndex.foreach{case (arr: Array[Char], idx: Int) => ansBoard(idx) = arr.clone()}
        true
      case _ =>
        false
    }
  }

  private def isValid(board: Array[Array[Char]], coord: (Int, Int), value: Char): Boolean = {
    val (rowIdx, colIdx) = coord
    val rowValid = ! board(rowIdx).contains(value)
    val columnValid = board.forall(row => row(colIdx) != value)
    val blockValid = generateBlockIdx(rowIdx, colIdx) forall  {case (r, c) => board(r)(c) != value}

    rowValid && columnValid && blockValid
  }

  private def generateBlockIdx(rowIdx: Int, colIdx: Int): Iterator[(Int, Int)] = {
    val blockRowIdx = (rowIdx / 3) * 3
    val blockColIdx = (colIdx / 3) * 3
    for(i <- (blockRowIdx until blockRowIdx + 3).toIterator ; j <- blockColIdx until blockColIdx + 3) yield (i,j)
  }
}



/**
* my first commitment
* DFS + pruning
*/
object Solution1 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    _solveSudoku(board)
  }
  def _solveSudoku(board: Array[Array[Char]]): Boolean = {

    for {
      (rows, rowIdx) <- board.zipWithIndex
      (v, colIdx) <- rows.zipWithIndex
    } {
      if (v == '.') {
        for (c <- '1' to '9') {

          if (_isValid(rowIdx, colIdx, c, board)) {
            board(rowIdx)(colIdx) = c
            if (_solveSudoku(board)) return true
            else board(rowIdx)(colIdx) = '.'
          }
        }
        return false
      }
    }
    true
  }

  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || board.slice(boardRowIndex, boardRowIndex + 3).map(_.slice(boardColIndex, boardColIndex + 3)).exists(r => r.contains(char))) false
    else true
  }
}



/**
*  DFS + pruning + queue
*  memo:
*    using a queue storing unfilled index
*/
object Solution1-2 {

  import scala.collection.immutable.Queue

  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val indexes = scala.collection.mutable.Queue[(Int, Int)]()
    for {
      (row, rowIdx) <- board.zipWithIndex
      (value, colIdx) <- row.zipWithIndex
    } {
      if (value == '.') {
        indexes.enqueue((rowIdx, colIdx))
      }
    }
    _solveSudoku(Queue(indexes.dequeueAll(_  => true): _*), board.map(_.clone()), board)
  }


  def _solveSudoku(indexes: Queue[(Int, Int)], currentBoard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    if (indexes.isEmpty) {
      // end condition
      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      true
    } else {
      val ((row, col), newIndexes) = indexes.dequeue
      ('1' to '9').filter(_isValid(row, col, _, currentBoard)).find ( c =>_solveSudoku(newIndexes, copyBoard(currentBoard)(row, col, c), finalBoard))
       match {
        case Some(_) => true
        case None => false
      }
    }

  }
  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val checkBoardExits = (rr: Int, cc: Int, c: Char) => {
      var result = false
      for {
        i <- 0 until 3
        j <- 0 until 3
        if !result
      } {
        if (board(i + rr)(j + cc) == c) result = true
      }
      result
    }
    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || checkBoardExits(boardRowIndex, boardColIndex, char)) {
      false
    } else {
      true
    }
  }

  val copyBoard = (b: Array[Array[Char]]) => (row: Int, col: Int, c: Char) => {
    val newB = b.map(_.clone())
    newB(row)(col) = c
    newB
  }
}


/**
*  DFS + pruning + queue
*/
object Solution1-3 {

  import scala.collection.immutable.Queue

  def solveSudoku(board: Array[Array[Char]]): Unit = {
    val indices = scala.collection.mutable.Queue[(Int, Int)]()

    for (i <- 0 until board.length; j <- 0 until board.length) {
      val v = board(i)(j)
      if (v == '.') indices.enqueue((i, j))
    }
    _solveSudoku(Queue(indices.dequeueAll(_ => true): _*), board.map(_.clone()), board)
  }


  def _solveSudoku(indices: Queue[(Int, Int)], currentBoard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    if (indices.isEmpty) {
      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      return true
    }

    val ((row, col), newIndices) = indices.dequeue
    ('1' to '9').filter(_checkValid(_, (row, col), currentBoard)).find { // find: 找出第一個合法數字，代表其後的迭代有解
      c =>
        currentBoard(row)(col) = c
        if (_solveSudoku(newIndices, currentBoard, finalBoard)) true
        else {
          currentBoard(row)(col) = '.'
          false
        }
    } match {
      case Some(_) => true
      case None => false  // 這個盤勢不管填什麼後續都無解
    }
  }

  def _checkValid(c: Char, index: (Int, Int), currentBoard: Array[Array[Char]]): Boolean = {
    val (row, col) = index
    val blockRowIdx = 3 * (row / 3)
    val blockColIdx = 3 * (col / 3)
    val checkBoard = (rowAnchar: Int, colAnchar: Int) => {
      val pairs = for (i <- 0 until 3; j <- 0 until 3) yield (rowAnchar + i, colAnchar + j)
      pairs.exists { case (i, j) => currentBoard(i)(j) == c }
    }
    if (currentBoard(row).contains(c) || currentBoard.exists(a => a(col) == c) || checkBoard(blockRowIdx, blockColIdx)) false
    else true
  }
}

/**
*  DFS + pruning + queue
*    improvement: isValid is more concise
*/
object Solution1-4 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    val coords = for(i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)
    if (!solveSudoku(board.map(_.clone), coords, board))
      println("cannot solve under this condition")
  }

  private def solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)] , ansBoard: Array[Array[Char]]): Boolean = {
    coordQueue match {
      case coord :: newQueue if coordQueue.nonEmpty =>
        ('1' to '9').filter(isValid(board, coord, _)).exists{ char =>
          board(coord._1)(coord._2) = char
          val ret = solveSudoku(board, newQueue, ansBoard)
          board(coord._1)(coord._2) = '.'
          ret
        }
      case _ if coordQueue.isEmpty =>
        board.zipWithIndex.foreach{case (arr: Array[Char], idx: Int) => ansBoard(idx) = arr.clone()}
        true
      case _ =>
        false
    }
  }

  private def isValid(board: Array[Array[Char]], coord: (Int, Int), value: Char): Boolean = {
    val (rowIdx, colIdx) = coord
    val rowValid = ! board(rowIdx).contains(value)
    val columnValid = board.forall(row => row(colIdx) != value)
    val blockValid = generateBlockIdx(rowIdx, colIdx) forall  {case (r, c) => board(r)(c) != value}

    rowValid && columnValid && blockValid
  }

  private def generateBlockIdx(rowIdx: Int, colIdx: Int): Iterator[(Int, Int)] = {
    val blockRowIdx = (rowIdx / 3) * 3
    val blockColIdx = (colIdx / 3) * 3
    for(i <- (blockRowIdx until blockRowIdx + 3).toIterator ; j <- blockColIdx until blockColIdx + 3) yield (i,j)
  }
}



object Solution2 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {

    _solveSudoku(0, 0, board.map(_.clone()), board)
  }

  def _solveSudoku(currentRow: Int, currentCol: Int, currenBboard: Array[Array[Char]], finalBoard: Array[Array[Char]]): Boolean = {
    (currentRow < finalBoard.length, currentCol < finalBoard.length) match {
      case (false, _) => // end condition
        currenBboard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
        true
      case (true, false) => // next line (row)
        _solveSudoku(currentRow + 1, 0, currenBboard, finalBoard)
      
      case (true, true) if currenBboard(currentRow)(currentCol) == '.' => 
        ('1' to '9').filter(c => _isValid(currentRow, currentCol, c, currenBboard))
          .find(c => _solveSudoku(currentRow , currentCol + 1, copyBoard(currenBboard)(currentRow, currentCol, c), finalBoard)) match { // fix row shift col
          case Some(_) => true
          case None => false
        }

      case _ => _solveSudoku(currentRow, currentCol + 1, currenBboard, finalBoard) // fix row, next col 
    }
  }

  val copyBoard = (b: Array[Array[Char]]) => (row: Int, col: Int, c: Char) => {
    val newB = b.map(_.clone())
    newB(row)(col) = c
    newB
  }

  def _isValid(row: Int, col: Int, char: Char, board: Array[Array[Char]]): Boolean = {

    val checkBoardExits = (rr: Int, cc: Int, c: Char) => {
      var result = false
      for {
        i <- 0 until 3
        j <- 0 until 3
        if !result
      } {
        if (board(i + rr)(j + cc) == c) result = true
      }
      result
    }
    val boardRowIndex = 3 * (row / 3)
    val boardColIndex = 3 * (col / 3)
    if (board(row).contains(char)
      || board.exists(r => r(col) == char)
      || checkBoardExits(boardRowIndex, boardColIndex, char)) {
      false
    } else {
      true
    }
  }

}


/**
* DFS + pruning + extra space
* using extra three two dimension array to store col row and block's information
* a mutable collection method
*/


object Solution4 {
  import scala.reflect.ClassTag
  import scala.collection.immutable.Queue
  def solveSudoku(board: Array[Array[Char]]): Unit = {
    val indexes = scala.collection.mutable.Queue[(Int, Int)]()
    val rows = Array.ofDim[Boolean](board.length, board.length)
    val cols = Array.ofDim[Boolean](board.length, board.length)
    val blocks = Array.ofDim[Boolean](board.length, board.length)
    for {
      (row, rowIdx) <- board.zipWithIndex
      (value, colIdx) <- row.zipWithIndex
    } {
      if (value == '.') {
        indexes.enqueue((rowIdx, colIdx))
      } else {
        val blockIdx = 3 * (rowIdx / 3) + (colIdx / 3)
        val v = value.asDigit - 1
        rows(rowIdx)(v) = true
        cols(colIdx)(v) = true
        blocks(blockIdx)(v) = true

      }

    }

    _solveSudoku( Queue(indexes.dequeueAll(_ => true): _*),
      rows,
      cols,
      blocks,
      board
    )

  }

  def _solveSudoku(indexes: Queue[(Int, Int)],
                   rows: Array[Array[Boolean]],
                   cols: Array[Array[Boolean]],
                   blocks: Array[Array[Boolean]],
                   currentBoard: Array[Array[Char]]
                  ): Boolean = {
    if (indexes.isEmpty) {
//      currentBoard.zipWithIndex.foreach { case (a, idx) => a.copyToArray(finalBoard(idx)) }
      true
    } else {
      val ((row, col), newIndexes) = indexes.dequeue
      ('1' to '9').filter(_isValid((row, col), _, rows, cols, blocks))
        .find { c =>
          val v = c.asDigit - 1
          rows(row).update(v, true)
          cols(col).update(v, true)
          blocks( 3 * (row / 3) + (col / 3)).update(v, true)
          currentBoard(row)(col) = c
          if (_solveSudoku(newIndexes,
            rows,
            cols,
            blocks,
            currentBoard
            //            copyBoard(rows)(row, v, true),
            //            copyBoard(cols)(col, v, true),
            //            copyBoard(blocks)(3 * (row / 3) + (col / 3), v, true),
            //            copyBoard(currentBoard)(row, col, c),
          //  finalBoard
          )) {
            true
          } else {
            rows(row).update(v, false)
            cols(col).update(v, false)
            blocks( 3 * (row / 3) + (col / 3)).update(v, false)
            currentBoard(row)(col) = '.'
            false
          }
        } match {
        case Some(_) => true
        case None => false
      }
    }
  }
  def _isValid(index: (Int, Int),
               char: Char,
               rows: Array[Array[Boolean]],
               cols: Array[Array[Boolean]],
               blocks: Array[Array[Boolean]]): Boolean = {


    val (row, col) = index
    val v = char.asDigit - 1
    val blockIdx = 3 * (row / 3) + (col / 3)

    if (rows(row)(v) || cols(col)(v) || blocks(blockIdx)(v)) false
    else true
  }

//  def copyBoard[T](b: Array[Array[T]])(row: Int, col: Int, c: T)(implicit ctg: ClassTag[T]): Array[Array[T]] = {
//    val newB = b.map(_.clone())
//    newB(row)(col) = c
//    newB
//  }
}

object Solution4-2 {
  def solveSudoku(board: Array[Array[Char]]): Unit = {
    /* three extra tables to record whether coordinate is occupied */
    val columns = Array.ofDim[Boolean](board.length, board.length)
    val rows = Array.ofDim[Boolean](board.length, board.length)
    /**
      * block index:
      *     1 2 3
      *     4 5 6
      *     7 8 9
      * convert (rowIndex, columnIndex) to blockIndex:  ( rowIndex / 3 ) * 3 + ( columnIndex / 3)
      */
    val blocks = Array.ofDim[Boolean](board.length, board.length)

    /* DFS worker*/
    def _solveSudoku(board: Array[Array[Char]], coordQueue: List[(Int, Int)], ans: Array[Array[Char]], checkValid: ((Int, Int), Char) => Boolean): Boolean = {
      coordQueue match {
          /* DFS not complete case : coordinate queue non empty */
        case coord :: newQueue if coordQueue.nonEmpty =>
          ('1' to '9').filter(checkValid(coord, _)).exists { char =>
            val (rowIdx, colIdx) = coord

            /* set board with char value by coordinate */
            board(rowIdx)(colIdx) = char
            rows(rowIdx)(char.asDigit - 1) = true
            columns(colIdx)(char.asDigit - 1) = true
            blocks((rowIdx / 3) * 3 + (colIdx / 3))(char.asDigit - 1) = true

            val ret = _solveSudoku(board, newQueue, ans, checkValid)

            /* recover to status before calling  _solveSudoku 
            *  reset board table, rows table, columns table and blocks table
            * */
            board(rowIdx)(colIdx) = '.'
            rows(rowIdx)(char.asDigit - 1) = false
            columns(colIdx)(char.asDigit - 1) = false
            blocks((rowIdx / 3) * 3 + (colIdx / 3))(char.asDigit - 1) = false
            ret
          }

          /* coordinate queue ran out, answer should shows up */
        case _ if coordQueue.isEmpty =>
          board.zipWithIndex.foreach { case (r, idx) => ans(idx) = r.clone }
          true

        case _ => false
      }
    }

    /* generate all empty coordinates */
    val coords = for (i <- board.indices.toList; j <- board.indices; if board(i)(j) == '.') yield (i, j)

    /* initial rows table, columns table, blocks table */
    for (i <- board.indices.toList; j <- board.indices; if board(i)(j) != '.') {
      val charIdx = board(i)(j).asDigit - 1  // index range from 0 to 9
      rows(i)(charIdx) = true
      columns(j)(charIdx) = true
      blocks((i / 3) * 3 + (j / 3))(charIdx) = true
    }
    val isValidFunc = isValid(_, _, rows, columns, blocks)

    _solveSudoku(board.map(_.clone), coords, board, isValidFunc)
  }

  /* check input char value is valid at the coordinate */
  def isValid(coord: (Int, Int), value: Char, rows: Array[Array[Boolean]], columns: Array[Array[Boolean]], blocks: Array[Array[Boolean]]): Boolean = {
    val (row, col) = coord
    val charIdx = value.asDigit - 1
    val blockIdx = (row / 3) * 3 + (col / 3)
    !rows(row)(charIdx) && !columns(col)(charIdx) && !blocks(blockIdx)(charIdx)
  }
}
```

###  3.34. <a name='Countandsay'></a>38-Count and say

[哈哈哈](https://www.bilibili.com/video/BV1QJ411R7MF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i717?spm_id_from=333.999.0.0)

```py
import itertools
class Solution:
    def countAndSay(self, n: int) -> str:
        res = '1'
        for _ in range(n-1):
            res = ''.join([str(len(list(g))) + k for k,g in itertools.groupby(res)])
        return res
```

```py
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1: 
            return '1'

        res = ''
        count = 1
        s = self.countAndSay(n-1)
        for i in range(len(s)):
            if i+1 < len(s) and s[i] == s[i+1]:
                count += 1
            else:
                res += str(count) + s[i]
                count = 1
        return res
```

```py
# 我的模仿😋

class Solution:
    def countAndSay(self, n: int) -> str:
        s = '1'
        for _ in range(n-1):
            tmp = ''
            count = 1  # 易错点：count的位置
            for j in range(len(s)):
                if j+1 < len(s) and s[j] == s[j+1]:
                    count += 1
                else:
                    tmp += str(count) + s[j]
                    count = 1  # 易错点：count重新置为1
            s = tmp
        return s
```

```scala
object Solution {
    def countAndSay(n: Int): String = {
        if(n == 1){
            "1"
        }else{
            val prev = countAndSay(n-1)
            val prevIntArray = prev.toCharArray.map(x => x - '0')
            
            var output = ""
            var count = 0
            if(!prevIntArray.isEmpty){
                var element = prevIntArray(0)
            
                for(elem <- prevIntArray){
                    if(elem == element){
                        count += 1
                    }else{
                        output = output + count + element
                        element = elem
                        count = 1
                    }
                }
                output = output + count + element
            }
            
            output
        }
    }
}


//Just using StringBuilder put the solution from 16% -> 93.5% in terms of time efficiency

object Solution {
    def countAndSay(n: Int): String = {
        if(n == 1){
            "1"
        }else{
            val prev = countAndSay(n-1)
            val prevIntArray = prev.toCharArray.map(x => x - '0')
            
            var output = new scala.collection.mutable.StringBuilder()
            var count = 0
            if(!prevIntArray.isEmpty){
                var element = prevIntArray(0)
            
                for(elem <- prevIntArray){
                    if(elem == element){
                        count += 1
                    }else{
                        output.append(count)
                        output.append(element)
                        element = elem
                        count = 1
                    }
                }
                output.append(count)
                output.append(element)
            }
            
            output.toString
        }
    }
}

```


###  3.35. <a name='CombinationSum39-'></a>39. Combination Sum 39-组合总和

[花花酱](https://www.bilibili.com/video/BV1gb411u7dy?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Wz411e79d?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12Z4y157nE?spm_id_from=333.999.0.0)

![Snipaste_2021-12-18_11-30-10](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/Snipaste_2021-12-18_11-30-10.5b1q5zh7t4w0.png)

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []

        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:]) 
                # 易错点，这里是res.append(path[:])，而不是res.append(path)
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    path.append(candidates[i])
                    dfs(i)
                    path.pop()
        dfs(0)
        return res
```

```scala
/**
* chosen solution - backtracking + dfs + pruning
* time complexity: O(N^target)
* space complexity: O(target)
*/

object Solution0 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(arr: Array[Int], idx: Int, currentSum: Int, list: List[Int], ans: mutable.ListBuffer[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += list
          return
        }
        val diff = target - currentSum
        (idx until arr.length).filter(i => arr(i) <= diff).foreach(i => dfs(arr, i, currentSum + arr(i), list :+ arr(i), ans)) 
      }
      
      val ans = mutable.ListBuffer.empty[List[Int]]
      
      dfs(candidates, 0, 0, List.empty, ans)
      ans.toList
        
    }
}

/**
* my first commitment: dfs - backtracking
*/

object Solution1-1 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(combination: List[Int], ans: mutable.Set[List[Int]]): Unit = {
        val currentSum = combination.sum
        
        if (currentSum == target) {
          ans += combination.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          candidates.filter(n => n <= diff).foreach{ case n => dfs(n :: combination, ans)}
        }
      }
      val ans = mutable.Set.empty[List[Int]]
      dfs(List.empty[Int], ans)
      ans.map(l => l.groupBy(identity).mapValues(_.length).toMap -> l).toMap.values.toList // distinct 
    }
}

/**
* optimize from 1-1: sort combination before appending to ans
*/
object Solution1-2 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(combination: List[Int], currentSum: Int, ans: mutable.Set[List[Int]]): Unit = {
        
        if (currentSum == target) {
          ans += combination.sorted.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          candidates.filter(n => n <= diff).foreach{ case n => dfs(n :: combination, currentSum + n, ans)}
        }
      }
      val ans = mutable.Set.empty[List[Int]]
      dfs(List.empty[Int], 0, ans)
      ans.toList
    }
}

/**
* optimize from 1-2: pruning some case- recording candidates array index i 
*/
object Solution1-3{
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(i: Int, combination: List[Int], currentSum: Int, ans: mutable.Set[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += combination.sorted.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          (i until candidates.length).filter(idx => candidates(idx) <= diff).foreach{ case idx => dfs(idx, candidates(idx) :: combination, currentSum + candidates(idx), ans)}
        }
      }
      
      val ans = mutable.Set.empty[List[Int]]
      dfs(0, List.empty[Int], 0, ans)
      ans.toList
    }
}

/**
* using ListBuffer instead of Set
* memo
* 1.candidates array should be in ascending order
* time complexity: O(N^target)
* space complexity: O(target)
*/
object Solution1-4 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(arr: Array[Int], idx: Int, currentSum: Int, list: List[Int], ans: mutable.ListBuffer[List[Int]]): Unit = {
        if (currentSum == target) {
          ans += list
          return
        }
        val diff = target - currentSum
        (idx until arr.length).filter(i => arr(i) <= diff).foreach(i => dfs(arr, i, currentSum + arr(i), list :+ arr(i), ans)) 
      }
      
      val ans = mutable.ListBuffer.empty[List[Int]]
      
      dfs(candidates, 0, 0, List.empty, ans)
      ans.toList
        
    }
}
```

```scala
package com.zhourui.leetcode
import scala.util.control.Breaks._
import scala.collection.mutable.Stack

package lc0039_combinationsum {
  object Solution {
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      var arr = candidates
      scala.util.Sorting.quickSort(arr)
      var ans = Vector[List[Int]]()
      var subset  = Stack[Int]()

      def helper(nums:Array[Int], start:Int, rest:Int): Unit = {
        if (rest == 0) {
          ans = ans :+ subset.toList
          return
        }
        breakable {
          for (i<- start until nums.length) {
            if (rest>=nums(i)) {
              subset.push(nums(i))
              helper(nums,i,rest-nums(i))
              subset.pop
            } else {
              break()
            }
          }
        }
      }
      helper(arr,0,target)
      ans.toList
    }
  }
}


```

###  3.36. <a name='CombinationSumII40-II'></a>40. Combination Sum II 40-组合总和 II

[花花酱](https://www.bilibili.com/video/BV1Pb411u7Yd?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gT4y1J7JE?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        candidates.sort()
        # candidates.reverse()
        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:])
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    # 易错点：需要剪枝
                    if i > firstIdx and candidates[i] == candidates[i-1]: continue
                    # [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]会超时
                    path.append(candidates[i])
                    dfs(i+1)
                    path.pop()
        dfs(0)
        return res
```

###  3.37. <a name='FirstMissingPositive'></a>41 First Missing Positive

[小明](https://www.bilibili.com/video/BV1fy4y1k7pV?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums.append(0)
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0 or nums[i] >= n:
                nums[i] = 0
        # for num in nums:
            # if num >= n or num <= 0:
            #     num = 0
            # 易错点：for num in nums,其中num只能进行读操作，不能进行写操作。
            # 容易出错
        
        for num in nums:
            nums[num % n] += n  
            # 易错点：% n,一定要取余数，不然会index out of range

        for i,num in enumerate(nums):
            if num < n:
                return i

        return n
```

###  3.38. <a name='TrappingRainWater'></a>42. Trapping Rain Water

[花花酱](https://www.bilibili.com/video/BV1hJ41177gG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fi4y1t7BP?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        
        n = len(height)
        leftMax = [height[0]] + [0] * (n - 1)
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])

        rightMax = [0] * (n - 1) + [height[n - 1]]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])

        ans = sum(min(leftMax[i], rightMax[i]) - height[i] for i in range(n))
        return ans
```

栈：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)
        
        return ans
```

双指针：

* 时间复杂度: O(n)

* 空间复杂度: O(1)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans

#   😋我的模仿

class Solution:
    def trap(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        leftmax = 0
        rightmax = 0
        res = 0
        while left < right:
            if height[left] < height[right]:
                leftmax = max(leftmax,height[left])
                # 易错点：注意res和left的次序：先res，后left
                res += leftmax-height[left] 
                left += 1
            else:
                rightmax = max(rightmax,height[right])
                # 易错点：注意res和right的次序：先res，后right
                res += rightmax-height[right]
                right -= 1
        return res
```

###  3.39. <a name='JumpGameII'></a>45 Jump Game II

[小明](https://www.bilibili.com/video/BV1fb4y1Z77x?spm_id_from=333.999.0.0)

```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        maxPos, end, step = 0, 0, 0
        for i in range(n - 1):
            if maxPos >= i:
                maxPos = max(maxPos, i + nums[i])
                if i == end:
                    end = maxPos
                    step += 1
        return step

#   😋我的模仿

class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        jump = 0
        cover = 0
        stop = 0
        i = 0
        while cover >= i and i < n-1: 
            #易错点：是n-1，不是n，只要调到最后一格就算成功
            cover = max(cover,i + nums[i])
            if i == stop:
                jump += 1
                stop = cover
            i += 1
        return jump
```

###  3.40. <a name='-1'></a>46-把数字翻译成字符串

[哈哈哈](https://www.bilibili.com/video/BV1Bz411i7cs?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411W7eC?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.66thg6sgm600.png)

```py
class Solution:
    def translateNum(self, num: int) -> int:
        s = str(num)
        n = len(s)
        dp = [1]*n
        if '10' <= s[0:2] <= '25':
            dp[1] = 2
        for i in range(2,n):
            if '10' <= s[i-1:i+1] <= '25':
                dp[i] = dp[i-1] + dp[i-2]
            else:
                dp[i] = dp[i-1]
        return dp[-1]
```

###  3.41. <a name='-1'></a>46-全排列

[哈哈哈](https://www.bilibili.com/video/BV1YA411v7zF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7fm?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oa4y1v7Kz?spm_id_from=333.999.0.0)

```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        # n = len(nums)
        def dfs(nums):
            # 易错点：if len(path) == n:
            if not nums: # 判断条件应该是这个
                res.append(path[:]) # 易错点：path[:]
                return
            else:
                for i in range(len(nums)):
                    path.append(nums[i])
                    dfs(nums[:i]+nums[i+1:]) # 易错点：n是不断变小的
                    path.pop()
        dfs(nums)
        return res

# 另一种写法😋
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def dfs(nums,path):
            if not nums: 
                res.append(path[:]) 
                return
            else:
                for i in range(len(nums)):
                    dfs(nums[:i]+nums[i+1:],path + [nums[i]]) 
        dfs(nums,[])
        return res
```

```scala
object Solution {
    var output = List.empty[List[Int]]
    
    def backtrack(nums: Array[Int], l: Int, r: Int): Unit = {
        def swap(a: Int, b: Int) = {
            val temp = nums(a)
            nums(a) = nums(b)
            nums(b) = temp
        }
        
        /**
        In backtracking, we collect all the leaf nodes of the tree
        In this question, we fix the first letter and swap the others till we reach (l==r), i.e. no swap needed since its the leaf node
        So we add it to output
        */
        
        if(l == r){
            output = output :+ nums.toList
        }else{
            (l to r).map(i => {
                swap(l, i)
                backtrack(nums, l+1, r)
                swap(l, i) //backtrack step
            })
        }
    }
    
    def permute(nums: Array[Int]): List[List[Int]] = {
        output = List.empty[List[Int]]
        var input = nums
        backtrack(input, 0, input.length - 1)
        output
    }
}

```

###  3.42. <a name='II-'></a>47-全排列 II-剪枝版

[哈哈哈](https://www.bilibili.com/video/BV1Ev411672A?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1qK4y1x7Qs?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1z54y1a7rQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        def dfs(nums,path):
            if not nums:
                res.append(path[:])
            else:
                for i in range(len(nums)):
                    if i>0 and nums[i] == nums[i-1]:
                        continue
                    dfs(nums[:i]+nums[i+1:],path + [nums[i]])

        dfs(nums,[])
        return res
```

###  3.43. <a name='RotateImage'></a>48. 旋转图像 Rotate Image

[官方](https://www.bilibili.com/video/BV1mf4y1e7ox?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Wy4y1s7fs?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3kl7avrsvhi0.png" width="30%">

```py
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n//2):
            for j in range((n+1)//2):
                matrix[i][j],matrix[j][n-1-i],matrix[n-1-i][n-1-j],matrix[n-1-j][i] = \
                matrix[n-1-j][i],matrix[i][j],matrix[j][n-1-i],matrix[n-1-i][n-1-j]
        return matrix
```

```scala
/**
* my first commitment
* rotate 4 cell in each iteration
*
*   pattern:  (row, col) -> (col, n - 1- row)
*       1. (i, j) - > (j, n - 1 -i)
*       2. (j, n - 1 -i) -> (n - 1 - i, n - 1 - j)
*       3. (n - 1 - i, n - 1 - j) -> (n -1 -j, n - 1 - (n -1 - i) ) =  (n - 1 -j, i)
*       4. (n - 1 -j, i) -> (i, n - 1 - (n - 1 - j)) = (i, j)
*
* ((0,0) -> (0,3) -> (3,3) -> (3,0))
* ((0,1) -> (1,3) -> (3,2) -> (2,0))
* ((1,0) -> (0,2) -> (2,3) -> (3,1))
* ((1,1) -> (1,2) -> (2,2) -> (2,1))
* 
*/
object Solution1 {
    def rotate(matrix: Array[Array[Int]]): Unit = {
      val n = matrix.size
      printMatrix(n)
      
      for (i <- 0 until (n / 2).toInt + n % 2; j <- 0 until (n / 2).toInt){      
        val tmp = matrix(n - 1 -j)(i)
        matrix(n - 1 - j)(i) = matrix(n - 1 - i)(n - j - 1)
        matrix(n - 1 - i)(n - j - 1) = matrix(j)(n - 1 - i)
        matrix(j)(n - 1 - i) = matrix(i)(j)
        matrix(i)(j) = tmp
      }
    }
    def printMatrix(size: Int): Unit = {
      for (i <- 0 until size) {
        for (j <- 0 until size) {
          print(s"($i, $j) ")
        }
        println(" ")
      }
    }
    /**
        (0, 0) (0, 1) (0, 2) (0, 3)  
        (1, 0) (1, 1) (1, 2) (1, 3)  
        (2, 0) (2, 1) (2, 2) (2, 3)  
        (3, 0) (3, 1) (3, 2) (3, 3)  
    */
}
/**
* clockwise rotate = transpose + horizontal flip
*/
object Solution2 {
    def rotate(matrix: Array[Array[Int]]): Unit = {
        transpose(matrix)
        horizontalFlip(matrix)
    }
  
    def transpose(matrix: Array[Array[Int]]): Unit = {
      for (i <- matrix.indices; j <- i until matrix(i).length; if i != j) {
        val tmp = matrix(i)(j)
        matrix(i)(j) = matrix(j)(i)
        matrix(j)(i) = tmp
      }
    }
    def horizontalFlip(matrix: Array[Array[Int]]): Unit = {
      for(row <- matrix) {
        var from = 0 
        var to = row.length - 1 
        while(from < to) { // reverse row elements
          val tmp = row(to)
          row(to) = row(from)
          row(from) = tmp
          from += 1
          to -= 1
        }
      }
    }
}

/**
* optimize: reversArray by recursion
*/
object Solution2-1{
    def rotate(matrix: Array[Array[Int]]): Unit = {
        transpose(matrix)
        horizontalFlip(matrix)
    }
  
    def transpose(matrix: Array[Array[Int]]): Unit = {
      for (i <- matrix.indices; j <- i until matrix(i).length; if i != j) {
        val tmp = matrix(i)(j)
        matrix(i)(j) = matrix(j)(i)
        matrix(j)(i) = tmp
      }
    }
    def horizontalFlip(matrix: Array[Array[Int]]): Unit = {
      matrix.foreach(row => reverseArray(row, 0, row.length  - 1))
    }
  
    @annotation.tailrec
    def reverseArray(arr: Array[Int], from: Int, to: Int) {
      if (from > to) return
      val tmp = arr(to)
      arr(to) = arr(from)
      arr(from) = tmp
      reverseArray(arr, from + 1, to - 1)
    }
}
```

###  3.44. <a name='GroupAnagrams'></a>49 Group Anagrams

[小明](https://www.bilibili.com/video/BV1n5411t79G?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Yf4y1e7gJ?spm_id_from=333.999.0.0)

```py
# 质数对应字母 乘积哈希
# 这个思想可以学习！但我还没看
from functools import reduce
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]
        chars = "abcdefghijklmnopqrstuvwxyz"
        ch_pr = {chars[i]:prime[i] for i in range(26)}
        for s in strs:
            keys = reduce(lambda x,y :x*y,[ch_pr[i] for i in s], 1)
            if keys in dic:
                dic[keys].append(s)
            else:
                dic[keys] = [s]
        return list(dic.values())
```

```py
# python3 : 常规做法

class Solution:
    def groupAnagrams(self, strs):
        res = []
        dic = {}
        for s in strs:
            keys = "".join(sorted(s))
            if keys not in dic:
                dic[keys] = [s]
            else:
                dic[keys].append(s)
        return list(dic.values())

# 我的模仿😋

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        for s in strs:
            keys = ''.join(sorted(s)) #易错点：s被sorted以后，会变成list
            if keys not in dic:
                dic[keys] = [s] #易错点：[s],而不是s
            else:
                dic[keys].append(s)
        # print(dic.values())输出dict_values([['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']])
        return list(dic.values())
```

```py
# 更简单的写法：
class Solution:
    def groupAnagrams(self, strs):
        dic = collections.defaultdict(list)

        for s in strs:
            keys = "".join(sorted(s))
            dic[keys].append(s)
        
        return list(dic.values())
```

```scala
object Solution {
    def groupAnagrams(strs: Array[String]): List[List[String]] = {
        
        import collection.mutable.HashMap
        import collection.mutable.ListBuffer
        
        val mapping = HashMap[String, ListBuffer[String]]()
        
        for (s <- strs) {
            if (mapping.contains(s.sorted)) {
                mapping(s.sorted) += s
            } else {
                mapping(s.sorted) = ListBuffer(s)
            }
        }
        

        mapping.values.map(_.toList).toList

    }
}
```

```scala
/**
* chosen solution
* time complexity: O(N KLogK) : N: strs.length, K: the longest string in strs 
*/
object Solution0 {
    def groupAnagrams(strs: Array[String]): List[List[String]] =
        strs.groupBy(_.sorted.hashCode).values.map(_.toList).toList
}

/**
* my first commit
* convert all strs into hashmap and group them by the hash value
* time complexity:  O(N K) , but groupBy op is slower
*/
object Solution1 {
  def groupAnagrams(strs: Array[String]): List[List[String]] = {
    strs.groupBy(str => str.groupBy(identity).mapValues(_.length).toMap).values.map(_.toList).toList
  }
}

/**
* inner groupBy is hands-on
* memo:
*   1. categorize by count
*/
object Solution1-2{
  def groupAnagrams(strs: Array[String]): List[List[String]] = {
        strs.toList.groupBy{str => 
            val hashmap = scala.collection.mutable.Map.empty[Char, Int]
            str.foreach(char => hashmap.update(char, hashmap.getOrElse(char, 0) + 1))
            hashmap.hashCode
        }.values.toList
        
    }
}

/**
* sort each string and groupby the sorted list's hashvalue
* time complexity: O(N KLogK) : N: strs.length, K: the longest string in strs
*/
object Solution2 {
    def groupAnagrams(strs: Array[String]): List[List[String]] =
        strs.groupBy(_.sorted.hashCode).values.map(_.toList).toList
}


```

```scala
package com.zhourui.leetcode

import scala.collection.mutable._
//import scala.collection.immutable.{HashMap, HashSet}
package lc0049_groupanagram {



  object Solution {
    def groupAnagrams(strs: Array[String]):List [List[String]] = {
      val hm = HashMap[String,List[String]]()
      strs.foreach{
          case s if hm.contains(s.sorted) => hm(s.sorted) = hm(s.sorted) :+(s)
          case s => hm(s.sorted)=List[String](s)
      }
      hm.values.toList
    }
  }
}

```

###  3.45. <a name='Powxn'></a>50 Pow(x, n)

[小明](https://www.bilibili.com/video/BV1W54y1q7CV?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ai4y147kr?spm_id_from=333.999.0.0)

```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        res = 1

        if n < 0:
            x = 1/x
            n = -n

        if n == 0:
            return res

        while n>0:
            if n % 2 == 1:
                res *= x
            n >>= 1
            # 等价于 n //= 2
            x *= x
        return res
```

```scala
/**
* chosen solution
* recursive - bottom-up
* memo
*   1. n may be negative or positive
*   2. n may be odd or even
*   3. do not care n during recursive
* time complexity: O(logN)
*/

object Solution0 {
    def myPow(x: Double, n: Int): Double = {
      if (n == 0) return 1
      val ans = _myPow(x, math.abs(n))
      if (n < 0) 1 / ans else ans 
    }
    
    def _myPow(x: Double, n: Int): Double = {
      if (n == 1 || n == 0) x
      else if ((n & 1) == 1) _myPow(x * x, n / 2) * x
      else _myPow(x * x, n / 2)
    }
}


/**
* recursive version : bottom-up
* memo
*   1. n may be negative or positive
*   2. n may be odd or even
* O(logN) in time
*/
object Solution1 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) 1
    else if(n > 0) {
      n % 2 match{
        case 1 => myPow(x * x, n / 2) * x
        case 0 => myPow(x * x, n / 2)
      }
    }else{
      val t = myPow(x, n / 2)
      math.abs(n % 2) match{
        case 1 => t * t * (1 / x)
        case 0 => t * t
      }
    }

  }
}
/**
* recursive version : bottom-up
*/
object Solution1-2 {
    def myPow(x: Double, n: Int): Double = {
        if(n == 0) return 1
        
        val t = myPow(x, n / 2)
        
        if(n % 2  == 0){
            t * t
        }else{
            if(n < 0) t * t * (1 / x)
            else t * t * x
        }
    }
}

/**
*  bottom-up -recursive,
*   do not care n during recursive
*/
object Solution1-3 {
    def myPow(x: Double, n: Int): Double = {
      if (n == 0) return 1
      val ans = _myPow(x, math.abs(n))
      if (n < 0) 1 / ans else ans 
    }
    
    def _myPow(x: Double, n: Int): Double = {
      if (n == 1 || n == 0) x
      else if ((n & 1) == 1) _myPow(x * x, n / 2) * x
      else _myPow(x * x, n / 2)
    }
}


/**
* top-down - iterative version 
* Binary Exponentiation with negative n
*
* each iteration is calculate pow(base, nn) * ans
*   ex: input x = 2, n = 10
*    0. base: 2.0, nn: 10 ans: 1.0 => pow(2, 10) * 1 =  1024
*    1. base: 4.0, nn: 5, ans: 1.0  => pow(4, 5) * 1 = 1024
*    2. base: 16.0, nn: 2, ans: 4.0 => pow(16, 2) * 4 = 1024
*    3. base: 256.0, nn: 1, ans: 4.0 => pow(256, 1) * 4 = 1024
*    4. base: 65536.0, nn: 0, ans: 1024.0 => pow(65536, 0) * 1024 = 1024
*
* time complexity: O(logN)
*/

object Solution2 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) return 1
    var ans = 1.0
    var nn = n
    var base = x

    while (nn != 0) {
     /* nn could be -1 if nn < 0 and run nn % 2, so using nn & 1 here */
      if((nn & 1) == 1)  ans = ans * base
      nn = nn / 2
      base = base * base
    }
    // judge n to decide whether reverse ans
    if (n < 0) 1.0 / ans else ans  
  }
}

/**
*  top-down - recursive with tail recursive
*/
object Solution2-1 {
    def myPow(x: Double, n: Int): Double = {
      val ans = _myPow(1, x, n)
      if(n < 0) 1 / ans else ans
    }
    
    @annotation.tailrec
    def _myPow(current: Double, base: Double, pow: Int): Double = {
        if(pow == 0) current
        else{
            if((pow & 1) == 1) _myPow(current * base, base * base, pow / 2)
            else _myPow(current, base * base, pow / 2)
        }
    }
}


```

###  3.46. <a name='-1'></a>51. 数组中的逆序对

[官方](https://www.bilibili.com/video/BV1Qk4y1r7u5?spm_id_from=333.999.0.0)

###  3.47. <a name='Maximumsubarray'></a>53-Maximum subarray

[哈哈哈](https://www.bilibili.com/video/BV1QJ411R75H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7dn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11A41187AR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ta4y1i7Sh?spm_id_from=333.999.0.0)

贪心

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5qrso4wuc440.png)

```py
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = preSum = nums[0]
        for num in nums[1:]:
            preSum = max(preSum + num, num)
            res = max(res,preSum)
        return res
```

时间复杂度：O(n)
时间复杂度：O(1)

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        
        // IDEA:
        // Go through the whole Array,
        // and change each element into the possible maximum sum of the subarray ENDING at its index 
        
        // During each iteration, the element at i-th index will be updated into the possible maximum sum of subarray ENDING at i-th index
        // then for (i+1)th index, if updated i-th value is positive, it can be used to update (i+1)th value as well.
        
        for (i <- Range(1, nums.length)) {
            if (nums(i-1) > 0) {
                nums(i) += nums(i-1)
            }
        }
        
        nums.max
    }
}
```

```scala
/**
* chosen solution
* dynamic programming
*    dp[i] defined as the sum of subarray that ending with ith element and must contains i-th element number   *
* actually, we don't need storing all previous status of nums.length
* we just need two status: one for maximum so far, the other one for the maximum accumulated value which containing with nums[i]
*
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution0{
    def maxSubArray(nums: Array[Int]): Int = {
        if (nums == null || nums.isEmpty) return 0
        var maxSoFar = nums(0)
        var maxEndingHere = nums(0)

        for(i <- 1 until nums.length) {
           maxEndingHere = (maxEndingHere +  nums(i))  max nums(i)
           maxSoFar = maxEndingHere max  maxSoFar
        }
        maxSoFar
        
    }
}

/**
* my first commit version
* time complexity: O(N^2)
* space complexity: O(N)
*/

object Solution1 {
    def maxSubArray(nums: Array[Int]): Int = {
     
        (1 to nums.length).map(n => _maxSubArray(nums, nums(n - 1), n)).max
        
    }
    
    def _maxSubArray(nums: Array[Int], preSum: Int, currentIdx: Int): Int = {
        if(nums.length == currentIdx) return preSum
        
        val currentSum = preSum + nums(currentIdx)
        val nexLevelSum = _maxSubArray(nums, currentSum, currentIdx + 1)
        preSum max currentSum max nexLevelSum
    }
    
}

/**
* dynamic programming
* memo:
*    1. dp[i] defined as the sum of subarray that ending with ith element and must contains i-th element number   
* time complexity: O(N)
* space complexity: O(N)  due to dp array
*/

object Solution2 {
    def maxSubArray(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.ofDim[Int](nums.length, 2)  // dp(0) ... dp(i) storing each status corresponding to  nums' index, means max subarray sum ending with nums[i]
        dp(0)(0) = nums(0)  // dim0: accumulate calculator which reset while new element is larger value inside,
        dp(0)(1) = nums(0) // dim1: maximum so far
        
        for(i <- 1 until nums.length) {
            
            dp(i)(0) = (dp(i - 1)(0) + nums(i))  max nums(i)
            dp(i)(1) = dp(i)(0) max dp(i - 1)(1) 
        }
        dp.last.last
    }
}

/**
* dynamic programming
* memo
*   1. one dimension array
* time complexity O(N)
* space complexity O(N)
*/
object Solution2-1 {
    def maxSubArray(nums: Array[Int]): Int = {
      val dp  = Array.ofDim[Int](nums.length)
      dp(0) = nums(0)
      for (i <- 1 until nums.size) {
        dp(i) = nums(i) max (nums(i) + dp(i - 1))
      }
      
      dp.max
    }
}

/**
* dynamic programming
* actually, we don't need storing all previous status of nums.length
* we just need two status: one for maximum so far, the other one for the maximum accumulated value which containing with nums[i]
*
* time complexity: O(N)
* space complexity: O(1)
*/

object Solution2-2 {
    def maxSubArray(nums: Array[Int]): Int = {
        if (nums == null || nums.isEmpty) return 0
        var maxSoFar = nums(0)
        var maxEndingHere = nums(0)

        for(i <- 1 until nums.length) {
           maxEndingHere = (maxEndingHere +  nums(i))  max nums(i)
           maxSoFar = maxEndingHere max  maxSoFar
        }
        maxSoFar
        
    }
}
/**
*  functional programming: foldLeft
*/
object Solution2-3 {
    def maxSubArray(nums: Array[Int]): Int = {
      if(nums == null || nums.isEmpty) return 0
      (1 until nums.length).foldLeft((nums(0), nums(0))){
          case ((maxEndingI, maxSofar), i) => 
            val maxEndingT = nums(i) max (nums(i) + maxEndingI)
            (maxEndingT, maxSofar max maxEndingT )
      }._2
    }
}
```

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        if(nums.length == 1){
            nums(0)
        }else{
            var sum = nums(0)
            var max = nums(0)
            var i = 1
            while (i < nums.length){
                val elem = nums(i)
                sum = sum + elem
                if(sum > max){
                    max = sum
                    i += 1
                }else if(sum < elem){
                    sum = elem
                    i += 1
                }else{
                    i += 1
                }
                
                if(elem > max){
                    max = elem
                    sum = elem
                }
            }
            max
        }
    }
}

```

```scala
package com.zhourui.leetcode

import scala.math.{abs, max}
import com.zhourui.codech.BaseExtension

package lc0053_maxsubarr {




  object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
      var maxsum:Int=Int.MinValue
      nums.foldLeft(0) {
        case (a,b) => { // 第一次进入时,a=0
          val cursum = max(a+b,b)
          maxsum = max(maxsum, cursum)
          cursum
        }
      }
      return maxsum
    }
  }

  class Test extends BaseExtension {
    def init {
      val arr = Array(-2, 1, -3, 4, -1, 2, 1, -5,4)
      println(Solution.maxSubArray(arr) == 6)

    }
    val name = "053 max sub array"
  }
}



/*
[-2,1,-3,4,-1,2,1,-5,4]
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int cursum = nums[0];
        int maxsum = cursum;

        for (int i=1;i<nums.size();i++) {
            cursum = max(cursum+nums[i],nums[i]);
            maxsum = max(maxsum, cursum);
        }
        return maxsum;
    }
};
 */
```

###  3.48. <a name='SpiralMatrix'></a>54. Spiral Matrix

[小梦想家](https://www.bilibili.com/video/BV1N7411h7i1?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        # print(list(matrix.pop(0)))
        print(list(zip(*matrix)))
        print(list(zip(*matrix))[::-1])
        return matrix and list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])
        # 含义是，如果matrix为空，则返回matrix
```

```py
return a and b
 
等价于
 
return b if a else a
```

```py
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res += matrix.pop(0) # 易错点：注意是+=
            matrix = list(zip(*matrix))[::-1] # 易错点：注意[::-1]的摆放
        return res
```

```scala
/**
* my first commitment: using extra seen matrix
* memo:
*  1. check next coordination, if have seen it, increase the direction index
* time complexity : O(N)
* space complexity: O(2N): seen matrix + output list
*/
object Solution1 {
    import collection.mutable
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {
      val n = matrix.length
      val m = matrix(0).length
      val seen = Array.ofDim[Boolean](n, m)
      val ans = mutable.ListBuffer.empty[Int]
      
      @annotation.tailrec
      def run(directionIdx: Int, coord: (Int, Int), ans: mutable.ListBuffer[Int], targetSize: Int): Unit = {
        if (ans.size == targetSize) return

        val (row, col) = coord
        ans += matrix(row)(col)  
        seen(row)(col) = true


        if (checkNextCoordAvailable(coord, directionIdx, seen)) {
          val direction = getDirection(directionIdx)
          val nextCoord = (row + direction._1, col + direction._2)
          run(directionIdx, nextCoord, ans, targetSize)
        }else {
          val newD = (d + 1) % 4
          val direction = getDirection(newD)
          val nextCoord = (row + direction._1, col + direction._2)
          run(newD, nextCoord, ans, targetSize)
        }

      }

      run(0, (0, 0), ans, n * m)
      ans.toList
    }
  
    
    def checkNextCoordAvailable(coord: (Int, Int), directionIdx: Int, seen: Array[Array[Boolean]]): Boolean = {
      val (row, col) = coord
      val direction = getDirection(directionIdx)
      val nextCoord = (row + direction._1, col + direction._2)

      
      0 <= nextCoord._1 && nextCoord._1 < seen.length && 0 <= nextCoord._2 && nextCoord._2 < seen(0).length && !seen(nextCoord._1)(nextCoord._2)
    }
   
    def getDirection(idx: Int): (Int, Int) = {
      val direction = List (
        (0, 1), // right
        (1, 0), // go down
        (0, -1), // go left
        (-1, 0) // go up
      )
      direction(idx)
    }
}


/**
* counterclockwise rotate matrix
* step:
*  1. add first line to list
*  2. counter-clockwise rotate remaining matrix: transpose + entire reverse
*  
*  remaining:
*  4 5 6
*  7 8 9
* 
* transpose:
*   4 7
*   5 8
*   6 9
* 
* reverse:
*   6 9
*   5 8
*   4 7
*/

object Solution2-1 {
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { 
        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {
            case mx if mx.isEmpty => List()
            case mx if mx.length == 1 => mx.head.toList
            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse)  // counter-clockwise
        }
        dfs(matrix)

    }    
}



/**
* bounded range: 
*  memo:
*    1. direction pattern: right -> down -> left -> up
* time complexity O(N)
* space complexity O(N) : output list
*/
object Solution3-1 {
    import collection.mutable
  
    sealed trait Direction
    case object Right extends Direction
    case object Down extends Direction
    case object Left extends Direction
    case object Up extends Direction
  
    def getNextDirection(direction: Direction): Direction = 
      direction match {
        case Right => Down
        case Down => Left
        case Left => Up
        case Up => Right
      }

  
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = {
      if (matrix.isEmpty) List.empty
      val n = matrix.length
      val m = matrix(0).length
      val ans = mutable.ListBuffer.empty[Int]
      run(matrix, ans, Right, 0, m - 1, 0, n - 1, n * m)
      ans.toList
    }
  
    def run(matrix: Array[Array[Int]], ans: mutable.ListBuffer[Int], direction: Direction, colLo: Int, colHi: Int, rowLo: Int, rowHi: Int, targetSize: Int): Unit = {
      if (ans.size < targetSize) {
        
        direction match {
          
          case Right => 
          /** 
          * fix rowLo and increase rowLo after traversing right
          */
            (colLo to colHi).foreach(colIdx => ans += matrix(rowLo)(colIdx))
            run(matrix, ans, getNextDirection(direction), colLo, colHi, rowLo + 1, rowHi, targetSize)
          case Down =>
           /** 
          * fix colHi and decrease colHi after traversing down
          */
            (rowLo to rowHi).foreach(rowIdx => ans += matrix(rowIdx)(colHi))
            run(matrix, ans, getNextDirection(direction), colLo, colHi - 1, rowLo, rowHi, targetSize)
          case Left =>
          /** 
          * fix rowHi and decrease rowHi after traversing left
          */
          
            (colHi to colLo by -1).foreach(colIdx => ans += matrix(rowHi)(colIdx))
            run(matrix, ans, getNextDirection(direction), colLo, colHi, rowLo, rowHi - 1, targetSize)
          case Up => 

            /** 
          * fix colLo and increase colLo after traversing up
          */
            (rowHi to rowLo by -1).foreach(rowIdx => ans += matrix(rowIdx)(colLo))
            run(matrix, ans, getNextDirection(direction), colLo + 1, colHi, rowLo, rowHi, targetSize)
          
        }
      }
    }
}
```

###  3.49. <a name='JumpGame'></a>55 Jump Game

[小明](https://www.bilibili.com/video/BV14K4y1b7Fw?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1be411s7XX?spm_id_from=333.999.0.0)

```py
# 首选while循环😁
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)
        i = 0

        while cover >= i:
            cover = max(cover, i+nums[i])
            if cover >= n -  1:
                return True
            i += 1
        return False



# 精简一下的for循环😁
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)

        for i in range(n):
            if i <= cover: # 易错点：在判断下一个cover前，先要判断i是否能够到达
                cover = max(cover, i+nums[i])
                # if cover == i:
                    # return False # 易错点：应该考虑特殊情况[0,1,2]

                if cover >= n -  1:
                    return True
        return False
```

```py
object Solution {
    def canJump(nums: Array[Int]): Boolean = {
        
        // We should look at this probelm in REVERSE ORDER:
        // The target is to check whether we can arrive at the last index,
        // then we should reversely check the elements,
        // meanwhile, update the smallest index that we must arrive (`target`) in order to arrive at the last index
        
        // For example, if the i-2 index index is 2,
        // we know we can make it as long as the earlier elements can send us to i-2 index.
        // My target should be updated to i-2 index rather than the last index.
        
        val n = nums.length 
     
        var target = n-1 // the initial target
        var i = n - 2
        
        // update the target
        while (i > 0) {
            if (nums(i) + i >= target) {
                target = i
            }
            i -= 1
        }
        
        // check if the first element can trigger the "chain effect"
        if (nums(0) >= target) {
            true
        } else {
            false
        }
 
    }
}
```

```scala


/**
* my first commitment: backtracking + dp - top-down
* memo:
*   1. cache array record which position could jump to destination
*   2. run the loop of jump step size  backward
*/

object Solution1-1 {
    sealed trait Index
    case object Good extends Index 
    case object Bad extends Index
    case object Unknown extends Index
  
    def canJump(nums: Array[Int]): Boolean = {
        val cache = Array.fill[Index](nums.length)(Unknown)
        cache(cache.length-1) = Good
        dfs(nums, 0, cache)

    }
  
    def dfs(nums: Array[Int], pos: Int, cache: Array[Index]): Boolean = {
      if (cache(pos) != Unknown) {
        return cache(pos) == Good
      }
      
      val furthestJump = ((nums.length - 1) - pos) min nums(pos) // don't jump exceed array's length
      val ret = (furthestJump to 1 by -1).collectFirst {  // 1 to  furthestJump would lead to TLE
        case j if dfs(nums, pos + j, cache) =>  true
      }.getOrElse(false)
      
      
      if (ret) cache(pos) = Good else cache(pos) = Bad
      ret
    }
}

/**
* backtracking: DP bottom-up: more simpler
* memo
* 1. solve problem from tail to head
* 2. cache value: true for GOOD position, false for Bad position
* 3. if cache(0) is true, we could jump to last position from position zero
*/

object Solution1-2 {
    def canJump(nums: Array[Int]): Boolean = {
      val cache = Array.ofDim[Boolean](nums.length)
      cache(cache.length - 1) = true
      
      (nums.length - 2 to 0 by -1).foreach { pos =>
        val furthestJump = ((nums.length - 1) - pos) min nums(pos)
        (furthestJump to 1 by -1).collectFirst {
          case step if cache(pos + step) => 
          cache(pos) = true
          cache(pos)
        }.getOrElse(false)
      }
      cache(0)
    }
}


/**
* Greedy - check each position could jump to last good position
* memo:
*  1. solve problem backward
*  2. record last good position which could jump to last position within multi-hop
*  3. check zero position could jump to last position by checking last position equals to zero
* time complexity: O(N)
*/

object Solution2-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var lastPosition = nums.length - 1
      
      (nums.length - 2 to 0 by -1).foreach{ pos =>
        if((nums(pos) +  pos) >= lastPosition) {
          lastPosition = pos
        }
        
      }
      lastPosition == 0
    }
}


/**
* Greedy: check max reach position
* memo
*  1. record max reach position: if current position is larger than max reach position, it means we couldn't jump to current position and it wouldn't be able to jump to last position
* time complexity: O(N)
*/

object Solution3-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var maxReachPos = nums(0)
      nums.indices.forall { pos =>  
          if (pos > maxReachPos) false  
          else {
            maxReachPos = maxReachPos max (pos + nums(pos))
            true
          }
        }        
    }
}

```

###  3.50. <a name='I.'></a>56-I. 数组中数字出现的次数

[官方](https://www.bilibili.com/video/BV1Qe411s7Kc?spm_id_from=333.999.0.0)

###  3.51. <a name='MergeIntervals'></a>56. Merge Intervals

[花花酱](https://www.bilibili.com/video/BV11t411J7zV?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1w7411a7Wo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411a7t4?spm_id_from=333.999.0.0)

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        # 等价于：intervals.sort(key = lambda x: x[0])
        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1],interval[1])
                # 易错点：不是interval[1]，而是max(res[-1][1],interval[1])
                # 比如，[[1,4],[2,3]]
        return res
```

```py
# 不使用额外的储存空间，直接在原矩阵上面修改的原地算法（反正排序的时候已经修改了原矩阵）：
# pop(i)操作和append()操作耗时一样吗。
# 如果你直接intervals.pop()而不是intervals.pop(i) ，那耗时一样，都是o(1)，
# 但是你指定位置pop，那就是o(n)了。

class Solution:
    def merge(self, intervals):
        intervals.sort()
        i = 1
        while(i < len(intervals)):
            if intervals[i][0] > intervals[i-1][1]:
                i += 1
            else:
                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])
                intervals.pop(i)       
        return intervals
```

```scala

/**
*  my first commitment: sort array
*  time complexity: O(nlogn) + O(n) = O(nlogn) 
*  space complexity: O(n): sorted array
*/

object Solution1-1 {
    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
      val sortedL = intervals.sortBy(_(0))
      val ans = collection.mutable.Set.empty[Array[Int]]
      
      var begin = sortedL(0)(0)
      var end = sortedL(0)(1)
      (1 to sortedL.length - 1).foreach { idx =>
        val l = sortedL(idx)
        if (end < l(0)){
          ans += Array(begin, end)
          begin = l(0)
          end = l(1) 
        }else {
          end = l(1) max end
        }
      }
      ans += Array(begin, end)
      ans.toArray
    }
}

/**
* simplify 1-1
* 1.not using Set
* 2. record uncertain (begin, end) pair in answer list
*/

object Solution1-2 {
    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
      intervals.sortBy(_(0)).foldLeft(List.empty[Array[Int]]){
        case (last::ans, arr) =>
          if (last.last < arr.head) {
            arr::last::ans
          } else {
            Array(last.head, last.last max arr.last)::ans
          }
        case (ans, arr) => arr::ans // for empty ans list
      }.toArray
    }
}
```

###  3.52. <a name='InsertInterval'></a>57. Insert Interval 

[花花酱](https://www.bilibili.com/video/BV11t411J74e?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ja4y1j7cG?spm_id_from=333.999.0.0)

```py
# 根据上一问修改。
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        intervals.append(newInterval)
        intervals.sort()
        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1],interval[1])
        return res
```

```scala
/**
* my first commitment
* memo
*  1. insert newInterval to intervals according to its first element value
*  2. combine overlapping range 
* time complexity: O(2N) = O(N)
* space complexity: O(N)
*/

object Solution1-1 {
    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {
      if (intervals.isEmpty) return Array(newInterval)
      (_insert(_, newInterval)).andThen(combine).apply(intervals).reverse.toArray
    }  
    val _insert = (intervals: Array[Array[Int]], newInterval: Array[Int]) => {
    /**
    * find the position to split intervals into two parts
    */
      val pos = intervals.indices.find(idx => intervals(idx).head > newInterval.head).getOrElse(intervals.length)
      intervals.slice(0, pos).toList ::: List(newInterval) ::: intervals.slice(pos, intervals.length).toList
    }
  
    val combine = (input: List[Array[Int]])  => input.foldLeft(List.empty[Array[Int]]) {
        case (last::ans, arr) =>
          if (last.last < arr.head) arr::last::ans
          else Array(last.head, arr.last max last.last)::ans
        case (ans, arr) => //for empty ans
            arr::ans
      }
}

/**
* optimize from 1-1
* 1.span
*/
object Solution1-2 {
    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {
      // if (intervals.isEmpty) return Array(newInterval)
      (insert(_, newInterval)).andThen(combine).apply(intervals.toList).reverse.toArray
    }
  
    val insert = (intervals: List[Array[Int]], newInterval: Array[Int]) => {
      val (a, b) = intervals.span(arr => arr.head < newInterval.head)
      a:::List(newInterval):::b
    }
  
    val combine = (input: List[Array[Int]])  => input.foldLeft(List.empty[Array[Int]]) {
        case (last::ans, arr) => if (last.last < arr.head) arr::last::ans else Array(last.head, arr.last max last.last)::ans
        case (ans, arr) => arr::ans //for empty ans
      }
}
```

###  3.53. <a name='LenghofLastWords'></a>58. Lengh of Last Words

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7so?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ay4y1y7d2?spm_id_from=333.999.0.0)

```py
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        s.strip()
        return len(s.split()[-1]) if s else 0
```

```py
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        res = 0
        tmp = 0
        for i in range(len(s)):
            if s[i] == ' ':
                tmp = 0
            else:
                tmp += 1
                res = tmp # 易错点：用res存储tmp变量，防止末尾的空格
        return res
```

###  3.54. <a name='II.LCOF'></a>59 - II. 队列的最大值 LCOF

[官方](https://www.bilibili.com/video/BV1L54y1z7ae?spm_id_from=333.999.0.0)

###  3.55. <a name='SpiralMatrixII'></a>59. Spiral Matrix II 

[小梦想家](https://www.bilibili.com/video/BV1J741157Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1q5411G7MY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0 for _ in range(n)] for _ in range(n)]
        x,y,dx,dy = 0,0,0,1 
        # 0,1 -> 1,0 -> 0,-1 -> -1,0
        for num in range(1,n*n + 1):
            res[x][y] = num

            if not 0 <= x+dx < n or not 0 <= y+dy < n or res[x+dx][y+dy] != 0:
            # 易错点：or res[x+dx][y+dy] != 0 顺序很重要，一定要在最后
                dx,dy = dy, -dx

            x += dx
            y += dy
        return res
```

###  3.56. <a name='RotateList'></a>61. Rotate List

[花花酱](https://www.bilibili.com/video/BV14y4y1r728?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV117411L7UG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jK411N7e6?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Xk4y1d7gF?spm_id_from=333.999.0.0)

```py
# python 解法 思路：先把链表首尾相连，再找到位置断开循环
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 易错点：要排除一些特殊情况
        if not head or not head.next:
            return head
            
        cur = head
        nodeNum = 1
        # 链接成一个环
        while cur.next:
            cur = cur.next
            nodeNum += 1
        cur.next = head


        # cur指针指向开头
        cur = cur.next
        # steps到达new head的前一个node
        steps = nodeNum - k % nodeNum - 1
        for _ in range(steps):
            cur = cur.next


        res = cur.next
        cur.next = None
        return res
```

###  3.57. <a name='-1'></a>62-不同路径

[哈哈哈](https://www.bilibili.com/video/BV1mC4y1W7Je?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sg4y1v7PM?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1cp4y167qx?spm_id_from=333.999.0.0)

二维动态规划：

时间复杂度：O(mn)

空间复杂度：O(mn)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 易错点：dp千万不要写错
        # 其他写法：dp = [[1 for i in range(n)] for j in range(m)]
        # 其他写法：dp = [[1]*n]*m
        dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

一维动态规划：

时间复杂度：O(mn)

空间复杂度：O(n)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 易错点：dp千万不要写错
        dp = [1]*n
        for i in range(1,m):
            for j in range(1,n):
                dp[j] += dp[j-1]
        return dp[-1]
```

```scala

/**
* my first commitment: math combination
* memo:
*  1. the total walk steps is (m-1) + (n -1) : (m-1) steps go down and (n-1) steps go right
*  2. unique paths is calculated by C^{m - 1 + n - 1}_{ m - 1} * C^{n-1}_{n-1}
*/
object Solution1 {
    def uniquePaths(m: Int, n: Int): Int = {
      val allStep = (m - 1)  +  (n - 1)
      calCombination(allStep, (m - 1))     
    }
    def calCombination(a: Int, b: Int): Int = {
      val c = a - b
      val max = c max b
      val min = c min b
      val numerator = (BigInt(a) until max by -1).product
      val denominator = (BigInt(min) to 1 by -1).product
      (numerator / denominator).toInt
    }
}

/**
* long type
*/
object Solution1-2 {
    def uniquePaths(m: Int, n: Int): Int = {
      val allStep = (m - 1)  + (n - 1)
      calCombination(allStep.toLong, (m - 1).toLong).toInt 
    }
    def calCombination(a: Long, b: Long): Long = {
      val c = a - b
      val max = c max b
      val min = c min b
      val numerator = (a until max by -1).product
      val denominator = (min to 1 by -1).product
      (numerator / denominator)
    }
}

/**
* dynamic programming
* time complexity: O(N *M)
* space complexity: O(N * M)
*/
object Solution2 {
    def uniquePaths(m: Int, n: Int): Int = {
      val dp = Array.tabulate[Int](m, n) {
        case (0, j) => 1
        case (i, 0) => 1
        case _ => 0
      }
      for (i <- 1 until m; j <- 1 until n) {
        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
      }
      
      dp.last.last
    }
}

/**
* fill dp array with 1
*/
object Solution2-1{
    def uniquePaths(m: Int, n: Int): Int = {
      val dp = Array.fill[Int](m, n)(1)
      for (i <- 1 until m; j <- 1 until n) {
        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
      }
      
      dp.last.last
    }
}
```

###  3.58. <a name='UniquePathsII'></a>63 Unique Paths II

[小明](https://www.bilibili.com/video/BV1Sv411L7qe?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pp4y1v7KR?spm_id_from=333.999.0.0)

```py
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        # 易错点：注意边界上也可能有obstacle
        # 易错点：dp = [[0]*(n+1)]*(m+1)这些写法是错误的
        dp = [[0]*(n+1) for _ in range(m+1)]
        # 易错点：dp[1][1] = 1,这个数字会被重新计算，所以应该写成：
        dp[0][1] = 1
        # 构建了一个大一圈的矩阵，但实际计算的时候，仍然是mn的大小
        for i in range(1,m+1):
            for j in range(1,n+1):
                if not obstacleGrid[i-1][j-1]:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        print(dp)
        return dp[-1][-1]
```

###  3.59. <a name='MinimumPathSum64-'></a>64. Minimum Path Sum 64-最小路径和

[花花酱](https://www.bilibili.com/video/BV12W411679S?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ka4y1i7Vu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1JC4y1x7j1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vi4y1u7a6?spm_id_from=333.999.0.0)

```py
# 可以直接在原数组上进行记忆，不需要额外的空间
# so easy,直接AC
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0:
                    continue
                if i == 0:
                    grid[i][j] += grid[i][j-1]
                if j == 0:
                    grid[i][j] += grid[i-1][j]
                if i > 0 and j > 0:
                    grid[i][j] += min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
```

###  3.60. <a name='ValidNumber'></a>65 Valid Number

[小明](https://www.bilibili.com/video/BV1hK4y1975b?spm_id_from=333.999.0.0)

###  3.61. <a name='Plusone'></a>66-Plus one

[哈哈哈](https://www.bilibili.com/video/BV1jJ411d7Ry?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7b1?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gi4y137GW?spm_id_from=333.999.0.0)

```py
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        for i in range(len(digits)-1,-1,-1):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        return [1] + digits

# 简单题重拳出击，最后一位加1，
# 等于10就进位，没有进位就输出，
# 进位到头就在output前面加个1，简单易懂
```

```scala
object Solution {
    def plusOne(digits: Array[Int]): Array[Int] = {
        var size = digits.length
        var add = 1
        
        var output = List.empty[Int]
        
        (0 to (size-1)).reverse.map(i => {
            
            val x = digits(i)
            
            if(x == 9 && add == 1 && i == 0){
                output = List(1, 0) ++ output
            }else if(x == 9 && add == 1){
                output = 0 +: output
            }else{
                if(add == 1){
                    output = (x+1) +: output
                    add = 0
                }else{
                    output = x +: output
                }
            }
        })
        output.toArray
    }
}

```

###  3.62. <a name='AddBinary'></a>67-Add Binary

[哈哈哈（常规方法）](https://www.bilibili.com/video/BV1N7411F73K?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV17J411d7G1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7Bo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Q5411h7gc?spm_id_from=333.999.0.0)

常规做法:

```py
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        res = ''
        carry = 0
        i = len(a)-1
        j = len(b)-1
        while i >= 0 or j >= 0 or carry: # 易错点： 不要漏 or carry
            val = carry
            if i >= 0: val += int(a[i]) # 易错点：[i],不要写成(i)
            if j >= 0: val += int(b[j])
            carry = val // 2
            res += str(val % 2)
            i -= 1
            j -= 1
        return res[::-1]
```

###  3.63. <a name='Sqrtx'></a>69 Sqrt(x)

[花花酱](https://www.bilibili.com/video/BV1WW411C7YN?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gJ411R7XR?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7TN?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1PK411s72g?spm_id_from=333.999.0.0)

袖珍计算器:

时间复杂度：O(1)

空间复杂度：O(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        ans = int(math.exp(0.5 * math.log(x)))
        return ans + 1 if (ans + 1) ** 2 <= x else ans
```

二分查找:

时间复杂度：O(logN)

空间复杂度：O(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r, ans = 0, x, -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans

# 二分法不需要ans
# 但是不好理解

class Solution:
    def mySqrt(self, x: int) -> int:
        l = 0
        r = x
        while l <= r:
            m = (l + r) // 2 # l和1，不要打错，哈哈哈
            if m**2 > x:
                r = m - 1
            else:
                l = m + 1
        return r
```

牛顿迭代法:

时间复杂度：O(logN)

空间复杂度：O(1)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3g2xmodb40u0.png)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1:
            return x
        
        C, res = float(x), float(x)
        while True:
            xi = 0.5 * (res + C / res)
            if abs(res - xi) < 1e-7:
                break
            res = xi
        
        return int(res)

class Solution:
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        if x <= 1:
            return x
        res = x # 初始值
        c = x # 牛顿迭代法中的常数
        while res > c / res:
            res = (res + c / res) // 2
        return int(res)
```

```scala
/**
* chosen solution
* binary search - recursive
* memo:
*   1. maintain max and min
* time complexity: O(logN)
*/
object Solution0 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        _mySqrt(0, x, x, math.pow(10, -5)).toInt
    }
    
    @annotation.tailrec
    def _mySqrt(min:Double, max: Double, target:Int, precision: Double): Double = {
        val guess = min + (max - min) / 2
        val estimate = guess * guess
        if(math.abs(estimate - target) < precision) guess
        else{ 
            if(estimate > target) _mySqrt(min, guess, target, precision)
            else _mySqrt(guess, max, target, precision)
        } 
    }
}


/**
* my first commitment
* binary search- iterative
* time complexity: O(LogN)
*/
object Solution1 {
  def mySqrt(x: Int): Int = {
    if(x == 0 || x== 1) return x

    val precision = math.pow(10, -5)
    var high: Double = if (x > 1) x else 1
    var low: Double = 0

    while(true) {
      val mid: Double = low + ((high - low) / 2)
      val estimate = mid * mid

      if(math.abs(estimate - x) < precision){
        return mid.toInt

      }else if(estimate > x) {
        high = mid
      }else {
        low = mid
      }
    }
    x
  }
}
/**
* binary search - iterative
* not return while in while block
*/
object Solution1-2 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        val precision = math.pow(10, -5)
        var max: Double = if(x > 1) x.toDouble else 1.0
        var min = 0.0
        var mid = min + (max - min) / 2 
        var condition = true
        
        while(condition){
            mid = min + (max - min) / 2 
            val estimate = mid * mid
            
            if(math.abs(estimate - x) < precision){
                condition = false
            }else if(estimate > x){
              max = mid  
            } else {
              min = mid
            }
        }
        mid.toInt
    }
}


/**
* binary search - recursive - top-down
* memo:
*   1. maintain max and min
*/
object Solution1-3 {
    def mySqrt(x: Int): Int = {
        if(x == 0 || x == 1) return x
        _mySqrt(0, x, x, math.pow(10, -5)).toInt
    }
    
    @annotation.tailrec
    def _mySqrt(min:Double, max: Double, target:Int, precision: Double): Double = {
        val guess = min + (max - min) / 2
        val estimate = guess * guess
        if(math.abs(estimate - target) < precision) guess
        else{
            if(estimate > target) _mySqrt(min, guess, target, precision)
            else _mySqrt(guess, max, target, precision)
        } 
    }
}

/**
* Newton's method - iterative
* y = x^2 => f(x) = x^2 - y
* x_{k+1} = x_k - f(x_k) / f'(x_k)
* x_{k+1} = x_k - (x_k^2 - y) / (2x_k) = (x_k + y / x_k) / 2
* time complexity: O(logN)
*/

object Solution2 {
     def mySqrt(x: Int): Int = {
        val precision = math.pow(10, -5)
        
        var ans: Double = x
        while(math.abs(ans * ans - x) > precision){
            ans = (ans + x / ans) / 2
            // println(ans)
        }
        ans.toInt
    }
}

/**
*  newton-method - recursive - top-down
*/

object Solution2-1 {
    def mySqrt(x: Int): Int = {
        _mySqrt(x, x, math.pow(10, -5)).toInt
    }

    @annotation.tailrec
    def _mySqrt(guess: Double, target: Int, precision: Double): Double = {
        /* see? (guess * guess - target) is just our f(x) =  x^2 - y */
        if(math.abs(guess * guess - target) < precision) guess
        else _mySqrt((guess + (target / guess)) / 2, target, precision)
    }
}


```

```scala
object Solution {
    def mySqrt(x: Int): Int = {
        if(x == 0){
            0
        }else if(x == 1){
            1
        }else{
            var num: Int = x/2
            var flag = true
            
            while(flag){
                // val sqr = num*num
                // if(sqr == x)
                
                //If we do num*num it may exceed Int range
                //Since we want to check: num*num < x
                //we can instead do num < x/num
                
                if(num > x/num){
                    num = num/2
                }else{
                    val temp = num + 1
                    if(temp > x/temp){
                        flag = false
                    }else{
                        num += 1
                    }
                }
            }
            num
        }
    }
}

//Better solution: in the above solution we are only decreasing the range on 1 side by half, but other side by only 1 number
//This solution decreases by half for both side (binary search pattern)

object Solution {
    def mySqrt(x: Int): Int = {
        if(x == 0){
            0
        }else if(x == 1){
            1
        }else{
            var start = 1
            var end = x
            var result = 0
            
            while(start <= end){
                var mid = start + (end - start)/2
                if(mid <= x/mid){
                    result = mid
                    start = mid+1
                }else{
                    end = mid-1
                }
            }
            result
        }
    }
}

```

###  3.64. <a name='ClimbingStairs'></a>70. Climbing Stairs

[5:32 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gJ411R7X1?spm_id_from=333.999.0.0)

[哈哈哈 70(重制版)](https://www.bilibili.com/video/BV1G54y197eZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7s9?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DZ4y1H7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ki4y1u7tn?spm_id_from=333.999.0.0)

```py
class Solution:
    def climbStairs(self, n: int) -> int:
        b1, b2 = 1, 1
        for i in range(n-1):
            b1, b2 = b2, b1 + b2
        return b2

# 我的模仿

class Solution:
    def climbStairs(self, n: int) -> int:
        dp0 = 1
        dp1 = 1
        for _ in range(n-1):
            dp1, dp0 = dp0 + dp1, dp1
            # 用2个数字分别存储
        return dp1
```

```scala
/**
* chosen solution
* dynamic programming
* memo
*   1. dp(i) represent climb to i floor's distinct ways
*   2. dp(i) could be calculate from dp(i - 1) + dp(i - 2)
*           (1) taking a single step from dp(i - 1)
*           (2) taking a step of two from dp(i - 2)
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution0 {
    def climbStairs(n: Int): Int = {
        val dp = Array.ofDim[Int](n + 1)
        dp(0) = 1
        dp(1) = 1
        (2 to n).foreach(i => dp(i) = dp(i - 1) + dp(i - 2))
        dp(n)
    }
}

/**
* my first commitment
* dynamic programming
* memo:
*   1. dp(i) represent climb to i floor's distinct ways
*   2. dp(i) could be calculate from dp(i - 1) + dp(i - 2)
*           (1) taking a single step from dp(i - 1)
*           (2) taking a step of two from dp(i - 2)
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def climbStairs(n: Int): Int = {
        if(n <= 2) n
        else {
            val cache = Array.ofDim[Int](n + 1)
            cache(0) = 1
            cache(1) = 1
            (2 to n).foreach{ nn =>
                cache(nn) = cache(nn - 1) + cache(nn - 2)
            }
            cache(n)
        }
    }
}

/**
*  simplify from 1
*/
object Solution1-2 {
    def climbStairs(n: Int): Int = {
        val dp = Array.ofDim[Int](n + 1)
        dp(0) = 1
        dp(1) = 1
        (2 to n).foreach(i => dp(i) = dp(i - 1) + dp(i - 2))
        dp(n)
    }
}



/**
* DP: only use two extra space to keep previous two value
* time complexity: O(N)
* space complexity: O(1)
*/

object Solution1-3 {
    def climbStairs(n: Int): Int = {
        if(n <= 2) n
        else {
            var a = 1
            var b = 2
            (3 to n).foreach{ nn =>
                val c = a + b
                a = b
                b = c    
            }
            b
        }
    }
}

/**
* dp: index from 0 until n
*   it would be confusing with index i original meaning which is the ways of climbing to stair i
* memo:
*  1. keep two previous status
*/
object Solution1-4 {
    def climbStairs(n: Int): Int = {
        var a = 0
        var b = 1
        for (_ <- 0 until n) {
            val c = a + b
            a = b
            b = c
        }
        b
    }
}
```

```scala
object Solution {
    
    def climbStairs(n: Int): Int = {
        if(n==1){
            1
        }else if(n == 2){
            2
        }else{
            climbStairs(n-1) + climbStairs(n-2)
        }
    }
}

/**
n = 3
1 1 1
1 2
-------
2 1
==================> 2 + 1
n = 4
 1 1 1 1
 1 1 2
 1 2 1
 --------
 2 1 1
 2 2
 =================> 3 + 2
*/

/**Alternate approach:
In the above approach we are doing repeated call for some numbers
example: 
climbStairs(5) -> 4 & 3
climbStairs(4) -> 3 & 2 | climbStairs(3) -> 2 & 1
climbStairs(3) -> 2 & 1 | climbStairs(2) | climbStairs(2) | climbStairs(1)
climbStairs(2) | climbStairs(1) | climbStairs(1)

To avoid recalculation again & again we can just store the results for the previous numbers at their indexes
*/
object Solution {
    
    def climbStairs(n: Int): Int = {
        if(n == 1){
            1
        }else{
            var dpArray = Array.fill(n+1)(0)
            dpArray(1) = 1
            dpArray(2) = 2
            (3 to n).map(i => {
                dpArray(i) = dpArray(i-1) + dpArray(i-2)
            })
            dpArray(n)
        }
    }
}

```

###  3.65. <a name='SimplifyPath'></a>71. Simplify Path

[小梦想家](https://www.bilibili.com/video/BV1V7411w7jX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1D5411J72c?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def simplifyPath(self, path):
        stack = []
        for i in path.split('/'):
            if i not in ['', '.', '..']:
                stack.append(i)
            elif i == '..' and stack:
                stack.pop()
        return "/" + "/".join(stack)
```

```py
# cool
from os.path import abspath

class Solution:
    def simplifyPath(self, path: str) -> str:
        return abspath(path)

from functools import reduce
class Solution:
    def simplifyPath(self, path: str) -> str:
        return "/"+"/".join(reduce(lambda x, y: x[:-1] if y == ".." else x + [y] if y and y != "." else x, path.split("/"), []))

# 等效于:

class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        for i in path.split('/'):
            if i == '..':
                if stack:
                    stack.pop()
                else:
                    continue
            elif i and i != '.': # 注意这里是elif,而不是if
                stack.append(i)
        return "/" + "/".join(stack)
```

###  3.66. <a name='EditDistance72-'></a>72. Edit Distance 72-编辑距离

[花花酱](https://www.bilibili.com/video/BV1cb411u7uX?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wv411P7aQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13Z4y1W7UB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ea4y147FK?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5kci5ryyi3k0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7fq2ehol7rg0.png)

```py
#@author:leacoder
#@des:  动态规划  编辑距离

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
        # 初始
        for i in range(len1+1):
            DP[i][0] = i
        for j in range(len2+1):
            DP[0][j] = j
        for i in range(1,len1+1):
            for j in range(1,len2+1):
                
                if word1[i - 1] == word2[j -1]:
                    DP[i][j] =  DP[i-1][j-1]
                else:
                    DP[i][j]  =  min(DP[i-1][j] + 1,DP[i][j-1] + 1,DP[i-1][j-1]+1)
        return DP[len1][len2]

# 换个写法

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
        
        for i in range(0,len1+1):
            for j in range(0,len2+1):
                if i == 0:               # 初始化
                    DP[i][j] = j
                elif j == 0:             # 初始化
                    DP[i][j] = i
                elif word1[i - 1] == word2[j -1]:
                    DP[i][j] =  DP[i-1][j-1]
                else:
                    DP[i][j]  =  min(DP[i-1][j],DP[i][j-1],DP[i-1][j-1]) + 1
                    
        return DP[-1][-1]
```

```py
比较好理解，but会超时，哭唧唧

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        @cache
        def dp(i, j) -> int:
            if i == -1:
                return j + 1
            if j == -1:
                return i + 1
            # 做出选择
            if word1[i] == word2[j]:
                return dp(i - 1, j - 1) # 什么都不做
            else:
                return min(
                    dp(i, j-1) + 1,  # insert
                    dp(i-1, j) + 1,  # delete
                    dp(i-1, j-1) + 1 # replace
                )
        return dp(len(word1)-1, len(word2)-1)
```

```scala
/**
* dynamic programming  - Levenshtein distance
* memo
*    1. dp(i)(j) represent the minimum edit distance from the length i substring from word1 to the length j substring from word2
*    2. dp(i)(j) is solved by its sub-optimal problem 
*         1, delete op: dp(i -1)(j)
*         2. replacement op: dp(i -1)(j - 1)
*         3. insertion op: dp(i)(j - 1)
* time complexity: O(NM) N is the length of word1, N is the length of word2
* space complexity: O(NM)
*/
object Solution1 {
  def minDistance(word1: String, word2: String): Int = {
    val m = word1.length
    val n = word2.length
    /* initial  Levenshtein distance table 
    * dp(i)(j) represent the minimum distance transforming from length i of substring word1 to length j of substring word2
    */
    val dp = Array.tabulate(m + 1, n + 1) {
      case (0, j) => j
      case (i, 0) => i
      case _ => 0
    }

    for (i <- 1 to m; j <- 1 to n) {
      /* i-1 is word1 index, j-1 is word2 index */
      if (word1(i - 1) == word2(j - 1)) {
        // do nothing case
        dp(i)(j) = dp(i - 1)(j - 1)
      } else {
        /**
        *       i-1,    i
        * j-1 replace  insertion     
        *  j   delete  dp(i)(j)
        */
        val replace = dp(i - 1)(j - 1)
        val insert = dp(i)(j - 1)
        val delete = dp(i - 1)(j)
        dp(i)(j) = (replace min insert min delete) + 1
      }
    }
    dp(m)(n)
  }
}
```

###  3.67. <a name='SetMatrixZeroes'></a>73. Set Matrix Zeroes

[小梦想家](https://www.bilibili.com/video/BV1W7411T7rX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1X64y1Y7kG?spm_id_from=333.999.0.0)

```py
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        tmp = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 0:
                    tmp.append([i,j])
        for r,c in tmp:
            for j in range(len(matrix[0])):
                matrix[r][j] = 0
            for i in range(len(matrix)):
                matrix[i][c] = 0
        return matrix
```

```scala

/**
* my first commitment
* time complexity: O(N * M)
* space complexity: O(N + M)
*/
object Solution1 {
    import collection.mutable
    def setZeroes(matrix: Array[Array[Int]]): Unit = {
      val cols = mutable.Set.empty[Int]
      val rows = mutable.Set.empty[Int]
      
      for (i <- matrix.indices; j <- matrix(i).indices; if matrix(i)(j) == 0) {
        rows += i
        cols += j
      }
      
      rows.foreach(row => matrix(row).indices.foreach(matrix(row)(_) = 0))
      cols.foreach(col => matrix.indices.foreach(matrix(_)(col) = 0))
    }
}



/**
* using first column and row to record cell to be set to zero
* memo:
*  1. we should set first columns and first row in the last, otherwise we cannot distinguish the zero between set by us and originally is
* time complexity: O(NM)
* space complexity: O(1)
*/
object Solution2 {
    import collection.mutable
    def setZeroes(matrix: Array[Array[Int]]): Unit = {
      var rowZero = false
      var colZero = false
      
      /**
      * using first row and first column as flag 
      */
      for (i <- matrix.indices; j <- matrix(i).indices; if matrix(i)(j) == 0) {
        if (i == 0) rowZero = true
        if (j == 0) colZero = true
        matrix(i)(0) = 0
        matrix(0)(j) = 0
      }
    
      /**
      * set one row to zero except first cell
      */
      (1 until matrix.length).foreach {
        case rowIdx if matrix(rowIdx)(0) == 0 => matrix(rowIdx).indices.foreach(matrix(rowIdx)(_) = 0)
        case _ =>
      }
      
      /**
      * set one column to zero except first cell
      */
      (1 until matrix(0).length).foreach {
        case colIdx if matrix(0)(colIdx) == 0 => matrix.indices.foreach(matrix(_)(colIdx) = 0)
        case _ => 
      }
      
      /**
      * set first column and first row to zero if true
      */
      if(rowZero) matrix(0).indices.foreach(matrix(0)(_) = 0)
      if(colZero) matrix.indices.foreach(matrix(_)(0) = 0)
      
    }
}
```

###  3.68. <a name='Searcha2DMatrix'></a>74 Search a 2D Matrix

[小明](https://www.bilibili.com/video/BV1aK4y1h7Bb?spm_id_from=333.999.0.0)

```py
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        l = 0
        r = m*n-1
        while l <= r:
            mid = (l + r) // 2
            midRow = mid // n
            midCol = mid % n
            if matrix[midRow][midCol] == target:
                return True
            elif matrix[midRow][midCol] > target:
                r = mid - 1 # 易错点：+1,-1不要写反了
            else:
                l = mid + 1
        return False
```

###  3.69. <a name='SortColors'></a>75. Sort Colors

[小梦想家](https://www.bilibili.com/video/BV1rE411n7mL?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ua4y1v7yd?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1tz4y1o7n5?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5l1bfbznzwc0.png)

```py
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        idx, left, right = 0, 0, len(nums) - 1
        while idx <= right:
            if nums[idx] == 2 and idx < right:
                nums[idx], nums[right] = nums[right], 2
                right -= 1
            elif nums[idx] == 0 and idx > left:
                nums[idx], nums[left] = nums[left], 0
                left += 1
            else:
                idx += 1
```

###  3.70. <a name='-1'></a>76-最小覆盖子串

[哈哈哈](https://www.bilibili.com/video/BV1PM4y1K7p6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK4y1t7Qd?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ud8tslp4vz4.png)

```py
class Solution:
    def minWindow(self, s: str, t: str) -> str:
    
        def isContains(windic,targetdic):
            for key in targetdic:
                if windic[key] < targetdic[key]:
                    return False # 只要有一个不满足，则不满足
            return True

        
        tdic = defaultdict(int)
        wdic = defaultdict(int)
        for char in t:
        	tdic[char] += 1
        for char in t:
            wdic[char] = 0

        minlen = len(s)
        l = 0
        res = ''

        for r in range(len(s)): 
            # 右边界移动,并把右边界加入字典
            if s[r] in tdic:
                wdic[s[r]] += 1
            while isContains(wdic,tdic):
                if r-l+1 <= minlen:
                    # 满足包含条件，并且minlen
                    minlen = r-l+1
                    res = s[l:r+1]
                if s[l] in wdic:
                    wdic[s[l]] -= 1
                l += 1 # 如果window满足条件，那就收缩左边界，但需要进行如上操作
        return res
```

```scala
/**
* chosen solution
*   time complexity: O(|S| + |T|)
*   space complexity: O(|s| + |T|)
* sliding windows: faster version
* @param
* left right : two pointer for enlarging and reducing windows size
* head and len: storing minWindow
* count: count = 0 when the range between left index and right index satisfy condition
*/
object Solution0{
    import collection.mutable
    def minWindow(s: String, t: String): String = {
      val sMap = mutable.Map.empty[Char, Int] ++ t.groupBy(identity).mapValues(_.length).toMap
      var counter = sMap.size
      
      var left = 0
      var minLength = s.length + 1
      var head = 0

      for (right <- s.indices) {
        val rightChar = s(right)
        sMap.get(rightChar) match {
          case Some(v) if v == 1 =>
            sMap.update(rightChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(rightChar, v - 1)
          case None => 
        }
        
        while(counter == 0) {

          val leftChar = s(left)
          if (minLength > (right - left  + 1)) {
            head = left
            minLength = right - left + 1
          }
          
          sMap.get(leftChar) match {
            case Some(v) if v == 0 =>
              sMap.update(leftChar, v + 1)
              counter += 1
            case Some(v) =>
              sMap.update(leftChar, v + 1)
            case None =>
          }
          
          left += 1
        }
        
      }
      if (minLength == (s.length + 1)) "" else s.slice(head, head + minLength)
      
      
    }
}
/**
* my first commitment
* sliding windows with two pointer: left and right
* time complexity: O(|S| + |T|)
*/
object Solution1 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    val tMap = t.groupBy(identity).mapValues(_.length).toMap

    /**
    * storing how far to reach t string's anagrams, the element's value could be negative. 
    * If negative, it means we could drop more char of this key from currentString
    */
    val budgetMap = scala.collection.mutable.Map() ++ tMap
    var currentString = ""
    var answer = ""

    for (char <- s) {
        budgetMap.get(char) match {

          case Some(e) => budgetMap.update(char, e - 1)
          case None =>
        }
      
      currentString += char

      while(!budgetMap.exists{case (_, v) => v > 0}) {
        /**
        *  drop first element from currentString if  currentString  still contains t string 
        */
        val tempChar = s(left)
        if(tMap.contains(tempChar)){
          budgetMap.update(tempChar, budgetMap.getOrElse(tempChar, 0) + 1)
        }

        if(answer.length > currentString.length || answer.isEmpty) {
          answer = currentString
        }
        currentString = currentString.drop(1)
        left += 1
      }
    }

    answer
  }
}


/**
* sliding windows : don't record string during process
*/
object Solution1-2 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    var head = 0
    var len = s.length + 1

    val budgetMap = scala.collection.mutable.Map() ++ t.groupBy(identity).mapValues(_.length)

    for ((char, right) <- s.zipWithIndex) {
      
        budgetMap.get(char) match {
          case Some(e) => budgetMap.update(char, e - 1)
          case None =>
        }
      
      while(!budgetMap.exists{case (_, v) => v > 0}) {
        val tempChar = s(left)
        if(budgetMap.contains(tempChar)){
          budgetMap.put(tempChar, budgetMap(tempChar) + 1)
        }
         /* update minWindow */
        if(len > (right - left)) {
          len = right - left + 1
          head  = left
        }
        left += 1
      }
    }
    // println(budgetMap)
    if(len == (s.length + 1)) "" else s.substring(head, head + len)
  }
}

/**
* sliding windows: faster version
* left right : two pointer for enlarging and reducing windows size
* head and len: storing minWindow
* count: count = 0 when the range between left index and right index satisfy condition
*/

object Solution1-3 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    var right = 0
    var head = 0
    var len = s.length + 1
    val budgetMap = scala.collection.mutable.Map() ++ t.groupBy(identity).mapValues(_.length)
    var count = budgetMap.size

    while (right < s.length) {
      val char = s(right)
     
        budgetMap.get(char) match {
            case Some(e) if e == 1 =>
            budgetMap.update(char, e - 1)
            count -= 1
            case Some(e) =>
            budgetMap.update(char, e - 1)
            case None =>
        }
      
      right += 1
      while(count == 0) {
        val tempChar = s(left)
        budgetMap.get(tempChar) match {
          case Some(e) if e == 0 =>
            budgetMap.update(tempChar, e + 1)
            count += 1
          case Some(e) =>
            budgetMap.update(tempChar, e + 1)
          case None =>
        }
        /* update minWindow*/
        if(len > (right - left)) {
          len = right - left
          head  = left
        }
        left += 1
      }
    }
    println(budgetMap)
    if(len == (s.length + 1)) "" else s.substring(head, head + len)
  }
}

/**
* 1. for loop auto increment right index
* 2. update minLength and head index before updating counter and left index
*/

object Solution1-4 {
    import collection.mutable
    def minWindow(s: String, t: String): String = {
      val sMap = mutable.Map.empty[Char, Int] ++ t.groupBy(identity).mapValues(_.length).toMap
      var counter = sMap.size
      
      var left = 0
      var minLength = s.length + 1
      var head = 0

      for (right <- s.indices) {
        val rightChar = s(right)
        sMap.get(rightChar) match {
          case Some(v) if v == 1 =>
            sMap.update(rightChar, v - 1)
            counter -= 1
          case Some(v) =>
            sMap.update(rightChar, v - 1)
          case None => 
        }
        
        while(counter == 0) {

          val leftChar = s(left)
          if (minLength > (right - left  + 1)) {
            head = left
            minLength = right - left + 1
          }
          
          sMap.get(leftChar) match {
            case Some(v) if v == 0 =>
              sMap.update(leftChar, v + 1)
              counter += 1
            case Some(v) =>
              sMap.update(leftChar, v + 1)
            case None =>
          }
          
          left += 1
        }
        
      }
      if (minLength == (s.length + 1)) "" else s.slice(head, head + minLength)
      
      
    }
}
```

###  3.71. <a name='-1'></a>77. 组合

```py
class Solution:
    def combine(self, n, k):
            res = []
            path = []
            def backtrack(StartIndex):
                if len(path) == k:
                    res.append(path[:])
                    return
                for i in range(StartIndex, n+1):
                    path.append(i)
                    backtrack(i+1)
                    path.pop()
            backtrack(1)
            return res
```

###  3.72. <a name='Subsets78-'></a>78. Subsets 78-子集

[花花酱](https://www.bilibili.com/video/BV1jt411k7py?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1HD4y1Q7Te?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1s7pq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1154y1R72Q?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = [[]]
        for num in nums:
            res.extend([tmp+[num] for tmp in res])
        return res  

# bfs
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        q=[[]]
        n=len(nums)
        for i in range(n):
            for j in range(len(q)):
                q.append(q[j]+[nums[i]])
        return q

        # 等效

        res = [[]]
        n = len(nums)
        for num in nums:
            for subres in res[:]:
                res.append(subres+[num])
        return res

# 注意代码中res[:]是必须的，因为切片是引用新的对象，
# 此时在循环中res[:]是不更新的，而res是不断有元素push进去的，很trick
```

```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  
        path = []  
        def backtrack(startIndex):
            res.append(path[:])  #收集子集，要放在终止添加的上面，否则会漏掉自己
            for i in range(startIndex,len(nums)):  #当startIndex已经大于数组的长度了，就终止了，for循环本来也结束了，所以不需要终止条件
                path.append(nums[i])
                backtrack(i+1)  #递归
                path.pop()  #回溯
        backtrack(0)
        return res
```

```scala
object Solution {
    //We either use or don't use the current item at the given index and continue until we are at the end of the array.
    
    def subsets(nums: Array[Int]): List[List[Int]] = {
        def backtrack(nums: List[Int], returnValue: List[Int]): List[List[Int]] = {
            nums
            .headOption
            .map(currentElem => 
                 backtrack(nums.tail, returnValue) ++ backtrack(nums.tail, currentElem +: returnValue))
            .getOrElse(List(returnValue))
        }
        
        backtrack(nums.toList, List.empty[Int])
    }
}

```

###  3.73. <a name='WordSearch'></a>79. Word Search

[小梦想家](https://www.bilibili.com/video/BV1yE411g7Tb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iZ4y1T78D?spm_id_from=333.999.0.0)

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def dfs(i, j, word):
            # 单词是否出现在以i，j为起点的网格中
            # word[0] 和 word[1:] 划分
            # 结束条件：
            if len(word) == 1:
                return word[0] == board[i][j]
            # 结束条件：
            if board[i][j] != word[0]:
                return False
            
            # 设置现场
            visit[i][j] = True
            for dire in direction: # 对四个方向进行搜索
                newi, newj = i + dire[0], j + dire[1]
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]) and not visit[newi][newj]:
                    if dfs(newi, newj, word[1:]): # dfs成功
                        return True
            # 还原现场
            visit[i][j] = False

        direction = [(0,1), (0, -1), (1, 0), (-1, 0)]
        m = len(board)
        n = len(board[0])
        visit = [[False]*n for _ in range(m)]
        for i in range(m): # 遍历所有格子作为单词起点
            for j in range(n):
                if dfs(i,j,word): # dfs成功
                    return True
        return False
```

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1: # k + 1等价于word[1:]
                return True
            
            visited.add((i, j)) # 用集合表示visited
            for di, dj in directions:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1): # k + 1等价于word[1:]
                            return True
            visited.remove((i, j)) # 用集合表示visited

        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        h, w = len(board), len(board[0])
        visited = set() # 用集合表示visited
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True
        
        return False
```

```scala
/**
* chosen solution
* directly compare char by char
* if there are only one word should be checked in board, brute force is a more efficient method
*/

object Solution0 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    dfs(word, board)
  }

  def dfs(word: String, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), wordIdx: Int): Boolean = {
      val char = board(coord._1)(coord._2)

      if(wordIdx >= word.length || char != word.charAt(wordIdx)) false
      else if(char == word.charAt(wordIdx) && wordIdx == word.length - 1) true
      else {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), wordIdx + 1)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      }
    }
    
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, 0))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
*  my first commitment
*    using Tries
*    watch out that uppercase is different from lower case => "POLAND" != "poland"
*/
object Solution1 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    val tries = new Tries()
    tries.insert(word)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), prePrefix: String): Boolean = {
      val char = board(coord._1)(coord._2)
      val newPrefix = prePrefix + char
      if(tries.search(newPrefix)) true

      else if(tries.startsWith(newPrefix)) {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), newPrefix)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      } else false
    }
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, ""))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
* helper class 
*   Tries Node is implemented with Map
*/
case class Node(child: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map.empty[Char, Node], var isWord: Boolean = false) {
  def update(char: Char, node: Node): Unit = child(char) = node
  def apply(char: Char): Option[Node] = child.get(char)
}

class Tries() {
  val root = Node()

  def insert(word: String): Unit = {
    var node = root
    word.foreach{
      case c if node(c).isDefined => node = node(c).get
      case c =>
        node(c) = Node()
        node = node(c).get
    }
    node.isWord = true
  }

  def search(word: String): Boolean = searchUtil(word).exists(_.isWord)

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined

  private def searchUtil(string: String): Option[Node] = {
    var node = root

    string.foreach{
      case c if node(c).isDefined => node = node(c).get
      case _ => return None
    }
    Some(node)
  }
}


/**
* directly compare with char by char
* if there are only one word should be checked in board, brute force is a more efficient method
*/

object Solution2 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    dfs(word, board)
  }

  def dfs(word: String, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), wordIdx: Int): Boolean = {
      val char = board(coord._1)(coord._2)

      if(wordIdx >= word.length || char != word.charAt(wordIdx)) false
      else if(char == word.charAt(wordIdx) && wordIdx == word.length - 1) true
      else {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), wordIdx + 1)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      }
    }
    
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, 0))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

###  3.74. <a name='RemoveDuplicatesfromSortedArrayII'></a>80 Remove Duplicates from Sorted Array II

[小明](https://www.bilibili.com/video/BV1vy4y1S7sN?spm_id_from=333.999.0.0)

###  3.75. <a name='IIRemoveDuplicatesfromSortedList'></a>82. 删除排序链表中的重复元素 II(Remove Duplicates from Sorted List

[洛阳](https://www.bilibili.com/video/BV1Fi4y187pj?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0,head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                while cur.next.next and cur.next.val == cur.next.next.val:
                    cur.next = cur.next.next # 删去重复节点的前一个
                cur.next = cur.next.next # 删去重复节点的剩余一个
            else:
                cur =  cur.next
        return dummy.next

# 另一种写法
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0,head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                x = cur.next.val
                while cur.next and cur.next.val == x:
                    cur.next = cur.next.next
            else:
                cur =  cur.next
        return dummy.next
```

###  3.76. <a name='Removeduplicatesfromsortedarray-1'></a>83-Remove duplicates from sorted array

[哈哈哈](https://www.bilibili.com/video/BV1yJ411R7FZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7s7?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1zK411L7Gg?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur =  cur.next
        return head
```

###  3.77. <a name='LargestRectangleinHistogram'></a>84. 柱状图中最大的矩形 Largest Rectangle in Histogram

[官方](https://www.bilibili.com/video/BV16D4y1D7ed?spm_id_from=333.999.0.0)

###  3.78. <a name='PartitionList'></a>86. 分隔链表(Partition List)

[洛阳](https://www.bilibili.com/video/BV1t64y1u7Ei?spm_id_from=333.999.0.0)

```py
        dummy1 = ListNode(0)
        dummy2 = ListNode(0)
        slow,fast,cur = dummy1, dummy2, head
        while cur:
            if cur.val < x:
                slow.next = cur # dummy1 指向第一个小于x的node
                slow = slow.next
            else:
                fast.next = cur # dummy2 指向第一个大于x的node
                fast = fast.next
            cur = cur.next
        slow.next = dummy2.next
        fast.next = None
        return dummy1.next
```

###  3.79. <a name='ScrambleString'></a>87. Scramble String

[花花酱](https://www.bilibili.com/video/BV1QE41137MG?spm_id_from=333.999.0.0)

###  3.80. <a name='Mergesortedarray'></a>88-Merge sorted array

[哈哈哈](https://www.bilibili.com/video/BV14J411X7JE?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7bg?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1g54y1s7ZG?spm_id_from=333.999.0.0)

直接合并后排序

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 三个指针
        cur1 = m - 1
        cur2 = n - 1
        i = m + n -1
        while cur1 >= 0 and cur2 >= 0:
            if nums1[cur1] < nums2[cur2]:
                nums1[i] = nums2[cur2]
                cur2 -= 1
            else:
                nums1[i] = nums1[cur1]
                cur1 -= 1
            i -= 1
        if cur2 >= 0:
            nums1[:cur2+1] = nums2[:cur2+1] # 易错点：不包括右边界

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()
```

```scala
object Solution {
    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {
        var trail = m+n-1
        
        var t1 = m-1
        var t2 = n-1
        
        while(t1 > -1 && t2 > -1){
            val e1 = nums1(t1)
            val e2 = nums2(t2)
            
            if(e1 > e2){
                nums1(trail) = e1
                t1 -= 1
                trail -= 1
            }else{
                nums1(trail) = e2
                t2 -= 1
                trail -= 1
            }
        }
        
        if(t1 == -1){
            while(t2 > -1){
                nums1(trail) = nums2(t2)
                t2 -= 1
                trail -= 1
            }
        }else{
            while(t1 > -1){
                nums1(trail) = nums1(t1)
                t1 -= 1
                trail -= 1
            }
        }
        
    }
}

```

###  3.81. <a name='89.'></a> 89. 格雷编码

```py
class Solution:
    def grayCode(self, n):
        # 易错点：递归部分必须是字符串部分
        def recur(i):
            if i==1:
                return ['0','1']
            else:
                lastList = recur(i-1)
                return ['0'+ x for x in lastList]+['1'+ x for x in lastList[::-1]]
            
        res = recur(n)
        return [int(x,2) for x in res] 
        # int(a,2)把二进制转化成10进制

class Solution:
    def grayCode(self, n: int) -> List[int]:
        res, head = [0], 1
        for i in range(n):
            for subres in res[::-1]: # 逆序，背一背
                res.append(head + subres)
            head <<= 1 # head就是2**i
        return res

class Solution:
    def grayCode(self, n):
        res, head = [0], 1
        for i in range(n):
            for j in range(len(res) - 1, -1, -1): # 逆序，背一背
                res.append(head + res[j])
            head <<= 1 # head就是2**i
        return res
```

###  3.82. <a name='II'></a>90-子集 II

[哈哈哈](https://www.bilibili.com/video/BV11z4y1Q7Hd?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

```py
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        n = len(nums)
        path = []
        nums.sort()
        def backtrack(startIndex):
            if startIndex == n:
                return
            else:
                for i in range(startIndex,n):
                    if i > startIndex and nums[i] == nums[i-1]: 
                        # 易错点：不是nums[i] == nums[startIndex]
                        continue
                    path.append(nums[i])
                    res.append(path[:]) # 易错点：一定要是path[:]
                    backtrack(i+1)
                    path.pop()
        backtrack(0)
        return res
```

```py
class Solution:
    def subsetsWithDup(self, nums):
        res = [[]]
        nums.sort()
        for i in range(len(nums)):
            for j in range(len(res)):
                if res[j] + [nums[i]] not in res:
                    res.append(res[j] + [nums[i]]) 
        return res

# 另一种写法
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        nums.sort()
        for num in nums:
            for subres in res[:]: # 注意：要写成 res[:]
                if subres + [num] not in res:
                    res.append(subres + [num]) 
        return res
```

###  3.83. <a name='DecodeWays'></a>91. Decode Ways

[花花酱](https://www.bilibili.com/video/BV1Lb411y7ec?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1G7M5?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        
        @cache
        def dp(i):
            if i == 0: 
                if '1' <= s[i] <= '9':
                    return 1
                else:
                    return 0
            if i == -1: 
                return 1 
                # 易错点：return 1，而不是return 0，比如‘12’，dp(i-2)应该要是1的
            if i >= 1:
                res = 0
                if '1' <= s[i] <= '9':
                    res = dp(i-1)
                if '10' <= s[i-1:i+1] <= '26':
                    res += dp(i-2)
                return res
        
        return dp(len(s) - 1)
```

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp0 = 1 # 这里dp=0或者是dp=1都可以，因为在第一轮的循环过后会更新
        dp1 = 1
        for i in range(n):
            res = 0
            if '1' <= s[i] <= '9':
                res = dp1
            if i > 0 and '10' <= s[i-1:i+1] <= '26':
                res += dp0
            dp1, dp0 = res, dp1
        return dp1
```

```scala


/**
* my first commitment dynamic programming
* memo:
* 1.subproblem dp(i) represents the decode ways of the sub-string which length is i 
* 2. dp(i) could be sum from dp(i-1) or dp(i-2) if s(i -1, i) or s(i-2, i) are valid coding
*  idx:   0 1 2 3 4 5 6 7
*  length 1 2 3 4 5 6 7 8
&  value  1 2 1 3 2 5 8 3
*   
*   dp(1) => "1"
*   dp(2) => "12" :
*            valid("12") + dp(0)
*            valid("2") + dp(1)
*   dp(3) => "121" :
*           valid("21") + dp(1)
*           valid("1) + dp(2)
*
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s.slice(idx-1, idx).toInt
        val tens = s.slice(idx-2, idx).toInt
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      
      }
      dp.last
    }
}
/**
* instead of using slice, handle single and tens by hands
* memo
*  1. char as digit
*/

object Solution1-1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s(idx-1).asDigit
        val tens = s(idx-2).asDigit * 10 + single
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      }
      
      dp.last
      
    }
}

/**
*  dp - only keep dp(i-1) and dp(i-2)
* time complexity: O(2N)
* space complexity: O(1)
*/

object Solution1-3 {
    def numDecodings(s: String): Int = {
      if (s == null && s.isEmpty) return 0
      (2 to s.length).foldLeft((1, if(s(0) == '0') 0 else 1)) {
      /**
      * pre = dp(i-1)
      * prepre = dp(i-2) 
      */
        case ((prepre, pre), idx) =>
          val decodeOne = if(decodeSingle(s, idx)) pre else 0
          val decodeTwo = if(decodeTens(s, idx)) prepre else 0
          (pre, decodeOne + decodeTwo)
      }._2
    }
  
    def decodeSingle(s: String, idx: Int): Boolean = s(idx - 1) != '0'
  
    def decodeTens(s: String, idx: Int): Boolean = (s(idx - 2) == '1' ) || (s(idx - 2) == '2' && s(idx-1) <= '6' )
    
}



```

###  3.84. <a name='ReverseLinkedListII'></a>92-Reverse Linked List II

[哈哈哈](https://www.bilibili.com/video/BV1n7411G7N4?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV19c411h7UE?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        dummy = ListNode(0,head)
        pre = dummy
        for _ in range(left-1):
            pre = pre.next

        cur = pre.next
        for _ in range(right-left):
            # 易错点：顺序不能错，中，后，前
            aft = cur.next
            cur.next = aft.next
            aft.next = pre.next
            pre.next = aft
        
        return dummy.next
```

###  3.85. <a name='93.IP'></a> 93. 复原 IP 地址

```py
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        def backtrack(s,path):
            if len(path) == 4 and len(s) == 0:
                res.append('.'.join(path))
                return # 注意点：一定要返回
            for i in range(len(s)):
                left,right = s[:i+1],s[i+1:]
                if 0 <= int(left) <= 255 and str(int(left)) ==  left:
                    backtrack(right,path + [left])  
        backtrack(s,[])    
        return res

优化一下：

class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        def backtrack(s,path):
            if len(path) == 4 and len(s) == 0:
                res.append('.'.join(path))
                return 
            if len(path) < 4: # 优化：只有在path小于4的时候，才有必要继续backtrack
                for i in range(min(3,len(s))): # 优化：s不需要遍历完，只要取出前三个看看是否符合
                    left,right = s[:i+1],s[i+1:]
                    if 0 <= int(left) <= 255 and str(int(left)) ==  left:
                        backtrack(right,path + [left])  
        backtrack(s,[])    
        return res
```

###  3.86. <a name='Inorderwihstack'></a>94-Inorder wih stack

[哈哈哈](https://www.bilibili.com/video/BV1uV411o78x?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1o54y1B7Z8?spm_id_from=333.999.0.0)



###  3.87. <a name='BinaryTreeInorderTraversal'></a>94-Binary Tree Inorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7g5?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1mV411Y7T1?spm_id_from=333.999.0.0)

```py
# 递归
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        @cache
        def dfs(root):
            if root: # 不要漏了条件判断
                dfs(root.left)
                res.append(root.val)
                dfs(root.right)
        dfs(root)
        return res
```

```py
# stack
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []

        while stack or root: # 代表res还没有填满
            while root:
                stack.append(root)
                root = root.left
            
            if stack:
                cur = stack.pop()
                res.append(cur.val)
                if cur.right:
                    root = cur.right
        
        return res

# 写啰嗦了，简化一下
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        stack = []

        while stack or root: # 代表res还没有填满
            while root:
                stack.append(root)
                root = root.left
            
            cur = stack.pop()
            res.append(cur.val)
            root = cur.right
        
        return res

# 其他更好理解的写法
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def addAllLeft(node):
            while node:
                stack.append(node)
                node = node.left

        stack, res = [], []
        addAllLeft(root)

        while stack:
            cur = stack.pop()
            res.append(cur.val)
            addAllLeft(cur.right)

        return res

# 其他更好理解的写法
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]: 
        stack, res = [], []
        cur = root
        while stack or cur:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                res.append(cur.val)
                cur = cur.right
        return res
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

/**
* chosen solution
* iterative version
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution0 {
    def inorderTraversal(root: TreeNode): List[Int] = {
      var node = root
      val stack = new collection.mutable.Stack[TreeNode]()
      val result = new collection.mutable.ListBuffer[Int]()

      while(node != null || stack.nonEmpty) {
        while(node != null){
          stack.push(node)
          node = node.left
        }

        node = stack.pop()
        result += node.value
        node = node.right

      }
      result.toList
    }
}


/**
* iterative version
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution1 {
    def inorderTraversal(root: TreeNode): List[Int] = {
      var node = root
      val stack = new collection.mutable.Stack[TreeNode]()
      val result = new collection.mutable.ListBuffer[Int]()

      while(node != null || stack.nonEmpty) {
        while(node != null){
          stack.push(node)
          node = node.left
        }

        node = stack.pop()
        result += node.value
        node = node.right

      }
      result.toList
    }
}

/**
* recursive version
* time complexity: O(N)
* space complexity: O(logN), worst: O(N)
*/
object Solution2 {
    def inorderTraversal(root: TreeNode): List[Int] = {
        _inorderTraversal(root)
    }
    
    def _inorderTraversal(node: TreeNode): List[Int] = {
        if (node == null) Nil
        else
            _inorderTraversal(node.left) ::: List(node.value) ::: _inorderTraversal(node.right)
        
    }
}
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def inorderTraversal(root: TreeNode): List[Int] = {
        if(root == null){
            List.empty[Int]
        }
        else if(root.left == null && root.right == null){
            List(root.value)
        }else if(root.left == null){
            List(root.value) ++ inorderTraversal(root.right)
        }else if(root.right == null){
            inorderTraversal(root.left) ++ List(root.value)
        }else{
            inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)
        }
    }
}

```

###  3.88. <a name='II-1'></a>95. 不同的二叉搜索树 II

```py
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:

        def backtrack(start,end) -> List[TreeNode]:
            if start > end:
                return [None]

            res = [] # res一定要写在backtrack里面
            
            for i in range(start,end+1):
                
                leftTrees = backtrack(start,i-1)
                rightTrees = backtrack(i+1,end)
                
                for left in leftTrees:
                    for right in rightTrees:
                        root = TreeNode(i) # root一定要写在for循环里面
                        root.left = left
                        root.right = right
                        res.append(root)
            return res
                    
        return backtrack(1,n)
```

###  3.89. <a name='UniqueBinarySearchTrees'></a>96. Unique Binary Search Trees

[小梦想家](https://www.bilibili.com/video/BV1xV411Y731?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1e5411W72t?spm_id_from=333.999.0.0)

```py
# 基于上一问修改
class Solution:
    def numTrees(self, n: int) -> int:

        @cache
        def backtrack(n):
            if n <= 1:
                return 1
            else:
                res = 0 # res一定要写在backtrack里面
                for i in range(n):
                    leftTrees = backtrack(i)
                    rightTrees = backtrack(n-i-1)
                    res += leftTrees*rightTrees # 易错点：一定是加号
                return res
                    
        return backtrack(n)

class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2,n+1):
            for subi in range(i):
                dp[i] += dp[subi]*dp[i-subi-1]
        return dp[-1]
```

###  3.90. <a name='ValidateBinarySearchTree98-'></a>98. Validate Binary Search Tree 98-验证二叉搜索树

[花花酱](https://www.bilibili.com/video/BV12t411Y7TP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Wz4y1R7dF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Hv411478d?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Fi4y147Ng?spm_id_from=333.999.0.0)

```py
有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

这样写是错误的，因为不仅仅左小于右就够了
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        if not root.left:
            validleft = True
        elif root.left and root.left.val < root.val and self.isValidBST(root.left):
            validleft = True
        else:
            validleft = False

        if not root.right:
            validright = True
        elif root.right and root.right.val > root.val and self.isValidBST(root.right):
            validright = True
        else:    
            validright = False
        return validleft and validright
```

中序遍历一下就行了

```py
# stack
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, res = [], float('-inf')
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if root.val <= res:
                return False
            res = root.val
            root = root.right
        return True

# 有很多易错点：
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        res = [float('-inf')] # 易错点：要有一个float('-inf')
        valid = True

        @cache
        def dfs(root):
            nonlocal valid # 易错点：valid 从外部传入内部，再传到外部
            if root: # 不要漏了条件判断
                dfs(root.left)
                if root.val <= res[-1]: valid = False
                res.append(root.val)
                dfs(root.right)
        dfs(root)

        return valid
```

定义上下界：

```py
class Solution:
    def isValidBST(self, root):
        def BFS(node, lower, upper):
            if not node:
                return True
            return lower < node.val < upper and BFS(node.left, lower, node.val) and BFS(node.right, node.val, upper)

        return fun(root, float('-inf'), float('inf'))
```

```scala
/**
* chosen solution
* inorder iterative version only keep pre node
* this is also the inorder-iterative-template
* 
* time complexity: O(N)
*/

object Solution0 {
   def isValidBST(root: TreeNode): Boolean = {
    val stack = new collection.mutable.Stack[TreeNode]()
    var node = root
    var pre: TreeNode = null
    var result = true
    while ((node != null || stack.nonEmpty) && result) {
      while (node != null) {
        stack push node
        node = node.left
      }

      node = stack.pop
      if (pre != null && node.value <= pre.value) result = false
      pre = node
      node = node.right

    }
    result
  }
}

/**
* inorder recursive traversal
* memo:
*    1. recursive version with all element storing
* Time complexity O(NlogN)  there are a distinct and sorted operation
* space complexity O(N)
*/
object Solution1 {
  def isValidBST(root: TreeNode): Boolean = {
    val inorder = traversal(root)
    inorder equals inorder.distinct.sorted // why distinct here? [1, 1] is not a BST because left tree should be smaller than root. 
  }
  def traversal(node: TreeNode): List[Int] = {
    if(node == null){
      List.empty[Int]
    }else {
      // (traversal(node.left) :+ node.value) ::: traversal(node.right) 
      traversal(node.left) ::: List(node.value) ::: traversal(node.right)
    }
  }
}



/**
* inorder recursive version only keep pre node
* time complexity: O(N)
*  ! Not recommend
*/

object Solution2 {
    def isValidBST(root: TreeNode): Boolean = {

    var prev: TreeNode = null
    def _isValidBST(node: TreeNode): Boolean = {
      if (node == null) return true
      if (!_isValidBST(node.left)) return false
      if (prev != null && node.value <= prev.value) {
        return false
      }
      prev = node
      _isValidBST(node.right)
    }
    _isValidBST(root)
  }
}

/**
* inorder iterative version only keep pre node
*   inorder iterative template
* time complexity: O(N)
*/

object Solution3 {
   def isValidBST(root: TreeNode): Boolean = {
    val stack = new collection.mutable.Stack[TreeNode]()
    var node = root
    var pre: TreeNode = null
    var result = true
    while ((node != null || stack.nonEmpty) && result) {
      while (node != null) {
        stack push node
        node = node.left
      }

      node = stack.pop
      if (pre != null && node.value <= pre.value) result = false
      pre = node
      node = node.right

    }
    result
  }
}

/**
* giving min max range when recursive
* time complexity: O(N)
*/

object Solution4 {
  def isValidBST(root: TreeNode): Boolean = {

    def _isValidBST(node: TreeNode, min: TreeNode, max: TreeNode): Boolean = {

      if(node == null) true
      else {
        if((min != null && node.value <= min.value) || (max != null  && node.value >= max.value)) false
        else {
          _isValidBST(node.lefmt, min, node) && _isValidBST(node.right, node, max)
        }
      }
    }
    _isValidBST(root, null, null)
  }

}
```

###  3.91. <a name='SameTree'></a>100-Same Tree 

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7ti?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vf4y1R7Ue?spm_id_from=333.999.0.0)

```py
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        if not p or not q:
            return False
        
        queue1 = collections.deque([p])
        queue2 = collections.deque([q])

        while queue1 and queue2:
            node1 = queue1.popleft()
            node2 = queue2.popleft()
            if node1.val != node2.val:
                return False
            left1, right1 = node1.left, node1.right
            left2, right2 = node2.left, node2.right
            if (not left1) ^ (not left2):
                return False
            if (not right1) ^ (not right2):
                return False
            if left1:
                queue1.append(left1)
            if right1:
                queue1.append(right1)
            if left2:
                queue2.append(left2)
            if right2:
                queue2.append(right2)

        return not queue1 and not queue2

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py

class Solution:
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """
        if not p and not q:
            return True
        elif p is not None and q is not None:
            if p.val == q.val:
                return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
            else:
                return False
        else:
            return False

# 递归法
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q: return True
        elif not p or not q: return False
        elif p.val != q.val: return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
# 迭代法
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q: return True
        if not p or not q: return False
        que = collections.deque()
        que.append(p)
        que.append(q)
        while que:
            leftNode = que.popleft()
            rightNode = que.popleft()
            if not leftNode and not rightNode: continue 
            if not leftNode or not rightNode or leftNode.val != rightNode.val: return False 
            que.append(leftNode.left)
            que.append(rightNode.left)
            que.append(leftNode.right)
            que.append(rightNode.right)
        return True

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        return str(p)==str(q)
```

```scala

/**
* my first commitment: recursive dfs traversal 
* time complexity: O(N)
*/
object Solution1 {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        traversal(p, q)
    }
    
    def traversal(p: TreeNode, q: TreeNode): Boolean = {
      (p, q) match {
        case (null, null) => true
        case (null, _) => false
        case (_, null) => false
        case (pp, qq) if pp.value == qq.value =>
        /**
        * we could travel one side and decide if it need to tavel the other side
        */
          traversal(p.left, q.left) && traversal(p.right, q.right)
        case _ => false
      }
    }
}
```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//if (p == null && q == null) {
//true
//} else if (p != null && q == null) {
//false
//} else if (p == null && q != null) {
//false
//} else if (p.value == q.value) {
//isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
//} else {
//false
//}
package lc0100 {
  object Solution {
//    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
//      if (p!=null && q!=null) {
//        p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
//      } else {
//        p == q
//      }
//    }
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        (p,q) match {
          case (p,q) if (p!=null && q!=null) => p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
          case (p,q) => p==q
        }
    }
  }

  class Test extends BaseExtension {
    def init {
      {
        val t1 = Tree.build(IndexedSeq("1","2 3"))
        val t2 = Tree.build(IndexedSeq("1","2 3"))
        println(Solution.isSameTree(t1,t2) == true)
      }
      {
        val t1 = Tree.build(IndexedSeq("1","2"))
        val t2 = Tree.build(IndexedSeq("1","N 2"))
        println(Solution.isSameTree(t1,t2) == false)
      }
    }
    val name = "100 sametree"
  }
}

```

###  3.92. <a name='Symmetrictree'></a>101-Symmetric tree

[哈哈哈](https://www.bilibili.com/video/BV1VJ41197KD?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xv41167z8?spm_id_from=333.999.0.0)

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        '''非递归,从root开始,把比较顺序写下,然后考虑如何用队列或栈实现这个顺序'''
        if root is None:
            return True
        s=[root.left,root.right]
        while s:
            node1=s.pop()
            node2=s.pop()
            if node1 is None and node2 is None:
                pass
            elif (node1 and node2 is None) or (node2 and node1 is None):
                return False
            else:
                if node1.val !=node2.val:
                    return False
                s.append(node1.left)
                s.append(node2.right)
                s.append(node1.right)
                s.append(node2.left)
        return True

    def is_symmetric(self, left:TreeNode ,right:TreeNode)->bool:
        '''左树是否镜像于右树'''
        if left is None and right is None:
            return True
        
        if left is not None and right is not None and left.val ==right.val and \
            self.is_symmetric(left.left,right.right) and self.is_symmetric(left.right,right.left):
            return True
        
        return False

    def isSymmetric_1(self, root: TreeNode) -> bool:
        '''递归'''
        if root is None:
            return True
        return self.is_symmetric(root.left,root.right)
```

```py
Python 递归：

class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        def check(node1, node2):
            if not node1 and not node2:
                return True
            elif not node1 or not node2:
                return False
            
            if node1.val != node2.val:
                return False
            return check(node1.left, node2.right) and check(node1.right, node2.left)
        
        return check(root, root)
Python 迭代：其实就是层序遍历，然后检查每一层是不是回文数组

class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        queue = [root]
        
        while(queue):
            next_queue = list()
            layer = list()
            for node in queue:
                if not node:
                    layer.append(None)
                    continue
                next_queue.append(node.left)
                next_queue.append(node.right)
                
                layer.append(node.val)
                
            if layer != layer[::-1]:
                return False
            queue = next_queue
            
        return True

分别传入左右子节点，主要是递归的 base case 需要理清楚：

要么都为空，要么都不为空
如果两个节点的值不一样，返回 false
递归条件就是 node1 的左子节点和 node2 的右子节点比较，node1 的右子节点与 node2 的左子节点比较。

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        return self._isSymmetric(root.left, root.right)
    
    def _isSymmetric(self, node1, node2):
        if not node1 and not node2: # 如果两个节点都为空，返回真
            return True
        if not node1 or not node2:
            return False
        if node1.val != node2.val:
            return False
        return self._isSymmetric(node1.left, node2.right) and self._isSymmetric(node1.right, node2.left)
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def symmetric(nodeA: TreeNode, nodeB: TreeNode): Boolean = {
        if(nodeA == null && nodeB == null){
            true
        }else if(nodeA !=null && nodeB != null){
            if(nodeA.value != nodeB.value){
                false
            }else{
                symmetric(nodeA.left, nodeB.right) && symmetric(nodeA.right, nodeB.left)
            }
        }else{
            false
        }
    }
    
    def isSymmetric(root: TreeNode): Boolean = {
        if(root == null){
            true
        } else{
            symmetric(root.left, root.right)
        }
    }
}

```

###  3.93. <a name='BinaryTreeLevelOrderTraversal'></a>102-Binary Tree Level Order Traversal

[哈哈哈](https://www.bilibili.com/video/BV1W54y197Lc?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14T4y1u7Wk?spm_id_from=333.999.0.0)

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        '''队列'''
        if root is None:
            return []
        q=[root]
        ret=[]
        while q:
            size=len(q)#当前层的个数!!!
            t=[]
            for _ in range(size):
                node=q.pop(0)
                t.append(node.val)

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            ret.append(t)
        return ret
```

```py
# 这个BFS模板真的是万能啊，除了本题，116、117等题也随便套。

class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        ans = []
        queue = [root] # 队列
        while queue:
            temp = []
            lenQ = len(queue) # 队列
            for i in range(lenQ):
                print("lenQ:",lenQ," i:",i)
                node = queue.pop(0) # 队列,lenQ有几次，就pop几次
                temp.append(node.val) 
                if node.left:
                    queue.append(node.left) # 队列
                if node.right:
                    queue.append(node.right) # 队列
            ans.append(temp)
        return ans

class Solution:
    def levelOrder(self, root: TreeNode):
        from collections import deque
        queue = deque() # 队列
        result = []
        if not root:
            return []
        queue.append(root) # 队列
        while queue: # 队列
            current_level_size = len(queue) # 队列
            current_level = [] # level【】
            for _ in range(current_level_size): # 队列,lenQ有几次，就pop几次
                node = queue.popleft() # 队列,lenQ有几次，就pop几次
                current_level.append(node.val) # level【】
                if node.left:
                    queue.append(node.left) # 队列
                if node.right:
                    queue.append(node.right) # 队列
            result.append(current_level) # level【】
        return result
```

```py
# py两分钟打完一次提交bug free，go因为尝试了下hash的无序性wa了一次，狗rust编译了10次以上才过，费老jb劲了

# py 用字典存层（py字典是有序的，所以最好用，其他语言都不好写）。
import collections
class Solution:
    def levelOrder(self, root):
        dic = collections.defaultdict(list)
        # --------------------- recurHelper ---------------------
        def recurHelper(node, level):
            if node:
                dic[level].append(node.val)
                recurHelper(node.left, level + 1)
                recurHelper(node.right, level + 1)
        recurHelper(root, 0) # 传入 (root, 0)
        # --------------------- recurHelper ---------------------
        
        return [*dic.values()]

# 递归

# ```python
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        res = []
        self.recurHelper(root, 0, res)
        return res
    
    def recurHelper(self, node, level, res):
        if not node: return
        if len(res) < level + 1:
            res.append([])
        res[level].append(node.val)
        self.recurHelper(node.left, level+1, res)
        self.recurHelper(node.right, level+1, res)
```

```scala
/**
* chosen solution
* BFS iterative
* time complexity O(N）
*/
object Solution0 {
  def levelOrder(root: TreeNode): List[List[Int]] = {
    if(root == null) return List[List[Int]]()

    val buffer =  scala.collection.mutable.Queue[TreeNode]()
    val result =  scala.collection.mutable.ListBuffer[List[Int]]()

    buffer.enqueue(root)
    while(buffer.nonEmpty) {
      val currentLevel = scala.collection.mutable.ListBuffer[Int]()

      for (_ <- 0 until buffer.size) {

        val node = buffer.dequeue
        currentLevel.append(node.value)

        if(node.left != null) buffer.enqueue(node.left)
        if(node.right != null) buffer.enqueue(node.right)
      }
      result += currentLevel.toList
    }

    result.toList

  }
}
/**
* BFS - iterative
* time complexity O(N）
*/
object Solution1 {
  def levelOrder(root: TreeNode): List[List[Int]] = {
    if(root == null) return List[List[Int]]()

    val buffer =  scala.collection.mutable.Queue[TreeNode]()
    val result =  scala.collection.mutable.ListBuffer[List[Int]]()

    buffer.enqueue(root)
    while(buffer.nonEmpty) {
      val currentLevel = scala.collection.mutable.ListBuffer[Int]()

      for (_ <- 0 until buffer.size) {

        val node = buffer.dequeue
        currentLevel.append(node.value)

        if(node.left != null) buffer.enqueue(node.left)
        if(node.right != null) buffer.enqueue(node.right)
      }
      result += currentLevel.toList
    }

    result.toList

  }
}
/**
* using hashmap to store level-list mapping
*/

object Solution2 {
  def levelOrder(root: TreeNode): List[List[Int]] = {
    val oderMap = scala.collection.mutable.Map[Int, List[Int]]()
    mapOrder(root, 1, oderMap)
    oderMap.values.toList
  }
  def mapOrder(node: TreeNode, level: Int, map: scala.collection.mutable.Map[Int, List[Int]]): Unit = {
    if (node != null) {

      val l = map.get(level)
        .map(_ :+ node.value)
        .getOrElse(List(node.value))

      map(level) = l
      mapOrder(node.left, level + 1, map)
      mapOrder(node.right, level + 1, map)

    }
  }
}

/**
* BFS - recursive with tail recursion
*/

object Solution3 {
  def levelOrder(root: TreeNode): List[List[Int]] = {
    _levelOrder(if(root == null) List() else List(root), List())
  }

  @annotation.tailrec
  def _levelOrder(queue: List[TreeNode], ans: List[List[Int]]): List[List[Int]] = {
    if(queue.isEmpty) ans
    else{
      // val level = queue.map(n => n.value)
      // val newQueue = queue.flatMap(n => List(n.left, n.right)).filter(_ != null)
      // _levelOrder(newQueue, ans :+ level)
      _levelOrder(queue.flatMap(n => List(n.left, n.right)).filter(_ != null), ans :+ queue.map(n => n.value))
    }

  }
}
```

###  3.94. <a name='BinaryTreeZigzagLevelOrderTraversal'></a>103. Binary Tree Zigzag Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1NE411M7Fm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15h411Z7h5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GA411W7NY?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root: return []

        que = []
        res = []
        que.append(root)
        index = 1 # flag
        while que:
            temp = []
            for _ in range(len(que)):
                cur = que.pop(0)
                temp.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            index += 1 # flag
            if not index % 2: # flag
                res.append(temp[:])
            else:
                res.append(temp[::-1])
        return res

# python 双端duque
from collections import deque
class Solution:
    def zigzagLevelOrder(self, root):
        q = deque([root])
        res = []
        flag = True # flag
        while q and q[0]:
            n = len(q)
            temp = []
            for i in range(n):
                node = q.popleft()
                temp.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if flag: # flag
                res.append(temp)
            else:
                res.append(temp[::-1])  # [::-1]反转
            flag = bool(1-flag) # flag
        return res
```

```py
# 先层次遍历，再对相应层数进行翻转。 python 执行用时，在所有python3提交中击败了96.87%的用户。

class Solution:
    def zigzagLevelOrder(self, root):
        stack = []
        def dfs(node, level, res):
            if not node:
                return
            if level >= len(res):
                res.append([])
            res[level].append(node.val)
            dfs(node.left, level + 1, res)
            dfs(node.right, level + 1, res)

        dfs(root, 0, stack)
        for i in range(1, len(stack), 2): # flag，各两个逆序
            stack[i] = stack[i][::-1]
        return stack

# 递归

class Solution:
    def zigzagLevelOrder(self, root):
        res = []
        if not root:
            return []
        
        def dfs(node, level):
            if len(res) == level:
                res.append([])
            
            if level % 2:
                res[level].insert(0, node.val)
            else:
                res[level].append(node.val)

            if node.left:
                dfs(node.left, level+1)
            if node.right:
                dfs(node.right, level+1)
            
        dfs(root, 0)
        return res
```

###  3.95. <a name='MaximumDepthofBinary'></a>104-Maximum Depth of Binary

[哈哈哈](https://www.bilibili.com/video/BV1AJ411Q7xG?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1u54y1D7Nx?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tK41137GM?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        '''树的最大深度,递归。层次遍历也行'''
        if root is None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

/**
* chosen solution
* BFS - recursive
* time complexity: O(N), N is the total node in tree
* space complexity: O(logN) depending on the depth of tree
*/
object Solution0 {
    def maxDepth(root: TreeNode): Int = {
        _maxDepth(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def _maxDepth(queue: List[TreeNode], ans: Int): Int = {
        if(queue.isEmpty) ans
        else _maxDepth(queue.flatMap(l => List(l.left, l.right)).filter(_ != null), ans + 1)
    }
}

 /**
* my first commitment
* DFS traversal - recursive
* time complexity O(N)
*/
object Solution1 {
    def maxDepth(root: TreeNode): Int = {
        if (root == null) return 0
        /**
        val left =  1 + maxDepth(root.left)
        val right = 1 + maxDepth(root.right)
        math.max(left, right)
        */
        math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}

/**
* BFS - iterative
* memo
*   1. queue: BFS iterative template
* time complexity: O(N) n is node number in tree
* space complexity: O(logN) , depending on the depth oof the tree
*/


object Solution2 {
    def maxDepth(root: TreeNode): Int = {
        if(root == null) return 0
        var depth = 0
        val queue = scala.collection.mutable.Queue[TreeNode]()
        queue.enqueue(root)

        while(queue.nonEmpty) {
            depth += 1
            for(_ <- 0 until queue.size){
                val node = queue.dequeue
                if(node.left != null) queue.enqueue(node.left)
                if(node.right != null) queue.enqueue(node.right)
            }
        }   
        depth
    }
}

/**
* BFS - recursive
* time complexity: O(N), N is the total node in tree
* space complexity: O(logN) depending on the depth of tree
*/

object Solution3 {
    def maxDepth(root: TreeNode): Int = {
        _maxDepth(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def _maxDepth(queue: List[TreeNode], ans: Int): Int = {
        if(queue.isEmpty) ans
        else _maxDepth(queue.flatMap(l => List(l.left, l.right)).filter(_ != null), ans + 1)
    }
}

```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def maxDepth(root: TreeNode): Int = root match {
        case null => 0
        case x: TreeNode => Math.max((1 + maxDepth(x.left)), (1 + maxDepth(x.right)))
    }
}

```

###  3.96. <a name='-1'></a>105-从前序与中序遍历序列构

[哈哈哈](https://www.bilibili.com/video/BV1uv411B73D?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1x54y1d7e8?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1ry4y1U7ZR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14A411q7Nv?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        '''可以考虑传递下标，减少数组拷贝的时间'''
        if len(preorder)==0:
            return None
        root_val=preorder[0]
        i=inorder.index(root_val)
        left_inorder=inorder[:i]
        right_inorder=inorder[i+1:]
        left_preorder=preorder[1:1+i]
        right_preorder=preorder[1+i:]

        return TreeNode(root_val,self.buildTree(left_preorder,left_inorder),self.buildTree(right_preorder,right_inorder))
```

```py
class Solution:
    def buildTree(self, preorder, inorder):
        if not preorder:return None

        x = preorder.pop(0) #前序第一个为root
        root = TreeNode(x)
        i = inorder.index(x) #中序遍历 root 的index

        root.left = self.buildTree(preorder[:i], inorder[:i])
        root.right = self.buildTree(preorder[i:], inorder[i+1:])
        return root

class Solution:
    def buildTree(self, preorder, inorder):
        if inorder:
            t = TreeNode(preorder.pop(0))
            i = inorder.index(t.val)
            t.left = self.buildTree(preorder, inorder[: i])
            t.right = self.buildTree(preorder, inorder[i + 1:])
            return t

# 递归构造，非常简洁！
# 改变了参数 preorder
# 方法一样，但是没用index ，大佬提醒了这个用法，
# 效率低是因为index函数复杂度是O（n），但是实际可以用哈希表将这个过程优化成O（1）
class Solution(object):
    def buildTree(self, preorder, inorder):
        if not preorder: 
            return None
        
        x = preorder.pop(0)
        node = TreeNode(x)
        i = inorder.index(x)
        
        node.left = self.buildTree(preorder[:i], inorder[:i])
        node.right = self.buildTree(preorder[i:], inorder[i+1:])
        return node
```

```scala

/**
* my first commitment
* memo
*  1. preorder traversal provides us with the placement of the root
*  2. inorder traversal provides us with the placement of the left and right children
* time complexity: O(2N)
*   1. build hashmap O(N)
*   2. build tree O(N)
*/
object Solution1 {
    def buildTree(preorder: Array[Int], inorder: Array[Int]): TreeNode = {
      val inorderMap = inorder.zipWithIndex.toMap
      buildTree(preorder, 0, inorderMap, 0, inorder.length - 1)
  
    }
  
  
    def buildTree(preorder: Array[Int], preorderIdx: Int, inorderMap: Map[Int, Int], inorderLeft: Int, inorderRight: Int): TreeNode = {
      if (inorderLeft > inorderRight || preorderIdx >= preorder.length) return null

      val currentRootValue = preorder(preorderIdx)
      val node = new TreeNode(currentRootValue)
     
      val preorderIdxOfRight = preorderIdx + inorderMap(currentRootValue) - inorderLeft + 1

      node.left = buildTree(preorder, preorderIdx + 1, inorderMap, inorderLeft, inorderMap(currentRootValue) - 1 )
      
      /**
     * right child's preoder index
     * the problem is how many increment should we have after building the left child tree
     * the answer above is:  the number of node at left child tree when root node is current preorder index  
     *  1. current root index: current preorder index
     *  2. the number nodes of left child tree: 
     *        the number of node between (inorderLeft, inorderMap(currentRootValue)]  in  inorder array
     *
     *  so the child's preorder index is: current preorder index + number of node at left child  + 1 (next)
     *
     */
      
      node.right = buildTree(preorder, preorderIdxOfRight, inorderMap, inorderMap(currentRootValue) + 1, inorderRight)
      
      node
    }
}
```

###  3.97. <a name='-1'></a>106-从中序与后序遍历序列构造二叉树

[哈哈哈](https://www.bilibili.com/video/BV1r5411W7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jh411Z7y8?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        '''传递下标'''
        index={}#元素在中序的下标
        for i in range(len(inorder)):
            index[inorder[i]]=i

        def build(inorder: List[int], postorder: List[int],i_l,i_r,p_l,p_r) -> TreeNode:
            if i_l>i_r:
                return None
            root_val=postorder[p_r]
            i=index[root_val]

            return TreeNode(root_val,build(inorder,postorder,i_l,i-1,p_l,p_l+(i-i_l-1)),\
                    build(inorder,postorder,i+1,i_r,p_l+(i-i_l),p_r-1))
        return build(inorder,postorder,0,len(inorder)-1,0,len(postorder)-1)

    def buildTree_1(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if len(postorder)==0:
            return None
        root_val=postorder[-1]
        i=inorder.index(root_val)

        left_inorder=inorder[:i]
        right_inorder=inorder[i+1:]
        left_postorder=postorder[:i]
        right_postorder=postorder[i:len(postorder)-1]#左闭右开!!
        return TreeNode(root_val,self.buildTree(left_inorder,left_postorder),self.buildTree(right_inorder,right_postorder))
```

```py
# 递归构造，非常简洁！90%

class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        
        if not inorder:
            return None
        
        x = postorder.pop()
        i = inorder.index(x)
        
        node = TreeNode(x)
        node.left = self.buildTree(inorder[:i], postorder[:i])
        node.right = self.buildTree(inorder[i+1:], postorder[i:])
        return node

class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        if not postorder:
            return None
        root = TreeNode(postorder[-1])#创建树
        n = inorder.index(root.val)
        root.left = self.buildTree(inorder[:n],postorder[:n])
        root.right = self.buildTree(inorder[n+1:],postorder[n:-1])
        return root

class Solution(object):
    def buildTree(self, inorder, postorder):
        if postorder == inorder == []:
            return None
        else:
            rootVal = postorder[-1]
            root = TreeNode(rootVal)
            print("rootVal:",rootVal)
            print("inorder:",inorder)
            k = inorder.index(rootVal)
            root.left = self.buildTree(inorder[:k],postorder[:k])
            root.right = self.buildTree(inorder[k+1:],postorder[k:-1])
            return root  
```

###  3.98. <a name='BinaryTreeLevelOrderTraversalII'></a>107-Binary Tree Level Order Traversal II

[哈哈哈](https://www.bilibili.com/video/BV1eJ411z7d6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1yK411n76R?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qA411i7P4?spm_id_from=333.999.0.0)


```py
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        '''层次遍历的逆序'''
        if root is None:
            return []
        q=[root]
        ret=[]
        while q:
            size=len(q)# 当前层节点的个数
            t=[]
            for _ in range(size):
                node=q.pop(0)
                t.append(node.val)

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            ret.append(t)
        return ret[::-1]
```

```py

```
###  3.99. <a name='ConvertSortedArraytoBinarySearchTree'></a>108 Convert Sorted Array to Binary Search Tree 

[花花酱](https://www.bilibili.com/video/BV1F7411H7tH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1JJ411q74U?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wa411c7tS?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left > right:
                return None

            # 总是选择中间位置左边的数字作为根节点
            mid = (left + right) // 2

            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(nums) - 1)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left > right:
                return None

            # 总是选择中间位置右边的数字作为根节点
            mid = (left + right + 1) // 2

            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(nums) - 1)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left > right:
                return None

            # 选择任意一个中间位置数字作为根节点
            mid = (left + right + randint(0, 1)) // 2

            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(nums) - 1)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
递归法：

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def buildaTree(left,right):
            if left > right: return None  #左闭右闭的区间，当区间 left > right的时候，就是空节点,当left = right的时候，不为空
            mid = left + (right - left) // 2 #保证数据不会越界
            val = nums[mid]
            root = TreeNode(val)
            root.left = buildaTree(left,mid - 1)
            root.right = buildaTree(mid + 1,right)
            return root
        root = buildaTree(0,len(nums) - 1)  #左闭右闭区间
        return root

简单递归就行

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid+1:])
        return root
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def formTree(nums: Array[Int], begin: Int, end: Int): TreeNode = {
        var mid = begin + Math.ceil((end - begin)/2).toInt
        TreeNode(
            nums(mid), 
            if(mid <= begin) null else formTree(nums, begin, mid-1), 
            if(mid >= end) null else formTree(nums, mid+1, end)
        )
    }
    
    def sortedArrayToBST(nums: Array[Int]): TreeNode = {
        if(nums.isEmpty){
            null
        }else{
            formTree(nums, 0, nums.size - 1)
        }
    }
}

```

###  3.100. <a name='-1'></a>109题. 有序链表转换二叉搜索树

https://www.bilibili.com/video/BV19a4y157U8?spm_id_from=333.999.0.0

https://www.bilibili.com/video/BV1ff4y197dS?spm_id_from=333.999.0.0

```py
class Solution:
    def sortedListToBST(self, head) -> TreeNode:
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)
            
        fast = slow = pre = head # pre切断
        while fast and fast.next:
            pre = slow # pre切断
            slow = slow.next
            fast = fast.next.next
        node = TreeNode(slow.val)
        # print(head.val,node.val,last.val)
        node.right = self.sortedListToBST(slow.next) # 从mid+1到tail
        pre.next = None # pre切断
        node.left = self.sortedListToBST(head) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        return node

class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        ###找到中间节点 断开   去掉中间节点
        ### 左子树等于递归 左边那段   右子树等于递归右边那段
        fast = head
        slow = head
        pre =  head
        if not head:
            return 
        while(fast and fast.next):
            fast = fast.next.next
            pre = slow
            slow  = slow.next
        root = TreeNode(slow.val)
        if slow==fast:
            return root 
        pre.next = None
        root.left = self.sortedListToBST(head) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        root.right = self.sortedListToBST(slow.next) # 从mid+1到tail
        return root
```

https://www.bilibili.com/video/BV19K411T73P?p=2&spm_id_from=pageDriver

```py
# py3 递归+快慢指针法。
# 不用断开链表，分别用head和tail定义链首和链尾，
# 链表区间为左闭右开，即 [ head , tail ）。

class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        return self.helper(head,None)

    def helper(self,head,tail):
        if head==tail:
            return
        slow=head
        fast=head
        while fast!=tail and fast.next!=tail:
            slow=slow.next
            fast=fast.next.next
        root=TreeNode(slow.val)
        root.left=self.helper(head,slow) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        root.right=self.helper(slow.next,tail) # 从mid+1到tail
        return root

class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getMedian(head: ListNode, tail: ListNode) -> ListNode:
            fast = slow = head
            while fast != tail and fast.next != tail:
                fast = fast.next.next
                slow = slow.next
            return slow
        
        def buildTree(left: ListNode, right: ListNode) -> TreeNode:
            if left == right:
                return None
            mid = getMedian(left, right)
            root = TreeNode(mid.val)
            root.left = buildTree(left, mid) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
            root.right = buildTree(mid.next, right) # 从mid+1到tail
            return root
        
        return buildTree(head, None)
```

```py

```

```py

```

###  3.101. <a name='BalancedBinaryTree'></a>110-Balanced Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1NJ411v7b1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Lb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sV411b7hR?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            return max(height(root.left), height(root.right)) + 1

        if not root:
            return True
        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            leftHeight = height(root.left)
            rightHeight = height(root.right)
            if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) > 1:
                return -1
            else:
                return max(leftHeight, rightHeight) + 1

        return height(root) >= 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

沙发。直接在递归高度的过程中判断每个节点是否平衡不就好了。时间和空间复杂度都是O(n)。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def helper(node):
            if not node:  return 0
            left_depth = helper(node.left)
            right_depth = helper(node.right)
            if abs(left_depth - right_depth) > 1:
                flag[0] = False
            return max(left_depth, right_depth) + 1
        flag = [True]
        helper(root)
        return flag[0]

其实就是二叉树先序遍历和后序遍历的区别，每种遍历方式都有它的用武之地。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        ans = True
        
        def post_order(root):
            nonlocal ans
            if not root or not ans:
                return 0
            l = post_order(root.left)
            r = post_order(root.right)
            if abs(l-r) > 1:
                ans = False
            return max(l, r) + 1
        
        post_order(root)
        return ans
```

```py

```

###  3.102. <a name='MinimumDepthofBinaryTree'></a>111-Minimum Depth of Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1E7411k7KY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1XZ4y1G7xM?spm_id_from=333.999.0.0)

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        if root.left is not None and root.right is None:#较高一层的值
            return 1+self.minDepth(root.left)
        if root.right is not None and root.left is None:
            return 1+self.minDepth(root.right)
        return 1+min(self.minDepth(root.left),self.minDepth(root.right))

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        """
        :type root: TreeNode
        :rtype: int
        """
        if root:
            if root.left and root.right:
                return 1+min(self.minDepth(root.left),self.minDepth(root.right))
            elif root.left:
                return 1+self.minDepth(root.left)
            elif root.right:
                return 1+self.minDepth(root.right)
            else:
                return 1
        else:
            return 0
递归
```

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        if not root.left and not root.right:
            return 1
        
        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth)
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth)
        
        return min_depth + 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        que = collections.deque([(root, 1)])
        while que:
            node, depth = que.popleft()
            if not node.left and not node.right:
                return depth
            if node.left:
                que.append((node.left, depth + 1))
            if node.right:
                que.append((node.right, depth + 1))
        
        return 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```scala
/**
* chosen solution
* 
* BFS - recursive
* time complexity
*    worst case: O(N), all node was visited
*/
object Solution0 {
    def minDepth(root: TreeNode): Int = {
        _minDepth(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def _minDepth(queue: List[TreeNode], ans: Int): Int = {
        if(queue.isEmpty) ans
        // node has no child 
        else if(queue.exists(t => t.left == null && t.right == null)) ans + 1
        else _minDepth(queue.flatMap(t => List(t.left, t.right)).filter(_ != null), ans + 1)
    }
}


/**
* DFS traversal - recursive
* memo
* 1.edge case: node only have one child
* time complexity O(N)
*/
object Solution1 {
    def minDepth(root: TreeNode): Int = {
        if (root == null) return 0
        val left = minDepth(root.left) 
        val right = minDepth(root.right) 

        if (left == 0 || right == 0) left + right + 1 else math.min(left, right) + 1
        
    }
}

object Solution1_2 {
    def minDepth(root: TreeNode): Int = {
        if(root == null) 0
        else if(root.left == null) minDepth(root.right) + 1
        else if(root.right == null) minDepth(root.left) + 1
        else minDepth(root.right) + 1 min minDepth(root.left) + 1
    
    }
}

/**
* BFS - iterative
* memo
*   1. queue
*   2. shortcut condition
* time complexity
*    worst case: O(N), all node was visited
*    if the tree was unbalance, BFS may be better
*/
object Solution2 {
    def minDepth(root: TreeNode): Int = {
        if(root == null) return 0
        val queue = scala.collection.mutable.Queue[TreeNode]()
        var depth = 0
        var condition = true
        queue.enqueue(root)
        
        while(queue.nonEmpty && condition){
            depth += 1
            for(_ <- 0 until queue.size; if condition){
                val node = queue.dequeue
                if(node.left == null && node.right == null) condition = false
                else {
                    if(node.left != null) queue.enqueue(node.left)
                    if(node.right != null) queue.enqueue(node.right)
                } 
            } 
        }
        depth
        
    }
}  


/**
* BFS - recursive
* time complexity
*    worst case: O(N), all node was visited
*/
object Solution3 {
    def minDepth(root: TreeNode): Int = {
        _minDepth(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def _minDepth(queue: List[TreeNode], ans: Int): Int = {
        if(queue.isEmpty) ans
        else if(queue.exists(t => t.left == null && t.right == null)) ans + 1
        else _minDepth(queue.flatMap(t => List(t.left, t.right)).filter(_ != null), ans + 1)
    }
}
```

###  3.103. <a name='PathSum'></a>112-Path Sum

[哈哈哈](https://www.bilibili.com/video/BV1T7411r7Yr?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1pb411e7r7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1uK411T7kX?spm_id_from=333.999.0.0)

```py
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        '''递归'''
        if root is None:
            return False
        if root.val==targetSum:
            return True
        return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
```

```py
典型的得用DFS做的题目，不断深入每个节点，只要找到一个即可

dfs函数包括当前节点和当前路径总和

如果当前节点为叶子节点，并且路径总和等于目标值，就改变ans为True

否则就继续深入当前节点的左右节点

class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root == None:
            return False
        self.target = targetSum
        self.ans = False
        self.dfs(root, 0)
        return self.ans

    def dfs(self, r, sumNum):
        if not r.left and not r.right:
            if sumNum + r.val == self.target:
                self.ans = True
        else:
            if r.left:
                self.dfs(r.left,  sumNum + r.val)
            if r.right:
                self.dfs(r.right, sumNum + r.val)

class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que_node = collections.deque([root])
        que_val = collections.deque([root.val])
        while que_node:
            now = que_node.popleft()
            temp = que_val.popleft()
            if not now.left and not now.right:
                if temp == sum:
                    return True
                continue
            if now.left:
                que_node.append(now.left)
                que_val.append(now.left.val + temp)
            if now.right:
                que_node.append(now.right)
                que_val.append(now.right.val + temp)
        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right:
            return sum == root.val
        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  3.104. <a name='-1'></a>113. 二叉树中和为某一值的路径

[哈哈哈](https://www.bilibili.com/video/BV1P54y1i73U?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1k54y177fu?spm_id_from=333.999.0.0)

```py
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        '''dfs+路径记录'''
        path=[]
        ret=[]
        def dfs(root,targetSum):
            if root is None:
                return
            
            path.append(root.val)
            if root.val==targetSum and root.left is None and root.right is None:
                ret.append(path.copy())#!!!!拷贝

            dfs(root.left,targetSum-root.val)
            dfs(root.right,targetSum-root.val)
            path.pop()
        dfs(root,targetSum)
        return ret
```

```py
class Solution:
    def pathSum(self, root: TreeNode, sum: int):
        res = []
        def dfs(root, tmp, sum):
            nonlocal res
            if not root:
                return 
            
            sum -= root.val # 对于每一个node，当前node的sum = 总和sum - root的值
            if not root.left and not root.right and sum == 0: # 结束条件
                res.append(tmp + [root.val])
            dfs(root.left, tmp + [root.val], sum)
            dfs(root.right, tmp + [root.val], sum)
            return res
        
        dfs(root, [], sum)
        return res

class Solution:
    def pathSum(self, root, targetSum: int):
        res = list()
        path = list()
        
        def dfs(node, sum):
            if not node:
                return
            path.append(node.val)
            sum -= node.val # 对于每一个node，当前node的sum = 总和sum - root的值
            if not node.left and not node.right and sum == 0: # 结束条件
                res.append(path[:])
            dfs(node.left, sum)
            dfs(node.right, sum)
            path.pop()
        
        dfs(root, targetSum)
        return res
```

```py
# 注意宁愿写几次curList + [root.val] 也不要直接传一个list进去，因为list pass by reference的亏已经吃过了

# ```python
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        res = []
        self.auxPathSum(root, sum, [], res)
        return res
    def auxPathSum(self, root, sum, path, res):
        if not root:
            return
        sum -= root.val # 对于每一个node，当前node的sum = 总和sum - root的值
        if sum == 0 and not root.left and not root.right:
            res.append(path + [root.val])
            return 
        if root.left:
            self.auxPathSum(root.left, sum, path + [root.val], res) 
        if root.right:
            self.auxPathSum(root.right, sum, path + [root.val], res)
```

###  3.105. <a name='-1'></a>114题. 二叉树展开为链表

https://www.bilibili.com/video/BV1T7411A7S8?from=search&seid=15731266160913668837&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6tma3pncods0.png" width="80%">

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5csg54lu3lw0.png" width="50%">

```py
class Solution:
    def flatten(self, root: TreeNode) -> None:
        if not root:
            return
        
        stack = [root]
        prev = None
        
        while stack:
            curr = stack.pop()
            if prev:
                prev.left = None
                prev.right = curr
            left, right = curr.left, curr.right
            if right:
                stack.append(right)
            if left:
                stack.append(left)
            prev = curr

        return root

class Solution:
    def flatten(self, root: TreeNode) -> None:
        preorderList = list()
        stack = list()
        node = root

        while node or stack:
            while node:
                preorderList.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        
        size = len(preorderList)
        for i in range(1, size):
            prev, curr = preorderList[i - 1], preorderList[i]
            prev.left = None
            prev.right = curr
```

```py
class Solution(object):
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: void Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        #把子树备份一下
        left_node = root.left
        right_node = root.right
        root.left = None #记得把左子树置空
        #先把左右子树捋直
        self.flatten(left_node)
        self.flatten(right_node)
        if left_node:
            root.right = left_node #把捋直的左子树放到右边
            while left_node.right: #找到现在右子树的最后一个node
                left_node = left_node.right 
            left_node.right = right_node #左子树接上右子树



        return root
```

###  3.106. <a name='DistinctSubsequences'></a>115. Distinct Subsequences

[花花酱](https://www.bilibili.com/video/BV1EW411d7PC?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV185411G7F6?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        if m < n:
            return 0
        
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][n] = 1
        
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if s[i] == t[j]:
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]
                else:
                    dp[i][j] = dp[i + 1][j]
        
        return dp[0][0]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/distinct-subsequences/solution/bu-tong-de-zi-xu-lie-by-leetcode-solutio-urw3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]
        for i in range(len(s)):
            dp[i][0] = 1
        for j in range(1, len(t)):
            dp[0][j] = 0
        for i in range(1, len(s)+1):
            for j in range(1, len(t)+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
Python3:

class SolutionDP2:
    """
    既然dp[i]只用到dp[i - 1]的状态，
    我们可以通过缓存dp[i - 1]的状态来对dp进行压缩，
    减少空间复杂度。
    （原理等同同于滚动数组）
    """
    
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(s), len(t)
        if n1 < n2:
            return 0

        dp = [0 for _ in range(n2 + 1)]
        dp[0] = 1

        for i in range(1, n1 + 1):
            # 必须深拷贝
            # 不然prev[i]和dp[i]是同一个地址的引用
            prev = dp.copy()
            # 剪枝，保证s的长度大于等于t
            # 因为对于任意i，i > n1, dp[i] = 0
            # 没必要跟新状态。 
            end = i if i < n2 else n2
            for j in range(1, end + 1):
                if s[i - 1] == t[j - 1]:
                    dp[j] = prev[j - 1] + prev[j]
                else:
                    dp[j] = prev[j]
        return dp[-1]
```

###  3.107. <a name='PopulatingNextRightPointersinEachNode'></a>116. Populating Next Right Pointers in Each Node

[花花酱](https://www.bilibili.com/video/BV1b4411R7G4?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1zQ4y1M75t?spm_id_from=333.999.0.0)

```py
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if root is None:
            return None
        
        q=[root]
        while q:
            size=len(q)
            last=None
            for _ in range(size):
                node=q.pop(0)
                if last:
                    last.next=node
                last=node

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
        
        return root
```

```py
# BFS版本

class Solution:
    # 层次遍历
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        q = deque([root])
        while q:
            sz = len(q)
            for i in range(sz):
                cur = q.popleft()
                if i < sz - 1:
                    cur.next = q[0]
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            
        return root

# DFS版本，只要关注两棵子树的next指针构建即可

class Solution:
    # DFS
    def connect(self, root: 'Node') -> 'Node':
        if not root: return
        def dfs(root1, root2):
            if not (root1 and root2): return 
            root1.next = root2
            dfs(root1.left, root1.right)
            dfs(root1.right, root2.left)
            dfs(root2.left, root2.right)
        
        dfs(root.left, root.right)
        return root

# Python递归，先序遍历，感觉很容易理解，速度还可以，只是空间复杂度用了递归所以差了点

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        def f(root):
            if root:
                p,q=root.left,root.right
                while p:
                    p.next=q
                    p,q=p.right,q.left
                f(root.left)
                f(root.right)
            return
        f(root)
        return root
```

###  3.108. <a name='PopulatingNextRightPointersinEa'></a>117 Populating Next Right Pointers in Ea

[小明](https://www.bilibili.com/video/BV1np4y1r7fQ?spm_id_from=333.999.0.0)


###  3.109. <a name='PascalsTriangle'></a>118-Pascal's Triangle

[哈哈哈](https://www.bilibili.com/video/BV1T741167KS?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7tJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1D54y147NY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        ret = list()
        for i in range(numRows):
            row = list()
            for j in range(0, i + 1):
                if j == 0 or j == i:
                    row.append(1)
                else:
                    row.append(ret[i - 1][j] + ret[i - 1][j - 1])
            ret.append(row)
        return ret

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/pascals-triangle/solution/yang-hui-san-jiao-by-leetcode-solution-lew9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

库函数重拳出击！

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        return [[comb(i, j) for j in range(i + 1)] for i in range(numRows)]
```

```py
class Solution:
    def generate(self, numRows):
        """
        :type numRows: int
        :rtype: List[List[int]]
        """
        result = []
        for i in range(numRows):
            now = [1]*(i+1)
            if i >= 2:
                for n in range(1,i):
                    now[n] = pre[n-1]+pre[n]
            result += [now]
            pre = now
        return result

头尾为1，中间的第j个为上一层的第j-1个和j个的和，即：

第i行lst[j] = ans[i-1][j-1] + ans[i-1][j]

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        ans = [[1]]
        for i in range(1, numRows):
            lst = [0 for _ in range(i+1)]
            lst[0], lst[-1] = 1, 1
            for j in range(1,i):  
                lst[j] = ans[i-1][j-1] + ans[i-1][j]
            ans.append(lst)
        return ans

计算好上一层的，用上一层的计算下一层

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        ans = []
        # 遍历每一层
        for i in range(1,numRows+1):
            tmp_lis = []
            # 遍历一层中的每一个元素
            for j in range(i):
                if j == 0 or j == i-1:
                    tmp_lis.append(1)
                else:
                    tmp_lis.append(ans[i-2][j-1] + ans[i-2][j])
            ans.append(tmp_lis)
        return ans
```

```scala
object Solution {
    def generate(numRows: Int): List[List[Int]] = {
        var output = List.empty[List[Int]]
        var curr = 1
        if(numRows == 0){
            output
        }else{
            while(curr <= numRows){
                curr match{
                    case 1 => output = List(List(1))
                    case _ => {
                        val prev = output(curr-2)
                        val begin = 0
                        val end = curr - 1
                        val row = 
                        (0 to curr-1)
                        .map(i => if(i == begin || i == end) 1 else prev(i)+prev(i-1))
                        .toList
                        
                        output = output :+ row
                    }
                }
                curr += 1
            }
        }
        output
    }
}

```

###  3.110. <a name='PascalsTriangleII'></a>119-Pascal's Triangle II

[哈哈哈](https://www.bilibili.com/video/BV187411B7Hj?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7hA?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ni4y1g7Lv?spm_id_from=333.999.0.0)

```py
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        r = [1]
        for i in range(rowIndex):
            r.append(0)
            j = i + 1
            while j > 0:
                r[j] = r[j] + r[j - 1]
                j -= 1
        return r
```

```py
# 方法 1：生成一半，另一半对称生成的一半
class Solution1:
    def generate(self, rowIndex):
        cur = []
        for i in range(rowIndex + 1):
            # 每行首个元素为 1
            temp = [1]
            # 由上一行生成当前行前一半的元素
            for j in range(i // 2):
                temp += [pre[j] + pre[j + 1]]
            # 对称生成另一半后合并，并组成新杨辉三角
            cur = temp + temp[::-1][(i + 1) % 2:]
            pre = cur
        return cur


# 方法 2：直接循环计算生成
class Solution2:
    def generate(self, rowIndex):
        cur = [1]
        for i in range(1, rowIndex + 1):
            # 每行首个元素为 1
            temp = [1]
            # 由上一行循环生成当前行元素（除两端）
            for j in range(1, i):
                temp += [pre[j - 1] + pre[j]]
            # 添加最后一个元素 1，并组成新杨辉三角
            cur = temp + [1]
            pre = cur
        return cur


# 方法 3：先直接生成所需空间（用 1 填充），再循环计算更新生成
class Solution3:
    def generate(self, rowIndex):
        for i in range(rowIndex + 1):
            # 用 1 先填充每行所有元素
            cur = [1] * (i + 1)
            # 由上一行循环生成当前行元素（除两端）
            for j in range(1, i):
                cur[j] = pre[j - 1] + pre[j]
            pre = cur
        return cur


# 方法 4：使用公式
# 组合公式C(n,i) = n!/(i!*(n-i)!)
# 则第(i+1)项是第i项的倍数=(n-i)/(i+1)
class Solution4:
    def generate(self, rowIndex):
        temp = 1
        res = []
        for i in range(rowIndex + 1):
            res.append(temp)
            temp = temp * (rowIndex - i) // (i + 1)
        return res


# 方法 5：使用公式生成一半
class Solution5:
    def generate(self, rowIndex):
        temp = 1
        res = []
        # 生成前半部分
        for i in range((rowIndex) // 2 + 1):
            res.append(temp)
            temp = temp * (rowIndex - i) // (i + 1)
        # 前半部分与其镜像对称的后半部分合并
        return res + res[::-1][(rowIndex + 1) % 2:]


# 方法 6：当前行等于上一行前后添零累加：[1,4,6,4,1] = [0,1,3,3,1] + [1,3,3,1,0]
class Solution6:
    def generate(self, rowIndex):
        res = [1]
        for i in range(rowIndex + 1):
            # temp1, temp2 = [0] + res, res + [0]
            # res = [temp1[j] + temp2[j] for j in range(i + 1)]
            res = [([0] + res)[j] + (res + [0])[j] for j in range(i + 1)]
        return res

大伙儿新年好啊

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        return [*accumulate(range(rowIndex), lambda x,i: x*(rowIndex-i)//(i+1), initial=1)]
```

###  3.111. <a name='Triangle'></a>120 Triangle

[小明](https://www.bilibili.com/video/BV1m54y1L7Af?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumTotal(self, triangle):
        n = len(triangle)
        f = [[0] * n for _ in range(n)]
        f[0][0] = triangle[0][0]

        for i in range(1, n):
            f[i][0] = f[i - 1][0] + triangle[i][0]
            for j in range(1, i):
                f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        
        return min(f[n - 1])
```

```py
class Solution:
    def minimumTotal(self, triangle):
        n = len(triangle)
        f = [0] * n
        f[0] = triangle[0][0]

        for i in range(1, n):
            f[i] = f[i - 1] + triangle[i][i]
            for j in range(i - 1, 0, -1):
                f[j] = min(f[j - 1], f[j]) + triangle[i][j]
            f[0] += triangle[i][0]
        
        return min(f)
```

```scala
/**
* selection solution
* dynamic programming - bottom up
*     state definition: dp(j) represents minimum sum at point triangle(i)(j) during bottom up 
* time complexity: O(N) N is the height of triangle
* space complexity: O(N), only create dp array with dimension of last triangle
*/

object Solution0 {
    def minimumTotal(triangle: List[List[Int]]): Int = {
        val depth = triangle.size
        val dp = triangle.last.toArray
        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices) {
            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) 
        }
        dp(0)
    }
}

/**
* my first commitment
* memo
*    dynamic programming from bottom to up
* time complexity: O(N) N is the height of triangle
* space complexity: O(N^2) : (1 + N) * N  / 2
*/
object Solution1 {
  import scala.util.Try
  def minimumTotal(triangle: List[List[Int]]): Int = {
    val result = Array.ofDim[Array[Int]](triangle.size)
    triangle.zipWithIndex.foreach { case (ll, idx) => result(idx) = Array.ofDim[Int](ll.size) }
    for (i <- triangle.size - 1 to 0 by -1) {
      val inner = triangle(i)
      inner.zipWithIndex.foreach {
        case (v, j) =>
          val left = Try(result(i + 1)(j))
          val right = Try(result(i + 1)(j + 1))
          result(i)(j) = (left.getOrElse(0) min right.getOrElse(0)) + v
      }
    }

    Try(result.head.head).getOrElse(0)
  }
}


/**
* dp dimension is like triangle
* time complexity: O(N) N is the height of triangle
* space complexity: O(N^2) : (1 + N) * N  / 2
*/

object Solution1-1 {
  def minimumTotal(triangle: List[List[Int]]): Int = {
    val result = triangle.map(_.toArray).toArray // O(N^2)
    for (i <- result.length - 2 to 0 by -1) {
      result(i).indices.foreach (j =>  result(i)(j) = ( result(i + 1)(j) min result(i + 1)(j + 1)) + result(i)(j))
    }
    result(0)(0)
  }
}


/**
* trick: dp is an array point to copy version of result's last array
* time complexity: O(N) N is the height of triangle
* space complexity: O(N^2) : (1 + N) * N  / 2
*/

object Solution1-2 {
  def minimumTotal(triangle: List[List[Int]]): Int = {
    val result = triangle.map(_.toArray).toArray  // O(N^2)
    val dp = result.last
    for (i <- result.length - 2 to 0 by -1) {
      val ll = result(i)
      ll.indices.foreach (j =>  dp(j) = (dp(j) min dp(j + 1)) + ll(j))
    }
    dp(0)
  }
}

/**
* optimize from above: without covert entire list to array
* time complexity: O(N) N is the height of triangle
* space complexity: O(N), only create dp array with dimension of last triangle
*/
object Solution1-3 {
    def minimumTotal(triangle: List[List[Int]]): Int = {
        val depth = triangle.size
        val dp = triangle.last.toArray
        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices) {
            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) 
        }
        dp(0)
    }
}
```

###  3.112. <a name='BestTimetoBuyandSellStock121-'></a>121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机

[花花酱](https://www.bilibili.com/video/BV1oW411C7UB?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1cZ4y1K7HP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1D7411s7A1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7by?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16z4y1Z7jD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1hA411t76C?spm_id_from=333.999.0.0)

```py
# 此方法会超时
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(len(prices)):
            for j in range(i + 1, len(prices)):
                ans = max(ans, prices[j] - prices[i])
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        inf = int(1e9)
        minprice = inf
        maxprofit = 0
        for price in prices:
            maxprofit = max(price - minprice, maxprofit)
            minprice = min(price, minprice)
        return maxprofit

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
动态规划

关键在于利润只和价格有关，和天数无关

从后往前遍历（代码里面先把prices reverse了一下所以是从前往后）

遇到更大的值，则更新此值为最高卖出价

遇到更小的值，就用最高卖出价减去其值，则为该位置能获得的最大利润

执行用时：168 ms, 在所有 Python3 提交中击败了84.89%的用户
内存消耗：22.8 MB, 在所有 Python3 提交中击败了88.83%的用户

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        prices.reverse()
        m = prices[0]
        prices[0] = 0
        for i in range(1,len(prices)):
            if prices[i] >= m:  #更新最高卖出价
                m = prices[i]
                prices[i] = 0
            else:
                prices[i] = m - prices[i]  #当前能获利最多
        return max(prices)

# 动态规划
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if len == 0:
            return 0
        have = [0] * length  # 表示第i天持有股票所得最多现金
        no = [0] * length    # 表示第i天不持有股票所得最多现金
        have[0] = -prices[0] # 此时的持有股票就一定是买入股票了
        no[0] = 0            # 不持有股票那么现金就是0
        for i in range(1, length):
            have[i] = max(have[i-1], -prices[i])
            no[i] = max(no[i-1], prices[i] + have[i-1])
        return no[-1]  # 不持有股票状态所得金钱一定比持有股票状态得到的多
        
# 空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if len == 0:
            return 0
        have = -prices[0] # 此时的持有股票就一定是买入股票了
        no = 0            # 不持有股票那么现金就是0
        for i in range(1, length):
            have = max(have, -prices[i])
            no = max(no, prices[i] + have)
        return no  # 不持有股票状态所得金钱一定比持有股票状态得到的多

# 贪心法
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        low = float("inf")
        result = 0
        for i in range(len(prices)):
            low = min(low, prices[i]) # 取最左最小价格
            result = max(result, prices[i] - low) # 直接取最大区间利润
        return result

class Solution:
    def maxProfit(self, prices) -> int:


        if len(prices) <= 1:
            return 0

        min_input = prices[0]
        max_profit = 0
        for p in prices[1:]:
            min_input = min(p, min_input)
            max_profit = max(max_profit, p - min_input)

        return max_profit

class Solution:
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        min_p, max_p = 999999, 0
        for i in range(len(prices)):
            min_p = min(min_p, prices[i])
            max_p = max(max_p, prices[i] - min_p)
        return max_p
```

```scala
/**
* dynamic programming
* time complexity : O(N)
* space complexity: O(3N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if (prices == null || prices.isEmpty) return 0
        /* 
        * state: 0: without holding, 
        *        1: holding 1 stock, 
        *        2: already sold stock
        */
        val profits = Array.ofDim[Int](prices.length, 3)
        
        profits(0)(0) = 0
        profits(0)(1) = -prices(0)
        profits(0)(2) = Int.MinValue
        
        for (i <- 1 until prices.length) {
            
            profits(i)(0) = profits(i - 1)(0)  // state: 0 -> 0
            profits(i)(1) = profits(i - 1)(1) max (profits(i - 1)(0) - prices(i)) // state: 0 -> 1, 1 -> 1
            profits(i)(2) = profits(i - 1)(2) max (profits(i - 1)(1) + prices(i)) // state: 2 -> 2, 1 -> 2
        }
        profits.last.max
    }
}
/**
* dynamic programming
* time complexity: O(N)
* space complexity: O(1): only create a size 3 of one dimension array
*/
object Solution1-2 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
       /* 
       * state: 0: without holding, 
       *        1: holding 1 stock, 
       *        2: already sold stock
       */
        val dp = Array.ofDim[Int](3)
        dp(0) = 0
        dp(1) = -prices(0)
        dp(2) = Int.MinValue // initial as 0 is acceptable
        
        for(i <- 1 until prices.size){
            dp(0) = dp(0)
            dp(1) = (dp(0) - prices(i)) max dp(1)
            dp(2) = (dp(1) + prices(i)) max dp(2)
        }
        dp.max
    }
}


/**
* Kadane's Algorithm: though of dynamic programming
* record min price so far and maxProfit during iteration
* time complexity O(N)
* space complexity O(1)
*/

object Solution2 {
    def maxProfit(prices: Array[Int]): Int = {
        prices.foldLeft((Int.MaxValue, 0)){
            case ((minPriceSoFar, maxProfit), price) => (minPriceSoFar min price, maxProfit max (price - minPriceSoFar))
        }._2
    }
}
```

```scala
package com.zhourui.leetcode

import com.zhourui.codech._
import scala.math.{min,max}

//[7,1,5,3,6,4] -> 6-1=5
package lc121_besttime_sell_stock {
  object Solution {
    def maxProfit(prices: Array[Int]): Int = {
      if (prices.isEmpty) return 0
      var maxProfit = Int.MinValue
      prices.reduceLeft((a,b)=>{
        maxProfit = max(maxProfit, b - a)
        min(a,b)
      })
      max(0,maxProfit)
    }
  }
}

```

```scala
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        var buy = 0
        var sell = 1
        
        var maxProfit = 0
        
        while(buy < sell && sell < prices.size){
            if(prices(buy) > prices(sell)){
                buy = sell
                sell += 1
            }else{
                val profit = prices(sell) - prices(buy)
                if(profit > maxProfit) {
                    maxProfit = profit
                }
                sell += 1
            }
        }
        
        maxProfit
    }
}

```


###  3.113. <a name='II122-BestTimetoBuyandSellStockII'></a>122-买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II

[哈哈哈](https://www.bilibili.com/video/BV12K411A7rL?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d7411x78d?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7iq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Fk4y1R7ve?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y1L7LG?spm_id_from=333.999.0.0)

```py
# 动态规划
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if len == 0:
            return 0
        have = [0] * length  # 表示第i天持有股票所得最多现金
        no = [0] * length    # 表示第i天不持有股票所得最多现金
        have[0] = -prices[0] # 此时的持有股票就一定是买入股票了
        no[0] = 0            # 不持有股票那么现金就是0
        for i in range(1, length):
            have[i] = max(have[i-1], no[i-1] - prices[i]) # 唯一不同之处
            no[i] = max(no[i-1], prices[i] + have[i-1])
        return no[-1]  # 不持有股票状态所得金钱一定比持有股票状态得到的多

# 贪心法
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i] > 0])

第一种方法：深度优先搜索，时间复杂度O(2^n)，这个通过不了LeetCode，不过能work，测试了多组测试样例是正确的

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        self.prices = prices
        self.profit = []
        self.helper(0, 0, 0)
        return max(self.profit)
        
    # have 0:未持有  1:持有
    def helper(self, i, have, profit):
        if i == len(self.prices):
            self.profit.append(profit)
            return
        if have: # 如果持有中
            self.helper(i+1, 0, profit + self.prices[i]) # 卖出
            self.helper(i+1, 1, profit) # 不动
        else: # 如果未持有
            self.helper(i+1, 0, profit) # 不动
            self.helper(i+1, 1, profit - self.prices[i]) # 买入
第二种方法：贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度O(n)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                ans += prices[i] - prices[i-1]
        return ans
第三种方法：DP动态规划，第i天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        n = len(prices)
        dp = [[0]*2 for _ in range(n)]
        # dp[i][0]表示第i天不持有股票, dp[i][1]表示第i天持有股票
        dp[0][0], dp[0][1] = 0, - prices[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
        return dp[n-1][0]
```

```py
class Solution(object):
    def maxProfit(self, prices):
        profit = 0
        for day in range(len(prices)-1):
            differ = prices[day+1] - prices[day]
            if differ > 0:
                profit += differ
        return profit

分享一个比较巧妙的思路： 可以将股票的价格画成折线统计图看一看，上升阶段的差值（波峰和波谷的差值）之和就是所能得到的最大价值（如果加入其他下降阶段只会减少收益）， 因此统计上升阶段的值即可

class Solution:
    def maxProfit(self, prices):
        if len(prices) == 0:    # 如果股票长度为零， 收益为0
            return 0

        maxPro = 0

        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                maxPro += prices[i] - prices[i-1]

        return maxPro

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        result = 0
        for i in range(1, len(prices)):
            result += max(prices[i] - prices[i - 1], 0)
        return result
python动态规划

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        dp = [[0] * 2 for _ in range(length)]
        dp[0][0] = -prices[0]
        dp[0][1] = 0
        for i in range(1, length):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]) #注意这里是和121. 买卖股票的最佳时机唯一不同的地方
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])
        return dp[-1][1]
```

```scala
/**
* my first commitment
* greedy alg
* time complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices.length > 1){
            prices.sliding(2).collect{ case arr: Array[Int] if arr(1) > arr(0)=> arr}
    .foldLeft(0){(sum, arr) => 
      sum + arr(1) - arr(0)}
        } else {
            0
        }
    }
}

/**
* greedy alg: one line pass
*/

object Solution1-2 {
  def maxProfit(prices: Array[Int]): Int = {
    if(prices.length > 1) prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum else 0
  }
}

/**
* dynamic programming 
* time complexity: O(N)
* space complexity: O(2N) create a two-dimension array
*/

object Solution2 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0   
        /* 
        * state definition: 
        *    0  without holding,
        *    1  holding a share
        */
        val profits = Array.ofDim[Int](prices.length, 2)
        
        profits(0)(0) = 0
        profits(0)(1) = -prices(0)
        for(i <- 1 until prices.length) {
            profits(i)(0) = profits(i - 1)(0) max (profits(i - 1)(1) + prices(i)) //  sell 
            profits(i)(1) = profits(i - 1)(1) max (profits(i - 1)(0) - prices(i)) // buy and hold
        }
        profits.last.max
    }
}
/**
* dynamic programming : simplify above solution
* time complexity: O(N)
* space complexity: O(1)
*/

object Solution2-1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        val dp = Array.ofDim[Int](2)
        /* 
        * state definition: 
        *    0  without holding,
        *    1  holding a share
        */
        dp(0) = 0
        dp(1) = -prices(0)
        for(i <- 1 until prices.size) {
        /*
        * it may causes a problem here, because we overwrite the previous dp(0) by new state i value and dp(1) would utilizes dp(0) which was overwritten 
        * in this problem, a stock can be bought or sold for multiple times in one day, so overwriting is not matter
        */
            dp(0) = dp(0) max (dp(1) + prices(i))
            dp(1) = dp(1) max (dp(0) - prices(i))
        }
        
        dp.max
        
    }
}
```


```scala
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        var buy = 0
        var sell = 1
        var profitNow = 0
        var maxProfit = 0
        var maxSell = 0
        
        var buyPrice = 0
        var sellPrice = 0
        
        while(buy < prices.size && sell < prices.size){
            
            buyPrice = prices(buy)
            sellPrice = prices(sell)
            
            if(buyPrice < sellPrice && sellPrice >= maxSell){
                maxSell = sellPrice
                profitNow = sellPrice - buyPrice
                sell += 1
            }else{
                maxProfit += profitNow
                maxSell = 0
                profitNow = 0
                buy = sell
                sell += 1
            }
        }
        
        if(maxProfit == 0) profitNow else maxProfit + profitNow
    }
}

//Alternate solution
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices
            .foldLeft(0,Int.MaxValue)((t, current) => (t._1 + 0.max(current-t._2), current))
            ._1
    }
}

```

```scala
package com.zhourui.leetcode

// 归纳为
// 如果今天价格比昨天高，那么昨天买入，今天卖出(假如昨天已经卖出，那么取消，改为今天卖出)
// 如果今天比昨天价格低，那么就今天买入(取消昨天的买入)

package lc0122_buynsellstock2 {
  object Solution {
    def maxProfit(prices: Array[Int]): Int = {
      if (prices.isEmpty) return 0
      else (0 until prices.length-1).foldLeft(0)(
        (profit,i) =>{
          if (prices(i)<prices(i+1)) profit+prices(i+1)-prices(i) else profit
        }
      )
    }
  }
}

```

###  3.114. <a name='III'></a>123-买卖股票的最佳时机 III

[哈哈哈](https://www.bilibili.com/video/BV1Xp4y1k7aD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rk4y117z8?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = buy2 = -prices[0]
        sell1 = sell2 = 0
        for i in range(1, n):
            buy1 = max(buy1, -prices[i])
            sell1 = max(sell1, buy1 + prices[i])
            buy2 = max(buy2, sell1 - prices[i])
            sell2 = max(sell2, buy2 + prices[i])
        return sell2

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iii-by-wrnt/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
## 未进行空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = [0] * n
        sell1 = [0] * n
        buy2 = [0] * n
        sell2 = [0] * n
        buy1[0] = buy2[0] = -prices[0]
        sell1[0] = sell2[0] = 0
        for i in range(1, n):
            buy1[i]  = max(buy1[i-1], -prices[i])
            sell1[i] = max(sell1[i-1], buy1[i-1] + prices[i])
            buy2[i]  = max(buy2[i-1], sell1[i-1] - prices[i])
            sell2[i] = max(sell2[i-1], buy2[i-1] + prices[i])
        return sell2[-1]

## 空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = buy2 = -prices[0]
        sell1 = sell2 = 0
        for i in range(1, n):
            buy1 = max(buy1, -prices[i])
            sell1 = max(sell1, buy1 + prices[i])
            buy2 = max(buy2, sell1 - prices[i])
            sell2 = max(sell2, buy2 + prices[i])
        return sell2

这题我会，甚至都不用翻之前的代码，至于空间优化什么的，只会让我的代码不够优雅（手动狗头）

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        # dp[i][j][k] 表示
        # 第i天 持有和不持有 交易k次
        dp = [[[0]*3 for _ in range(2)] for _ in range(n)]
        
        # 初始化 第0天的时候 持有和不持有其实与交易次数无关 和之前的初始化是一样的
        for i in range(3):
            dp[0][0][i],dp[0][1][i] = 0,-prices[0]

        # 按照天数和交易次数来遍历
        for i in range(1,n):
            for k in range(3):
                # 和以往的题目一样 卖出的时候算作一次交易 这里用到了k-1 所以k为0要分开讨论
                # 想一想k为0时候的意思 第i天不持有而且没有卖出过 只能是i-1天的时候也不持有
                dp[i][0][k] = max(dp[i-1][0][k],dp[i-1][1][k-1]+prices[i]) if k!=0 else dp[i-1][0][k]
                dp[i][1][k] = max(dp[i-1][1][k],dp[i-1][0][k]  -prices[i])
        # 和以往的题目一样 最大值出现在最后一天不持有的情况下
        return max(dp[n-1][0])

# k表示的是交易的次数，这涉及到“进行一次交易”的定义，
# 可以在买的时候定义为进行了一次交易，也可以在卖的时候定义为进行了一次交易，
# 这里我们的定义是在卖出的时候视为进行了一次交易，这不但方便代码书写，
# 也符合常规的思维模式，所以在买入的时候交易次数k不变

更容易理解的写法：

def maxProfit(self, prices: list) -> int:
    
   # special case handle

    if len(prices) == 1:
        return 0

    sell1 = sell2 = 0
    buy1 = buy2 = prices[0]
    for p in prices:
        buy1 = min(buy1, p)
        sell1 = max(sell1, p - buy1)
        buy2 = min(buy2, p - sell1)
        sell2 = max(sell2, p - buy2)
    return sell2
小脑袋只能看着答案分析出来怎么运作的，想不出大佬们怎么从无到有创造出这个算法的。

假想价格波动：

单调递减波形： a-递减->b
在单调递减的阶段：buy2和buy1将保持相等，不断更新最低买进价格。
（在复杂波形处始的递减波形直到第一个转折点都没有意义）

单调递增波形：a-递增->b
buy1 保持为当前p价位之前找到的最低价位。
sell1随着单调递增不断更新最大获益值。
同时buy2 = min(buy2', p-sell1),假设buy2' < p-sell1：
则这种情况下，buy2 保持不变，同样为之前找到的最低价位即与buy1相等；
若buy2' > p- sell1. 
则buy2 = p-sell1 = p - (p-buy1) = buy1，同样也与buy1相等。
即在单调递增的情况下，
buy2，sell2收敛为整场只做一次买卖的buy1,sell1的同等情况。

先单调递增后单调递减的波形：
单调递增部分同<2>分析，buy2=buy1,sell2=sell1; 
在转折点开始递减以后，由于p值不断减小，
sell1 保持为转折点处的最大收益值不变。
buy2 = min(buy2', p - sell1) 可能有两种取值，若buy2取值buy2'，
很明显此时buy2、sell2将收敛为与buy1、sell1相等的情况；
若buy2开始取值p-sell1,由于p的值不断减小(单调递减波段），
那么从此以后buy2将一直取值p-sell1, 
在这种情况下，sell2 = max(sell2‘, p - buy2)，
如sell2 取值sell2'不变则与sell1值相同，
若sell2取值p-buy2=p-(p-sell1)=sell1, 
则也必然与sell1相同。
也就是在先单调递增后单调递减的波段，
最大收益就是在转折点一次买卖的buy1,sell1情况。

先单调递增后单调递减，
然后又单调递增的波形：
a-递增->b-递减->c-递增->d
在a->c段通<3>分析。c->d段。
buy2的值将保持c - (b-a)不变 
sell2 = max(sell2‘, p - buy2) = max( b -a, p - (c- (b-a))) = max (b-a, (p-c + (b-a)))

dp1[i] = max(dp[i-1], prices[i] - minval) 从前往后遍历，表示第1天到第i天之间的最大利润（通过是否在第i天卖出确认）；
dp2[i] = max(dp[i+1], maxval - prices[i]) 从后往前遍历，表示第i天到最后一天之间的最大利润（通过是否在第i天买进确认）；
res = max(dp1 + dp2)，(dp1 + dp2)[i] 正好表示从第1天到最后一天经过两次交易的最大利润，我们的目标是找到令总利润最大的i。
python：
class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        if n < 2:
            return 0
        dp1 = [0 for _ in range(n)]
        dp2 = [0 for _ in range(n)]
        minval = prices[0]
        maxval = prices[-1]
        #前向   
        for i in range(1,n):
            dp1[i] = max(dp1[i-1], prices[i] - minval)
            minval = min(minval, prices[i])
        #后向    
        for i in range(n-2,-1,-1):
            dp2[i] = max(dp2[i+1], maxval - prices[i])
            maxval = max(maxval, prices[i])
        
        dp = [dp1[i] + dp2[i] for i in range(n)]
        return max(dp)

第一种方法：标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。与下面188题买卖股票4一样的代码，把交易k次定义为2次。当然也可以把内层的for循环拆出来，分别列出交易0次、1次、2次的状态转移方程即可

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        n = len(prices)
        dp = [[[0]*2 for _ in range(3)] for _ in range(n)]
        # dp[i][j][0]表示第i天交易了j次时不持有股票, dp[i][j][1]表示第i天交易了j次时持有股票
        # 定义卖出股票时交易次数加1
        for i in range(3):
            dp[0][i][0], dp[0][i][1] = 0, -prices[0]
        
        for i in range(1, n):
            for j in range(3):
                if not j:
                    dp[i][j][0] = dp[i-1][j][0]
                else:
                    dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j-1][1] + prices[i])
                dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0] - prices[i])
        
        return max(dp[n-1][0][0], dp[n-1][1][0], dp[n-1][2][0])

第二种方法：用变量而不是多维数组保存迭代的值，优点是省内存空间，缺点是不是标准DP，没法泛化

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        
        buy1, sell1, buy2, sell2 = -prices[0], 0, -prices[0], 0
        for i in range(1,len(prices)):
            buy1 = max(buy1,-prices[i])	#用负值统一变量
            sell1 = max(sell1,buy1 + prices[i])	#sell1为 0~i(含)天股市中买卖一次的最优利润
            buy2 = max(buy2,sell1 - prices[i])	#仅当＞0才会更新，保证 第二次买入不会与第一次卖出为同一天。而sell1为历史记录保证第二次买入比第一次卖出晚。
            sell2 = max(sell2,buy2 + prices[i])	#若第二轮买卖为同一天，则不会更新。此操作自然保证sell2为买卖至多两次的最优利润。
        return sell2
```

```scala
/**
* Dynamic programming: three dimension dp array
*    memo:
*       dp definition: dp[i][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*/ 
object Solution1 {
  def maxProfit(prices: Array[Int]): Int = {
    /* 
    * profits(i)(j)(k)
    *   dimension i: state sequence
    *   
    *   profits()(0)(0) keep observing
    *   profits()(0)(1) buy first share
    *   profits()(1)(0) after selling first share
    *   profits()(1)(1) buy second share
    *   profits()(2)(0) after selling second share
    *   profits()(2)(1) non-meaningful
    */
    val profits = Array.ofDim[Int](prices.length, 3, 2)
    
    profits(0)(0)(0) = 0
    profits(0)(0)(1) = -prices(0)
    profits(0)(1)(0) = 0
    profits(0)(1)(1) = Int.MinValue  // buy state
    profits(0)(2)(0) = 0
    profits(0)(2)(1) = Int.MinValue // buy state
    
    /* state transition */
    for(i <- 1 until prices.length) {
      profits(i)(0)(0) = profits(i - 1)(0)(0)  // actually non-meaningful
      profits(i)(0)(1) = profits(i - 1)(0)(1) max (profits(i - 1)(0)(0) - prices(i)) // buy
      profits(i)(1)(0) = profits(i - 1)(1)(0) max (profits(i - 1)(0)(1) + prices(i)) // sell
      profits(i)(1)(1) = profits(i - 1)(1)(1) max (profits(i - 1)(1)(0) - prices(i)) // buy
      profits(i)(2)(0) = profits(i - 1)(2)(0) max (profits(i - 1)(1)(1) + prices(i)) // sell        
    }
    profits.last.map(_(0)).max
  }
}
/**
* Dynamic programming: three dimension dp array
*   shift state definition
*/ 
object Solution1-2 {
    def maxProfit(prices: Array[Int]): Int = {
            /* 
            * profits(i)(j)(k)
            *   dimension i: state sequence
            *   
            *   profits()(0)(0) dummy state
            *   profits()(0)(0) dummy state
            *   profits()(1)(0) buying first share
            *   profits()(1)(1) after sold first share
            *   profits()(2)(0) buying second share
            *   profits()(2)(1) after sold second share
            */
        val dp = Array.tabulate(prices.length, 3, 2){
            case (0, 1, 0) => -prices(0)  // buy state
            case (0, 1, 1) => 0  // sell state
            case (0, 2, 0) => Int.MinValue // buy state
            case (0, 2, 1) => 0 // sell state
            case _ => 0
        }
        for(i <- 1 until prices.length; j <- 1 to 2) {
            dp(i)(j)(0) = dp(i - 1)(j)(0) max (dp(i - 1)(j - 1)(1)  - prices(i)) // buy
            dp(i)(j)(1) = dp(i - 1)(j)(1) max (dp(i - 1)(j)(0) + prices(i))  // sell
        }
        dp.last.map(_(1)).max
    }
}
/**
* dynamic programming: tree dimension array
*   drop dummy state
*/

object Solution1-3 {
    def maxProfit(prices: Array[Int]): Int = {
        val transactionLimit = 2
            /* 
            * profits(i)(j)(k)
            *   dimension i: state sequence
            *   profits()(0)(0) buying first share
            *   profits()(0)(1) after sold first share
            *   profits()(1)(0) buying second share
            *   profits()(1)(1) after sold second share
            */
        val dp = Array.tabulate(prices.length, transactionLimit, 2){
            case (0, 0, 0) => -prices(0)  // buy
            case (0, _, 1) => 0  // sell
            case (0, _, 0) => Int.MinValue // buy
            case _ => 0
        }
        
        for(i <- 1 until prices.length; j <- 0 until transactionLimit) {
            /*
            * 0 buy, 1 sell
            */
            dp(i)(j)(0) = dp(i - 1)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(i - 1)(j - 1)(1) - prices(i)
            }    
            dp(i)(j)(1) = dp(i - 1)(j)(1) max (dp(i - 1)(j)(0) + prices(i))
        }
        dp.last.map(_(1)).max
    }
}

/**
* Dynamic programming with only keeping two time state: current and previous
* this version is more elegant than above one
* time complexity: O(N)
* space complexity: O(2 * 2 * 2) = O(8) = O(1)
*/
object Solution2 {
    def maxProfit(prices: Array[Int]): Int = {
        val transactions = 2
        val profits = Array.ofDim[Int](2, transactions, 2)
        
        for (i <- profits.indices; j <- 0 until transactions) {
            profits(i)(j)(0) = Int.MinValue // buy
            profits(i)(j)(1) = 0 // sell
        }
     
        /** iterate from index 0 */
        for (i <- prices.indices; j <- 0 until transactions) {
            val currentStatus = i % 2
            val previousStatus = (i + 1) % 2
            profits(currentStatus)(j)(1) =  profits(previousStatus)(j)(1) max  (profits(previousStatus)(j)(0) + prices(i)) // sell

            if(j == 0)  
                profits(currentStatus)(j)(0) =  profits(previousStatus)(j)(0) max - prices(i) // buy
            else 
                profits(currentStatus)(j)(0) =  profits(previousStatus)(j)(0) max (profits(previousStatus)(j - 1)(1) - prices(i)) // buy from previous (j - 1) sell status

        }

        profits((prices.length - 1) % 2).map(_.max).max
        
    }
     private def debugProfits(profits: Array[Array[Array[Int]]]): Unit = {
        profits.zipWithIndex.foreach{
          case (p, i) =>
            println(s"status: $i")
            p.zipWithIndex.foreach{
            case (pp, j) =>
                println(s"transaction $j: hold: ${pp(0)}, sell: ${pp(1)}")
          }
            println(" ")
        }
  }
}

/**
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution2-1 {
    def maxProfit(prices: Array[Int]): Int = {
        val transactionLimit = 2
        val dp = Array.tabulate(2, transactionLimit, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until transactionLimit) {
            val currentIdx = i & 1  // bit op: AND op
            val previousIdx = currentIdx ^1 // bit op: XOR op

            // 0 buy; 1 sell
            dp(currentIdx)(j)(0) = dp(previousIdx)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previousIdx)(j - 1)(1) - prices(i)
            }
            dp(currentIdx)(j)(1) = dp(previousIdx)(j)(1) max (dp(previousIdx)(j)(0) + prices(i))
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}

/**
* Kadane's Algorithm:  dynamic programming only keep one previous status
* time complexity: O(N)
* space complexity: O(1)
*/ 
object Solution3{
    def maxProfit(prices: Array[Int]): Int = {
        val r = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case (acc, px) =>
                val (buy1, sell1, buy2, sell2) = acc
                val newBuy1 = buy1 max - px
                val newSell1 =  sell1 max (buy1 + px)
                val newBuy2 = buy2 max (sell1 - px)
                val newSell2 = sell2 max (buy2 + px)
                (newBuy1, newSell1, newBuy2, newSell2)
        }
        r._2 max r._4
    }
}

object Solution3-1 {
    def maxProfit(prices: Array[Int]): Int = {
        val (buy1, sell1, buy2, sell2) = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case ((buy1, sell1, buy2, sell2), cost) =>
                (
                    buy1 max -cost,
                    sell1 max (buy1 + cost),
                    buy2 max (sell1 - cost),
                    sell2 max (buy2 + cost)
                )
        }
        sell1 max.sell2
    }
}
```

###  3.115. <a name='BinaryTreeMaximumPathSum'></a>124. Binary Tree Maximum Path Sum

[花花酱](https://www.bilibili.com/video/BV1ct411r7qw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CT4y1g7bR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qT4y1J71C?spm_id_from=333.999.0.0)

```py
# python3

class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.max_val = -float('inf')
        self.process(root)
        return self.max_val


    def process(self, root):
        if not root:
            return 0
        left = max(0, self.process(root.left))
        right = max(0, self.process(root.right))
        self.max_val = max(self.max_val, root.val + left + right, root.val + max(left, right))# 把 {左中右} + {经过中间} 保存下来
        return root.val + max(left, right) #  {左中右}的值不会返回 + {经过中间} 会返回

# 不用看官方题解，那么复杂。 
# 所有树的题目，都想成一颗只有根、左节点、右节点 的小树。
# 然后一颗颗小树构成整棵大树，所以只需要考虑这颗小树即可。
# 接下来分情况， 按照题意：一颗三个节点的小树的结果只可能有如下6种情况：

# 根 + 左 + 右
# 根 + 左
# 根 + 右
# 根
# 左
# 右
# 好了，分析上述6种情况， 只有 2,3,4 可以向上累加，
# 而1,5,6不可以累加（这个很好想，情况1向上累加的话，必然出现分叉，
# 情况5和6直接就跟上面的树枝断开的，没法累加），
# 所以我们找一个全局变量存储 1,5,6这三种不可累加的最大值， 
# 另一方面咱们用遍历树的方法求2,3,4这三种可以累加的情况。 
# 最后把两类情况得到的最大值再取一个最大值即可。

class Solution(object):
    def maxPathSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.max_sum = -sys.maxsize - 1

        def scan(root):
            if root is None:
                return -sys.maxsize - 1
            left = scan(root.left)
            right = scan(root.right)
            self.max_sum = max(self.max_sum, root.val + left + right, left, right) # 情况1,5,6，不累加直接放变量里暂存
            return max(root.val, root.val + left, root.val + right)  # 情况2,3,4 ，累加需要递归

        new_max = scan(root)
        return max(self.max_sum, new_max)  # 两类情况再求最大

import sys

class Solution:
    
    result = -sys.maxsize-1
    
    def maxPathSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.maxValue(root)
        return self.result
    
    """
    最大路径和：根据当前节点的角色，路径和可分为两种情况：
    一：以当前节点为根节点
    1.只有当前节点
    2.当前节点+左子树
    3.当前节点+右子书
    4.当前节点+左右子树    
    这四种情况的最大值即为以当前节点为根的最大路径和
    此最大值要和已经保存的最大值比较，得到整个树的最大路径值
    
    二：当前节点作为父节点的一个子节点
    和父节点连接的话则需取【单端的最大值】
    1.只有当前节点
    2.当前节点+左子树
    3.当前节点+右子书
    这三种情况的最大值    
    """
    def maxValue(self,root):
        if root == None:            
            return 0
        
        leftValue = self.maxValue(root.left)
        rightValue = self.maxValue(root.right)
        
        value1 = root.val
        value2 = root.val + leftValue
        value3 = root.val + rightValue
        value4 = root.val + rightValue + leftValue
        
        #以此节点为根节点的最大值
        maxValue = max([value1,value2,value3,value4])
        
        #当前遍历树的最大值
        self.result = max(maxValue, self.result)
        
        #要和父节点关联，则需要取去除情况4的最大值
        return max([value1,value2,value3])

class Solution:
    def __init__(self):
        self.maxSum = float("-inf")

    def maxPathSum(self, root: TreeNode) -> int:
        def maxGain(node):
            if not node:
                return 0

            # 递归计算左右子节点的最大贡献值
            # 只有在最大贡献值大于 0 时，才会选取对应子节点
            leftGain = max(maxGain(node.left), 0)
            rightGain = max(maxGain(node.right), 0)
            
            # 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
            priceNewpath = node.val + leftGain + rightGain
            
            # 更新答案
            self.maxSum = max(self.maxSum, priceNewpath)
        
            # 返回节点的最大贡献值
            return node.val + max(leftGain, rightGain)
   
        maxGain(root)
        return self.maxSum
```

```scala
/**
* my first commitment: variation of Kadane's algorithm.
*/

object Solution1 {
    def maxPathSum(root: TreeNode): Int = {
        dfs(root)._1
    }
     /**
      * maxEndingHere records the path maximum summation which ending at current node
      * maxSoFar records the maximum sum globally
      */
    def dfs(node: TreeNode): (Int, Int) = {
      if (node == null) return (Int.MinValue, 0)
      
      val (leftSoFar, leftEndingHere) = dfs(node.left)
      val (rightSoFar, rightEndingHere) = dfs(node.right)

      val maxSoFar = leftSoFar max rightSoFar max (node.value + leftEndingHere + rightEndingHere)
      /**
      * we should choose one path witch makes summation maximum ending at current node
      * maxEndingHere is not charge for node.value + leftEndingHere + rightEndingHere
      */
      val maxEndingHere = 0 max (node.value + (leftEndingHere max rightEndingHere))
      (maxSoFar, maxEndingHere)
    }
}
```

###  3.116. <a name='ValidPalindrome'></a>125-Valid Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1d7411n7cF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7ML?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17h411Z7ey?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        sgood = "".join(ch.lower() for ch in s if ch.isalnum())
        return sgood == sgood[::-1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPalindrome(self, s: str) -> bool:
        sgood = "".join(ch.lower() for ch in s if ch.isalnum())
        n = len(sgood)
        left, right = 0, n - 1
        
        while left < right:
            if sgood[left] != sgood[right]:
                return False
            left, right = left + 1, right - 1
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPalindrome(self, s: str) -> bool:
        n = len(s)
        left, right = 0, n - 1
        
        while left < right:
            while left < right and not s[left].isalnum():
                left += 1
            while left < right and not s[right].isalnum():
                right -= 1
            if left < right:
                if s[left].lower() != s[right].lower():
                    return False
                left, right = left + 1, right - 1

        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        s = ''.join(filter(str.isalnum,s)).lower()
        return s==s[::-1]

练习一下正则

import re
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s=re.sub('[^a-zA-Z0-9]','',s)
        s=s.lower()
        return s==s[::-1]
```

```py
class Solution(object):
    def isPalindrome(self, s):
        st = []
        for i in s:
            if i.isalpha():
                st.append(i.lower())
        return st == st[::-1]
```

```scala

/**
* two pointer comparison
* memo
*  1. alphanumeric = letters + numerals
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def isPalindrome(s: String): Boolean = {
      val newString = s.filter(_.isLetterOrDigit).toLowerCase
      isPalindrome(newString, 0, newString.length - 1)
    }
    @annotation.tailrec
    def isPalindrome(s: String, left: Int, right: Int): Boolean = {
      if (left > right) return true
      if (s(left) == s(right)) isPalindrome(s, left + 1, right - 1)
      else false
    }
}
```

```scala
object Solution {
    def isPalindrome(s: String): Boolean = {
        val str = s.filter(c => c.isLetter || c.isDigit).toUpperCase
        if(str.isEmpty){
            true
        }else{
            var flag = true
            var head = 0
            var tail = str.length - 1
            
            import scala.util.control.Breaks._
            breakable{
            while(head <=  tail){
                if(str(head) != str(tail)){
                    flag = false
                    break
                }
                head +=1
                tail -=1
            }
            }
            flag
        }
        
    }
}

```

###  3.117. <a name='WordLadderII'></a>126. Word Ladder II

[花花酱](https://www.bilibili.com/video/BV1yt411Y7gH?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV16K4y1j7hX?spm_id_from=333.999.0.0)

```py
吐血了，从127而来，自己写了一版本， 击败5%用时3300ms。。。然后看了一下top。 仅68ms， 代码特别美 我的高仿127，单向bfs搞定，比较辣眼睛，可以跳过直接看大神代码。。。

    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        if endWord not in wordList or not endWord or not beginWord or not wordList:
            return []

        dictory = defaultdict(list)
        L = len(beginWord)

        # 准备过程  将字典中其中一位用*代替，建立map    
        for word in wordList:
            for i in range(L):
                dictory[word[:i] + '*' + word[i+1:]].append(word)
                
        ans = []

        queue_begin = [(beginWord, 1, [[beginWord]])]
        visited_begin = {beginWord:[[beginWord]]}

        minLevel = len(wordList) + 1 # 最大长度为字典长度+1

        while queue_begin:
            current_word,level, paths = queue_begin.pop(0)

            if level > minLevel: continue            

            for i in range(L):
                tmp = current_word[:i] + '*' + current_word[i+1:]
                for word in dictory[tmp]:
                    if word == endWord:
                        # 拼接路径
                        for p in paths:
                            minLevel = level
                            ans.append(p + [endWord])
                            
                    elif word not in visited_begin:
                        new_paths = [p+[word] for p in paths]
                        visited_begin[current_word] = new_paths
                        queue_begin.append((word, level+1, new_paths))

        return ans
大神代码来了 击败100% 仅68ms

def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
        if endWord not in wordList: return []
        # 定义了从头向后访问的集合，从尾向前访问的集合
        # 将wordlist转成了set，方便做减法运算。定义了默认首次访问方向为向后
        forward, backward, wordList, flag = {beginWord}, {endWord}, set(wordList), True  
        # 所有字符，用于取代通配符，词长度， dic的key和value都是单词，value表示parent，或者说前置节点的意思。这里前置和后置的关系取决于距离beginword和endWord的距离
        # dic 或者说 指向的是离beginWord距离更近一层的节点。一种BFS的思想。
        letters, length, dic = 'abcdefghijklmnopqrstuvwxyz', len(beginWord), defaultdict(set)
        while forward:
            if len(forward) > len(backward): # 当向后方向的长度大于向前方向长度时，反转以下三个值。 处理了困扰我n久的双向遍历时最大深度问题。。。
                forward, backward, flag = backward, forward, not flag

            wordList -= forward  # 从wordList移除将要遍历的forward ， 这样顺便将wordList当做了visited用，很棒的想法
            cur = set()
            for word in forward:
                # 这个循环我们将未插入dic的节点中，层数+1的节点全部插入dic。注意两个方向有区别。
                for i in range(length):
                    left, right = word[:i], word[i+1:]  #老生常谈的通配符
                    for l in letters:  # l类似我们之前用的通配符*
                        w = left + l + right  # 这个用letters处理，免去了构造一整个dict的过程，节约了很多代码和额外空间
                        if w in wordList:
                            cur.add(w)
                            if flag:
                                dic[w].add(word)    # 单词w可由word变化而来， 这里 w 比 word 离 beginWord远
                            else:
                                dic[word].add(w)    # 这个意思是逆序遍历时， 视为word可由w变化而来。这里 w 比word 离 endWord远，就是说离beginWord更近
            
            #很酷炫的写法，利用了集合的交集 &计算出的是一个set。
            if cur & backward:  # 产生交集，最短路径找到  
                # 用于生成全部路径，开始只放一个尾结点，通过dic不停找前置节点获取全路径
                # 这是一个二维数组， 第一维表示全部的路径，第二维表示该路径下的全部节点。
                res = [[endWord]] 
                while res[0][0] != beginWord:  # 循环结束条件是刚添加进去的节点是beginWord
                    # 这也是体现算法功底的代码。 遍历的是全部的路径， i代表的是其中一条路径，
                    # i[0]代表的是每个路径的最前置节点，即第一个点。 注意我们每次都会清空之前的res，进行重新赋值。
                    # 去除第一个点之后，通过dic[i[0]]获取前置节点x， 拼接路径：[x]+i
                    # 这个代码干了这么多事，两层循环，但简洁优雅，又透露出算法功底，很佩服原作者！
                    res = [[x]+i for i in res for x in dic[i[0]]]
                return res  # 产生交集就return,避免了我写的那个有5层又有6层的情况。很妙
            # 这个有一种指针向后移动的意味， 其实代表的是该层遍历结束，我们向后/向前移动一层。 类似常写的 cur = cur.next
            forward = cur
        return []
```

```py
把单词到通配串的路径生成，再把通配串到单词的路径生成，然后再单向宽搜，写双向就更复杂了，单向速度也马马虎虎吧，148ms。 py

class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[str]:
        d = collections.defaultdict(list)
        for word in wordList + [beginWord]:
            w = [*word]
            for i, c in enumerate(word):
                w[i] = '.'
                p = ''.join(w)
                d[p].append(word)
                d[word].append(p)
                w[i] = c
        if endWord in d:
            q, v = {beginWord: [[beginWord]]}, {beginWord}
            while q:
                if endWord in q:
                    return [*q[endWord]]
                t = collections.defaultdict(set)
                for i in q:
                    for j in d[i]:
                        for w in d[j]:
                            if w not in v:
                                t[w].update((*p, w) for p in q[i])
                q = t
                v.update(q.keys())
        return []
```

###  3.118. <a name='WordLadder'></a>127. Word Ladder

[花花酱](https://www.bilibili.com/video/BV1yt411Y7Me?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1BK4y157k1?spm_id_from=333.999.0.0)

```py
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        def addWord(word: str):
            if word not in wordId:
                nonlocal nodeNum
                wordId[word] = nodeNum
                nodeNum += 1
        
        def addEdge(word: str):
            addWord(word)
            id1 = wordId[word]
            chars = list(word)
            for i in range(len(chars)):
                tmp = chars[i]
                chars[i] = "*"
                newWord = "".join(chars)
                addWord(newWord)
                id2 = wordId[newWord]
                edge[id1].append(id2)
                edge[id2].append(id1)
                chars[i] = tmp

        wordId = dict()
        edge = collections.defaultdict(list)
        nodeNum = 0

        for word in wordList:
            addEdge(word)
        
        addEdge(beginWord)
        if endWord not in wordId:
            return 0
        
        dis = [float("inf")] * nodeNum
        beginId, endId = wordId[beginWord], wordId[endWord]
        dis[beginId] = 0

        que = collections.deque([beginId])
        while que:
            x = que.popleft()
            if x == endId:
                return dis[endId] // 2 + 1
            for it in edge[x]:
                if dis[it] == float("inf"):
                    dis[it] = dis[x] + 1
                    que.append(it)
        
        return 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        def addWord(word: str):
            if word not in wordId:
                nonlocal nodeNum
                wordId[word] = nodeNum
                nodeNum += 1
        
        def addEdge(word: str):
            addWord(word)
            id1 = wordId[word]
            chars = list(word)
            for i in range(len(chars)):
                tmp = chars[i]
                chars[i] = "*"
                newWord = "".join(chars)
                addWord(newWord)
                id2 = wordId[newWord]
                edge[id1].append(id2)
                edge[id2].append(id1)
                chars[i] = tmp

        wordId = dict()
        edge = collections.defaultdict(list)
        nodeNum = 0

        for word in wordList:
            addEdge(word)
        
        addEdge(beginWord)
        if endWord not in wordId:
            return 0
        
        disBegin = [float("inf")] * nodeNum
        beginId = wordId[beginWord]
        disBegin[beginId] = 0
        queBegin = collections.deque([beginId])

        disEnd = [float("inf")] * nodeNum
        endId = wordId[endWord]
        disEnd[endId] = 0
        queEnd = collections.deque([endId])

        while queBegin or queEnd:
            queBeginSize = len(queBegin)
            for _ in range(queBeginSize):
                nodeBegin = queBegin.popleft()
                if disEnd[nodeBegin] != float("inf"):
                    return (disBegin[nodeBegin] + disEnd[nodeBegin]) // 2 + 1
                for it in edge[nodeBegin]:
                    if disBegin[it] == float("inf"):
                        disBegin[it] = disBegin[nodeBegin] + 1
                        queBegin.append(it)

            queEndSize = len(queEnd)
            for _ in range(queEndSize):
                nodeEnd = queEnd.popleft()
                if disBegin[nodeEnd] != float("inf"):
                    return (disBegin[nodeEnd] + disEnd[nodeEnd]) // 2 + 1
                for it in edge[nodeEnd]:
                    if disEnd[it] == float("inf"):
                        disEnd[it] = disEnd[nodeEnd] + 1
                        queEnd.append(it)
        
        return 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

(压根没想到用虚拟节点的方法，用了最蠢的遍历a-z的方法。没想到竟然能通过= =)

附上我的低效python代码，仅供参考。

from collections import deque
class Solution:
    def ladderLength(self, beginWord, endWord, wordList):
        word_dict = set(wordList)
        visited = set(['beginWord'])
        queue = deque([(beginWord, 1)])
        while queue:
            pop, depth = queue.popleft()
            if pop == endWord:
                return depth
            for i in range(len(pop)):
                for j in range(97, 123):
                    new_word = pop[:i] + chr(j) + pop[i+1:]
                    if new_word not in visited and new_word in word_dict:
                        queue.append((new_word, depth + 1))
                        visited.add(new_word)
        return 0
```

```py
还有个更巧妙的想法，将 word 的某一位改为 '*' 作为 word 的 key。例如 hit 的 key 为 '*it'、'h*t'、'hi*'。

在 wordList 中找到 key 相同的单词，即是能转换的单词。于是提前将 wordList 的单词按 key 存在哈希表中，就可以进一步减少搜索范围到 len(word)。

def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
    d = defaultdict(list)
    gen_key = lambda w: [w[:i] + '*' + w[i+1:] for i in range(len(w))]
    for word in wordList:
        for key in gen_key(word):
            d[key].append(word)
    queue, vis = deque([(beginWord, 1)]), {beginWord}
    while queue:
        word, T = queue.popleft()
        for key in gen_key(word):
            for w in d[key]:
                if w not in vis:
                    if w == endWord:
                        return T+1
                    vis.add(w)
                    queue.append([w, T+1])
    return 0
```

###  3.119. <a name='LongestConsecutiveSequence'></a>128. Longest Consecutive Sequence

[花花酱](https://www.bilibili.com/video/BV14t411Y7cg?spm_id_from=333.999.0.0)

###  3.120. <a name='SumRoottoLeafNumbers'></a>129 Sum Root to Leaf Numbers

[小明](https://www.bilibili.com/video/BV1VK411H7o5?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        def dfs(root, prevTotal) -> int:
            if not root:
                return 0
            total = prevTotal * 10 + root.val
            if not root.left and not root.right:
                return total
            else:
                return dfs(root.left, total) + dfs(root.right, total)
        return dfs(root, 0)

def sumNumbers(self, root: TreeNode) -> int:
        nums = []
        def dfs(root, s):
            nonlocal nums
            if not root:
                return 0
            s = 10 * s + root.val
            if not root.left and not root.right:
                nums.append(s)
            dfs(root.left, s)
            dfs(root.right, s)
        dfs(root, 0)
        return sum(nums)


class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        def dfs(root, nowVal):
            nonlocal ans
            if root.left == None and root.right == None:
                ans += nowVal
                return
            if root.left:
                dfs(root.left, nowVal*10 + root.left.val)
            if root.right:
                dfs(root.right, nowVal*10 + root.right.val)
        ans = 0
        if root:
            dfs(root, root.val)
        return ans

class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        ans = 0
        
        def dfs(root, acc):
            nonlocal ans
            if not root.left and not root.right:
                ans += acc * 10 + root.val
                return
            if root.left:
                dfs(root.left, acc*10+root.val)
            if root.right:
                dfs(root.right, acc*10+root.val)
        dfs(root, 0)
        return ans

class Solution:
    total = 0
    
    def dfs(self, p: TreeNode, cur: int) -> None:
        if p.left == None and p.right == None:
                self.total += cur * 10 + p.val
                return
        next_val = cur * 10 + p.val
        if p.left: self.dfs(p.left, next_val)
        if p.right: self.dfs(p.right, next_val)
    
    def sumNumbers(self, root: TreeNode) -> int:
        if not root: return 0
        self.dfs(root, 0)
        return self.total

class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.dfs(root, 0)

    def dfs(self, root, sum):
        if root is None:
            return 0
        sum  = sum * 10 + root.val
        if root.left is None and root.right is None:
            return sum
        return self.dfs(root.left, sum) + self.dfs(root.right, sum)

# 其实递归不难想到，不过我自己做错在细节方面

# 如果只有单支，每朝下走一层，代表的数字都增加10， 10* 原本的 + 新节点的数字，最终也是用这个来解

# ```
class Solution(object):
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.dfs(root,0)
    
    
    def dfs(self,root,curSum):
        if root == None:
            return 0
        else:
            curSum = curSum * 10 + root.val
            if root.left == None and root.right == None:
                return curSum
            else:
                return self.dfs(root.left, curSum) + self.dfs(root.right, curSum)
```

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        import collections
        ans = 0
        nq = collections.deque([root])
        vq = collections.deque([root.val])
        while nq:
            root = nq.popleft()
            val = vq.popleft()

            if root.left:
                nq.append(root.left)
                vq.append(val*10+root.left.val)
            if root.right:
                nq.append(root.right)
                vq.append(val*10+root.right.val)
            if not root.left and not root.right:
                ans += val
        return ans

class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return 0

        total = 0
        nodeQueue = collections.deque([root])
        numQueue = collections.deque([root.val])
        
        while nodeQueue:
            node = nodeQueue.popleft()
            num = numQueue.popleft()
            left, right = node.left, node.right
            if not left and not right:
                total += num
            else:
                if left:
                    nodeQueue.append(left)
                    numQueue.append(num * 10 + left.val)
                if right:
                    nodeQueue.append(right)
                    numQueue.append(num * 10 + right.val)

        return total

# 利用辅助栈的非递归方法

class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        stack = []
        p = root
        sum = 0
        while(p or stack):
            if(p):
                stack.append(p)
                if(p.left):
                    p.left.val += p.val*10
                p = p.left
            else:
                p = stack.pop()
                if(not p.left and not p.right):
                    sum += p.val
                if(p.right):
                    p.right.val += p.val*10
                p = p.right
        return sum
```

###  3.121. <a name='SurroundedRegions130-'></a>130. Surrounded Regions 130-被围绕的区域

[花花酱](https://www.bilibili.com/video/BV1dE411f7U4?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV18y4y1j7JH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411k7TH?spm_id_from=333.999.0.0)

```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        n, m = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < n or not 0 <= y < m or board[x][y] != 'O':
                return
            
            board[x][y] = "A"
            dfs(x + 1, y)
            dfs(x - 1, y)
            dfs(x, y + 1)
            dfs(x, y - 1)
        
        for i in range(n):
            dfs(i, 0)
            dfs(i, m - 1)
        
        for i in range(m - 1):
            dfs(0, i)
            dfs(n - 1, i)
        
        for i in range(n):
            for j in range(m):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/surrounded-regions/solution/bei-wei-rao-de-qu-yu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        n, m = len(board), len(board[0])
        que = collections.deque()
        for i in range(n):
            if board[i][0] == "O":
                que.append((i, 0))
                board[i][0] = "A"
            if board[i][m - 1] == "O":
                que.append((i, m - 1))
                board[i][m - 1] = "A"
        for i in range(m - 1):
            if board[0][i] == "O":
                que.append((0, i))
                board[0][i] = "A"
            if board[n - 1][i] == "O":
                que.append((n - 1, i))
                board[n - 1][i] = "A"
        
        while que:
            x, y = que.popleft()
            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= mx < n and 0 <= my < m and board[mx][my] == "O":
                    que.append((mx, my))
                    board[mx][my] = "A"
        
        for i in range(n):
            for j in range(m):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/surrounded-regions/solution/bei-wei-rao-de-qu-yu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
方法一：BFS

class Solution:
    def solve(self, board: List[List[str]]) -> None:
        self.m, self.n = len(board), len(board[0])
        self.board = board
        self.connectedToBorder = set()
        for i in range(self.m):   #把第一行和最后一行的所有O相连的都加入集合
            if (i, 0) not in self.connectedToBorder and self.board[i][0] == 'O':
                self.bfs(i, 0)
            if (i, self.n-1) not in self.connectedToBorder and self.board[i][self.n-1] == 'O':
                self.bfs(i, self.n-1)
        for j in range(self.n):   #把第一列和最后一列的所有O相连的都加入集合
            if (0, j) not in self.connectedToBorder and self.board[0][j] == 'O':
                self.bfs(0, j)
            if (self.m-1, j) not in self.connectedToBorder and self.board[self.m-1][j] == 'O':
                self.bfs(self.m-1, j)

        #把不在集合中的O全变为X
        for i in range(self.m):
            for j in range(self.n):
                if (i,j) not in self.connectedToBorder and self.board[i][j] == 'O':
                    self.board[i][j] = 'X'

    def bfs(self, k, l):
        Q = collections.deque([(k,l)])
        while Q:
            i, j = Q.popleft()
            self.connectedToBorder.add((i,j))
            for x, y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
                if (x,y) not in self.connectedToBorder:
                    if self.m > x >=0 and self.n > y >= 0 and self.board[x][y] == 'O':
                        self.connectedToBorder.add((x,y))
                        Q.append((x,y))
方法二：DFS

class Solution:
    def solve(self, board: List[List[str]]) -> None:
        self.m, self.n = len(board), len(board[0])
        self.board = board
        self.connectedToBorder = set()
        for i in range(self.m):   #把第一行和最后一行的所有O相连的都加入集合
            if (i, 0) not in self.connectedToBorder and self.board[i][0] == 'O':
                self.dfs(i, 0)
            if (i, self.n-1) not in self.connectedToBorder and self.board[i][self.n-1] == 'O':
                self.dfs(i, self.n-1)
        for j in range(self.n):   #把第一列和最后一列的所有O相连的都加入集合
            if (0, j) not in self.connectedToBorder and self.board[0][j] == 'O':
                self.dfs(0, j)
            if (self.m-1, j) not in self.connectedToBorder and self.board[self.m-1][j] == 'O':
                self.dfs(self.m-1, j)

        #把不在集合中的O全变为X
        for i in range(self.m):
            for j in range(self.n):
                if (i,j) not in self.connectedToBorder and self.board[i][j] == 'O':
                    self.board[i][j] = 'X'

    def dfs(self, i, j):
        self.connectedToBorder.add((i,j))
        for x, y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:
            if (x,y) not in self.connectedToBorder and self.m > x >=0 and self.n > y >= 0 and self.board[x][y] == 'O':
                self.dfs(x,y)   
```

###  3.122. <a name='-1'></a>131-分割回文串

[哈哈哈](https://www.bilibili.com/video/BV1dK411p7eU?spm_id_from=333.999.0.0)

###  3.123. <a name='PalindromePartitioningII'></a>132. Palindrome Partitioning II

[花花酱](https://www.bilibili.com/video/BV1NJ411v7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1944y1C71s?spm_id_from=333.999.0.0)

```py
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        g = [[True] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                g[i][j] = (s[i] == s[j]) and g[i + 1][j - 1]

        f = [float("inf")] * n
        for i in range(n):
            if g[0][i]:
                f[i] = 0
            else:
                for j in range(i):
                    if g[j + 1][i]:
                        f[i] = min(f[i], f[j] + 1)
        
        return f[n - 1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/fen-ge-hui-wen-chuan-ii-by-leetcode-solu-norx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def minCut(self, s: str) -> int:

        isPalindromic=[[False]*len(s) for _ in range(len(s))]

        for i in range(len(s)-1,-1,-1):
            for j in range(i,len(s)):
                if s[i]!=s[j]:
                    isPalindromic[i][j] = False
                elif  j-i<=1 or isPalindromic[i+1][j-1]:
                    isPalindromic[i][j] = True

        # print(isPalindromic)
        dp=[sys.maxsize]*len(s)
        dp[0]=0

        for i in range(1,len(s)):
            if isPalindromic[0][i]:
                dp[i]=0
                continue
            for j in range(0,i):
                if isPalindromic[j+1][i]==True:
                    dp[i]=min(dp[i], dp[j]+1)
        return dp[-1]
```

```py
记忆化dfs，5%睡了睡了

class Solution:
    def minCut(self, s: str) -> int:
        self.memo = [9999]*len(s)
        self.s = s
        return self.dfs(0)
    
    def dfs(self,pos):
        if pos >= len(self.memo):
            return -1
        elif pos == len(self.memo)-1: 
            self.memo[pos] = 0
            return 0
        
        if self.memo[pos] < 9999: 
            return self.memo[pos]

        for i in range(pos,len(self.s)):
            if self.s[pos:i+1]==self.s[pos:i+1][::-1] :
                self.memo[pos] = min(self.dfs(i+1),self.memo[pos])
        self.memo[pos] += 1
        return self.memo[pos]

```

###  3.124. <a name='CloneGraph'></a>133. Clone Graph

[小梦想家](https://www.bilibili.com/video/BV1wA411T7SM?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV18i4y1c7FE?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12K411A7Zb?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1hzav19bp1wg.png" width="70%">

https://www.bilibili.com/video/BV1Cy4y127Di?from=search&seid=15236791324980694232&spm_id_from=333.337.0.0

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6d4fzq5ov200.png)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.2ie91wvv2iu0.png" width="70%">


```py
class Solution:
    def createNode(self, oldNode):
        newNode = Node(oldNode.val)
        self.newNodeDict[newNode.val] = newNode
        for i in oldNode.neighbors:
            if i.val not in self.newNodeDict:
                self.createNode(i)
            newNode.neighbors.append(self.newNodeDict[i.val])
        return newNode
        
    def cloneGraph(self, node):
        if not node:
            return None
        self.newNodeDict = {}
        return self.createNode(node)
```

```py
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        def dfs(u):
            vis[u] = Node(u.val)
            vis[u].neighbors = [dfs(v) if v not in vis else vis[v] for v in u.neighbors]
            return vis[u]

        vis = {}
        return dfs(node) if node else None

# bfs模板加一个dict记录即可！

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if node is None: return None
        from collections import deque
        d = deque([node])
        visited = set([node.val])
        has = {node.val: Node(node.val)}
        while d:
            onode = d.pop()
            cnode = has[onode.val]
            for nd in onode.neighbors:
                if nd.val not in visited:
                    d.append(nd)
                    visited.add(nd.val)
                if nd.val not in has:
                    has[nd.val] = Node(nd.val)
                cnode.neighbors.append(has[nd.val])
        return has[node.val]

class Solution(object):
    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if node == None: return None

        root = Node(node.val)
        # must 1 to 1
        createdNodes = {}
        createdNodes[root.val] = root 

        stack = []
        stack.append(node)

        while stack:
        	cur = stack.pop()
        	if cur.val in createdNodes:
        		existNode = createdNodes[cur.val]
        		for neighbor in cur.neighbors:
        			if neighbor.val in createdNodes:
        				existNeighbor = createdNodes[neighbor.val]
        				existNode.neighbors.append(existNeighbor)
        			else:
        				newNode = Node(neighbor.val)
        				existNode.neighbors.append(newNode)
        				createdNodes[neighbor.val] = newNode
        				stack.append(neighbor)
        return root

class Solution(object):

    def __init__(self):
        self.visited = {}

    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node

        # 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回
        if node in self.visited:
            return self.visited[node]

        # 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表
        clone_node = Node(node.val, [])

        # 哈希表存储
        self.visited[node] = clone_node

        # 遍历该节点的邻居并更新克隆节点的邻居列表
        if node.neighbors:
            clone_node.neighbors = [self.cloneGraph(n) for n in node.neighbors]

        return clone_node
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.4t97v5kpwvq0.png" width="50%">

###  3.125. <a name='GasStation'></a>134. Gas Station

[小梦想家](https://www.bilibili.com/video/BV1BC4y1472f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1754y1176F?spm_id_from=333.999.0.0)

```py
啪就打开题解 很快啊

class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        i = 0
        while i<len(cost):
            soG = 0
            soC = 0
            tmp = 0
            while tmp<len(cost):
                j = (i+tmp)%len(cost)
                soC+=cost[j]
                soG+=gas[j]
                if soC>soG:
                    break
                tmp+=1
            if tmp == len(cost):
                return i
            else:
                i = i+tmp+1
        return -1

class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        n = len(gas)
        start = 0
        surplus = 0
        i = 0
        while True:
            t = (start+i) % n
            surplus += gas[t] - cost[t]
            i += 1
            if surplus < 0:
                if start == n-1:
                    return -1
                surplus = 0
                start += 1
                i = 0
            elif i == n:
                return start
算法思路一样，复杂度分析一下应该也是O(n)，但是运行到倒数第二个测试就会超时，很头疼
```

```py
class Solution(object):
    def canCompleteCircuit(self, gas, cost):
        # a 就是那个数组
        a = []
        for i in range(len(gas)):
            a.append(gas[i] - cost[i])

        if sum(a) < 0:
            return -1

        start = 0
        all_money = 0
        for i in range(len(a)):
            all_money += a[i]
            if all_money < 0:
                all_money = 0
                start = i+1

        return start

class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        start = 0
        curSum = 0
        totalSum = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            if curSum < 0:
                curSum = 0
                start = i + 1
        if totalSum < 0: return -1
        return start
```

###  3.126. <a name='CopyListwithRandomPointer'></a>138 Copy List with Random Pointer

[小明](https://www.bilibili.com/video/BV1BN411R7a8?spm_id_from=333.999.0.0)

###  3.127. <a name='SingleNumber'></a>136-Single Number

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7bf?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Sp4y1D7M3?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7PU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pa4y1t7tr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.distinct.filter(x => nums.filter(_ == x).length != 2)(0)
    }
}
```

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        var hashSet = scala.collection.mutable.HashSet.empty[Int]
        for(num <- nums){
            if(hashSet.contains(num)){
                hashSet.remove(num)
            }else{
                hashSet.add(num)
            }
        }
        
        hashSet.head
    }
}

//Alternate solution (not much time improvement)
/**
scala> 3 ^ 3
res0: Int = 0

scala> 3 ^ 4
res1: Int = 7

scala> 3 ^ 4 ^ 3
res2: Int = 4
*/
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.reduce(_ ^ _)
    }
}

```

```scala
package com.zhourui.leetcode

package lc0136_singlenumber {
  object Solution {
    def singleNumber(nums: Array[Int]): Int = {
      val ret = nums.foldLeft(0) ( _ ^ _)
      return ret

    }
  }

}

```

###  3.128. <a name='SingleNumberII'></a>137 Single Number II

[小明](https://www.bilibili.com/video/BV1Hv411B7rd?spm_id_from=333.999.0.0)

###  3.129. <a name='WordBreak'></a>139 Word Break

[小明](https://www.bilibili.com/video/BV1p54y1k7vf?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        ok = [True]
        for i in range(1, len(s)+1):
            ok += [any(ok[j] and s[j:i] in wordDict for j in range(i))]
        return ok[-1]

class Solution:
    def wordBreak(self, s, wordDict):
        wordDictSet = set(wordDict)
        dp = [False] * (len(s) + 1)
        for i in range(1, len(s) + 1):
            # 找切分点
            for j in range(i):
                if dp[j] and s[j: i] in wordDictSet:
                    dp[i] = True # 说明s[: i] 在wordDict中
                    break # 剩下的切分点j不用再寻找了
        return dp[-1]

class Solution:
    def wordBreak(self, s, wordDict):
        '''排列'''
        dp = [False]*(len(s) + 1)
        dp[0] = True
        # 遍历背包
        for j in range(1, len(s) + 1):
            # 遍历单词
            for word in wordDict:
                if j >= len(word):
                    dp[j] = dp[j] or (dp[j - len(word)] and word == s[j - len(word):j])
        return dp[len(s)]

# python 动态规划

# 从 i = 0 开始分析：i = 0， 遍历 j in range(1, n+1)， 

# 即遍历所有以 s[0]开头的组合，把第一个单词可能的情况全部找出来。

# 此时相当于把打头的单词可能的情况全部找出来了。

# 然后基于第一个单词一个单词一个单词地接上去。

class Solution:
    def wordBreak(self, s, wordDict):
        n = len(s) 

        flag = [True] + [False]*n

        for i in range(n):
            for j in range(i+1, n+1):
                if flag[i] == True and (s[i:j] in wordDict):
                    flag[j] = True
        
        return flag[-1]

class Solution:
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        if not s:
            return True
        
        breakp = [0]
        
        for i in range(len(s) + 1):
            for j in breakp:
                if s[j:i] in wordDict:
                    breakp.append(i)
                    break
        return breakp[-1] == len(s)

class Solution:
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        if not s:
            return True
        
        breakp = [0]
        
        for i in range(len(s) + 1):
            for j in breakp:
                if s[j:i] in wordDict:
                    breakp.append(i)
                    break
        return breakp[-1] == len(s)

# 超时了 但是还是想分享一下 一个回溯的方法

class Solution:
    def wordBreak(self, s, wordDict):
        def dfs(s):
            if s.isspace():
                return True
            for item in wordDict:
                if item in s:
                    if dfs(s.replace(item,' ',1)):
                        return True
            return False
        return dfs(s)
```

###  3.130. <a name='WordBreakII'></a>140 Word Break II

[小明](https://www.bilibili.com/video/BV1ht4y1X7DJ?spm_id_from=333.999.0.0)

```py
# 直接回溯过了，这是样例出问题了还是标错难度了。。。

class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: List[str]
        """
        cash = dict()
        for word in wordDict:
            cash[word] = 1
        ans = []
        def backtract(s, tmp, ans):
            if len(s) == 0:
                ans.append(tmp[1:])
                return

            n = len(s)
            for i in range(n):
                if s[:i+1] in cash:
                    backtract(s[i+1:], tmp+" "+s[:i+1], ans)
        backtract(s, "", ans)
        #ans.sort()
        return ans

class Solution:
    def wordBreak(self, s, wordDict):
        # @lru_cache(None)
        def backtrack(index: int):
            if index == len(s):
                return [[]]
            ans = list()
            for i in range(index + 1, len(s) + 1):
                word = s[index:i]
                if word in wordSet:
                    nextWordBreaks = backtrack(i)
                    for nextWordBreak in nextWordBreaks:
                        ans.append(nextWordBreak.copy() + [word])
            return ans
        
        wordSet = set(wordDict)
        breakList = backtrack(0)
        return [" ".join(words[::-1]) for words in breakList]

class Solution(object):
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: List[str]
        """
        memo = {len(s): ['']}
        def sentences(i):
            if i not in memo:
                memo[i] = [s[i:j] + (tail and ' ' + tail)
                           for j in range(i+1, len(s)+1)
                           if s[i:j] in wordDict
                           for tail in sentences(j)]
            return memo[i]
        return sentences(0)
```

###  3.131. <a name='LinkedListCycle'></a>141-Linked List Cycle

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7ta?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411H7XP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1KX4y157vh?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1PA411b7gq?spm_id_from=333.999.0.0)

```py
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        seen = set()
        while head:
            if head in seen:
                return True
            seen.add(head)
            head = head.next
        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head or not head.next:
            return False
        
        slow = head
        fast = head.next

        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
感觉初始时把快慢指针都指向 head 反而更简洁：

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
        
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

/**
* chosen solution
* memo
*      1. create two pointers one work faster with two step the other work slower with a step
*         if there is a cycle in linked list, the faster pointer will equal to  slower pointer sooner or later
*
* time complexity: 
*       no cycle: O(N)
*       has cycleL O(N + K) K is the cycle length
* space complexity: O(1) )
*/

object Solution0 {
    def hasCycle(head: ListNode): Boolean = {
        if(head != null && head.next != null) 
            _hasCycle(head.next.next, head.next)
        else false
    }
    
    @annotation.tailrec
    def _hasCycle(fast: ListNode, slow: ListNode): Boolean = {
        if(fast == null || fast.next == null || slow == null) return false
        else if(fast == slow) return true
        else _hasCycle(fast.next.next, slow.next)
    }
}


/**
* seen set  iterative version
* memo
*     using a set to record the node which was seen
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def hasCycle(head: ListNode): Boolean = {
        
        var p = head
        val seenSet = new scala.collection.mutable.HashSet[ListNode]()
        
        var result: Boolean = false
        while (p != null && result != true) {

            if(seenSet.contains(p))  
                result = true
            else {
                seenSet += p
                p = p.next
            
            }
        }
        result
    }
}
/**
* seen set - recursive version
* memo
*     using a set to record the node which was seen
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution2 {
    def hasCycle(head: ListNode): Boolean = {
        val seenSet = new scala.collection.mutable.HashSet[ListNode]()
        _hasCycle(head, seenSet)
     
    }
    
    def _hasCycle(n: ListNode, seenSet: scala.collection.mutable.HashSet[ListNode]): Boolean = {
        (n, seenSet.contains(n)) match {
            case (null, _) => false
            case (_, true) => true
            case (_, false) => 
                 seenSet += n
                _hasCycle(n.next, seenSet)
        }
    }
    
}

/**
* two pointer - iterative version
* memo
*      1. create two pointers one work faster with two step the other work slower with a step
*         if there is a cycle in linked list, the faster pointer will equal to  slower pointer sooner or later
*
* time complexity: 
*       no cycle: O(N)
*       has cycleL O(N + K) K is the cycle length
* space complexity: O(1) 
*/
object Solution3 {
    def hasCycle(head: ListNode): Boolean = {
        var pointerA = head
        var pointerB = head
        
        
        var result = false
        while (pointerA != null && pointerA.next != null && result != true) {
            pointerA = pointerA.next.next
            pointerB = pointerB.next
        
            if(pointerA == pointerB) result = true
        }
        result
    }
}

/**
* two pointer - recursive version
* time complexity: 
*       no cycle: O(N)
*       has cycleL O(N + K) K is the cycle length
* space complexity: O(1)     
*/
object Solution4 {
    def hasCycle(head: ListNode): Boolean = {
        if( head != null && head.next != null) 
            _hasCycle(head.next, head)
        else 
            false
    }
    
    def _hasCycle(fast: ListNode, slow: ListNode): Boolean = {
        (fast, slow, fast == slow) match {
            case (null, _, _) => false
            case (_, null, _) => false
            case (_, _, true) => true
            case (_, _, false) => 
                if (fast.next == null) false
                else _hasCycle(fast.next.next, slow.next)   
        }  
    } 
}
/**
* two pointer - tail recursive
*/
object Solution4-1 {
    def hasCycle(head: ListNode): Boolean = {
        if(head != null && head.next != null) 
            _hasCycle(head.next.next, head.next)
        else false
    }
    
    @annotation.tailrec
    def _hasCycle(fast: ListNode, slow: ListNode): Boolean = {
        if(fast == null || fast.next == null || slow == null) return false
        else if(fast == slow) return true
        else _hasCycle(fast.next.next, slow.next)
    }
}

```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    def hasCycle(head: ListNode): Boolean = {
        var ha = head
        if(ha == null){
            false
        }else if(ha.next == null){
            false
        }else{
            var hs = scala.collection.mutable.HashSet.empty[ListNode]
            var flag = true
            var output = false
            while(flag){
                if(hs.contains(ha)){
                    flag = false
                    output = true
                }else if(ha.next == null){
                    flag = false
                }else{
                    hs.add(ha)
                    ha = ha.next
                }
            }
            output
        }
    }
}

//Alternate solution: Slow & Fast pointer
object Solution {
    def hasCycle(head: ListNode): Boolean = {
        
        if(head == null){
            false
        }else{
        
        var slow = head
        var fast = head.next
        var output = true
        
        import scala.util.control.Breaks._
        breakable{
            while(slow != fast){
                if(fast == null || fast.next == null){
                    output=false
                    break
                }
                slow = slow.next
                fast = fast.next.next
            }
        }
        output
    }
    }
}

```

###  3.132. <a name='LinkedListCycleII'></a>142 Linked List Cycle II

[小明](https://www.bilibili.com/video/BV1W5411L7AF?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV15e41147EY?spm_id_from=333.999.0.0)

```py
只有我的代码这么奇葩吗=-=

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        while head:
            if head.val == 'bjfuvth':
                return True
            else:
                head.val = 'bjfuvth'
            head = head.next
        return False

方法一：集合 如果发现节点已在集合内则说明存在环

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        s = set()
        while h2 != None and head.next != None:
            s.add(head)
            head = head.next
            if head in s:
                return True
        return False

方法二：双指针。 快慢指针，如果两个指针相遇则说明存在环

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        h1, h2 = head, head
        while h2 != None and h2.next != None:
            h2 = h2.next.next
            h1 = h1.next
            if h1 == h2:
                return True
        return False
```

```py
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head: return False
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if fast == slow:
                return True
        return False
```

```scala
/**
* chosen solution 
* two pointer: tail recursive
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution0 {
    def detectCycle(head: ListNode): ListNode = {
        if(head == null || head.next == null || head.next.next == null) return null
        val meetNode =  _findMeetNode(head.next, head.next.next)
        
        meetNode match {
            case null => null
            case _ => _findStartNode(head, meetNode)
        }
    }
    
    @annotation.tailrec
    def _findStartNode(nodeA: ListNode, nodeB: ListNode): ListNode = {
       if(nodeA == nodeB) nodeA
        else _findStartNode(nodeA.next, nodeB.next)
        
    }
    
    @annotation.tailrec
    def _findMeetNode(slow: ListNode, fast: ListNode): ListNode = {
        if(fast == null || fast.next == null) return null
        if(slow == fast) return slow
        _findMeetNode(slow.next, fast.next.next)
        
    }
}

/**
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def detectCycle(head: ListNode): ListNode = {
        val seenSet = new scala.collection.mutable.HashSet[ListNode]()
        var p = head
        
        var result: ListNode = null

        while (p != null && result == null) {
            // println(result)
            if(seenSet.contains(p))  
                result = p
            else {
                seenSet += p
                p = p.next
            }
        }
        result
        
    }
}


/**
* two pointer
* without using extra space
*/
object Solution2 {
    def detectCycle(head: ListNode): ListNode = {
        val meetPoint = if (head != null && head.next != null)
            _detectCycle(head.next.next, head.next)
        else None
            
        meetPoint match {
            case None => null
            case Some(slow1) => getStartOfLoop(head, meetPoint)   
        }
        
    }
    
    def getStartOfLoop(slow1: ListNode, slow2: ListNode): ListNode = {
        
        if (slow1 != slow2) 
            getStartOfLoop(slow1.next, slow2.next)
        else
            slow2

    }
    
    def _detectCycle(fast: ListNode, slow: ListNode): Option[ListNode] = {
        
        (fast, slow, fast == slow) match {
            case (null, _, _) => None
            case (_, null, _) => None
            case (_, _, true) => Some(slow)
            case (_, _, false) => 
                if(fast.next != null) _detectCycle(fast.next.next, slow.next)
                else None
        }
        
    }
}

/**
* two pointer
* iterative version without extra space
*/

object Solution2-1 {
    def detectCycle(head: ListNode): ListNode = {
        val meetNode = _detectCycle(head)
        
        if(meetNode == null) {
            null
        }else {
         findStartPoint(head, meetNode)   
        }
        
    }
    def findStartPoint(head: ListNode, meet: ListNode): ListNode =  {
        var node1 = head
        var node2 = meet
        
        while(node1 != node2) {
            node1 = node1.next
            node2 = node2.next
        }
        node1
    }
    
    def _detectCycle(head: ListNode): ListNode = {
        var fast = head
        var slow = head
        
        var result:ListNode = null
        while(result == null && fast != null && slow != null && fast.next != null) {
            fast = fast.next.next
            slow = slow.next
            if(fast == slow){
                result = slow
            }
        }
        
        result
    }
}

/**
* two pointer: tail recursive
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution2-2 {
    def detectCycle(head: ListNode): ListNode = {
        if(head == null || head.next == null || head.next.next == null) return null
        val meetNode =  _findMeetNode(head.next, head.next.next)
        
        meetNode match {
            case null => null
            case _ => _findStartNode(head, meetNode)
        }
    }
    
    @annotation.tailrec
    def _findStartNode(nodeA: ListNode, nodeB: ListNode): ListNode = {
       if(nodeA == nodeB) nodeA
        else _findStartNode(nodeA.next, nodeB.next)
        
    }
    
    @annotation.tailrec
    def _findMeetNode(slow: ListNode, fast: ListNode): ListNode = {
        if(fast == null || fast.next == null) return null
        if(slow == fast) return slow
        _findMeetNode(slow.next, fast.next.next)
        
    }
}

```

###  3.133. <a name='ReorderList'></a>143 Reorder List

[小明](https://www.bilibili.com/video/BV1Jf4y1Q7y7?spm_id_from=333.999.0.0)

###  3.134. <a name='Preorderwithstack'></a>144-Preorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1HT4y1G74i?spm_id_from=333.999.0.0)

###  3.135. <a name='BinaryTreePreorderTraversal'></a>144-Binary Tree Preorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7NZ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Ch411Q74P?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1RD4y1D7C7?spm_id_from=333.999.0.0)

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def preorder(root: TreeNode):
            if not root:
                return
            res.append(root.val)
            preorder(root.left)
            preorder(root.right)
        
        res = list()
        preorder(root)
        return res

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = list()
        if not root:
            return res
        
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = list()
        if not root:
            return res
        
        p1 = root
        while p1:
            p2 = p1.left
            if p2:
                while p2.right and p2.right != p1:
                    p2 = p2.right
                if not p2.right:
                    res.append(p1.val)
                    p2.right = p1
                    p1 = p1.left
                    continue
                else:
                    p2.right = None
            else:
                res.append(p1.val)
            p1 = p1.right
        
        return res

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        ans = []
        if not root:
            return ans
        stack = [root]
        while stack:
            node = stack.pop()
            ans.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return ans
```

```py
Python迭代

class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        
        stack = [root]
        res = []
        while stack:
            cur = stack.pop()
            res.append(cur.val)            
            if cur.right:
                stack.append(cur.right)
            if cur.left:
                stack.append(cur.left)
        return res
Python递归

class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
```

###  3.136. <a name='Postorderwithstack'></a>145-Postorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1Ti4y187jL?spm_id_from=333.999.0.0)

###  3.137. <a name='BinaryTreePostorderTraversal'></a>145-Binary Tree Postorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7ub?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1uv411h7Gc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1xZ4y1H7uS?spm_id_from=333.999.0.0)

```py
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def postorder(root: TreeNode):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = list()
        postorder(root)
        return res

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return list()
        
        res = list()
        stack = list()
        prev = None

        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if not root.right or root.right == prev:
                res.append(root.val)
                prev = root
                root = None
            else:
                stack.append(root)
                root = root.right
        
        return res

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def addPath(node: TreeNode):
            count = 0
            while node:
                count += 1
                res.append(node.val)
                node = node.right
            i, j = len(res) - count, len(res) - 1
            while i < j:
                res[i], res[j] = res[j], res[i]
                i += 1
                j -= 1
        
        if not root:
            return list()
        
        res = list()
        p1 = root

        while p1:
            p2 = p1.left
            if p2:
                while p2.right and p2.right != p1:
                    p2 = p2.right
                if not p2.right:
                    p2.right = p1
                    p1 = p1.left
                    continue
                else:
                    p2.right = None
                    addPath(p1.left)
            p1 = p1.right
        
        addPath(root)
        return res

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
# 前序遍历-递归-LC144_二叉树的前序遍历
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # 保存结果
        result = []
        
        def traversal(root: TreeNode):
            if root == None:
                return
            result.append(root.val) # 前序
            traversal(root.left)    # 左
            traversal(root.right)   # 右

        traversal(root)
        return result

# 中序遍历-递归-LC94_二叉树的中序遍历
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            result.append(root.val) # 中序
            traversal(root.right)   # 右

        traversal(root)
        return result

# 后序遍历-递归-LC145_二叉树的后序遍历
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            traversal(root.right)   # 右
            result.append(root.val) # 后序

        traversal(root)
        return result

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        from collections import deque
        res, q = [], deque()
        q.append(root) if root else None
        while q:
            t = q.pop()
            res.append(t.val)
            q.append(t.left) if t.left else None
            q.append(t.right) if t.right else None
        return res[::-1]
```

###  3.138. <a name='LRUCache'></a>146 LRU Cache 

[花花酱](https://www.bilibili.com/video/BV19b411c7ue?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7c6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1t7zj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ZQ4y1A74H?spm_id_from=333.999.0.0)

```py
class LRUCache(collections.OrderedDict):

    def __init__(self, capacity: int):
        super().__init__()
        self.capacity = capacity


    def get(self, key: int) -> int:
        if key not in self:
            return -1
        self.move_to_end(key)
        return self[key]

    def put(self, key: int, value: int) -> None:
        if key in self:
            self.move_to_end(key)
        self[key] = value
        if len(self) > self.capacity:
            self.popitem(last=False)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class DLinkedNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None


class LRUCache:

    def __init__(self, capacity: int):
        self.cache = dict()
        # 使用伪头部和伪尾部节点    
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.capacity = capacity
        self.size = 0

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        # 如果 key 存在，先通过哈希表定位，再移到头部
        node = self.cache[key]
        self.moveToHead(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key not in self.cache:
            # 如果 key 不存在，创建一个新的节点
            node = DLinkedNode(key, value)
            # 添加进哈希表
            self.cache[key] = node
            # 添加至双向链表的头部
            self.addToHead(node)
            self.size += 1
            if self.size > self.capacity:
                # 如果超出容量，删除双向链表的尾部节点
                removed = self.removeTail()
                # 删除哈希表中对应的项
                self.cache.pop(removed.key)
                self.size -= 1
        else:
            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)
    
    def addToHead(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)

    def removeTail(self):
        node = self.tail.prev
        self.removeNode(node)
        return node

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```scala

/**
* chosen solution
* build-in linkedHashMap
* time complexity: O(1)
*/
class LRUCache0(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
    cache.get(key) match {
        case Some(v) => 
            cache.remove(key)
            cache.put(key, v)
            v
        case None => -1
    }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}

/**
* my first commitment
* implement with linked list
* time complexity:
*    get, put, delete: O(N)
*/
case class Node(key: Int, var value: Int, var next: Node = null)

class LRUCache1(_capacity: Int) {
  private val head = Node(Int.MinValue, -1, null)
  private val capacity = _capacity


  def get(key: Int): Int = {
    var preNode = head
    var current = head.next


    // find the key in linkedList
    while(current != null && current.key != key) {
      preNode = current
      current = current.next
    }


    if(current != null) {
      deleteNode(preNode)
      prepend(current)
      current.value
    } else {
      -1
    }

  }

def put(key: Int, value: Int) {
    var prepreNode = head
    var preNode = head
    var current = preNode.next
    var count = 0

    while(current != null && current.key != key) {
      prepreNode = preNode
      preNode = current
      current = current.next
      count += 1
    }
    if(current != null) {
      current.value = value
      deleteNode(preNode)
      prepend(current)

    }else {

      if(count >= this.capacity) {
        // delete node
        prepreNode.next = null
//        deleteTail()
      }
      prepend(Node(key, value, null))
    }

  }

  private def deleteNode(preNode: Node) {
    val deleteOne = preNode.next
    if(deleteOne != null) {
      preNode.next = deleteOne.next
    }
  }
  
  private def deleteTail(): Unit ={
    var preNode = head
    var current = preNode.next
    while(current != null && current.next != null) {
      preNode = current
      current = current.next
    }
    deleteNode(preNode)
  }

  private def prepend(newNode: Node) {
    newNode.next = head.next
    head.next = newNode
  }

  private def traversal(): Unit = {
    var node = head.next

    while(node != null) {
      print(s"(key: ${node.key} value: ${node.value})")
      node = node.next
    }
    println(" ")
  }
  
}

/**
* double linked list + hashset
* time complexity:
*    get, put, delete: O(1)
*/

case class Node(key: Option[Int], var value: Int, var pre:Node = null, var next: Node = null)
class LRUCache2(_capacity: Int) {

  private val capacity = _capacity
  private var currentSize = 0
  private val head = Node(None, -1)
  private var tail = Node(None, -1)
  head.next = tail
  tail.pre = head

  private val cache = collection.mutable.HashMap[Int, Node]()

  def get(key: Int): Int = {
    cache.get(key).map{ node =>
      removeNode(node)
      prependNode(node)
      node.value
    }.getOrElse(-1)
  }

  def put(key: Int, value: Int) {
    val node = cache.get(key) match {
      case Some(n) =>
        n.value = value
        removeNode(n)
        prependNode(n)
        n
      case None =>
        if(currentSize >= capacity) {
          cache.remove(tail.pre.key.get)
          removeTail()
          currentSize -= 1
        }
        currentSize += 1
        prependNode(Node(Some(key), value))
        head.next
    }
    cache += (key -> node)
  }
  private def removeTail(): Unit ={
    val lastNode = tail.pre
    removeNode(lastNode)
  }

  private def prependNode(node: Node): Unit = {
    node.next = head.next
    node.pre = head

    head.next.pre = node
    head.next = node
  }
  private def removeNode(node: Node): Unit = {
    node.pre.next = node.next
    node.next.pre = node.pre
  }
}


/**
* build-in linkedHashMap
*/
class LRUCache3(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
  /**
   *cache.get(key).map{
   *   value =>
   *     cache.remove(key)
   *     cache.update(key, value)
   *     value
   * }.getOrElse(-1)
   */
   cache.get(key) match {
            case Some(v) => 
                cache.remove(key)
                cache.put(key, v)
                v
            case None => -1
        }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}

```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._
import scala.collection.mutable._

package lc0146 {
  class LRUCache(_capacity: Int) {

    val hm = HashMap[Int, Int]()
    val lb = ListBuffer.empty[Int]
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key)
      } else {
        -1
      }

    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key) = value
      } else {
        if (hm.size == c) {
          val lk = lb.head
          hm.remove(lk)
          lb.remove(0)
        }
        hm(key) = value
        lb += key
      }
    }
  }


  class LRUCache2(_capacity: Int) {
    case class KV(k:Int,var v:Int)
    case class Node(v:KV,var prev:Node,var next:Node)


    var head:Node = null
    var tail:Node = null
    val hm = HashMap[Int, Node]()
    val c = _capacity

    def addToHead(cur:Node): Unit = {
      if (head!=null) {
        head.prev = cur
      } else {
        tail = cur
      }
      cur.prev = null
      cur.next = head
      head = cur
    }

    // cur not null
    def remove(cur:Node): Unit = {
      if (cur.prev!=null) { // it is Not head
        cur.prev.next = cur.next
      } else {
        head = cur.next
      }

      if (cur.next!=null) { // not tail
        cur.next.prev = cur.prev
      } else {
        tail = cur.prev
      }
    }

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val node = hm(key)
        remove(node)
        addToHead(node)
        node.v.v
      } else { // not found
        -1
      }
    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val node = hm(key)
        remove(node)
        addToHead(node)
        node.v.v = value
      } else {
        if (hm.size == c) {
          val old = tail
          if (old!=null) {
            remove(old)
            hm.remove(old.v.k)
          }
        }
        val node = Node(KV(key,value),null,null)
        hm(key) = node
        addToHead(node)
      }
    }
  }

// test case
//  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
//  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]

//  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]
  class LRUCache3(_capacity: Int) {
    val hm = HashMap[Int, Node]()
    val dl = new DoublyLinkedList()
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v
      } else { // not found
        -1
      }
    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v = value
      } else {
        if (hm.size == c) {
          val old = dl.tail
          if (old!=null) {
            dl.erase(old)
            hm.remove(old.v.k)
          }
        }
        val node = Node(KV(key,value),null,null)
        hm(key) = node
        dl.push_front(node)
      }
    }
  }

  class Test extends BaseExtension {
    def init {
      val lru = new LRUCache(2)
      lru.put(1,1)
      lru.put(2,2)
      println(lru.get(1) == 1)
    }

    val name = "146 LRU chache"
  }

//  ["LRUCache","put","put","get","put","get","put","get","get","get"]
//  [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
  class Test2 extends BaseExtension {
    def init {
      val lru = new LRUCache2(2)
      lru.put(2,1)
      lru.put(1,1)
      lru.put(2,3)
      lru.put(4,1)
      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }

  //  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
  //  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]
  //  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]

  class Test3 extends BaseExtension {
    def init {
      val lru = new LRUCache3(10)
      lru.put(10,13)
      lru.put(3,17)
      lru.put(6,11)
      lru.put(10,5)
      lru.put(9,10)

      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }



}

```

###  3.139. <a name='InsertionSortList'></a>147 Insertion Sort List

[小明](https://www.bilibili.com/video/BV1F54y1k7oU?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Ti4y187pN?spm_id_from=333.999.0.0)

```py
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        dummyHead = ListNode(0)
        dummyHead.next = head
        lastSorted = head
        curr = head.next

        while curr:
            if lastSorted.val <= curr.val:
                lastSorted = lastSorted.next
            else:
                prev = dummyHead
                while prev.next.val <= curr.val:
                    prev = prev.next
                lastSorted.next = curr.next
                curr.next = prev.next
                prev.next = curr
            curr = lastSorted.next
        
        return dummyHead.next

class Solution(object):
    def insertionSortList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None or head.next == None:
            return head

        dummy = ListNode(-1)
        dummy.next = head

        prev = head 
        cur = head.next

        while cur:
            p = dummy
            while p.next.val <= cur.val and p != prev:
                p = p.next
            if p != prev:
                prev.next = cur.next
                cur.next = p.next
                p.next = cur
            prev = cur
            cur = cur.next

        return dummy.next

class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        dummyHead = ListNode()
        dummyHead.next = head
        ppre = head
        p = head.next
        while p:
            #如果前一个节点的值小于当前节点的值，就不需要插入，直接指向下一个节点就可以了
            if ppre.val <= p.val:
                ppre = p 
                p = p.next
            else:
                #首先把当前节点摘出来
                #用tmp来保存要插入的节点
                tmp = p
                #将它的前一个节点指向后一个节点,p后移
                ppre.next = p.next
                p = p.next
                #然后接着将tmp插入到之前已经排序好的链表中
                #定义一个q指针和qpre指针
                q = head
                qpre = dummyHead
                #当当前指针的值小于要插入节点的值，就将当前指针后移 
                while tmp.val > q.val:
                    qpre = q
                    q = q.next
                #结束循环的时候q指向的是满足q.val >= tmp.val，qpre.val < tmp.val 也就是tmp应该插入到qpre的后面
                tmp.next = q
                qpre.next = tmp
                #至此插入完成
                #！！！注意插入完成后head节点可能发生了变化，需要更新一下
                head = dummyHead.next
        return dummyHead.next

class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0)
        dummy.next = head
        while head and head.next:
            if head.val <= head.next.val:
                head = head.next
                continue
            pre = dummy
            while pre.next.val < head.next.val:
                pre = pre.next
            cur = head.next
            head.next = cur.next
            cur.next = pre.next
            pre.next = cur
            
        return dummy.next
        #  试一下这组数据 [0, 5000]+list(range(1, 5000)) 会超时。只是题目的测试用例没有，所以过了

# 菜鸡版 python

class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        cur = head.next
        dummy.next.next = None
        while cur:
            node = dummy
            while node.next and cur.val > node.next.val:
                node = node.next
            third = cur.next
            cur.next = node.next
            node.next = cur
            cur = third
        return dummy.next
```

###  3.140. <a name='SortList'></a>148. Sort List

[花花酱](https://www.bilibili.com/video/BV1jW411d7z7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK411A7Gm?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        h_head = ListNode(-1, head)
        mem = []
        while(head is not None):
            next_h = head.next
            head.next = None
            mem.append(head)
            head = next_h
        mem = sorted(mem, key=lambda x: x.val)
        n = len(mem)
        if n == 0:
            return None
        h_head.next = mem[0]
        for i in range(n-1):
            mem[i].next = mem[i+1]
        
        return h_head.next
```

```py
# py3 归并排序，递归实现。空间复杂度主要在递归栈深度：O( log(n) )，整个递归过程有点像后序遍历

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        mid=self.findmid(head)
        left=head # 指定左右
        right=mid.next # 指定左右
        mid.next=None # 断开链接
        l=self.sortList(left)
        r=self.sortList(right)
        return self.merge(l,r)

    def findmid(self,head):
        slow=head
        fast=head
        while fast.next and fast.next.next:
            slow=slow.next
            fast=fast.next.next
        return slow

    def merge(self,l,r):
        dummy=ListNode(None)
        cur=dummy
        while l and r:
            if l.val<=r.val:
                cur.next=l
                l=l.next # 下一个
            else:
                cur.next=r
                r=r.next # 下一个
            cur=cur.next # 下一个
        cur.next=l or r
        return dummy.next

        # 基本用法：
        # v = p1 or p2

        # 它完成的效果等同于：
        # if p1:
        #     v = p1
        # else:
        #     v = p2
```

###  3.141. <a name='MaxPointsonaLine'></a>149. Max Points on a Line

[花花酱](https://www.bilibili.com/video/BV1zb411u7WW?spm_id_from=333.999.0.0)

###  3.142. <a name='EvaluateReversePolishNotation'></a>150. Evaluate Reverse Polish Notation

[花花酱](https://www.bilibili.com/video/BV14f4y127K8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16B4y1P7Nx?spm_id_from=333.999.0.0)

```py
class Solution:
    def evalRPN(self, tokens):
        f1 = lambda a,b:a+b
        f2 = lambda a,b:a-b
        f3 = lambda a,b:a*b
        f4 = lambda a,b:int(a/b)
        maps = {'+':f1,'-':f2,'*':f3,'/':f4}
        stack = []
        for i in tokens:
            if i in maps:
                a = stack.pop()
                b = stack.pop()
                stack.append(maps[i](b,a))
            else:
                i = int(i)
                stack.append(i)
        return stack[-1]

class Solution:
    def evalRPN(self, tokens):
        stack = []
        for item in tokens:
            if item not in {"+", "-", "*", "/"}:
                stack.append(item)
            else:
                first_num, second_num = stack.pop(), stack.pop()
                stack.append(
                    int(eval(f'{second_num} {item} {first_num}'))   # 第一个出来的在运算符后面
                )
        return int(stack.pop()) # 如果一开始只有一个数，那么会是字符串形式的

class Solution:
    def evalRPN(self, tokens):
        """
        解题思路:数字入栈，算数符号出栈两个数字栈并计算，计算结果入栈
        """
        stack = []
        
        for item in tokens:

            if item not in ['+', '-', '*', '/']:
                stack.append(int(item))
            else:
                a = stack.pop()
                b = stack.pop()
                if item == '+': stack.append(a + b)
                elif item == '-': stack.append(b - a)
                elif item == '*': stack.append(a * b)
                elif item == '/': stack.append(int(b / float(a)))   # 注意如何取整
        return stack[0]
```

###  3.143. <a name='ReverseWordsinaString'></a>151. Reverse Words in a String

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7g4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rT4y1g7AJ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ei4y1V7yA?spm_id_from=333.999.0.0)

###  3.144. <a name='-1'></a>152-乘积最大子数组

[哈哈哈](https://www.bilibili.com/video/BV12a4y1i76G?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iK411K7yG?spm_id_from=333.999.0.0)

```scala

/**
* chosen solution
* dynamic programming
* using dp array to record previous max min value ending at index i-th
*   dp(i)(j) means the maximum and minimum contiguous product ending at i-th position
*   each state i update 
*        1. max(current v,  previous state max value * current value,  previous state min value * current value)
*        2. min(current v,  previous state max value * current value,  previous state min value * current value)
*
*  time complexity: O(N)
*/ 

object Solution0 {
  def maxProduct(nums: Array[Int]): Int = {
    val dp = Array.ofDim[Int](nums.length, 2) // record each position n's max product( from 0 to n)
    var result = nums(0)
    dp(0)(0) = nums(0)
    dp(0)(1) = nums(0)

    /* 0 for min, 1 for max */
    for (i <- 1 until nums.length) {
      val a = dp(i - 1)(0) * nums(i)
      val b = dp(i - 1)(1) * nums(i)
      dp(i)(0) = nums(i) min a min b // record min
      dp(i)(1) = nums(i) max a max b // record max
      result = result max dp(i)(1)
    }
    result
  }
}

/**
* my first commitment
* recursive version : correct but may cause memory exceed limit
* time complexity: O(N^2)
*/
object Solution1 {
  def maxProduct(nums: Array[Int]): Int = {
    (1 to nums.length).map(n =>  _maxProduct(nums(n - 1), nums.takeRight(nums.length - n))).max
  }

  def _maxProduct(curr: Int, nums: Array[Int]): Int = {
      if(nums.isEmpty) return curr          
      curr max  _maxProduct( curr * nums(0), nums.takeRight(nums.length - 1))
  }
}


/**
* optimize above one
* don't copy subArray during transmit parameters
* time complexity： O(N^2)
*/
object Solution1-2 {
  def maxProduct(nums: Array[Int]): Int = {
    (1 to nums.length).map(n =>  _maxProduct(nums(n - 1), n, nums)).max
  }
  def _maxProduct(curr: Int, idx: Int, nums: Array[Int]): Int = {
      if(idx >= nums.length) return curr   
      curr max  _maxProduct( curr * nums(idx), idx + 1, nums)
  }

}

/**
* dynamic programming
* using dp array to record previous max min value ending at index i-th
*   dp(i)(j) means the maximum and minimum contiguous product ending at i-th position
*   each state i update 
*        1. max(current v,  previous state max value * current value,  previous state min value * current value)
*        2. min(current v,  previous state max value * current value,  previous state min value * current value)
*
*  time complexity: O(N)
*  space  complexity: O(2N), actually it can be optimized to O(2) which records previous min and max value
*/
object Solution2 {
    def maxProduct(nums: Array[Int]): Int = {
        // 0:  minimum , 1:  maximum
        val dp = Array.ofDim[Int](nums.length, 2)
        dp(0)(0) = nums(0)
        dp(0)(1) = nums(0)
        
        for(i <- 1 until nums.length) {
            val a = dp(i - 1)(0) * nums(i) 
            val b = dp(i - 1)(1) * nums(i)
            dp(i)(0) = a min b min nums(i)
            dp(i)(1) = a max b max nums(i)
        }
        
        
        dp.map(_(1)).max
    }
}


/**
* dynamic programming
* memo
*   1. only keep previous state 
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution2-1 {
    def maxProduct(nums: Array[Int]): Int = {
        
        val (_, _, ans) = (1 until nums.length).foldLeft((nums.head, nums.head, nums.head)){
            case ((min, max, ans), idx) => 
                val a = nums(idx) * min 
                val b = nums(idx) * max
                val newMin = a min b min nums(idx)
                val newMax = a max b max nums(idx)
                (newMin, newMax, ans max newMax)
        }
        ans
    }
}


/**
* a recursive dp method： not my own 
* memo
*   1. only keep the closest state
* time complexity: O(N)
* space complexity: O(N) although it don;t create a length of nums array, it convert nums array to list
*/
object Solution2-2 {
    def maxProduct(nums: Array[Int]): Int = {
        if (nums == null || nums.size == 0) {
            return 0;
        }
        val list: List[Int] = nums.toList
        val head: Int = list.head
        val tail: List[Int] = list.tail
        _MaxProduct(tail, head, head, head)
    }
    
    def _MaxProduct(nums: List[Int], min: Int, max: Int, result: Int): Int = nums match {
        case Nil => result
        case x :: xs => {
            val cur_min = math.min(x, math.min(x * max, x * min))
            val cur_max = math.max(x, math.max(x * max, x * min))
            _MaxProduct(xs, cur_min, cur_max, math.max(cur_max, result))
        }
    }
}
```

###  3.145. <a name='-1'></a>153-寻找旋转排序数组中的最小值

[哈哈哈](https://www.bilibili.com/video/BV1bT4y1w7yK?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1yK411L7rp?spm_id_from=333.999.0.0)

```scala

/**
* my first commitment binary search
*/
object Solution1 {
    def findMin(nums: Array[Int]): Int = {
        search(nums, 0, nums.length - 1)
    }
  
    def search(nums: Array[Int], left: Int, right: Int): Int = {
      if (left > right) return nums(left)
      val mid = left + (right - left) / 2
      val leftAns = if (nums(mid) >= nums(left)){ // left part in order
        nums(left)
      } else {
        search(nums, left, mid - 1)
      }
      
      val rightAns = if (nums(mid) <= nums(right)) { // right part in order
        nums(mid)
      } else {
        search(nums, mid + 1, right)
      }
      
      leftAns min rightAns
    }
}
```

###  3.146. <a name='FindMinimuminRotatedSortedArr'></a>154 Find Minimum in Rotated Sorted Arr

[小明](https://www.bilibili.com/video/BV1ik4y1B7de?spm_id_from=333.999.0.0)

###  3.147. <a name='MinStack'></a>155-Min Stack

[哈哈哈](https://www.bilibili.com/video/BV1H74118748?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1r77W?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ja4y1Y7vY?spm_id_from=333.999.0.0)


```scala
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var min = Int.MaxValue

    def push(x: Int) {
        stack = stack :+ x
        if(x < min){
            min = x
        }
    }

    def pop() {
        stack = stack.init
        min = Int.MaxValue
        stack.map(x => {
            if(x < min) min = x
        })
    }

    def top(): Int = {
        stack.last
    }

    def getMin(): Int = {
        min
    }

}

//Alternate solution: much faster
//Here we are prepending elements to the list instead of appending
//Note that since List is actually a LinkedList its much easier to deal with "head" of the list
//There is also another list to maintain min elements of the list
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var mins = List.empty[Int]

    def push(x: Int) {
        //this line fails if we make second condition as x < mins.head
        //with NoSuchElementException: head of empty list
        //why???
        if(mins.isEmpty || mins.head >= x) mins = x +: mins
        stack = x +: stack
    }

    def pop() {
        if(mins.head == stack.head) mins = mins.tail
        stack = stack.tail
    }

    def top(): Int = {
        stack.head
    }

    def getMin(): Int = {
        mins.head
    }

}

```

###  3.148. <a name='IntersectionofTwoLinkedLists'></a>160-Intersection of Two Linked Lists

[哈哈哈](https://www.bilibili.com/video/BV1n741187X6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411H7uq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K4y1J7wx?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1np4y1y789?spm_id_from=333.999.0.0)

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {
        if(headA == null){
            null
        }else if(headB == null){
            null
        }else{
            var ha = headA
        var hb = headB
        
        var hAsize = 0
        var hBsize = 0
        while(ha.next != null){
            hAsize += 1
            ha = ha.next
        }
        while(hb.next != null){
            hBsize += 1
            hb = hb.next
        }
        
        var first: ListNode = null
        var second: ListNode = null
        var diff = 0
        
        if(hAsize>hBsize){
            first = headA
            second = headB
            diff=hAsize-hBsize
        }else{
            first = headB
            second = headA
            diff=hBsize-hAsize
        }
        
        while(diff > 0){
            first = first.next
            diff -= 1
        }
        
        var result: ListNode = null
        import scala.util.control.Breaks._
        breakable{
        while(first!= null && second!= null){
            if(first == second){
                result = first
                break
            }
            first = first.next
            second = second.next
        }
        }
        
        result
        }
    }
}

//Alternate solution

/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {
        var ha = headA
        var hb = headB
        
        while(ha != hb){
            if(ha == null){
                ha = headB
            }else{
                ha = ha.next
            }
            
            if(hb == null){
                hb = headA
            }else{
                hb = hb.next
            }
        }
        
        ha
    }
}

```

###  3.149. <a name='FindPeakElement'></a>162. Find Peak Element

[小梦想家](https://www.bilibili.com/video/BV1Rb411n7dT?spm_id_from=333.999.0.0)

###  3.150. <a name='CompareVersionNumbers'></a>165. Compare Version Numbers

[小梦想家](https://www.bilibili.com/video/BV19K4y1C7L3?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pk4y117dF?spm_id_from=333.999.0.0)

###  3.151. <a name='FractiontoRecurringDecimal'></a>166. Fraction to Recurring Decimal

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7PE?spm_id_from=333.999.0.0)

###  3.152. <a name='TwoSumII-Inputarrayissorted'></a>167-Two Sum II - Input array is sorted

[哈哈哈](https://www.bilibili.com/video/BV167411h7ou?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7id?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1VZ4y1M7eu?spm_id_from=333.999.0.0)

###  3.153. <a name='ExcelSheetColumnTitle'></a>168-Excel Sheet Column Title

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7FY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H777?spm_id_from=333.999.0.0)

###  3.154. <a name='MajorityElement'></a>169. Majority Element

[花花酱](https://www.bilibili.com/video/BV1hb411c7bF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7pW?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ff4y1U7Vn?spm_id_from=333.999.0.0)

```scala

/**
* chosen solution
*
* Boyer-Moore Voting Algorithm
* time complexity N(N)
* space complexity O(1)
*/
object Solution {
    def majorityElement(nums: Array[Int]): Int = {
      var counter = 1
      var candidate = nums(0)
      for (idx <- 1 until nums.length) {
        val value = nums(idx)
        if(candidate == value)
          counter += 1
        else {
          if(counter == 1)
            candidate = value
          else
            counter -= 1
        }
      }
      candidate
    }
}


/**
* Boyer-Moore Voting Algorithm
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1 {
  def majorityElement(nums: Array[Int]): Int = {
    var num = nums(0)
    var counter = 0
    nums.foreach { n =>
      if (num == n) {
        counter += 1
      } else {
        counter -= 1
        if (counter == 0) {
          num = n
          counter += 1
        }
      }
    }
    num
  }
}

/**
* immutable during iteration
*/
object Solution1-2 {
    def majorityElement(nums: Array[Int]): Int = {
       val (ans, accumulate) = (1 until nums.length).foldLeft((nums.head, 1)) {
            case ((cur, acc), idx) =>
                val incoming = nums(idx)
                if(incoming == cur) (cur, acc + 1)
                else {
                    if(acc == 1) (incoming, 1)
                    else (cur, acc - 1)
                }
        }
        ans
    }
}

/**
* HashMap
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution2 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.groupBy(identity).mapValues(_.length).maxBy(_._2)._1  
    }
}


/**
* sorting array and pick middle element
* time complexity O(NlogN)
*/

object Solution3 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.sorted(Ordering.Int)(nums.length / 2)
    }
}


```

```scala
object Solution {
    def majorityElement(nums: Array[Int]): Int = {
        var map = scala.collection.mutable.Map.empty[Int, Int]
        for(elem <- nums){
            map.get(elem) match{
                case Some(count) => map += (elem -> (count+1))
                case None => map += (elem -> 1)
            }
        }
        
        map.toList.filter(_._2 > (nums.size / 2)).head._1
    }
}

//Alternate solution O(n) but NO EXTRA SPACE
object Solution {
    def majorityElement(nums: Array[Int]): Int = {     
        var current = nums.head
        var count = 0
        nums.foreach(num => {
            if(count == 0) { 
                current = num
                count = 0
            }
            if(num == current) count+=1;
            else count-=1;
        })
        
        current
    }
}

```

###  3.155. <a name='ExcelSheetColumnNumber'></a>171. Excel Sheet Column Number

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7nT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1h541187Sv?spm_id_from=333.999.0.0)

```scala
object Solution {
    def titleToNumber(s: String): Int = {
        var size = s.size
        var i = 0
        var sheetNumber = 0
        while(i < size){
            var sum = (s.charAt(i) - 'A' + 1) * Math.pow(26, (size - i-1)).toInt
            
            sheetNumber += sum
            i += 1
        }
        sheetNumber
    }
}


//Alternate solution
object Solution {
    def titleToNumber(s: String): Int = 
        s.foldLeft(0)((acc, ch) => acc * 26 + (ch - 'A' + 1))
}

```

###  3.156. <a name='FactorialTrailingZeroes'></a>172-Factorial Trailing Zeroes

[哈哈哈](https://www.bilibili.com/video/BV1hE411n7TM?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7tS?spm_id_from=333.999.0.0)

```scala
object Solution {
    def trailingZeroes(n: Int): Int = {
        var count5 = 0
        var count2 = 0
        
        var temp = n
        while(temp>=5){
            count5 += temp/5
            temp = temp/5
        }
        
        temp = n
        while(temp>=2){
            count2 += temp/2
            temp = temp/2
        }
        
        if(count5 < count2) count5 else count2
    }
}

```

###  3.157. <a name='BinarySearchTreeIterator'></a>173 Binary Search Tree Iterator

[小明](https://www.bilibili.com/video/BV1qK41137h1?spm_id_from=333.999.0.0)

###  3.158. <a name='DungeonGame'></a>174 Dungeon Game

[小明](https://www.bilibili.com/video/BV1TK411W7T1?spm_id_from=333.999.0.0)

###  3.159. <a name='LargestNumber'></a>179 Largest Number

[小明](https://www.bilibili.com/video/BV1mV411m7aN?spm_id_from=333.999.0.0)

###  3.160. <a name='ReverseWordsinaStringII'></a>186. Reverse Words in a String II 

[哈哈哈](https://www.bilibili.com/video/BV1GV411Z7fo?spm_id_from=333.999.0.0)

###  3.161. <a name='RepeatedDNASequences'></a>187 Repeated DNA Sequences

[小明](https://www.bilibili.com/video/BV1mp4y1r7v5?spm_id_from=333.999.0.0)

###  3.162. <a name='BestTimetoBuyandSellStockIV'></a>188 Best Time to Buy and Sell Stock IV

[小明](https://www.bilibili.com/video/BV1f54y1k7cX?spm_id_from=333.999.0.0)

```scala
/**
* chosen solution
* dynamic programming
* memo 
*    1: using an 3-dim array to record previous state
*     dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's restrictions
*  space complexity: O(K),  worst case: O(N)N
*/ 
object Solution0 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
/**
* my first commitment
* dynamic programming
* memo 
*    1: using an 3-dim array to record all previous state
*         dp[state index][k times transaction][buy or sell]
*     dp definition: dp[i][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's constraint
*/
object Solution1 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum
    val profits = Array.ofDim[Int](prices.length, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val ii = (i + prices.length - 1) % prices.length
      profits(i)(j)(1) = profits(ii)(j)(1)  max ( profits(ii)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(i)(j)(0) = profits(ii)(j)(0)  max ( profits(ii)(j - 1)(1) - prices(i)) // buy
      else
        profits(i)(j)(0) = profits(ii)(j)(0)  max  - prices(i) // buy
    }

    profits(prices.length - 1).map(_.max).max
  }
}

/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/

object Solution1-2 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum


    val profits = Array.ofDim[Int](2, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val currentI = (i + 1) % 2
      val preciousI = i % 2
      profits(currentI)(j)(1) = profits(preciousI)(j)(1)  max ( profits(preciousI)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max ( profits(preciousI)(j - 1)(1) - prices(i)) // buy
      else
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max  - prices(i) // buy
    }
    profits(prices.length % 2).map(_.max).max // prices.length % 2: decide the newest status index
  }

  private def debugProfits(profits: Array[Array[Array[Int]]]): Unit = {
        profits.zipWithIndex.foreach{
          case (p, i) =>
            println(s"status: $i")
            p.zipWithIndex.foreach{
            case (pp, j) =>
                println(s"transaction $j: hold: ${pp(0)}, sell: ${pp(1)}")
          }
            println(" ")
        }
  }
}
/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/
object Solution1-3 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
```

###  3.163. <a name='RotateArray'></a>189. Rotate Array 

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Yy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N541177Bk?spm_id_from=333.999.0.0)

###  3.164. <a name='ReverseBits'></a>190. Reverse Bits

[花花酱](https://www.bilibili.com/video/BV1NJ411k7VP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qv411i7Wg?spm_id_from=333.999.0.0)

```scala
object Solution {
    // you need treat n as an unsigned value
    def reverseBits(x: Int): Int = {
        var binaryString = x.toBinaryString.toList
        
        var additional = (1 to (32 - binaryString.length)).map(_ => '0').toList
        
        binaryString = additional ++ binaryString
        
        val reversed = reverseBinary(binaryString, "")
        
        Integer.parseUnsignedInt(reversed.mkString, 2)
    }
    
    def reverseBinary(x: List[Char], str: String): String = x match{
        case Nil => str
        case x::xs => reverseBinary(xs, x + str)
    }
}

```

###  3.165. <a name='Numberof1Bits'></a>191 Number of 1 Bits

[小明](https://www.bilibili.com/video/BV1i5411J7SA?spm_id_from=333.999.0.0)

```scala
/**
* chosen solution
* bit operation - recursive version
* time complexity: O(1)
*/
object Solution0{
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        _hammingWeight(n, 0)
    }
    
    @annotation.tailrec
    def _hammingWeight(n: Int, counter: Int): Int = {
        if(n  == 0) counter
        else _hammingWeight(n & (n - 1), counter + 1 )
    }
}

/**
* my first commitment
* time complexity: fixed size: 32 bits, so O(1)
*/
object Solution0 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {

        var mask = 1
        var counter = 0
        for (_ <- 0 to 32) {

            if ((n & mask) != 0) {
                counter += 1
            }
            mask  = mask << 1
        }
        counter
    }
}


/**
* bit operation - iterative version
* memo
*    1. using bit operation :  x = x & (x -1)  to set the last non zero pos to zero
*
*/
object Solution1 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {

        var nn = n
        var counter = 0
        while(nn != 0) {
            counter += 1
            nn = nn & (nn -1)
        }
        
        counter
    }
}

/**
* bit operation - recursive version
*/
object Solution1-2 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        _hammingWeight(n, 0)
    }
    
    @annotation.tailrec
    def _hammingWeight(n: Int, counter: Int): Int = {
        if(n  == 0) counter
        else _hammingWeight(n & (n - 1), counter + 1 )
    }
}

```

```scala
object Solution {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        n.toBinaryString.toCharArray.filter(_ == '1').length
    }
}

//Alternate bit-wise shift and count 1
def hammingWeight(n: Int): Int = {
        var count = 0
        var num   = n

        while (num != 0) {
            if ((num & 1) > 0) { count = count + 1 }
            num = num >>> 1
        }
    count
}

//Alternate (need to understand whats happening here) AND of num, num-1
// num & num-1 returns the last SET bit
def hammingWeight(n: Int): Int = {
        println(n)
        var sum = 0
        var num = n         
        while (num != 0) {
            sum += 1
            num &= (num-1)                
        }
        sum
    }

```

###  3.166. <a name='HouseRobber198-'></a>198. House Robber 198-打家劫舍

[12:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1tW411676f?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1u64y1M7PA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7hu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gZ4y1N75c?spm_id_from=333.999.0.0)、

[官方](https://www.bilibili.com/video/BV18g4y1i7f9?spm_id_from=333.999.0.0)

```scala
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else if(nums.length == 1){
            nums(0)
        }else if(nums.length == 2){
            Math.max(nums(0), nums(1))
        }else{
            Math.max(
                nums(0) + rob(nums.drop(2)),
                nums(1) + rob(nums.drop(3))
            )
        }
    }
}

//The above solution worked for small input arrays
//but had MEMORY LIMIT EXCEEDED for large input

//While using DP: we try to store values of repetitive calculations
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var dp = Array.fill(nums.length+1)(0)
            
            dp(0) = 0
            dp(1) = nums(0)
            (1 to nums.length-1).map(i => {
                dp(i+1) = Math.max(dp(i), dp(i-1) + nums(i))
            })
            
            dp(nums.length)
        }
    }
}

//Another way to do the same
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.isEmpty){
            0
        }else{
            var rob = nums(0)
            var no_rob = 0
            var prev = rob
            for(i <- 1 until nums.length){
                prev = rob
                rob = no_rob + nums(i)
                no_rob = Math.max(prev, no_rob)
                
            }
            Math.max(no_rob, rob)
        }
    }
}

```

###  3.167. <a name='BinaryTreeRightSideView'></a>199 Binary Tree Right Side View

[小明](https://www.bilibili.com/video/BV1854y1W7CB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xK4y1b7Wh?spm_id_from=333.999.0.0)

###  3.168. <a name='-1'></a>200-岛屿数量

[哈哈哈](https://www.bilibili.com/video/BV15K411p72j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Cg4y1i7dZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1KK4y1U7Ds?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1E64y1T7Nk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Np4y1977S?spm_id_from=333.999.0.0)

```scala
/**
* chosen solution
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/

object Solution0 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}


/**
* my first commit
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/
object Solution1 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}

/**
* Union & Find 
* memo
*    1. without modify original grid's elements
* time complexity: O(N * M) both N M is the dimension of grid 
*     both union and find operation's amortized time complexity in UnionFind class are very very close to 1 but not 1
*/

/**
* weighted quick-union with path compression
* all operation's amortized time complexity are very very close to 1
*/
class UnionFind(grid: Array[Array[Char]]) {
  private val n = grid.length
  private val m = grid(0).length
  private val roots = Array.tabulate(n * m){i => i}
  private val rank = Array.fill[Int](n * m)(1)
  var counter = (for(i <- 0 until n; j <- 0 until m ; if grid(i)(j) == '1' ) yield(i, j)).size

  def findRoot(coord: (Int, Int)): Int = {
    var idx = coord._2 + coord._1 * m
    var root = idx

    while(root != roots(root)) {
      root = roots(root)
    }
    /** path compression */
    while(idx != roots(idx)) {
      val tmp = roots(idx)
      roots(idx) = root
      idx = tmp
    }
    root
  }

  def isConnected(coordA: (Int, Int), coordB: (Int, Int)): Boolean = {
    findRoot(coordA) == findRoot(coordB)
  }
  def union(coordA: (Int, Int), coordB: (Int, Int)): Unit = {
    val findA  = findRoot(coordA)
    val findB = findRoot(coordB)
    if(findA == findB) return

    if(rank(findA) > rank(findB)) {
      roots(findB) = findA
    }else if(rank(findA) < rank(findB)) {
      roots(findA) = findB
    }else {
      roots(findA) = findB
      rank(findB) += 1
    }
    counter -= 1
  }

}

object Solution2 {
  private val endLabel = '0'
  def numIslands(grid: Array[Array[Char]]): Int = {
    val unionFind = new UnionFind(grid)
    for(i <- grid.indices; j <- grid(0).indices)
      union((i, j), unionFind, grid)
    unionFind.counter

  }

  def union(coord: (Int, Int), unionFind: UnionFind, grid: Array[Array[Char]]): Unit = {
    val (row, col) = coord
    if(grid(row)(col) == endLabel) return

    neighbors(coord, (grid.length, grid(0).length)).foreach {
      case (nr, nc) if grid(nr)(nc) != endLabel  =>
        unionFind.union(coord, (nr, nc))
      case _ =>
    }
  }

  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{ case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

```scala
package com.zhourui.leetcode


// 思路 
package lc0200_numberofisland {
  object Solution {
    def numIslands(grid: Array[Array[Char]]): Int = {
      if(grid.isEmpty || grid(0).isEmpty){
        return 0
      }
      val m = grid.size
      val n = grid(0).size;

      //val dp:Array[Array[Int]];//vector<vector<int>> dp(m,std::vector<int>(n));
      //val dp = Array.ofDim[Int](m,n)
      val dp = Array.fill(m,n)(0)

      var count=0;
      for (i<-0 until m) {
        for (j<-0 until n) {
          if (dp(i)(j)==0) {
            if (bfs(grid,dp,(i,j)))
              count +=1;
          }
        }
      }
      count;
    }

    def bfs(grid:Array[Array[Char]], dp:Array[Array[Int]],pos:(Int,Int)):Boolean = {
      val m = grid.length
      val n = grid(0).length
      if (pos._1>=m || pos._2>=n || pos._1<0 || pos._2<0) {
        return false
      }
      if (dp(pos._1)(pos._2) == 1) {
        false
      } else if (dp(pos._1)(pos._2) == 0 && grid(pos._1)(pos._2) == '1') {
        dp(pos._1)(pos._2) = 1
        // right
        bfs(grid, dp, (pos._1, pos._2 + 1))
        // down
        bfs(grid, dp, (pos._1 + 1, pos._2))
        // up
        bfs(grid, dp, (pos._1 - 1, pos._2))
        // left
        bfs(grid, dp, (pos._1, pos._2 - 1))
        true;
      } else {
        false
      }
    }
  }
}

```

###  3.169. <a name='BitwiseANDofNumbersRange'></a>201 Bitwise AND of Numbers Range

[小明](https://www.bilibili.com/video/BV1dT4y1g75m?spm_id_from=333.999.0.0)

```scala
package com.zhourui.leetcode

//看题感觉需要对所有的[m,n]范围内的数字进行遍历一遍吧。。其实不需要的。
//
//我们知道，数组的数字是连续的，那么m,n范围内的二进制表示的末尾相同位置一定会出现不同的0,1.我们只要找出m,n的做左边起的最长相同的二进制头部即可呀。
//
//如[5, 7]里共有三个数字，分别写出它们的二进制为：
//
//101　　110　　111
//
//相与后的结果为100，仔细观察我们可以得出，最后的数是该数字范围内所有的数的左边共同的部分（即m,n左边的共同部分），如果上面那个例子不太明显，我们再来看一个范围[26, 30]，它们的二进制如下：
//
//11010　　11011　　11100　　11101　　11110
//
//也是前两位是11，后面3位在不同数字中一定会出现0和1、相与即为0了。
//————————————————
//版权声明：本文为CSDN博主「负雪明烛」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
//原文链接：https://blog.csdn.net/fuxuemingzhu/article/details/79495633

class lc201_bitwiseand {
  object Solution {
    def rangeBitwiseAnd(m: Int, n: Int): Int = {
      var count = 0
      var m1 = m
      var n1 = n
      while (m1!=n1) {
        m1 >>= 1
        n1 >>=1
        count+=1
      }
      m1<<count
    }
  }
}

```

###  3.170. <a name='HappyNumber'></a>202. 快乐数 Happy Number

[官方](https://www.bilibili.com/video/BV1Ca4y1v7Qr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CA41187LQ?spm_id_from=333.999.0.0)

```scala
object Solution {
    
    def getDigitSquaresSum(num: Int) = {
        num.toString.map(_.asDigit).map(x => x*x).foldLeft(0)(_ + _)
    }
    
    def isHappy(n: Int): Boolean = {
        var num = n
        var set = scala.collection.mutable.HashSet.empty[Int]
        var flag = true
        while(flag){
            if(num == 1){
                flag = false
            }else if(set.contains(num)){
                flag = false
            }else{
                set.add(num)
                num = getDigitSquaresSum(num)
            }
        }
        
        num == 1
    }
}

```

```scala
package com.zhourui.leetcode

package lc0202_happynumber {
  object Solution {
    def isHappy(n: Int): Boolean = {
      def next(x:Int): Int ={
        x.toString().map(e=> (e-'0')*(e-'0')).sum
      }

      def solve(x:Int, m:Set[Int]): Boolean = x match {
        case 1 => return true
        case x if m.contains(x) =>return false
        case x =>solve(next(x), m+x)
      }
      solve(n, Set[Int]())
    }
  }
}

```

###  3.171. <a name='RemoveLinkedListElements'></a>203. Remove Linked List Elements

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7bf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Yi4y137WA?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Sz411b7zw?spm_id_from=333.999.0.0)

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//Remove all elements from a linked list of integers that have value val.
//
//Example:
//
//Input:  1->2->6->3->4->5->6, val = 6
//Output: 1->2->3->4->5

package lc203_remove_linkedlist_element {
  /**
   * Definition for singly-linked list.
   * class ListNode(var _x: Int = 0) {
   *   var next: ListNode = null
   *   var x: Int = _x
   * }
   */
  object Solution {
    def removeElements(head: ListNode, `val`: Int): ListNode = {
      val dummy = ListNode(0)
      dummy.next = head
      var prev = dummy
      var cur = head
      while (cur!=null) {
        if (cur.x != `val`) {
          prev.next = cur
          prev = cur
        } else {
          prev.next = null
        }
        cur = cur.next
      }
      dummy.next
    }
  }
}

```

###  3.172. <a name='CountPrimes'></a>204-Count Primes

[哈哈哈](https://www.bilibili.com/video/BV167411w7Sf?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7cV?spm_id_from=333.999.0.0)

```scala
object Solution {
    def countPrimes(n: Int): Int = {
        
        //Sieve of Eratosthenes
        
        var primeArray = Array.fill(n)(false)
        (2 until n).map(i => primeArray(i) = true)
        
        //We need to check for all numbers i, where i < sqrt(n)
        //To avoid doing sqrt operation again & again (since its expensive)
        //We can do i*i < n
        
        var i =2
        while(i*i < n){
            if(primeArray(i)){
                var j = i*i
                while(j < n){
                    primeArray(j) = false
                    j += i //because we are only checking multiple of i for each i in iteration
                }
            }
            i+=1
        }
        
        primeArray.filter(x => x).length
    }
}

```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def reverseList(head: ListNode): ListNode = {
        if(head == null || head.next == null){
            head
        } else{
            var p = reverseList(head.next)
            head.next.next = head
            head.next = null
            p
        }
    }
}

```

###  3.173. <a name='isomorphicstrings'></a>205. isomorphic strings

[小梦想家](https://www.bilibili.com/video/BV1ab411H7ZS?spm_id_from=333.999.0.0)

```scala
package com.zhourui.leetcode

import scala.collection.mutable._

package lc205_lsomorphic {
  object Solution {
    def isIsomorphic(s: String, t: String): Boolean = {
      val m:HashMap[Char,Char] = HashMap[Char,Char]()
      val n:HashMap[Char,Char] = HashMap[Char,Char]()

      s.indices.foreach(
        idx=>idx match {
          case idx if m.contains(s(idx)) && m(s(idx))!=t(idx) => return false
          case idx if n.contains(t(idx)) && n(t(idx))!=s(idx) => return false
          case idx =>{
            m(s(idx))=t(idx)
            n(t(idx))=s(idx)
          }
        }
      )
      true
    }
  }
}

/*
unordered_map<char,char> m;
unordered_map<char,char> n;

for (int i=0;i<s.length();i++) {
    if (m.count(s[i])) {
        if (m[s[i]]!=t[i]) return false;
    } else if (n.count(t[i])) {
        if (n[t[i]]!=s[i]) return false;
    } else {
        m[s[i]]=t[i];
        n[t[i]]=s[i];
    }
}
return true;

 */
```

###  3.174. <a name='ReverseLinkedList'></a>206-Reverse Linked List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7zr?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV16Q4y1M767?spm_id_from=333.999.0.0)

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
/**
* chosen solution - iterative version
* time complexity: O(n)
* space complexity: O(1) 
*/
object Solution0 {
    def reverseList(head: ListNode): ListNode = {        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        prev
    }
}

 /**
 * iterative version
 * time complexity: O(n)
 * space complexity: O(1)
 */
object Solution1 {
    def reverseList(head: ListNode): ListNode = {
        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        // printNode(curr)
        prev
    }
    
    def printNode(node: ListNode) {
        var n = node
        while(n != null) {
            print(s"${n.x} ")
            n = n.next
        }
    }
}


/** recursive version */

object Solution2 {
    def reverseList(head: ListNode): ListNode = {
        
        val curr:ListNode = null
        
        _reverseList(curr, head)
        
    }
    
    @annotation.tailrec
    def _reverseList(curr: ListNode, next: ListNode): ListNode = {
        if(next == null) {
            curr
        }else{
            val tmpNode = next.next
            next.next = curr
            _reverseList(next, tmpNode)
        }
    }
}

object Solution2-1 {
    def reverseList(head: ListNode): ListNode = {
        if(head == null) head
        else _reverseList(head)
        
    }
    
    def _reverseList(node: ListNode): ListNode = {
        if (node == null || node.next == null) {
            node
        }else {
            val newHead = _reverseList(node.next)
              // reversedHead 是返回原本的尾巴，若一開始輸入是 1 -> 2 -> 3 -> 4 -> 5  -> null , 那 reversedHead 就是 5
            // 每次 iteration 返回都是同一個 reversedHead 也就是 5
            node.next.next = node
            node.next = null
             // 每次迭代 改變的就是送進每個 function 的 listnode 的 next 與 next.next 指向
            newHead
        }
        
        
    }
}
/**
stdout:
    5 4 
    5 4 3 
    5 4 3 2 
    5 4 3 2 1 
*/

/**
The recursive version is slightly trickier and the key is to work backwards.
Assume that the rest of the list had already been reversed, now how do I reverse the front part?
Let's assume the list is: n1 → … → nk-1 → nk → nk+1 → … → nm → Ø

Assume from node nk+1 to nm had been reversed and you are at node nk.

n1 → … → nk-1 → nk → nk+1 ← … ← nm

We want nk+1’s next node to point to nk.

So,
nk.next.next = nk;

Be very careful that n1's next must point to Ø.
If you forget about this, your linked list has a cycle in it.
This bug could be caught if you test your code with a linked list of size
*/
```

###  3.175. <a name='-1'></a>207-课程表

[花花酱](https://www.bilibili.com/video/BV1Ut411a74a?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV19k4y1r76s?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jz411B7UJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xp4y1Y7FJ?spm_id_from=333.999.0.0)

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

// new and apply
// Use the new keyword when you want to refer to a class's own constructor:
// 解法是 每个node(node)，1.它依赖的node个数(parent) 2.统计依赖它的node个数(son)，
// 一个node没有依赖其它节点，放入zeroInDegree
// 对zeroIndegree的node遍历，对每个依赖它的node都可以直接除去依赖

package lc207_course_schedule {

  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum == numCourses
    }
  }

  class Test extends BaseExtension {
    def init {
      val input = Array(Array(0,1),Array(1,2))
      println(Solution.canFinish(3,input) == true)
      //println(lru.get(1) == 1)
    }

    val name = "207 course schedule"
  }
}

```

###  3.176. <a name='ImplementTriePrefixTree'></a>208. Implement Trie (Prefix Tree)

[花花酱](https://www.bilibili.com/video/BV1Ut411a74P?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zz4y1R7j8?spm_id_from=333.999.0.0)

```scala
/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

/**
* chosen solution
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie0() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}



/**
* my first commitment
*/
case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
}

class Trie1() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach { c =>

      val cIdx = c.asDigit - 'a'.asDigit
      if (node.childNode(cIdx) == null) {
        node.childNode(cIdx) = Node()
      }
      node = node(cIdx)
    }
    node.isWord = true

  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    val node = searchUtil(word)

    node != null && node.isWord

  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix) != null
  }


   private def searchUtil(s: String): Node = {
    var node = root
    var continue = true
    for {
      c <- s
      if continue
    } {
      val cIdx = c.asDigit - 'a'.asDigit
      if (node(cIdx) == null) {
        continue = false
      } 
      node = node(cIdx)
    }
    node
  }
}


/**
*  more elegant
*  Node with apply and update
*/

case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
  
  def update(idx: Int, node: Node): Unit = {
    childNode(idx) = node
  }

  def update(c: Char, node: Node): Unit = {
    this.update(c.asDigit - 'a'.asDigit, node)
  }
}
class Trie1-2() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach {
      case c if node(c) == null => 
        node(c) = Node()
        node = node(c)

      case c => node = node(c)
    }
    node.isWord = true
      
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }


  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach {
      case c if node(c) != null => node = node(c)
      case _ => return None
    }
    Some(node)
  }
  def traversal(): Unit = {
    val result = scala.collection.mutable.ListBuffer[String]()

    def _traversal(prefix: String, node: Node): Unit = {
      if (node.isWord) {
        result += prefix
      }
      node.childNode.zipWithIndex.foreach {
        case (n, idx) if n != null => _traversal(prefix + ('a' + idx).toChar, n)
        case _ =>
      }

    }

    _traversal("", root)
    result.foreach(s => println(s.mkString("")))

  }

}

/**
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie2() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}
```

###  3.177. <a name='-1'></a>209-长度最小的子数组

[哈哈哈](https://www.bilibili.com/video/BV1JZ4y1N7Rt?spm_id_from=333.999.0.0)

###  3.178. <a name='CourseScheduleII210-II'></a>210. Course Schedule II 210-课程表II

[花花酱](https://www.bilibili.com/video/BV1gW411y7Kb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ja4y147on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qt4y1X7oC?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kK411W7rL?spm_id_from=333.999.0.0)

```scala
package com.zhourui.leetcode

import scala.collection.mutable.ArrayBuffer
// 与lc207类似，不过要给出顺序

class lc210_courseschedule2 {
  object Solution {
    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      val ans = ArrayBuffer[Int]()
      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        ans += cur
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum match {
        case canFinshNum if canFinshNum == numCourses => ans.toArray
        case _ => Array()
      }
    }
  }
}

```

###  3.179. <a name='AddandSearchWord'></a>211 Add and Search Word

[小明](https://www.bilibili.com/video/BV1x5411a77S?spm_id_from=333.999.0.0)

###  3.180. <a name='WordSearchII'></a>212. Word Search II

[花花酱](https://www.bilibili.com/video/BV184411d7i9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1G7NQ?spm_id_from=333.999.0.0)

```scala

/**
* chosen solution
* tries + dfs + pruning
* memo
*   1. put all words into tries which is implemented by hashmap
*   2. DFS way searching all char in board composing a word and searching whether the word exists in tries
*   3. in dfs, we directly input the node from tries instead of tries itself 
*   4. pruning an edge after matching a word and its children couldn't represent a word
*/
import scala.collection.mutable
case class Node(next: mutable.Map[Char, Node] = mutable.Map.empty, var isWord: Boolean = false){
  def apply(char: Char): Option[Node] = next.get(char)
  def update(char: Char, node: Node): Unit = next(char) = node
}

class Tries(){
  val root = Node()
  def insert(word: String): Unit = {
    var node = root
    word.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined
  def search(word: String): Boolean =  searchUtil(word).exists(_.isWord)

  def searchUtil(s: String): Option[Node] = {
    var node = root
    s.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }
}


object Solution0 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
* tries + dfs + pruning
* memo
*   1. a seenBoard to record which position was visited 
* time complexity: 
* 
*/

object Solution1-1 {
  val result = scala.collection.mutable.Set[String]()

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for{
      row <- board.indices
      col <- board(0).indices
    }{
      _dfs(board, Array.ofDim[Boolean](board.length, board(0).length), tries, "", (row, col))
    }

    result.toList
  }

  private def _dfs(board: Array[Array[Char]], seenBoard:Array[Array[Boolean]], tries: Trie, currentPrefix: String, currentIdx: (Int, Int)) {
    val (row, col) = currentIdx
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    if(tries.startsWith(newPrefix)){
      seenBoard(row)(col) = true
      getNextPosition(currentIdx, seenBoard).foreach{idx =>
        _dfs(board, seenBoard.map(_.clone()), tries, newPrefix, idx)
      }
    }
  }

  private def getNextPosition(currentIdx: (Int, Int), seenBoard: Array[Array[Boolean]]): Array[(Int, Int)] = {

    def check(row: Int, col: Int): Boolean = {
      if(row >= seenBoard.length || row < 0 || col >= seenBoard(0).length || col < 0 || seenBoard(row)(col))  false
      else true
    }
    val (row, col) = currentIdx
    val result = scala.collection.mutable.ArrayBuffer[(Int, Int)]()

    for{
      i <- -1 to 1
      j <- -1 to 1
    }{
      if((math.abs(i) + math.abs(j) == 1) && check(row + i, col + j)) result.append((row + i, col + j))
    }
    result.toArray
  }
}

/**
* simplify : without seen matrix
*/

object Solution1-2 {

  val result = scala.collection.mutable.Set[String]()
  private val inBounds = (shape: (Int, Int)) => (coord: (Int, Int)) => coord._1 < shape._1 && coord._1 >= 0 && coord._2 < shape._2 && coord._2 >= 0
  private val getNeighbors = (coord: (Int, Int), filter: ((Int, Int)) => Boolean) => {
    List(
      (coord._1 + 1, coord._2),
      (coord._1, coord._2 + 1),
      (coord._1 - 1, coord._2),
      (coord._1, coord._2 - 1)
    ).filter(filter)
  }

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for {
      row <- board.indices
      col <- board(0).indices
    } {
      _dfs(board, tries, "", (row, col))
    }
    result.toList
  }

  private def _dfs(board: Array[Array[Char]], tries: Trie, currentPrefix: String, coord: (Int, Int)) {

    val (row, col) = coord
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    val c = board(row)(col)
    board(row)(col) = '#'
    if (tries.startsWith(newPrefix)) {

      getNeighbors(coord, inBounds((board.length, board.head.length))(_))
        .foreach {
          case (nr, nc) if board(nr)(nc) != '#' =>
            _dfs(board, tries, newPrefix, (nr, nc))
          case _ =>
        }
    }
    board(row)(col) = c
  }
}


object Solution1-3 {
  private val visitedLabel = '#'
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Trie()
    words.foreach(tries.insert)
    dfs(tries, board)
  }


  def dfs(tries: Trie, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int) ,prePrefix: String, board: Array[Array[Char]], ret: scala.collection.mutable.HashSet[String]): Unit = {
      val currentChar =  board(coord._1)(coord._2)
      val newPrefix = prePrefix + currentChar
      if(tries.search(newPrefix)) ret += newPrefix
      /* pruning */
      if(tries.startsWith(newPrefix)){
        board(coord._1)(coord._2) = visitedLabel
        getAvailableCoords(coord, (board.length, board(0).length)).foreach {
          case (r, c) if board(r)(c) != visitedLabel => _dfs((r, c), newPrefix, board, ret)
          case _ =>
        }
        board(coord._1)(coord._2) = currentChar
      }
    }

    val coords = for(i <- board.indices; j <- board(0).indices) yield (i, j)
    val ret = scala.collection.mutable.HashSet[String]()
    coords.foreach(coord => _dfs(coord, "", board, ret))
    ret.toList

  }

  private val getAvailableCoords = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row, col + 1),
      (row - 1, col),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 &&  0 <= c && c < shape._2}
  }
}


/** helper class **/
case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {
  def apply(c: Char): Node = this.apply(c.asDigit - 'a'.asDigit)
  def apply(idx: Int): Node =  childNode(idx)
  def update(idx: Int, node: Node): Unit = childNode(idx) = node
  def update(c: Char, node: Node): Unit = this.update(c.asDigit - 'a'.asDigit, node)
}


class Trie() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach {
      case c if node(c) == null =>
        node(c) = Node()
        node = node(c)

      case c => node = node(c)
    }
    node.isWord = true

  }
  def insert(words: Array[String]): Unit = {
    words.foreach(insert)
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }


  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach {
      case c if node(c) != null => node = node(c)
      case _ => return None
    }
    Some(node)
  }
  def traversal(): Unit = {
    val result = scala.collection.mutable.ListBuffer[String]()

    def _traversal(prefix: String, node: Node): Unit = {
      if(node.isWord) {
        result += prefix
      }
      node.childNode.zipWithIndex.foreach{
        case (n, idx) if n != null => _traversal(prefix + ('a' + idx).toChar, n)
        case _ =>
      }

    }
    _traversal("", root)
    result.foreach(s => println(s.mkString("")))

  }
}


/**
* implement prefix tries by hashmap
* memo
*   1. in dfs, we directly input the node from tries instead of tries itself 
*   2. pruning an edge after matching a word and its children couldn't represent a word
*   3. this solution is faster than solution1
*/

import scala.collection.mutable
case class Node(next: mutable.Map[Char, Node] = mutable.Map.empty, var isWord: Boolean = false){
  def apply(char: Char): Option[Node] = next.get(char)
  def update(char: Char, node: Node): Unit = next(char) = node
}

class Tries(){
  val root = Node()
  def insert(word: String): Unit = {
    var node = root
    word.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined
  def search(word: String): Boolean =  searchUtil(word).exists(_.isWord)

  def searchUtil(s: String): Option[Node] = {
    var node = root
    s.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }
}


object Solution2 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


```

###  3.181. <a name='HouseRobberII213-II'></a>213. House Robber II 213-打家劫舍II

[18:13 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ea4y147oh?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1GD4y1d7DS?spm_id_from=333.999.0.0)

###  3.182. <a name='CombinationSumIII216-III'></a>216. Combination Sum III 216-组合总和 III

[花花酱](https://www.bilibili.com/video/BV14b411u7q8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1SC4y1a7Vy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gz4y1Z7CV?spm_id_from=333.999.0.0)

###  3.183. <a name='ContainsDuplicate'></a>217. Contains Duplicate

[小梦想家](https://www.bilibili.com/video/BV1ab411H7Zw?spm_id_from=333.999.0.0)

```scala
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        var hashSet = scala.collection.mutable.HashSet.empty[Int]
        import scala.util.control.Breaks._
        var flag = false
        breakable{
            for(num <- nums){
                if(hashSet.contains(num)){
                        flag = true
                        break
                    }else{
                    hashSet.add(num)
                }
                }
            }
        flag
        }
    }
    
  
//Alternate (SCALA) solution
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        return nums.distinctBy(_.self).length != nums.length
    }
}

```

###  3.184. <a name='TheSkylineProblem'></a>218. The Skyline Problem

[花花酱](https://www.bilibili.com/video/BV1hb411c7Q4?spm_id_from=333.999.0.0)

###  3.185. <a name='ContainsDuplicateII'></a>219. Contains Duplicate II

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ga?spm_id_from=333.999.0.0)

###  3.186. <a name='ContainsDuplicateIII'></a>220 Contains Duplicate III

[小明](https://www.bilibili.com/video/BV19h41197iw?spm_id_from=333.999.0.0)

###  3.187. <a name='-1'></a>221-最大正方形

[哈哈哈](https://www.bilibili.com/video/BV1XT4y137Gq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16K411575r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1mA411q7Sw?spm_id_from=333.999.0.0)

###  3.188. <a name='CountCompleteTreeNodes'></a>222. Count Complete Tree Nodes

[花花酱](https://www.bilibili.com/video/BV1n44y1E73D?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qz411i7bh?spm_id_from=333.999.0.0)

###  3.189. <a name='RectangleArea'></a>223. Rectangle Area

[小梦想家](https://www.bilibili.com/video/BV1Ck4y1z7Hp?spm_id_from=333.999.0.0)

###  3.190. <a name='ImplementStackusingQueues'></a>225-Implement Stack using Queues

[哈哈哈](https://www.bilibili.com/video/BV1p741177pK?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ep4y1Y77j?spm_id_from=333.999.0.0)

```scala
/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */


/**
* chosen solution
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack0() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}




 /**
 * my first commit
 * two queue version
 * time complexity: 
 *   push: O(1)
 *   pop: O(2n - 1)  n is the element in queue1
 *   top: O(2n - 1)
 */
class MyStack1() {

    /** Initialize your data structure here. */
    var queue1 = scala.collection.mutable.Queue[Int]()
    var queue2 = scala.collection.mutable.Queue[Int]()

    /** Push element x onto stack. */
    def push(x: Int) {
        queue1.enqueue(x)
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
       }
    
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        ret
        
    }

    /** Get the top element. */
    def top(): Int = {
        while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
        }
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        queue1.enqueue(ret)
        ret
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty && queue2.isEmpty
    }

}

/**
* two queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack2() {

   import scala.collection.mutable.Queue
    /** Initialize your data structure here. */
    var queue1 = Queue.empty[Int] 


    /** Push element x onto stack. */
    def push(x: Int) {
        val queue2 = Queue(x)
        queue2.enqueueAll(queue1.dequeueAll(_ => true))
        queue1 = queue2
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
        if(queue1.isEmpty) -1 else queue1.dequeue
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }
}

/**
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack3() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}

/**
* memo:
*   1. push entire old queue into a new queue without expanding all elements 
* time complexity:  
*     all operation are O(1) after being amortized
*   
* start  Queue()
* push1  Queue(1, Queue())
* push2  Queue(2, Queue(1, Queue()))
* push3  Queue(3, Queue(2, Queue(1, Queue())))
* push4  Queue(4, Queue(3, Queue(2, Queue(1, Queue()))))
* pop    Queue(3, Queue(2, Queue(1, Queue())))
* pop    Queue(2, Queue(1, Queue()))
*/

class MyStack4() {
  import scala.collection.mutable
  /** Initialize your data structure here. */
  var queue: mutable.Queue[Any] = mutable.Queue.empty[Any]

  /** Push element x onto stack. */
  def push(x: Int) {
    val queue2: mutable.Queue[Any] = mutable.Queue(x)
    queue2.enqueue(queue)
    queue = queue2

  }
  /** Removes the element on top of the stack and returns that element. */
  def pop(): Int = {

    if(queue.isEmpty) -1 else {
      val ret = queue.dequeue.asInstanceOf[Int]
      queue = queue.dequeue.asInstanceOf[mutable.Queue[Any]]
      ret
    }
  }
  /** Get the top element. */
  def top(): Int = {
    if(queue.isEmpty) -1 else queue.head.asInstanceOf[Int]
  }

  /** Returns whether the stack is empty. */
  def empty(): Boolean = {
    queue.size != 2
  }
}
```

###  3.191. <a name='-1'></a>226-翻转二叉树

[哈哈哈](https://www.bilibili.com/video/BV1Sh411R7B2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73E?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FK411p7Co?spm_id_from=333.999.0.0)

###  3.192. <a name='BasicCalculatorII'></a>227 Basic Calculator II

[小明](https://www.bilibili.com/video/BV1Qy4y167Ax?spm_id_from=333.999.0.0)

###  3.193. <a name='SummaryRanges'></a>228 Summary Ranges

[小明](https://www.bilibili.com/video/BV1Et4y1i7YZ?spm_id_from=333.999.0.0)

###  3.194. <a name='MajorityElementII'></a>229. Majority Element II 

[哈哈哈](https://www.bilibili.com/video/BV12z411B7rS?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nK411P7qR?spm_id_from=333.999.0.0)

###  3.195. <a name='KthSmallestElementinaB'></a>230 Kth Smallest Element in a B

[小明](https://www.bilibili.com/video/BV1ha4y1i7dZ?spm_id_from=333.999.0.0)

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

object Solution {
    def kthSmallest(root: TreeNode, k: Int): Int = {

      val stack = collection.mutable.Stack[TreeNode]()
      var node = root
      var counter = 0
      var ans = 0
      while ((counter <= k) && (node != null || stack.nonEmpty)) {
        while(node != null) {
          stack push node
          node = node.left
        }
        node = stack.pop
        
        counter += 1
        if (counter == 1 || counter <= k) {
          ans = node.value
        }
        
        node = node.right
        
      }
      ans
    }
}
/**
* my first commit
* inorder iterative template
* time complexity: O(H + K) => H is tree height, H + K = element in stack
*/

object Solution1 {
    def kthSmallest(root: TreeNode, k: Int): Int = {
        
        val stack = collection.mutable.Stack[TreeNode]()
        var node = root
        var counter = 0
        
        
        while(node != null || stack.nonEmpty) {
            while(node != null) {
                stack push node
                node = node.left
            }
            node = stack.pop
            counter += 1
            if(counter == k) return node.value
            else node = node.right
            
        }
        -1
    }
}

/**
* inorder traversal - recursive version
* time complexity: O(H + k)
*/

object Solution2-1 {
    import scala.collection.mutable
    def kthSmallest(root: TreeNode, k: Int): Int = {
        val ret = _kthSmallest(root, k, mutable.ListBuffer.empty)

        ret(k - 1)
    }
    
    def _kthSmallest(node: TreeNode, k:Int, l: mutable.ListBuffer[Int]): mutable.ListBuffer[Int]  = {
       if(node == null) l
       else {
           _kthSmallest(node.left, k, l)
           l += node.value
           if(l.size >= k) l  // shortcut
           else  _kthSmallest(node.right, k, l)  
       }
    }
}


/**
* a brilliant solution - inorder recursive traversal 
* memo:
*   1. using Either, right records numbers of visited node, left record the value when the condition is meet
* time complexity:
*      O(H + K) H is the height of the tree calculated by log(N) approximately
*/
object Solution2-2 {
  def go (node: TreeNode, k: Int) : Either[Int, Int] = {
     val r =for {
      numElementsLeft <- if (node.left == null) Right (0) else go(node.left, k)
      numElementsRight <- if (numElementsLeft + 1 == k) Left(node.value)
      else
        if (node.right == null) Right(0) else go(node.right, k - (numElementsLeft + 1))

    } yield numElementsLeft + numElementsRight + 1
      println(r)
      r

  }

  def kthSmallest(root: TreeNode, k: Int): Int = {
    go(root, k).left.get
  }
}

```

```scala

object Solution {
    var x = 0
    var result = 0
    
    //Using inorder and maintaining count
    
    def findk(root: TreeNode, k: Int): Unit = {
        if(root == null){
            ()
        }
        else if(root.left == null && root.right == null){
            x = x+1
            if(x == k) result = root.value
        }else if(root.left == null){
            x = x+1
            if(x == k) result = root.value
            findk(root.right, k)
        }else if(root.right == null){
            findk(root.left, k)
            x = x+1
            if(x == k) result = root.value
        }else{
            findk(root.left, k)
            x = x+1
            if(x == k) result = root.value
            findk(root.right, k)
        }
    }
    
    def kthSmallest(root: TreeNode, k: Int): Int = {
        x=0
        result=0
        findk(root, k)
        result
    }
}

```

###  3.196. <a name='PowerofTwo'></a>231. Power of Two

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rV411r7AL?spm_id_from=333.999.0.0)

```scala
/**
* time complexity  O(1)
*/
object Solution {
    def isPowerOfTwo(n: Int): Boolean = {
        n > 0 && (n & (n - 1) ) == 0
    }
}
```

###  3.197. <a name='ImplementQueueusingStacks'></a>232-Implement Queue using Stacks

[哈哈哈](https://www.bilibili.com/video/BV1p741177pp?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Gf4y147Vj?spm_id_from=333.999.0.0)

```scala
/**
* using two stack to implement
* one for push, the other for pop
* time complexity amortized O(1) per operation
* space complexity
*/

class MyQueue() {

  /** Initialize your data structure here. */
  private val inputStack = scala.collection.mutable.ArrayStack[Int]()
  private val outputStack = scala.collection.mutable.ArrayStack[Int]()


  /** Push element x to the back of queue. */
  def push(x: Int) {
    inputStack.push(x)

  }

  /** Removes the element from in front of queue and returns that element. */
  def pop(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.pop()

  }

  /** Get the front element. */
  def peek(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.head
  }

  /** Returns whether the queue is empty. */
  def empty(): Boolean = {
    outputStack.isEmpty && inputStack.isEmpty
  }

}

```

###  3.198. <a name='PalindromeLinkedList'></a>234. Palindrome Linked List

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ML?spm_id_from=333.999.0.0)

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
 
 /**
 * my first commitment
 *  using two pointer, one run 2 times faster than the other
 */
object Solution1 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null){
            true
        }else {
            var slowPre: ListNode = null
            var slow = head
            var fast = head

            while (fast != null && fast.next != null) {
                fast = fast.next.next

                val slowNext = slow.next
                slow.next = slowPre
                slowPre = slow
                slow = slowNext

            }

            fast match {
                case null => checkPalindrome(slowPre, slow)
                case _ => checkPalindrome(slowPre, slow.next)  // odd case
            }
            /**
                1 2 2 1 null
                s f
                    s   f  

                1 2 3 2 1 null
                s f   
                    s   f
            */
        }
       
                
    }
    def checkPalindrome(left: ListNode, right: ListNode): Boolean = {
        (left, right) match {
            case (null, null) => true
            case (l, r) if l != null && r != null && l.x == r.x => checkPalindrome(left.next, right.next)
            case _ => false   
        }
        
    }
    

    def printNode(node: ListNode) {
        var n = node
        
        while(n != null) {
            print(s"${n.x}\t")
            n = n.next
        }
    }
}


/**
* very brilliant solution
*/
object Solution2 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null) {
            return true
        }
        var p = head
        var result = true
        def go(node: ListNode): Unit = {
            if (node.next != null) {
                go(node.next)
            }
            if (p.x != node.x) {
                result = false
            }
            p = p.next
        }
        go(head)
        result
    }
}
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def isPalindrome(head: ListNode): Boolean = {
        var flag = true
        var rev = head
        var h = head
        def reverse(n: ListNode): Unit = {
            if(n == null){
                ()
            }else{
                reverse(n.next)
                val cond = n.x == h.x
                flag = flag && cond
                h = h.next
            }
        }
       
        reverse(rev)
        flag
    }
}

```

###  3.199. <a name='LowestCommonAncestorofaBinarySearchTree'></a>235. Lowest Common Ancestor of a Binary Search Tree

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7VY?spm_id_from=333.999.0.0)

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
* DFS 
* 
* exploit binary search three property:  right > parent value > left
* time complexity : O(N)
* space complexity: O(N)
*/
object Solution1 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }
  
  @annotation.tailrec
  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    (p, q) match {
      case (pp, qq) if p.value > node.value && q.value > node.value  && node != null => _lowestCommonAncestor(node.right, pp, qq)
      case (pp, qq) if p.value < node.value && q.value < node.value && node != null => _lowestCommonAncestor(node.left, pp, qq)
      case _ => node
    }
  }
}


/**
* iterative version
*/
object Solution1-2 {
    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
      if(root == null) return root
      var node = root
      
      var condition = true
      while(condition && node != null){
        if(q.value > node.value && p.value > node.value)
          node = node.right
        else if (node.value > q.value && node.value > p.value)
          node = node.left
        else 
          condition = false
      }
      node
    }
}
```

###  3.200. <a name='-1'></a>236-二叉树的最近公共祖先

[哈哈哈](https://www.bilibili.com/video/BV1ov411172r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411p7dr?spm_id_from=333.999.0.0)

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
*  chosen solution
*  DFS with recursive
*  time complexity O(N), N is the number of node in the tree
*  space complexity O(N)
*/
object Solution0 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }

  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    if (node == null || node == p || node == q) return node
    /**
    *  1. if p and q are node 's child, return p q 's LCA 
    *  2.  if p and q are not node's child return null
    *  3. if p and q, only one of then ar node's child return that node (p or q)
    */
    val left = _lowestCommonAncestor(node.left, p, q)
    val right = _lowestCommonAncestor(node.right, p, q)

    (left, right) match {
      case (null, _) => right  // p and q are both not in left
      case (_, null) => left  // p and q are both not in right
      case (l, r) =>  node // only lowest common ancestor could return both non null node
      // p and q, one of then in left and the other one in right
    }
  }
}
```

###  3.201. <a name='DeleteNodeinaLinkedList'></a>237. Delete Node in a Linked List

[小梦想家](https://www.bilibili.com/video/BV1rv411h7Lv?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1ap4y1C7JP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vt4y1y7eM?spm_id_from=333.999.0.0)

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getNext(node: ListNode): ListNode = {
        val nextNode = node.next
        if(nextNode == null)
            null
        else{
            node.x = nextNode.x
            node.next = getNext(nextNode)
            node
        }
    }
    
    def deleteNode(node: ListNode): Unit = {
        getNext(node)
    }
}

//The above solution can be simplified to:
object Solution {
    
    def deleteNode(node: ListNode): Unit = {
        node.x = node.next.x
        node.next = node.next.next //These 2 lines are effectively the same as doing the above recursion in scala
    }
}

```

###  3.202. <a name='ProductofArrayExceptSelf'></a>238 Product of Array Except Self

[小明](https://www.bilibili.com/video/BV1oT4y1G78Y?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16z4y197oQ?spm_id_from=333.999.0.0)

```scala
object Solution {

    //pre-compute prefix & suffix products in O(N) time and then multiply them
    def productExceptSelf(nums: Array[Int]): Array[Int] = {
        var prefix = Array.fill(nums.length)(1)
        var suffix = Array.fill(nums.length)(1)
        
        (1 until prefix.length).map(i => {
            prefix(i) = prefix(i-1)*nums(i-1)
        })
        
        (suffix.length-2 to 0 by -1).map(i => {
            suffix(i) = suffix(i+1)*nums(i+1)
        })
        
        (0 until nums.length).map(i => {
            nums(i) = prefix(i) * suffix(i)
        })
        nums
    }
}

```

###  3.203. <a name='SlidingWindowMaximum'></a>239. Sliding Window Maximum

[花花酱](https://www.bilibili.com/video/BV1WW411C763?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Bf4y1v758?spm_id_from=333.999.0.0)

```scala

/**
* chosen solution 
* using  array deque (double side queue)  which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution0 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
        //you should always delete elements from right side
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* using max heap, may not AC
* pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)} : keep element's time complexity is O(K)
* time complexity: O(N log K)
*/

object Solution1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        var pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
        val rest = scala.collection.mutable.ArrayBuffer[Int]()
        
        nums.zipWithIndex.foreach{case (v: Int, idx: Int) => {
     
            pq += ((v, idx))
            
            /* keep the elements that is only larger than newest v and the nearest k */
            pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)}       

            if (idx + 1 >= k) {
                rest += pq.head._1
            }
          
        }}        
        rest.toArray
    }
}


/**
* may not AC
* fold left version, it is worst than for loop version
*/
object Solution1-2 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
  val (_, rest, _) = nums.zipWithIndex.foldLeft((pq, Array.empty[Int], k)){
    (B, v_id) =>
      val (_pq, rest: Array[Int], _k) = B
      var newPq = _pq
      newPq += v_id
      if(v_id._2 + 1 >= k) {
        newPq = newPq.filter{case (_v:Int, _idx: Int) => (_v >= v_id._1) && (_idx > v_id._2 - k) }
          
         (newPq, rest :+ newPq.head._1, _k)
      }else {
         (newPq, rest, _k)
      }
     
  }
  rest
        
    }
}


/**
* using scala vector, due to scala vector is immutable, any operation about add update remove is generate a new vector
* so it's not a proper substitute for deque
*/

object Solution2 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    var windows = Vector.empty[Int]
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.head <= index - k)
        windows = windows.drop(1)

      while (windows.nonEmpty && nums(windows.last) <= value){
        windows = windows.dropRight(1)
      }
      windows = windows :+ index
      if (index + 1 >= k) {
        ret += nums(windows.head)
      }
    }
    ret.toArray
  }
}

/**
* using java array deque (double side queue) version which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution3 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    import java.util
    val windows = new util.ArrayDeque[Int]  // record nums index
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.peekFirst() <= index - k) {
        // remove out of date element
        windows.removeFirst()
      }

      while (!windows.isEmpty && nums(windows.peekLast()) <= value) {
        // drop the element if  it is smaller than upcoming element
        windows.removeLast()
      }
      windows.add(index)
      if (index + 1 >= k) {
        ret += nums(windows.peekFirst())
      }
    }
    ret.toArray
  }
}

/**
* use scala build-in arrayDeque
*/
object Solution3-1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* brute force, not AC
*/
object Solution4 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        nums.sliding(k).map(_.max).toArray
    }
}
```

###  3.204. <a name='-1'></a>240. 二维数组的查找

[哈哈哈](https://www.bilibili.com/video/BV1dz411i7jC?spm_id_from=333.999.0.0)

###  3.205. <a name='ValidAnagram'></a>242. Valid Anagram 

[小梦想家](https://www.bilibili.com/video/BV1Db411s78v?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hV411i73u?spm_id_from=333.999.0.0)

```scala

/**
* chosen solution
* one line version
* time complexity: O(N)
*/

object Solution0 {
  def isAnagram(s: String, t: String): Boolean = {
   s.groupBy(identity).mapValues(_.length).toMap == t.groupBy(identity).mapValues(_.length).toMap  // toMap: transform MapView to Map

  }
}


/**
* my first commit
* time complexity: O(N)
*/

object Solution1 {
  def isAnagram(s: String, t: String): Boolean = {
    charCounter(s) equals charCounter(t)
  }
  private def charCounter(str: String): Map[Char, Int] = {
    str.foldLeft(collection.mutable.Map.empty[Char, Int]) {
      (map, s) =>
        map.get(s) match {
          case Some(e) =>
            map.update(s, e + 1)
            map
          case None =>
            map.update(s, 1)
            map
        }
    }.toMap
  }
}



```

```scala
//Time complexity( O(NlogN + N))
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        if(arr1.size != arr2.size){
            false
        } else{
            java.util.Arrays.sort(arr1)
            java.util.Arrays.sort(arr2)
            
            var flag = true
            import scala.util.control.Breaks._
            var index = 0
            breakable{
            while(index < arr1.size){
                if(arr1(index) != arr2(index)){
                    flag = false
                    break
                }
                index += 1
            }
            }
            flag
        }
    }
}

//Time complexity O(n)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        
        if(arr1.size != arr2.size){
            false
        } else{
            var map = scala.collection.mutable.Map.empty[Char, Int]
            for(elem <- arr1){
                map.get(elem) match{
                    case Some(count) => map += (elem -> (count+1))
                    case None => map += (elem -> 1)
                }
            }
            
            for(elem <- arr2){
                map.get(elem) match{
                    case Some(count) if count == 1 => map.remove(elem)
                    case Some(count) => map += (elem -> (count-1))
                    case None => ()
                }
            }
            
            if(map.keys.isEmpty) true else false
        }
    }
}

//One more: O(N)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        if(s.size != t.size){
            false
        }else{
        var arr = Array.fill(26)(0)
        for(elem <- s){
            arr(elem - 'a') += 1
        }
        
        import scala.util.control.Breaks._
        var flag = true
        breakable{
        for(elem <- t){
            arr(elem - 'a') -= 1
            if(arr(elem - 'a') < 0){
                flag = false
                break
            }
        }
        }
        flag
    }
    }
}

```

###  3.206. <a name='ShortestWordDistance'></a>243. Shortest Word Distance

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Ae?spm_id_from=333.999.0.0)

###  3.207. <a name='StrobogrammaticNumber'></a>246. Strobogrammatic Number

[小梦想家](https://www.bilibili.com/video/BV14b411g7zD?spm_id_from=333.999.0.0)

###  3.208. <a name='-1'></a>257-二叉树的所有路径

[哈哈哈](https://www.bilibili.com/video/BV1rf4y1X7He?spm_id_from=333.999.0.0)

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//Given a binary tree, return all root-to-leaf paths.
//
//Note: A leaf is a node with no children.
//
//Example:
//
//Input:
//
//1
///   \
//2     3
//\
//5
//
//Output: ["1->2->5", "1->3"]
//
//Explanation: All root-to-leaf paths are: 1->2->5, 1->3

package lc0257 {

  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def binaryTreePaths(root: TreeNode): List[String] = {
      val tmp = ArrayBuffer[Int]()
      val ret =ArrayBuffer[ArrayBuffer[Int]]()
      helper(root, tmp, ret)
      ret.toList.map({
        x=>x.mkString("->")
      })
    }

    def helper(node:TreeNode,tmp:ArrayBuffer[Int],ret:ArrayBuffer[ArrayBuffer[Int]]): Unit = {
      if (node==null) {
        return
      }

      tmp += node.value

      if (node.left == null && node.right==null) {
          ret += tmp.clone()
      } else {
        helper(node.left, tmp, ret)
        helper(node.right, tmp, ret)
      }
      tmp.remove(tmp.length-1)
    }
  }

  class Test extends BaseExtension {
    def init {
      val t1 = Tree.build(IndexedSeq("1","2 3","5 N N N"))
      println(Solution.binaryTreePaths(t1))
    }
    val name = "257 binary tree path"
  }
}

```

###  3.209. <a name='AddDigits'></a>258. Add Digits

[小梦想家](https://www.bilibili.com/video/BV1ub41137cm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N54y1B7XU?spm_id_from=333.999.0.0)

###  3.210. <a name='III-1'></a>260-只出现一次的数字 III

[哈哈哈](https://www.bilibili.com/video/BV15Z4y1H7Sw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK411J7dN?spm_id_from=333.999.0.0)

###  3.211. <a name='UglyNumber'></a>263 Ugly Number

[花花酱](https://www.bilibili.com/video/BV11W411C7zd?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Mb41157Pa?spm_id_from=333.999.0.0)

###  3.212. <a name='UglyNumberII'></a>264. Ugly Number II

[花花酱](https://www.bilibili.com/video/BV1yW411C7Sm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vT4y1775u?spm_id_from=333.999.0.0)

###  3.213. <a name='MissingNumber'></a>268 Missing Number

[小明](https://www.bilibili.com/video/BV1LU4y1p7n7?spm_id_from=333.999.0.0)

```scala
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        val idealSum = (size * (size + 1))/2
        
        val arraySum = nums.foldLeft(0)(_ + _) // can also use nums.sum
        
        idealSum - arraySum
    }
}

//Removing foldLeft improved time
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        var idealSum = (size * (size + 1))/2
        
        for(num <- nums){
            idealSum -= num
        }

        idealSum
    }
}

```

###  3.214. <a name='ClosestBinarySearchTreeValue'></a>270. Closest Binary Search Tree Value

[哈哈哈](https://www.bilibili.com/video/BV1zy4y1a7mR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1fi4y1u7Sb?spm_id_from=333.999.0.0)

###  3.215. <a name='H-Index'></a>274 H-Index

[小明](https://www.bilibili.com/video/BV1ZV411z7Kx?spm_id_from=333.999.0.0)


###  3.216. <a name='FirstBadVersion'></a>278. First Bad Version

[小梦想家](https://www.bilibili.com/video/BV1rZ4y1P7YF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1cQ4y1N7dc?spm_id_from=333.999.0.0)

```scala
/* The isBadVersion API is defined in the parent class VersionControl.
      def isBadVersion(version: Int): Boolean = {} */



/**
* my first commitment
* binary search recursive version
* time complexity
*   log(n)
*/
class Solution1 extends VersionControl {
    def firstBadVersion(n: Int): Int = {
        search(1, n)
    }
  
    def search(left: Int, right: Int): Int  = {
      if (left > right) return -1
       /**
      * it's bad version from mid to n, we could keep right side a bad version
      * the we return left side index as left index equals to right index
      */
      if (left == right) return left
      
      val mid = left + (right - left) / 2
      if (isBadVersion(mid))
     
        search(left, mid) 
      else
        search(mid + 1, right)
    }
}

```

###  3.217. <a name='PerfectSquares'></a>279 Perfect Squares

[小明](https://www.bilibili.com/video/BV1r5411Y7MH?spm_id_from=333.999.0.0)

###  3.218. <a name='ExpressionAddOperators'></a>282. Expression Add Operators

[花花酱](https://www.bilibili.com/video/BV15W411C727?spm_id_from=333.999.0.0)

###  3.219. <a name='MoveZeros'></a>283. Move Zeros

[小梦想家](https://www.bilibili.com/video/BV1m441187Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ba4y1t7eK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Wp4y1y7pT?spm_id_from=333.999.0.0)

```scala
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        var p1 = 0
        var p2 = 0
        while(p1 < nums.size && p2 < nums.size){
            if(nums(p1) == 0 && nums(p2) != 0 && p1<p2){
                nums(p1) = nums(p2)
                nums(p2) = 0
                p1 += 1
                p2 += 1
            } else if(nums(p1) != 0 && nums(p2) != 0){
                p1 += 1
            }else{
                p2 += 1
            }
        }
    }
}

//Alternate solution: calculate the number of shifts 
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        
        var zeroCount = 0
        //count of zero is amount character is shifted to left
        //from first zero position traverse array left
        for(a <- 0 to nums.size-1){   
            //count zeroes and shift when not zero
            if(nums(a) == 0){
                zeroCount = zeroCount + 1
            }else if(zeroCount>0){
                //shift left if not 0 by zeroCount
                nums(a-zeroCount) = nums(a)
                nums(a) = 0
            }
        }
    }
}

```

```scala
package com.zhourui.leetcode

package lc0283_movezero {
  object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
//      nums.foldLeft(0) {
//        case (w,b) => {
//          if (b!=0) {
//            nums(w) = b
//
//            w+1
//          } else w
//        }
//      }

      nums.indices.foldLeft(0) {
        case (acc, e) => {
          if (nums(e)!=0) {
            val tmp = nums(e)
            nums(e) = nums(acc)
            nums(acc) = tmp
            acc+1
          } else acc
        }
      }
    }
  }
}

/*
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int w = 0;
        for (int i = 0; i< nums.size(); i++) {
            if (nums[i]!=0) {
                swap(nums[w++], nums[i]);
            }
        }
    }
};
 */

```

###  3.220. <a name='PeekingIterator'></a>284 Peeking Iterator

[小明](https://www.bilibili.com/video/BV1LN411R7U7?spm_id_from=333.999.0.0)

###  3.221. <a name='FindtheDuplicateNumber'></a>287 Find the Duplicate Number

[小明](https://www.bilibili.com/video/BV1Ug4y1v7mF?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pz4y1X7qR?spm_id_from=333.999.0.0)

###  3.222. <a name='GameofLife'></a>289. Game of Life

[花花酱](https://www.bilibili.com/video/BV14W411d7ji?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hp4y1B7D5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vz4y1R7DJ?spm_id_from=333.999.0.0)

###  3.223. <a name='WordPattern'></a>290. Word Pattern

[小梦想家](https://www.bilibili.com/video/BV1d4411V7mi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1N7wD?spm_id_from=333.999.0.0)

###  3.224. <a name='SerializeandDeserializeBinaryTree'></a>297. Serialize and Deserialize Binary Tree

[花花酱](https://www.bilibili.com/video/BV1Hb411c7cr?spm_id_from=333.999.0.0)

###  3.225. <a name='BullsandCows'></a>299. Bulls and Cows

[小梦想家](https://www.bilibili.com/video/BV1M64y1M7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1bh411R7n4?spm_id_from=333.999.0.0)

###  3.226. <a name='LongestIncreasingSubsequence'></a>300 Longest Increasing Subsequence 最长上升子序列

[花花酱](https://www.bilibili.com/video/BV1Wf4y1y7ou?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1rT4y1u7jV?spm_id_from=333.999.0.0)

```scala



/**
* chosen answer
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution0 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}

/**
* brute force : not Ac
* memo:
* 1. each position have two choice :
*    1. take current value if currentIdx value > previousIdx value 
*    2. do not take current value
* time complexity: O(2^n)
*/
object Solution1 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        lengthOfLIS(nums, 0, -1)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int): Int = {
      if (currentIdx >= nums.length) return 0
      
      val taken = if (previousIdx == -1  ||  (nums(currentIdx) > nums(previousIdx))) {
        lengthOfLIS(nums, currentIdx + 1, currentIdx) + 1
      } else {
        0
      } 
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx)
      taken max nonTaken
    }
}

/**
* with memorized: we just fill the nxn dimension memory array
* time complexity: O(n^2)
* space complexity: O(n^2)
*/
object Solution1-2 {
    def lengthOfLIS(nums: Array[Int]): Int = {
      val memory = Array.fill[Int](nums.length, nums.length)(-1)
      lengthOfLIS(nums, 0, -1, memory)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int, memory: Array[Array[Int]]): Int  = {
      // println(currentIdx, previousIdx)
      if (nums.length == currentIdx) return 0
      if (memory(currentIdx)(previousIdx + 1) != -1) return memory(currentIdx)(previousIdx + 1)
      
      val taken = if (previousIdx == -1 || nums(currentIdx) > nums(previousIdx)) {
        1 + lengthOfLIS(nums, currentIdx + 1, currentIdx, memory)
      } else {
        0
      }
      
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx, memory)
      
      memory(currentIdx)(previousIdx + 1) = taken max nonTaken
      
      memory(currentIdx)(previousIdx + 1) 
    }
  
  
}





/**
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution3 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        

        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}
```

###  3.227. <a name='RemoveInvalidParentheses'></a>301. Remove Invalid Parentheses

[花花酱](https://www.bilibili.com/video/BV1VW411y7Xd?spm_id_from=333.999.0.0)

###  3.228. <a name='-1'></a>303-区域和检索 - 数组不可变

[哈哈哈](https://www.bilibili.com/video/BV1RV411d76R?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV18441137fs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ho4y1U7wF?spm_id_from=333.999.0.0)

###  3.229. <a name='RangeSumQuery2D'></a>304. Range Sum Query 2D

[花花酱](https://www.bilibili.com/video/BV1Jb411k7LQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1R64y127jL?spm_id_from=333.999.0.0)

###  3.230. <a name='BestTimetoBuyandSellStockwithCooldown309-'></a>309. Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期

[花花酱](https://www.bilibili.com/video/BV1qW411C7Xc?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Vy4y1z7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13D4y1U7iU?spm_id_from=333.999.0.0)

```scala

/**
* my first commitment
* dynamic programming
* memo
*   1. dp definition: dp[i][j] means the best profit we can have at i-th day in state j of without holding / holding / cooldown 
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        /*
        * state definition
        * 0: without holding
        * 1: holding one
        * 2: sold than cooldown
        */
        val dp = Array.tabulate(prices.length, 3){
            case (0, 0) => 0
            case (0, 1) => -prices(0)
            case (0, 2) => 0
            case _ => 0
        }
        
        for(i <- 1 until prices.length) {
            dp(i)(0) = dp(i - 1)(0) max dp(i - 1)(2) // 0 -> 0 or 2 -> 0
            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i)) // 1 -> 1 or  0 -> 1
            dp(i)(2) = dp(i - 1)(1) + prices(i) // 1 -> 2
        }
        
        dp.last.max
    }
}

/**
* dynamic programming
* memo
*    ok! lets reduce the dp array size without keep all i-th state
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-2 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        var withoutHold = 0
        var hold = Int.MinValue
        var coolDown = 0
        
        for(price <- prices) {
            val withoutHold_ = withoutHold  // keep value
            val hold_ = hold // keep value
            withoutHold = withoutHold max coolDown
            hold = hold max (withoutHold_ - price)
            coolDown = hold_ + price  
        }
        withoutHold max coolDown
    }
}

/**
* dynamic programming - function programming
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-3 {
    def maxProfit(prices: Array[Int]): Int = {
        val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) {
            case ((withoutHold, hold, cooldown), cost) => 
             (
                 withoutHold max cooldown,
                 hold max (withoutHold - cost),
                 hold + cost      
             )
        }
        withoutHold max cooldown
    }
}
```

###  3.231. <a name='MinimumHeightTrees'></a>310 Minimum Height Trees

[小明](https://www.bilibili.com/video/BV1eA411j7XQ?spm_id_from=333.999.0.0)

###  3.232. <a name='BurstBalloons'></a>312 Burst Balloons

[小明](https://www.bilibili.com/video/BV1Q64y1f7Vy?spm_id_from=333.999.0.0)

###  3.233. <a name='CountofSmallerNumbersAfterSelf'></a>315. Count of Smaller Numbers After Self

[花花酱](https://www.bilibili.com/video/BV1BW411C7TM?spm_id_from=333.999.0.0)

###  3.234. <a name='RemoveDuplicateLetters'></a>316 Remove Duplicate Letters

[小明](https://www.bilibili.com/video/BV1x54y1R7y7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Tz4y167pC?spm_id_from=333.999.0.0)

###  3.235. <a name='CreateMaximumNumber'></a>321. Create Maximum Number

[花花酱](https://www.bilibili.com/video/BV11W411U7NR?spm_id_from=333.999.0.0)

###  3.236. <a name='CoinChange'></a>322. Coin Change

[花花酱](https://www.bilibili.com/video/BV1SW411C7d1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1tz4y1d7XM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ty4y187dh?spm_id_from=333.999.0.0)

```scala
/**
* dynamic programming: bottom up
* time complexity: O(S * N), S is the amount, N is the coin denomination count
* space complexity: O(S)
*/

object Solution {
    def coinChange(coins: Array[Int], amount: Int): Int = {
         
        val dp = Array.fill[Int](amount + 1)(amount + 1) // record the minimum needed coins of each denominations

        dp(0) = 0
        for (i <- 1 to amount; denominations <- coins) {

            if(denominations <= i) {
                dp(i) = dp(i) min (dp(i - denominations) + 1)
            }        
        }
    
        if (dp.last > amount) -1 else dp.last
    }
}

```

###  3.237. <a name='PowerofThree'></a>326. Power of Three

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7QC?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1h441137PM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sZ4y1F7Lr?spm_id_from=333.999.0.0)

###  3.238. <a name='OddEvenLinkedList'></a>328. 奇偶链表 (Odd Even Linked List)

[洛阳](https://www.bilibili.com/video/BV1v64y1u7AH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ag4y1B78z?spm_id_from=333.999.0.0)

###  3.239. <a name='LongestIncreasingPathinaMatrix'></a>329. Longest Increasing Path in a Matrix

[花花酱](https://www.bilibili.com/video/BV1mW411d7q8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK4y1K7SX?spm_id_from=333.999.0.0)

###  3.240. <a name='ReconstructItinerary'></a>332 Reconstruct Itinerary

[小明](https://www.bilibili.com/video/BV1qa4y1h7Ti?spm_id_from=333.999.0.0)

###  3.241. <a name='IncreasingTripletSubseque'></a>334 Increasing Triplet Subseque

[小明](https://www.bilibili.com/video/BV1Kr4y1F7m9?spm_id_from=333.999.0.0)

###  3.242. <a name='HouseRobberIII'></a>337 House Robber III

[小明](https://www.bilibili.com/video/BV1WD4y1X7JQ?spm_id_from=333.999.0.0)

###  3.243. <a name='CountingBits'></a>338 Counting Bits

[小明](https://www.bilibili.com/video/BV1VK411s7xi?spm_id_from=333.999.0.0)

```scala

/**
* chosen solution
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution0 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}

object Solution1 {
    def countBits(num: Int): Array[Int] = {
        (0 to num).map(_counter).toArray
        
    }
    private def _counter(n: Int): Int = {
        var counter = 0
        var nn = n
        
        while(nn != 0) {
            counter += 1
            nn = nn & (nn - 1)
        }
        counter 
    }
}

/**
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution2 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}
```

###  3.244. <a name='PowerofFour'></a>342. Power of Four

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7D5?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1p5411a7h1?spm_id_from=333.999.0.0)

###  3.245. <a name='-1'></a>343-整数拆分

[哈哈哈](https://www.bilibili.com/video/BV1Dp4y1U79P?spm_id_from=333.999.0.0)

###  3.246. <a name='ReverseString'></a>344. Reverse String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7Ha?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nC4y1a7DR?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1nQ4y1R7nH?spm_id_from=333.999.0.0)

```scala
object Solution {
    def reverseString(s: Array[Char]): Unit = {
        var begin = 0
        var end = s.length - 1
        while(begin < end){
            var temp = s(begin)
            s(begin) = s(end)
            s(end) = temp
            
            begin += 1
            end -= 1
        }
    }
}

```

###  3.247. <a name='ReverseVowelsofaString'></a>345. Reverse Vowels of a String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7JH?spm_id_from=333.999.0.0)

###  3.248. <a name='MovingAveragefromDataStream'></a>346 Moving Average from Data Stream

[小明](https://www.bilibili.com/video/BV1xV411m73u?spm_id_from=333.999.0.0)

###  3.249. <a name='TopKFrequentElements'></a>347. Top K Frequent Elements 

[花花酱](https://www.bilibili.com/video/BV1Mt411371T?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sk4y1B7vj?spm_id_from=333.999.0.0)

```scala
object Solution {
    def topKFrequent(nums: Array[Int], k: Int): Array[Int] = {
        var hm = scala.collection.mutable.Map.empty[Int, Int]
        for(elem <- nums){
            hm.get(elem) match{
                case Some(count) => hm += (elem -> (count+1))
                case None => hm += (elem -> 1)
            }
        }
        
        // hm.toList.sortBy(x => (x._2)*(-1)).take(k).map(_._1).toArray
        // The above is a sorting approach. We can use Heap/PriorityQueue to achieve better time complexity
        
        import scala.math.Ordering.Implicits._
        
        def orderByFrequency(tup: (Int, Int)) = tup._2
        
        val pq = new scala.collection.mutable.PriorityQueue[(Int, Int)]()(Ordering.by(orderByFrequency))
        
        for(entry <- hm){
            pq.enqueue(entry)
        }
        
        println(pq)
        (1 to k).map(_ => pq.dequeue).map(_._1).toArray
        
    }
}

```

###  3.250. <a name='IntersectionofTwoArrays'></a>349. Intersection of Two Arrays

[小梦想家](https://www.bilibili.com/video/BV1zx411o7i1?spm_id_from=333.999.0.0)

###  3.251. <a name='IntersectionofTwoArraysII'></a>350. Intersection of Two Arrays II 

[小梦想家](https://www.bilibili.com/video/BV1gx411X7q8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV165411879H?spm_id_from=333.999.0.0)

```scala
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        
        val map1 = nums1.groupBy(identity).mapValues(_.length)
        val map2 = nums2.groupBy(identity).mapValues(_.length)
        
        val keys = map1.keySet intersect map2.keySet
        
        keys.map(key => {
            val count1 = map1.get(key).get
            val count2 = map2.get(key).get
            val count = if(count1 > count2) count2 else count1
            Array.fill(count)(key)
        }).toArray.flatten
    }
}


//Alternate solution to keep count in HashMap from 1st array & decrease from second array... whatever is left is intersection
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        var map = scala.collection.mutable.Map.empty[Int, Int]
        var output = List.empty[Int]
        for(item <- nums1){
            map.get(item) match{
                case Some(count) => map += (item -> (count + 1))
                case None => map += (item -> 1)
            }
        }
        
        for(item <- nums2){
            map.get(item) match{
                case Some(count) => {
                    output = output :+ item
                    if(count - 1 == 0) map.remove(item) else map += (item -> (count - 1))
                }
                case None => map.remove(item)
            }
        }
        
        output.toArray
    }
}

```

###  3.252. <a name='DesignTwitter'></a>355. 设计推特 Design Twitter

[官方](https://www.bilibili.com/video/BV1aQ4y1N72N?spm_id_from=333.999.0.0)

###  3.253. <a name='LoggerRateLimiter'></a>359 Logger Rate Limiter

[小明](https://www.bilibili.com/video/BV1k64y1F7dE?spm_id_from=333.999.0.0)

###  3.254. <a name='ValidPerfectSquare'></a>367. Valid Perfect Square

[小梦想家](https://www.bilibili.com/video/BV1Gx411X7Ke?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DT4y1377H?spm_id_from=333.999.0.0)

###  3.255. <a name='LargestDivisibleSubset'></a>368 Largest Divisible Subset

[小明](https://www.bilibili.com/video/BV15D4y1Q74b?spm_id_from=333.999.0.0)

###  3.256. <a name='FindKPairswithSmallestSumsk'></a>373. Find K Pairs with Smallest Sums查找和最小的k对数字

[图灵](https://www.bilibili.com/video/BV1Mv4y1Z79v?spm_id_from=333.999.0.0)

###  3.257. <a name='GuessNumberHigherorLower'></a>374. Guess Number Higher or Lower

[小梦想家](https://www.bilibili.com/video/BV1Hx41197ou?spm_id_from=333.999.0.0)

###  3.258. <a name='-1'></a>376-摆动序列

[哈哈哈](https://www.bilibili.com/video/BV1sk4y167wV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16X4y1376k?spm_id_from=333.999.0.0)

###  3.259. <a name='CombinationSumIV'></a>377. Combination Sum IV

[花花酱](https://www.bilibili.com/video/BV1gW411y7uz?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1zA411L7nu?spm_id_from=333.999.0.0)

###  3.260. <a name='K'></a>378-有序矩阵中第K小的元素

[哈哈哈](https://www.bilibili.com/video/BV1mT4y1w7u2?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Zy4y127qr?spm_id_from=333.999.0.0)

###  3.261. <a name='InsertDeleteGetRandomO1'></a>380 Insert Delete GetRandom O(1)

[小明](https://www.bilibili.com/video/BV1Fg4y1q7Ru?spm_id_from=333.999.0.0)

###  3.262. <a name='LinkedListRandomNode'></a>382 Linked List Random Node

[小明](https://www.bilibili.com/video/BV1xZ4y1G7ie?spm_id_from=333.999.0.0)

###  3.263. <a name='RansomNote'></a>383 Ransom Note

[小明](https://www.bilibili.com/video/BV1GQ4y1N7Q5?spm_id_from=333.999.0.0)

###  3.264. <a name='FirstUniqueCharacterinaString'></a>387. First Unique Character in a String

[小梦想家](https://www.bilibili.com/video/BV1y4411A7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1b541147WU?spm_id_from=333.999.0.0)

```scala
object Solution {
    def firstUniqChar(s: String): Int = {
        var map = scala.collection.mutable.Map.empty[Char, (Int, Int)]
        (0 to s.length-1).map(i =>
            map.get(s.charAt(i)) match{
                case Some(indexAndCount) => map += (s.charAt(i) -> (i, indexAndCount._2 + 1))
                case None => map += (s.charAt(i) -> (i, 1))
            }
        )
        map.toList.filter(x => x._2._2 == 1).map(_._2._1).sorted.headOption.getOrElse(-1)
    }
}

//Alternate/Better SCALA solution
object Solution {
    def firstUniqChar(s: String): Int = {
        val hmap =  s.toCharArray.groupBy(identity).mapValues(_.length)
        val uniqChar = s.toCharArray.zipWithIndex.find (p => hmap(p._1) == 1)
        if(uniqChar.nonEmpty) uniqChar.get._2 else -1 
    }
}

/**How the above solution works:
scala> val a = "akashs"
a: String = akashs

scala> a.toCharArray.groupBy(identity)
res0: scala.collection.immutable.Map[Char,Array[Char]] = Map(h -> Array(h), k -> Array(k), s -> Array(s, s), a -> Array(a, a))

scala> a.toCharArray.groupBy(identity).mapValues(_.length)
res1: scala.collection.immutable.Map[Char,Int] = Map(h -> 1, k -> 1, s -> 2, a -> 2)

scala> a.toCharArray.zipWithIndex
res2: Array[(Char, Int)] = Array((a,0), (k,1), (a,2), (s,3), (h,4), (s,5))

scala> a.toCharArray.zipWithIndex.find(x => res1(x._1) == 1)
res3: Option[(Char, Int)] = Some((k,1))
*/

```

###  3.265. <a name='FindtheDifference'></a>389. Find the Difference

[小梦想家](https://www.bilibili.com/video/BV1Et411K7jP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

###  3.266. <a name='PerfectRectangle'></a>391. Perfect Rectangle

[花花酱](https://www.bilibili.com/video/BV184411c7cs?spm_id_from=333.999.0.0)

###  3.267. <a name='IsSubsequence'></a>392. Is Subsequence

[小梦想家](https://www.bilibili.com/video/BV1fg4y1q7eT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Za4y1a73v?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19f4y197yS?spm_id_from=333.999.0.0)

###  3.268. <a name='UTF-8Validation'></a>393. UTF-8 Validation

[花花酱](https://www.bilibili.com/video/BV1SE411w7no?spm_id_from=333.999.0.0)

###  3.269. <a name='DecodeString'></a>394 Decode String

[小明](https://www.bilibili.com/video/BV145411V75E?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GZ4y1p7pE?spm_id_from=333.999.0.0)

###  3.270. <a name='LongestSubstringwithAtLeastK'></a>395 Longest Substring with At Least K

[小明](https://www.bilibili.com/video/BV1hD4y1X7rq?spm_id_from=333.999.0.0)

###  3.271. <a name='EvaluateDivision'></a>399. Evaluate Division

[花花酱](https://www.bilibili.com/video/BV1iW41167Nb?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XU4y1s7Lk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ko4y1f7eK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rZ4y1N7CW?spm_id_from=333.999.0.0)

###  3.272. <a name='RemoveKDigits'></a>402 Remove K Digits

[小明](https://www.bilibili.com/video/BV1PV411C79X?spm_id_from=333.999.0.0)

###  3.273. <a name='SumofLeftLeaves'></a>404. Sum of Left Leaves

[小梦想家](https://www.bilibili.com/video/BV1Et411K7wa?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15a4y1779U?spm_id_from=333.999.0.0)

###  3.274. <a name='ConvertaNumbertoHexadecimal'></a>405-Convert a Number to Hexadecimal

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7ds?spm_id_from=333.999.0.0)

###  3.275. <a name='QueueReconstructionbyHeight'></a>406. Queue Reconstruction by Height 

[小明](https://www.bilibili.com/video/BV1xC4y1a72W?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV144411R7ch?spm_id_from=333.999.0.0)

###  3.276. <a name='ValidWordAbbreviation'></a>408. Valid Word Abbreviation

[小梦想家](https://www.bilibili.com/video/BV1A4411q74A?spm_id_from=333.999.0.0)

###  3.277. <a name='LongestPalindrome'></a>409. Longest Palindrome

[小梦想家](https://www.bilibili.com/video/BV1B441127W2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19C4y1479a?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Lk4y1z7PG?spm_id_from=333.999.0.0)

###  3.278. <a name='SplitArrayLargestSum'></a>410. Split Array Largest Sum

[花花酱](https://www.bilibili.com/video/BV14W411d7D4?spm_id_from=333.999.0.0)

###  3.279. <a name='FizzBuzz'></a>412. Fizz Buzz

[小梦想家](https://www.bilibili.com/video/BV1xE411R7yK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tD4y1m76j?spm_id_from=333.999.0.0)

```scala
object Solution {
    def fizzBuzz(n: Int): List[String] = {
        (1 to n).map(num => {
            if(num%15 == 0)
                "FizzBuzz"
            else if(num%5 == 0)
                "Buzz"
            else if(num%3 == 0)
                "Fizz"
            else
                num.toString
        }).toList
    }
}

```

###  3.280. <a name='-1'></a>413-等差数列划分

[哈哈哈](https://www.bilibili.com/video/BV13a4y1i7tR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13f4y167YZ?spm_id_from=333.999.0.0)

###  3.281. <a name='ThirdMaximumNumber'></a>414. Third Maximum Number

[小梦想家](https://www.bilibili.com/video/BV1UE411X7k1?spm_id_from=333.999.0.0)

###  3.282. <a name='AddStrings'></a>415-Add Strings

[哈哈哈](https://www.bilibili.com/video/BV18E411n7Cy?spm_id_from=333.999.0.0)

###  3.283. <a name='PartitionEqualSubsetSum'></a>416. Partition Equal Subset Sum

[花花酱](https://www.bilibili.com/video/BV1AW411y7So?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oZ4y1G7QY?spm_id_from=333.999.0.0)

###  3.284. <a name='PacificAtlanticWaterFlow'></a>417. Pacific Atlantic Water Flow

[花花酱](https://www.bilibili.com/video/BV1Kb411K7ty?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1by4y1h7ab?spm_id_from=333.999.0.0)

###  3.285. <a name='BattleshipsinaBoard'></a>419. Battleships in a Board 

[小梦想家](https://www.bilibili.com/video/BV1TJ411j7QZ?spm_id_from=333.999.0.0)

###  3.286. <a name='MaximumXORofTwoNumbersinanArray'></a>421 Maximum XOR of Two Numbers in an Array

[小明](https://www.bilibili.com/video/BV1s64y1F7Wm?spm_id_from=333.999.0.0)

###  3.287. <a name='ReconstructOriginalDigitsfromEnglish'></a>423 Reconstruct Original Digits from English

[小明](https://www.bilibili.com/video/BV1554y1h73S?spm_id_from=333.999.0.0)

###  3.288. <a name='LongestRepeatingCharacterReplacem'></a>424. 替换后的最长重复字符 Longest Repeating Character Replacem

[官方](https://www.bilibili.com/video/BV14r4y1K7rN?spm_id_from=333.999.0.0)

###  3.289. <a name='N-aryTreeLevelOrderTraversal'></a>429. N-ary Tree Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1CE411Q7BQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Uv411K77M?spm_id_from=333.999.0.0)

###  3.290. <a name='FlattenaMultilevelDoublyLinkedList'></a>430 Flatten a Multilevel Doubly Linked List

[小明](https://www.bilibili.com/video/BV1754y1q7Kb?spm_id_from=333.999.0.0)

###  3.291. <a name='AllOoneDataStructure'></a>432. All O`one Data Structure

[花花酱](https://www.bilibili.com/video/BV1XW411d7qR?spm_id_from=333.999.0.0)

###  3.292. <a name='Non-overlappingIntervals'></a>435-Non-overlapping Intervals

[哈哈哈](https://www.bilibili.com/video/BV1i7411p7pv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ak4y1U7f8?spm_id_from=333.999.0.0)

###  3.293. <a name='FindRightInterval'></a>436 Find Right Interval

[小明](https://www.bilibili.com/video/BV1YT4y1w7EP?spm_id_from=333.999.0.0)

###  3.294. <a name='PathSumIII'></a>437 Path Sum III

[小明](https://www.bilibili.com/video/BV1tZ4y1M7JR?spm_id_from=333.999.0.0)

###  3.295. <a name='FindAllAnagramsinaString'></a>438. Find All Anagrams in a String

[花花酱](https://www.bilibili.com/video/BV1iW411d7Nb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1254y1X7HV?spm_id_from=333.999.0.0)

```scala
/**
* chosen solution
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/
object Solution0 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }
    ret.toList
  }
}

/**
* my first commit
* sliding window + hashMap within windows
* time complexity: O(NM): N: s.length, M: p.length
*/

object Solution1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap

     s.sliding(p.length).zipWithIndex.filter{ case (c, _) => pMap == c.groupBy(identity).mapValues(_.length).toMap}.map(_._2).toList
  }
}


/**
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/

object Solution2 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }

    ret.toList
  }
}

/**
* sliding window - two hashmap version
* using a mutable map storing current window's string element and amount
* time complexity: O(N)
* space complexity: O(2N) -> two hashMap
*/

object Solution2-1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap
    val sMap = scala.collection.mutable.Map[Char, Int]()
    val result = scala.collection.mutable.ListBuffer[Int]()

    for((char, right) <- s.zipWithIndex) {
      sMap.put(char, sMap.getOrElse(char, 0) + 1)

      if(right >= p.length) {
        val leftChar = s(right - p.length)
        sMap.get(leftChar) match {
          case Some(e) if e == 1 => sMap.remove(leftChar)
          case Some(e) => sMap.update(leftChar, e - 1)
          case _ =>
        }
      }
      if(pMap.equals(sMap)) result += (right - p.length + 1)
    }
    result.toList
  }
}

```

###  3.296. <a name='ArrangingCoins'></a>441 Arranging Coins

[小明](https://www.bilibili.com/video/BV1eV411k7rg?spm_id_from=333.999.0.0)

###  3.297. <a name='FindAllDuplicatesinanArray'></a>442 Find All Duplicates in an Array

[小明](https://www.bilibili.com/video/BV1Lh411d7AD?spm_id_from=333.999.0.0)

###  3.298. <a name='StringCompression'></a>443. String Compression

[小梦想家](https://www.bilibili.com/video/BV1rE411f7Ld?spm_id_from=333.999.0.0)

###  3.299. <a name='AddTwoNumbersII'></a>445-Add Two Numbers II

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7Qz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pt4y1m78o?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17a4y1s7BG?spm_id_from=333.999.0.0)

###  3.300. <a name='NumberofBoomerangs'></a>447. Number of Boomerangs

[小梦想家](https://www.bilibili.com/video/BV1hE411o7V2?spm_id_from=333.999.0.0)

###  3.301. <a name='FindAllNumbersDisappearedinanArray'></a>448. Find All Numbers Disappeared in an Array

[小梦想家](https://www.bilibili.com/video/BV1SE411d7FM?spm_id_from=333.999.0.0)

###  3.302. <a name='SerializeandDeserializeBST'></a>449. Serialize and Deserialize BST

[花花酱](https://www.bilibili.com/video/BV1ab411c75V?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1r7FT?spm_id_from=333.999.0.0)

###  3.303. <a name='DeleteNodeinaBST'></a>450. Delete Node in a BST

[花花酱](https://www.bilibili.com/video/BV1XW411d7yU?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1YK4y1h7Mw?spm_id_from=333.999.0.0)

###  3.304. <a name='SortCharactersByFrequency'></a>451 Sort Characters By Frequency

[小明](https://www.bilibili.com/video/BV18v411z7iy?spm_id_from=333.999.0.0)

###  3.305. <a name='SumII'></a>454 4Sum II

[小明](https://www.bilibili.com/video/BV1ny4y1D7UL?spm_id_from=333.999.0.0)

###  3.306. <a name='MinimumNumberofArrowstoBurstBalloons'></a>452. Minimum Number of Arrows to Burst Balloons

[花花酱](https://www.bilibili.com/video/BV1bW411d77B?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1PZ4y1L7VM?spm_id_from=333.999.0.0)

###  3.307. <a name='AssignCookies'></a>455-Assign Cookies

[哈哈哈](https://www.bilibili.com/video/BV157411s7b9?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1YE411r7UN?spm_id_from=333.999.0.0)

###  3.308. <a name='Pattern'></a>456 132 Pattern

[小明](https://www.bilibili.com/video/BV18f4y1i734?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1SZ4y1x74J?spm_id_from=333.999.0.0)

###  3.309. <a name='PoorPigs'></a>458 Poor Pigs

[小明](https://www.bilibili.com/video/BV1g5411576M?spm_id_from=333.999.0.0)

###  3.310. <a name='RepeatedSubstringPattern'></a>459 Repeated Substring Pattern

[小明](https://www.bilibili.com/video/BV1Yt4y1S7XZ?spm_id_from=333.999.0.0)

###  3.311. <a name='LFUCacheO1'></a>460. LFU Cache / O(1)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7PR?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1Xb411c7m7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kA41147t8?spm_id_from=333.999.0.0)

###  3.312. <a name='HammingDistance'></a>461 Hamming Distance

[小明](https://www.bilibili.com/video/BV1M5411Y79g?spm_id_from=333.999.0.0)

###  3.313. <a name='IslandPerimeter'></a>463 Island Perimeter

[小明](https://www.bilibili.com/video/BV16V41167bF?spm_id_from=333.999.0.0)

###  3.314. <a name='CanIWin'></a>464. Can I Win

[花花酱](https://www.bilibili.com/video/BV1KW411o7m2?spm_id_from=333.999.0.0)

###  3.315. <a name='CountTheRepetitions'></a>466. 统计重复个数 Count The Repetitions

[官方](https://www.bilibili.com/video/BV1Qk4y1678m?spm_id_from=333.999.0.0)

###  3.316. <a name='ValidateIPAddress'></a>468 Validate IP Address

[小明](https://www.bilibili.com/video/BV1tg4y1q7Kq?spm_id_from=333.999.0.0)

###  3.317. <a name='ImplementRand10UsingRand7'></a>470. Implement Rand10() Using Rand7()

[花花酱](https://www.bilibili.com/video/BV1Ut411Z7KX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AD4y1m7Qb?spm_id_from=333.999.0.0)

###  3.318. <a name='Heaters'></a>475. Heaters

[小梦想家](https://www.bilibili.com/video/BV1vJ41117VH?spm_id_from=333.999.0.0)

###  3.319. <a name='NumberComplement'></a>476. Number Complement

[花花酱](https://www.bilibili.com/video/BV1PW411y7mv?spm_id_from=333.999.0.0)

###  3.320. <a name='TotalHammingDistance'></a>477. Total Hamming Distance

[花花酱](https://www.bilibili.com/video/BV1SW411r78m?spm_id_from=333.999.0.0)

###  3.321. <a name='GenerateRandomPointinaCircle'></a>478 Generate Random Point in a Circle

[小明](https://www.bilibili.com/video/BV1Nz4y127a1?spm_id_from=333.999.0.0)

###  3.322. <a name='SlidingWindowMedian'></a>480. Sliding Window Median

[花花酱](https://www.bilibili.com/video/BV15W411C7iy?spm_id_from=333.999.0.0)

###  3.323. <a name='FindPermutation'></a>484 Find Permutation

[小明](https://www.bilibili.com/video/BV1NT4y1L76i?spm_id_from=333.999.0.0)

###  3.324. <a name='MaxConsecutiveOnes'></a>485. Max Consecutive Ones

[小梦想家](https://www.bilibili.com/video/BV1zJ411R7SJ?spm_id_from=333.999.0.0)

###  3.325. <a name='PredicttheWinner'></a>486. Predict the Winner

[花花酱](https://www.bilibili.com/video/BV1kW411d7R2?spm_id_from=333.999.0.0)

###  3.326. <a name='TheMaze'></a>490 The Maze

[小明](https://www.bilibili.com/video/BV1az4y1f7Hn?spm_id_from=333.999.0.0)

###  3.327. <a name='TargetSum'></a>494. Target Sum

[花花酱](https://www.bilibili.com/video/BV1WW411C7Mp?spm_id_from=333.999.0.0)

[花花酱 下](https://www.bilibili.com/video/BV1WW411C7Mr?spm_id_from=333.999.0.0)

###  3.328. <a name='TeemoAttacking'></a>495 Teemo Attacking

[小明](https://www.bilibili.com/video/BV1LK4y1Y75e?spm_id_from=333.999.0.0)

###  3.329. <a name='INextGreaterElementI'></a>496. 下一个更大元素 I (Next Greater Element I)

[洛阳](https://www.bilibili.com/video/BV1Ce411W7pW?spm_id_from=333.999.0.0)

###  3.330. <a name='RandomPointinNon-overlapping'></a>497 Random Point in Non-overlapping

[小明](https://www.bilibili.com/video/BV12K4y1Y7r6?spm_id_from=333.999.0.0)

###  3.331. <a name='KeyboardRow'></a>500. Keyboard Row

[小梦想家](https://www.bilibili.com/video/BV1vJ411X7BR?spm_id_from=333.999.0.0)

###  3.332. <a name='NextGreaterElementII'></a>503-Next Greater Element II

[哈哈哈](https://www.bilibili.com/video/BV197411L77N?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1k5411t7Pa?spm_id_from=333.999.0.0)

###  3.333. <a name='Base7'></a>504-Base 7

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7o5?spm_id_from=333.999.0.0)

###  3.334. <a name='FibonacciNumber'></a>509. Fibonacci Number

[1:30 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15y4y147Re?spm_id_from=333.999.0.0)

```scala
/**
* chosen solution
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution0 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* iterative - bottom up with memorization
* time complexity O(N)
* space complexity O(N)
*/

object Solution1 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1
        (2 to N).foreach(n => cache(n) = cache(n -1) + cache(n -2))
        cache(N)
    }
}

/**
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution1-2 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* recursive - top-down with memorization
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution2 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1

        def _fib(n: Int):Int = {
            if(n <= 1) return n
            
            if(cache(n) != 0) cache(n)
            else {
                cache(n) = _fib(n-1) + _fib(n-2)
                cache(n)
            }
        }
        _fib(N)
        
    }
}



/**
* recursive version - bottom up
* time complexity: O(2^N）
* space complexity: O(N)
*/

object Solution3 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
           fib(N - 1) + fib(N - 2)
        }
    }
}


/**
* matrix operation with pow operation
* memo
*   n > 1
*   | fn   |    | 1  1  |^ (n -1)  | 1 |
*   | fn-1 |  = | 1  0  |          | 1 |
* time complexity: O(logN)
* space complexity: O(logN) due to stack size
*/
object Solution4 {
  def fib(N: Int): Int = {
    if (N <= 1) return N

    val matrix = Array.ofDim[Int](2, 2)
    matrix(0)(0) = 1
    matrix(0)(1) = 1
    matrix(1)(0) = 1
    matrix(1)(1) = 0

    val identityMatrix = Array.tabulate(2, 2) {
      case (i, j) if i == j => 1
      case _ => 0
    }
    val retMatrix = matrixPow(identityMatrix, matrix, N - 1)
    retMatrix(0)(0)
  }

  @annotation.tailrec
  def matrixPow(current: Array[Array[Int]], base: Array[Array[Int]], pow: Int): Array[Array[Int]] = {
    if (pow == 0) current
    else {
      if ((pow & 1) == 1) {
        val newCurrent = multiply(current, base)
        val newBase = multiply(base, base)

        matrixPow(newCurrent, newBase, pow / 2)
      } else {
        val newBase = multiply(base, base)
        matrixPow(current, newBase, pow / 2)
      }
    }

  }

  def multiply(a: Array[Array[Int]], b: Array[Array[Int]]): Array[Array[Int]] = {
    val a00 = a(0)(0) * b(0)(0) + a(0)(1) * b(1)(0)
    val a01 = a(0)(0) * b(0)(1) + a(0)(1) * b(1)(1)
    val a10 = a(1)(0) * b(0)(0) + a(1)(1) * b(1)(0)
    val a11 = a(1)(0) * b(0)(1) + a(1)(1) * b(1)(1)
    a(0)(0) = a00
    a(0)(1) = a01
    a(1)(0) = a10
    a(1)(1) = a11
    a
  }
}
```

###  3.335. <a name='LongestPalindromicSubsequence'></a>516. Longest Palindromic Subsequence

[花花酱](https://www.bilibili.com/video/BV18W411d7k2?spm_id_from=333.999.0.0)

###  3.336. <a name='CoinChange2'></a>518 Coin Change 2

[小明](https://www.bilibili.com/video/BV1jC4y1a7YT?spm_id_from=333.999.0.0)

###  3.337. <a name='DetectCapital'></a>520. Detect Capital

[小梦想家](https://www.bilibili.com/video/BV1NJ41197da?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xT4y1j7G4?spm_id_from=333.999.0.0)

###  3.338. <a name='ContiguousArray'></a>525. Contiguous Array

[花花酱](https://www.bilibili.com/video/BV14W411d7SD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV185411t7tu?spm_id_from=333.999.0.0)

###  3.339. <a name='BeautifulArrangement'></a>526 Beautiful Arrangement

[小明](https://www.bilibili.com/video/BV1DK411M7QR?spm_id_from=333.999.0.0)

###  3.340. <a name='RandomPickwithWeight'></a>528 Random Pick with Weight

[小明](https://www.bilibili.com/video/BV1UV411r7MK?spm_id_from=333.999.0.0)

###  3.341. <a name='MinimumAbsoluteDifferenceinBST'></a>530. Minimum Absolute Difference in BST

[花花酱](https://www.bilibili.com/video/BV1fW411k7eT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1FJ41147BB?spm_id_from=333.999.0.0)

###  3.342. <a name='K-diffPairsinanArray'></a>532 K-diff Pairs in an Array

[小明](https://www.bilibili.com/video/BV1MV41127o1?spm_id_from=333.999.0.0)

###  3.343. <a name='EncodeandDecodeTinyURL'></a>535. Encode and Decode TinyURL

[小梦想家](https://www.bilibili.com/video/BV1hb411e7zp?spm_id_from=333.999.0.0)

###  3.344. <a name='ComplexNumberMultiplicatin'></a>537 Complex Number Multiplicatin

[小明](https://www.bilibili.com/video/BV1sP4y1p7Px?spm_id_from=333.999.0.0)

###  3.345. <a name='ConvertBSTtoGreaterTree'></a>538 Convert BST to Greater Tree

[小明](https://www.bilibili.com/video/BV1k541177bt?spm_id_from=333.999.0.0)

###  3.346. <a name='SingleElementinaSortedArray540-'></a>540. Single Element in a Sorted Array 540-有序数组中的单一元素

[花花酱](https://www.bilibili.com/video/BV1gW411y7N3?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1P64y1F7cd?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Tg4y1B7Va?spm_id_from=333.999.0.0)

###  3.347. <a name='Matrix'></a>542. 01 矩阵 01 Matrix 

[官方](https://www.bilibili.com/video/BV1cZ4y1s727?spm_id_from=333.999.0.0)

###  3.348. <a name='DiameterofBinaryTree'></a>543 Diameter of Binary Tree

[小明](https://www.bilibili.com/video/BV12K4y1r78T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qA411t7LR?spm_id_from=333.999.0.0)

###  3.349. <a name='RemoveBoxes'></a>546 Remove Boxes

[花花酱](https://www.bilibili.com/video/BV11W411Z7jG?spm_id_from=333.999.0.0)

###  3.350. <a name='-1'></a>547-朋友圈

[哈哈哈](https://www.bilibili.com/video/BV1Ta411F7rk?spm_id_from=333.999.0.0)

```scala


/**
* union & find: implement both union by rank and path compression
* time complexity : 
*   in union & find each op:
*           find: very very close to O(1) amortized
*           union: very very close to O(1) amortized
*   the entire ：
*       O(n + M), n is node size, M is the times we call Union operation which cause O(1) 
*       n (constructor) + M (call union times)
*/

object Solution1 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    unionFind.counter

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)
  var counter = M

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
    counter -= 1
  }
}

/**
* union & find: without counter in union&find to record current cluster
*       O(n + M + n), n is node size, M is the times we call Union operation which cause O(1) 
*       n (construct union & find ) + M (call union times)  + n (n time call findRoot)
*/
object Solution1-2 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    M.indices.map(unionFind.findRoot).distinct.size

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
  }
}


```

###  3.351. <a name='BrickWall'></a>554 Brick Wall

[小明](https://www.bilibili.com/video/BV1mo4y1f7wc?spm_id_from=333.999.0.0)

###  3.352. <a name='NextGreaterElementIII'></a>556 Next Greater Element III

[小明](https://www.bilibili.com/video/BV19t4y167yb?spm_id_from=333.999.0.0)

###  3.353. <a name='SubarraySumEqualsKK'></a>560. Subarray Sum Equals K 和为K的子数组

[花花酱](https://www.bilibili.com/video/BV1XW411d71i?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d54y127ri?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vK4y1k7ku?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV13t4y1y7ya?spm_id_from=333.999.0.0)

###  3.354. <a name='BinaryTreeTilt'></a>563 Binary Tree Tilt

[小明](https://www.bilibili.com/video/BV1KV41117ho?spm_id_from=333.999.0.0)

###  3.355. <a name='PermutationinString567-'></a>567. Permutation in String 567-字符串的排列

[花花酱](https://www.bilibili.com/video/BV14W411d7g6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1z54y1C7qB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV175411E761?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1154y1X7qB?spm_id_from=333.999.0.0)

```scala


/**
* my first commitment: sliding window: hashcode with build-in sliding method
*/
object Solution1 {
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1Length = s1.length
      val s1Hash = s1.groupBy(identity).mapValues(_.length).toMap.hashCode

      s2.sliding(s1Length).exists(seq => seq.groupBy(identity).mapValues(_.length).toMap.hashCode == s1Hash)
    }
}


/**
* optimize from 1-1 : maintain sliding window and hashmap by my self
* time complexity: O(s1.length + s2.length)
* space complexity: O(s1.distinct.length)
*/
object Solution1-2 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1HashCode = s1.groupBy(identity).mapValues(_.length).toMap.hashCode
      val s2Map = mutable.Map.empty[Char, Int]
      
      (0 until s2.length).exists {
        case idx if idx < s1.length =>
          val char = s2(idx)
          mapIncrement(s2Map, char)
          s2Map.hashCode == s1HashCode
        case idx => 
          val rightChar = s2(idx)
          val leftChar = s2(idx - s1.length)
          mapIncrement(s2Map, rightChar)
          mapDecrement(s2Map, leftChar) 
          s2Map.hashCode == s1HashCode
      }
    }
    def mapIncrement(map: mutable.Map[Char, Int], char: Char): Unit = {
      map.get(char) match {
            case Some(v) => map.update(char, v + 1)
            case None => map.update(char, 1)
      }
    }
    def mapDecrement(map: mutable.Map[Char, Int], char: Char) = map.get(char) match {
      case Some(v) if v == 1 => map.remove(char)
      case Some(v) => map.update(char, v - 1)
      case None =>
    }
}

/**
* sliding windows: using only 1 map to record differential
* 1. if diff map is empty, s2 contains the permutation of s1
* 2. initial map with foreach instead of groupBy witch is time consuming
* time complexity (l1 + l2)
*/
object Solution1-3 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val diffMap = mutable.Map.empty[Char, Int]
      s1.foreach(mapUpdate(diffMap, _, 1))
      
      (0 until s2.length).exists {case idx =>
        if (idx >= s1.length) {
          val leftChar = s2(idx - s1.length)
          mapUpdate(diffMap, leftChar, 1)
        }
        val rightChar = s2(idx)
        mapUpdate(diffMap, rightChar, -1)
        diffMap.isEmpty
      }
    }
    def mapUpdate(map: mutable.Map[Char, Int], char: Char, value: Int): Unit = {
      map.get(char) match {
            case Some(v) if v + value == 0 => map.remove(char)
            case Some(v) => map.update(char, v + value)
            case None => map.update(char, value)
      }
    }
}
```

###  3.356. <a name='-1'></a>572-另一个树的子树

[哈哈哈](https://www.bilibili.com/video/BV1cA411t7zD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1wt4y197aB?spm_id_from=333.999.0.0)

###  3.357. <a name='DistributeCandies'></a>575 Distribute Candies

[小明](https://www.bilibili.com/video/BV11i4y1T7Pr?spm_id_from=333.999.0.0)

###  3.358. <a name='OutofBoundaryPaths'></a>576. Out of Boundary Paths

[花花酱](https://www.bilibili.com/video/BV18W411d7Cf?spm_id_from=333.999.0.0)

###  3.359. <a name='ShortestUnsortedContinuousSuba'></a>581 Shortest Unsorted Continuous Suba

[小明](https://www.bilibili.com/video/BV1Y54y1h7Xa?spm_id_from=333.999.0.0)

###  3.360. <a name='N-aryTreePreorderTraversal'></a>589 N-ary Tree Preorder Traversal

[小明](https://www.bilibili.com/video/BV1io4y1f7qT?spm_id_from=333.999.0.0)

###  3.361. <a name='ValidSquare'></a>593 Valid Square

[小明](https://www.bilibili.com/video/BV1j5411V73U?spm_id_from=333.999.0.0)

###  3.362. <a name='LongestHarmoniousSubsequence'></a>594 Longest Harmonious Subsequence

[小明](https://www.bilibili.com/video/BV1Pp4y1p7ss?spm_id_from=333.999.0.0)

###  3.363. <a name='CanPlaceFlowers'></a>605 Can Place Flowers

[小明](https://www.bilibili.com/video/BV1Uz4y1k7xU?spm_id_from=333.999.0.0)

###  3.364. <a name='TaskScheduler'></a>621. Task Scheduler

[花花酱](https://www.bilibili.com/video/BV1Wt411Y7Y9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1LZ4y1M7Bg?spm_id_from=333.999.0.0)

###  3.365. <a name='DesignCircularQueue'></a>622 Design Circular Queue

[小明](https://www.bilibili.com/video/BV1kV411n7Uk?spm_id_from=333.999.0.0)

###  3.366. <a name='AddOneRowtoTree'></a>623 Add One Row to Tree

[小明](https://www.bilibili.com/video/BV1AK4y1U7ud?spm_id_from=333.999.0.0)

###  3.367. <a name='SumofSquareNumbers'></a>633-Sum of Square Numbers

[哈哈哈](https://www.bilibili.com/video/BV1a7411h7on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qh411i7Yh?spm_id_from=333.999.0.0)

###  3.368. <a name='ExclusiveTimeofFunctions'></a>636. Exclusive Time of Functions

[花花酱](https://www.bilibili.com/video/BV1PW411o7Bh?spm_id_from=333.999.0.0)

###  3.369. <a name='AverageofLevelsinBinaryTree'></a>637 Average of Levels in Binary Tree

[小明](https://www.bilibili.com/video/BV1eb4y1976M?spm_id_from=333.999.0.0)

###  3.370. <a name='DecodeWaysII'></a>639. Decode Ways II

[花花酱](https://www.bilibili.com/video/BV1YW411r75q?spm_id_from=333.999.0.0)

###  3.371. <a name='MaximumAverageSubarrayI'></a>643. Maximum Average Subarray I

[小梦想家](https://www.bilibili.com/video/BV1dV411k7i6?spm_id_from=333.999.0.0)

###  3.372. <a name='-1'></a>645-错误的集合

[哈哈哈](https://www.bilibili.com/video/BV1az411e7zU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1479j?spm_id_from=333.999.0.0)

###  3.373. <a name='-1'></a>646-最长数对链

[哈哈哈](https://www.bilibili.com/video/BV1rz411q7pZ?spm_id_from=333.999.0.0)

###  3.374. <a name='PalindromicSubstrings'></a>647 Palindromic Substrings

[小明](https://www.bilibili.com/video/BV1g54y1h7uv?spm_id_from=333.999.0.0)

###  3.375. <a name='-1'></a>650-只有两个键的键盘

[哈哈哈](https://www.bilibili.com/video/BV1254y1z7ze?spm_id_from=333.999.0.0)

###  3.376. <a name='FindDuplicateSubtrees'></a>652. Find Duplicate Subtrees

[花花酱](https://www.bilibili.com/video/BV1cW411y7d1?spm_id_from=333.999.0.0)

###  3.377. <a name='TwoSumIV'></a>653. Two Sum IV

[小梦想家](https://www.bilibili.com/video/BV1Qz4y197h1?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AQ4y117mc?spm_id_from=333.999.0.0)

###  3.378. <a name='MaximumWidthofBinaryTree'></a>662. Maximum Width of Binary Tree

[花花酱](https://www.bilibili.com/video/BV1cv411q7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16a4y1h7fG?spm_id_from=333.999.0.0)

###  3.379. <a name='BeautifulArrangementII'></a>667 Beautiful Arrangement II

[小明](https://www.bilibili.com/video/BV1j54y1b7Br?spm_id_from=333.999.0.0)

###  3.380. <a name='KthSmallestNumberinMultiplicationTable'></a>668. Kth Smallest Number in Multiplication Table

[花花酱](https://www.bilibili.com/video/BV17W411C7ai?spm_id_from=333.999.0.0)

###  3.381. <a name='TrimaBinarySearchTree'></a>669 Trim a Binary Search Tree

[小明](https://www.bilibili.com/video/BV19y4y1J7fu?spm_id_from=333.999.0.0)

###  3.382. <a name='NumberofLongestIncreasingSubse'></a>673 Number of Longest Increasing Subse

[小明](https://www.bilibili.com/video/BV1gT4y1F7y3?spm_id_from=333.999.0.0)

###  3.383. <a name='ValidParenthesisString'></a>678 Valid Parenthesis String

[小明](https://www.bilibili.com/video/BV1ap4y1X7nu?spm_id_from=333.999.0.0)

###  3.384. <a name='ValidPalindromeII'></a>680-Valid Palindrome II

[哈哈哈](https://www.bilibili.com/video/BV167411h7x1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y147xn?spm_id_from=333.999.0.0)

###  3.385. <a name='KEmptySlots'></a>683. K Empty Slots

[花花酱](https://www.bilibili.com/video/BV1Jb411k7Yu?spm_id_from=333.999.0.0)

###  3.386. <a name='RedundantConnection684-'></a>684. Redundant Connection 684-冗余连接

[花花酱](https://www.bilibili.com/video/BV1mt411J79j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1oe411p7qF?spm_id_from=333.999.0.0)

###  3.387. <a name='RedundantConnectionII'></a>685. Redundant Connection II

[花花酱](https://www.bilibili.com/video/BV1St411J7Ur?spm_id_from=333.999.0.0)

###  3.388. <a name='LongestUnivaluePath'></a>687. Longest Univalue Path

[花花酱](https://www.bilibili.com/video/BV1wt411r7Pr?spm_id_from=333.999.0.0)

###  3.389. <a name='KnightProbabilityinChessboard'></a>688. Knight Probability in Chessboard

[花花酱](https://www.bilibili.com/video/BV1Hb411c7mu?spm_id_from=333.999.0.0)

###  3.390. <a name='EmployeeImportance'></a>690. Employee Importance

[花花酱](https://www.bilibili.com/video/BV1Ut411J7uC?spm_id_from=333.999.0.0)

###  3.391. <a name='TopKFrequentWords'></a>692. Top K Frequent Words

[花花酱](https://www.bilibili.com/video/BV1Mt41137eL?spm_id_from=333.999.0.0)

###  3.392. <a name='-1'></a>695-岛屿的最大面积

[哈哈哈](https://www.bilibili.com/video/BV1s54y1B77k?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wz4y1R7e6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1k64y1c798?spm_id_from=333.999.0.0)

###  3.393. <a name='CountBinarySubstrings'></a>696 Count Binary Substrings

[小明](https://www.bilibili.com/video/BV14p4y1b7nV?spm_id_from=333.999.0.0)

###  3.394. <a name='FallingSquares'></a>699. Falling Squares

[花花酱](https://www.bilibili.com/video/BV1Lt41137EM?spm_id_from=333.999.0.0)

###  3.395. <a name='SearchinaBinarySearchTree'></a>700 Search in a Binary Search Tree

[小明](https://www.bilibili.com/video/BV14z411e76U?spm_id_from=333.999.0.0)

###  3.396. <a name='InsertintoaBinarySearchTree'></a>701 Insert into a Binary Search Tree

[小明](https://www.bilibili.com/video/BV1q54y1k76s?spm_id_from=333.999.0.0)

###  3.397. <a name='KthLargestElementinaStreamK'></a>703.Kth Largest Element in a Stream数据流中的第K大元素

[图灵](https://www.bilibili.com/video/BV1g5411w7o8?spm_id_from=333.999.0.0)

```scala
/**
* using min heap
*/
class KthLargest(_k: Int, _nums: Array[Int]) {
    private val pq = scala.collection.mutable.PriorityQueue.empty[Int](Ordering[Int].reverse)
    val k = _k
    _nums.foreach(add)


    def add(`val`: Int): Int = {
        if (pq.size < k)
            /* if only add one element at once, += is more effective than enqueue op */
            pq += `val`
            // pq.enqueue(`val`)
        else if(pq.head < `val`){
            pq.dequeue
            pq += `val`
            // pq.enqueue(`val`)
        }
        // println(pq.clone.dequeueAll)
        pq.head
               
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(`val`)
 */
```

###  3.398. <a name='BinarySearch'></a>704.Binary Search二分查找

[图灵](https://www.bilibili.com/video/BV1Dh411v7yT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qa4y157E4?spm_id_from=333.999.0.0)

```scala

/**
* my first commitment:
* time complexity: O(logn)
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        println(left, right)
        val mid: Int = left  + (right - left) / 2
        if(nums(mid) == target){
          ans = mid
        } else if(target > nums(mid)) {
          left = mid + 1
        } else {
          right = mid - 1
        }
 
      }
      ans
    }
}

/**
* recursive version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
        search(nums, target, 0, nums.length - 1)
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      
      val mid = left + (right - left) / 2
      if (nums(mid) == target) 
        mid
      else if (target > nums(mid))
        search(nums, target, mid + 1, right)
      else 
        search(nums, target, left, right - 1)
      
    }
}
```

###  3.399. <a name='DesignHashSet'></a>705 Design HashSet

[小明](https://www.bilibili.com/video/BV1hV411z73p?spm_id_from=333.999.0.0)

###  3.400. <a name='DesignHashMap'></a>706. Design HashMap设计哈希映射

[图灵](https://www.bilibili.com/video/BV1Ho4y1Q7cr?spm_id_from=333.999.0.0)

###  3.401. <a name='DesignLinkedList'></a>707. Design Linked List

[花花酱](https://www.bilibili.com/video/BV1yW411Z7dV?spm_id_from=333.999.0.0)

###  3.402. <a name='MinimumASCIIDeleteSumforTwoStrings'></a>712. Minimum ASCII Delete Sum for Two Strings

[花花酱](https://www.bilibili.com/video/BV17W411d7m2?spm_id_from=333.999.0.0)

###  3.403. <a name='SubarrayProductLessThanK'></a>713 Subarray Product Less Than K

[小明](https://www.bilibili.com/video/BV1T5411j7tC?spm_id_from=333.999.0.0)

###  3.404. <a name='-1'></a>714-买卖股票的最佳时机含手续费

[哈哈哈](https://www.bilibili.com/video/BV1WK4y1E7mP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1t54y187Qy?spm_id_from=333.999.0.0)

```scala
/**
* my first commitment
* dynamic programming
*     dp(i)(j) means the best profit we can have at i-th day in different state un-holding stock or holding a share of stock.
* 
*  memo:
*    this problem is similar to problem no 122
*  time complexity: O(N)
*  space complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        if(prices == null || prices.isEmpty) return 0
        
        /*
        *  0 for un-holding any stack
        *  1 for holding a share of stock
        */
        val dp = Array.tabulate(prices.length, 2) {
            case (0, 0) => 0
            case (0, 1) => -prices(0)
            case _ => 0
        }
        
        // 0: without holding, 1 holding
        for(i <- 1 until prices.length) {
            /** only pay the transition fee in selling a share of stock */
            dp(i)(0) = dp(i - 1)(0) max (dp(i - 1)(1) + prices(i) - fee)
            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i))
        }
        dp.last(0) // last time's state 0
        
    }
}

/**
* dynamic programming: only create an array keeping holding and un-holding
* time complexity: O(N)
* space complexity:  O(1)
*/
object Solution1-1 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        if(prices == null || prices.isEmpty) return 0
        val dp = Array.ofDim[Int](2)
        dp(0) = 0
        dp(1) = -prices(0)
        // 0 un-holding, 1 holding
        for(i <- 1 until prices.length){
        /*
        * it may causes a problem here, because we overwrite the previous dp(0) by new state i value and dp(1) would utilizes dp(0) which was overwritten 
        */
            dp(0) = dp(0) max (dp(1) + prices(i) - fee)
            dp(1) = dp(1) max (dp(0) - prices(i))
        }
        dp(0)
    }
}

/**
* dynamic programming 
* function programming
*/
object Solution2 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        val (unholding, holding) = prices.foldLeft((0, Int.MinValue)){
            case ((unholding, holding), price) =>
            (
            // avoiding overflow
                if((price - fee) > 0) unholding max (holding + price - fee) else unholding,
                holding max (unholding - price)
            )
        }
        unholding
    }
}
```

###  3.405. <a name='RangeModule'></a>715. Range Module

[花花酱](https://www.bilibili.com/video/BV1jt411379W?spm_id_from=333.999.0.0)

###  3.406. <a name='FindK-thSmallestPairDistance'></a>719. Find K-th Smallest Pair Distance

[花花酱](https://www.bilibili.com/video/BV1zb411u7iP?spm_id_from=333.999.0.0)

###  3.407. <a name='LongestWordinDictionary'></a>720. Longest Word in Dictionary

[花花酱](https://www.bilibili.com/video/BV1vW411r75D?spm_id_from=333.999.0.0)

###  3.408. <a name='FindPivotIndex'></a>724. Find Pivot Index

[花花酱](https://www.bilibili.com/video/BV1KW411S7nG?spm_id_from=333.999.0.0)

###  3.409. <a name='SplitLinkedListinParts'></a>725. Split Linked List in Parts

[花花酱](https://www.bilibili.com/video/BV1KW411S7ti?spm_id_from=333.999.0.0)

###  3.410. <a name='NumberofAtoms'></a>726. Number of Atoms

[花花酱](https://www.bilibili.com/video/BV11W411U7KT?spm_id_from=333.999.0.0)

###  3.411. <a name='CountDifferentPalindromicSubsequences'></a>730. Count Different Palindromic Subsequences

[花花酱](https://www.bilibili.com/video/BV12W41167vQ?spm_id_from=333.999.0.0)

###  3.412. <a name='MyCalendarIII'></a>732. My Calendar III

[花花酱](https://www.bilibili.com/video/BV1fW411k75b?spm_id_from=333.999.0.0)

###  3.413. <a name='FloodFill'></a>733. 图像渲染 Flood Fill

[花花酱](https://www.bilibili.com/video/BV1yW41167S4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fp4y1v7Pn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1p7vH?spm_id_from=333.999.0.0)

###  3.414. <a name='AsteroidCollision'></a>735 Asteroid Collision

[小明](https://www.bilibili.com/video/BV1jT4y1F76n?spm_id_from=333.999.0.0)

###  3.415. <a name='SentenceSimilarityII'></a>737. Sentence Similarity II

[花花酱](https://www.bilibili.com/video/BV1qW41167iB?spm_id_from=333.999.0.0)

###  3.416. <a name='DailyTemperatures'></a>739-Daily Temperatures

[哈哈哈](https://www.bilibili.com/video/BV1Q7411L7w8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ov411z7rM?spm_id_from=333.999.0.0)

###  3.417. <a name='DeleteandEarn'></a>740. Delete and Earn

[24:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1xW41167b5?spm_id_from=333.999.0.0)

###  3.418. <a name='CherryPickup'></a>741. Cherry Pickup

[花花酱](https://www.bilibili.com/video/BV1tW41167jy?spm_id_from=333.999.0.0)

###  3.419. <a name='NetworkDelayTime'></a>743. Network Delay Time

[花花酱](https://www.bilibili.com/video/BV1UW411r7S8?spm_id_from=333.999.0.0)

###  3.420. <a name='PrefixandSuffixSearch'></a>745. Prefix and Suffix Search

[花花酱](https://www.bilibili.com/video/BV1TW411k7PY?spm_id_from=333.999.0.0)

###  3.421. <a name='MinCostClimbingStairs'></a>746. Min Cost Climbing Stairs

[7:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1VW411y7Dq?spm_id_from=333.999.0.0)

###  3.422. <a name='ShortestCompletingWord'></a>748. Shortest Completing Word

[花花酱](https://www.bilibili.com/video/BV15W411y7sJ?spm_id_from=333.999.0.0)

###  3.423. <a name='OpentheLock'></a>752. Open the Lock

[花花酱](https://www.bilibili.com/video/BV1NW411y74z?spm_id_from=333.999.0.0)

###  3.424. <a name='PartitionLabels'></a>763 Partition Labels

[小明](https://www.bilibili.com/video/BV1Ca4y177LW?spm_id_from=333.999.0.0)

###  3.425. <a name='CouplesHoldingHands'></a>765. 情侣牵手 Couples Holding Hands

[官方](https://www.bilibili.com/video/BV1pv411Y7wX?spm_id_from=333.999.0.0)

###  3.426. <a name='MaxChunksToMakeSorted'></a>769. Max Chunks To Make Sorted

[花花酱](https://www.bilibili.com/video/BV1LW411C7nD?spm_id_from=333.999.0.0)

###  3.427. <a name='JewelsandStones'></a>771 Jewels and Stones

[小明](https://www.bilibili.com/video/BV1RC4y1W7yH?spm_id_from=333.999.0.0)

###  3.428. <a name='SlidingPuzzle'></a>773. Sliding Puzzle

[花花酱](https://www.bilibili.com/video/BV1PW411o7g4?spm_id_from=333.999.0.0)

###  3.429. <a name='GlobalandLocalInversions'></a>775. Global and Local Inversions

[花花酱](https://www.bilibili.com/video/BV1JW411d75t?spm_id_from=333.999.0.0)

###  3.430. <a name='SwiminRisingWater'></a>778. Swim in Rising Water

[花花酱](https://www.bilibili.com/video/BV1ab411k7TH?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kv4y1f7to?spm_id_from=333.999.0.0)

###  3.431. <a name='LetterCasePermutation'></a>784. Letter Case Permutation

[花花酱](https://www.bilibili.com/video/BV1wW411o7WK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sv411a7Gx?spm_id_from=333.999.0.0)

###  3.432. <a name='-1'></a>785-判断二分图

[哈哈哈](https://www.bilibili.com/video/BV1KQ4y1N72Z?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11r4y1P7Wr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1254y1i7Ut?spm_id_from=333.999.0.0)

###  3.433. <a name='K-thSmallestPrimeFraction'></a>786. K-th Smallest Prime Fraction

[花花酱](https://www.bilibili.com/video/BV1AW411o7oi?spm_id_from=333.999.0.0)

###  3.434. <a name='CheapestFlightsWithinKStops'></a>787. Cheapest Flights Within K Stops

[花花酱](https://www.bilibili.com/video/BV13W411o7wc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DZ4y1H7oH?spm_id_from=333.999.0.0)

###  3.435. <a name='DominoandTrominoTiling'></a>790. Domino and Tromino Tiling

[花花酱](https://www.bilibili.com/video/BV13W411o7AW?spm_id_from=333.999.0.0)

###  3.436. <a name='NumberofMatchingSubsequences'></a>792. Number of Matching Subsequences

[花花酱](https://www.bilibili.com/video/BV13W411o7Af?spm_id_from=333.999.0.0)

###  3.437. <a name='AllPathsFromSourcetoTarget'></a>797 All Paths From Source to Target

[小明](https://www.bilibili.com/video/BV1qa4y1E7sg?spm_id_from=333.999.0.0)

###  3.438. <a name='ChampagneTower'></a>799 Champagne Tower

[小明](https://www.bilibili.com/video/BV1Da411A7u5?spm_id_from=333.999.0.0)

###  3.439. <a name='MinimumSwapsToMakeSequencesIncreasing'></a>801. Minimum Swaps To Make Sequences Increasing

[花花酱](https://www.bilibili.com/video/BV1FW411o7tL?spm_id_from=333.999.0.0) 

###  3.440. <a name='BricksFallingWhenHit'></a>803. Bricks Falling When Hit 

[花花酱](https://www.bilibili.com/video/BV13W411o7kA?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xv411W74B?spm_id_from=333.999.0.0)

###  3.441. <a name='UniqueMorseCodeWords'></a>804 Unique Morse Code Words

[小明](https://www.bilibili.com/video/BV1RD4y1Q7AM?spm_id_from=333.999.0.0)

###  3.442. <a name='LargestSumofAverages'></a>813. Largest Sum of Averages

[花花酱](https://www.bilibili.com/video/BV1XW411d7RB?spm_id_from=333.999.0.0)

###  3.443. <a name='BusRoutes'></a>815. Bus Routes

[花花酱](https://www.bilibili.com/video/BV1QW411d794?spm_id_from=333.999.0.0)

###  3.444. <a name='LinkedListComponents'></a>817. Linked List Components

[花花酱](https://www.bilibili.com/video/BV1cW411o7Eu?spm_id_from=333.999.0.0)

###  3.445. <a name='RaceCar'></a>818. Race Car (上)

[花花酱](https://www.bilibili.com/video/BV1cW411o7Tb?spm_id_from=333.999.0.0)

###  3.446. <a name='ShortestDistancetoaCharacter'></a>821 Shortest Distance to a Character

[小明](https://www.bilibili.com/video/BV1gy4y1Y784?spm_id_from=333.999.0.0)

###  3.447. <a name='BinaryTreesWithFactors'></a>823. Binary Trees With Factors

[花花酱](https://www.bilibili.com/video/BV1CW411d7RX?spm_id_from=333.999.0.0)

###  3.448. <a name='GoatLatin'></a>824 Goat Latin

[小明](https://www.bilibili.com/video/BV1Th411o782?spm_id_from=333.999.0.0)

###  3.449. <a name='MakingALargeIsland'></a>827. Making A Large Island

[花花酱](https://www.bilibili.com/video/BV1mW411d7rc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Cg4117727?spm_id_from=333.999.0.0)

###  3.450. <a name='FlippinganImage'></a>832 Flipping an Image

[小明](https://www.bilibili.com/video/BV1q54y1r7f3?spm_id_from=333.999.0.0)

###  3.451. <a name='ImageOverlap'></a>835 Image Overlap

[小明](https://www.bilibili.com/video/BV1NK4y1a7Yf?spm_id_from=333.999.0.0)

###  3.452. <a name='New21Game'></a>837. 新 21 点 New 21 Game

[官方](https://www.bilibili.com/video/BV1Sz4y197cA?spm_id_from=333.999.0.0)

###  3.453. <a name='KeysandRooms'></a>841 Keys and Rooms

[小明](https://www.bilibili.com/video/BV1Wb4y1Q7hE?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1HK411F7JQ?spm_id_from=333.999.0.0)

###  3.454. <a name='SplitArrayintoFibonacciSequence'></a>842. Split Array into Fibonacci Sequence

[花花酱](https://www.bilibili.com/video/BV1ZJ411H7t4?spm_id_from=333.999.0.0)

###  3.455. <a name='BackspaceStringCompare'></a>844 Backspace String Compare

[小明](https://www.bilibili.com/video/BV1aC4y1s7LK?spm_id_from=333.999.0.0)

###  3.456. <a name='LongestMountaininArray'></a>845 Longest Mountain in Array

[小明](https://www.bilibili.com/video/BV1zi4y1L7yV?spm_id_from=333.999.0.0)

###  3.457. <a name='ShortestPathVisitingAllNodes'></a>847 Shortest Path Visiting All Nodes

[花花酱](https://www.bilibili.com/video/BV1hW411d7MU?spm_id_from=333.999.0.0)

###  3.458. <a name='MaximizeDistancetoClosestPerson'></a>849 Maximize Distance to Closest Person

[小明](https://www.bilibili.com/video/BV1ZZ4y1G7iT?spm_id_from=333.999.0.0)

###  3.459. <a name='ScoreofParentheses'></a>856. Score of Parentheses

[花花酱](https://www.bilibili.com/video/BV1bW411d7gp?spm_id_from=333.999.0.0)

###  3.460. <a name='MirrorReflection'></a>858 Mirror Reflection

[小明](https://www.bilibili.com/video/BV1av411r7MW?spm_id_from=333.999.0.0)

###  3.461. <a name='BuddyStrings'></a>859 Buddy Strings

[小明](https://www.bilibili.com/video/BV1nz4y1o7Wo?spm_id_from=333.999.0.0)

###  3.462. <a name='AllNodesDistanceKinBinaryTree'></a>863. All Nodes Distance K in Binary Tree

[花花酱](https://www.bilibili.com/video/BV14W411d7mz?spm_id_from=333.999.0.0)

###  3.463. <a name='ShortestPathtoGetAllKeys'></a>864. Shortest Path to Get All Keys

[花花酱](https://www.bilibili.com/video/BV1LW411d7th?spm_id_from=333.999.0.0)

###  3.464. <a name='ReorderedPowerof2'></a>869 Reordered Power of 2

[小明](https://www.bilibili.com/video/BV1M64y1D78v?spm_id_from=333.999.0.0)

###  3.465. <a name='SmallestSubtreewithalltheDeepestNodes'></a>865. Smallest Subtree with all the Deepest Nodes

[花花酱](https://www.bilibili.com/video/BV14W411d7ZR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CV41187ZA?spm_id_from=333.999.0.0)

###  3.466. <a name='MinimumNumberofRefuelingStops'></a>871. Minimum Number of Refueling Stops

[花花酱](https://www.bilibili.com/video/BV1JW411d7VK?spm_id_from=333.999.0.0)

###  3.467. <a name='LengthofLongestFibonacciSubsequence'></a>873. Length of Longest Fibonacci Subsequence

[花花酱](https://www.bilibili.com/video/BV1jW411d79H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ab411i7wx?spm_id_from=333.999.0.0)

###  3.468. <a name='KokoEatingBananas'></a>875.Koko Eating Bananas科科吃香蕉

[图灵](https://www.bilibili.com/video/BV1iV411s7eU?spm_id_from=333.999.0.0)

###  3.469. <a name='MiddleoftheLinkedList'></a>876.Middle of the Linked List 链表的中间结点

[图灵](https://www.bilibili.com/video/BV1Kv411p7vf?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Pz41187WS?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK411T74X?spm_id_from=333.999.0.0)

###  3.470. <a name='StoneGame'></a>877 Stone Game

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Hr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xq4y1Q7uL?spm_id_from=333.999.0.0)

###  3.471. <a name='ProfitableSchemes'></a>879. Profitable Schemes

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Jt?spm_id_from=333.999.0.0)

###  3.472. <a name='DecodedStringatIndex'></a>880 Decoded String at Index

[小明](https://www.bilibili.com/video/BV1Tt4y1k7GJ?spm_id_from=333.999.0.0)

###  3.473. <a name='BoatstoSavePeople'></a>881 Boats to Save People

[小明](https://www.bilibili.com/video/BV1MT4y1K7yq?spm_id_from=333.999.0.0)

###  3.474. <a name='ReachableNodesInSubdividedGraph'></a>882. Reachable Nodes In Subdivided Graph

[花花酱](https://www.bilibili.com/video/BV11W411Z71N?spm_id_from=333.999.0.0)

###  3.475. <a name='PossibleBipartition'></a>886. Possible Bipartition

[花花酱](https://www.bilibili.com/video/BV1DW411Z7G6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FT4y1g77u?spm_id_from=333.999.0.0)

###  3.476. <a name='SuperEggDrop'></a>887. Super Egg Drop

[花花酱](https://www.bilibili.com/video/BV1Tv411i7cP?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ri4y1t78d?spm_id_from=333.999.0.0)

###  3.477. <a name='ConstructBinaryTreefromPreorderandPostorder'></a>889. Construct Binary Tree from Preorder and Postorder

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Qi?spm_id_from=333.999.0.0)

###  3.478. <a name='SumofSubsequenceWidths'></a>891. Sum of Subsequence Widths

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Yv?spm_id_from=333.999.0.0)

###  3.479. <a name='AllPossibleFullBinaryTrees'></a>894. All Possible Full Binary Trees

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Sb?spm_id_from=333.999.0.0)

###  3.480. <a name='MaximumFrequencyStack'></a>895. Maximum Frequency Stack

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Hp?spm_id_from=333.999.0.0)

###  3.481. <a name='BitwiseORsofSubarrays'></a>898. Bitwise ORs of Subarrays

[花花酱](https://www.bilibili.com/video/BV1kW411Z7HV?spm_id_from=333.999.0.0)

###  3.482. <a name='OnlineStockSpan'></a>901. Online Stock Span

[花花酱](https://www.bilibili.com/video/BV1kW411k77K?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Jg4y1B74H?spm_id_from=333.999.0.0)

###  3.483. <a name='NumbersAtMostNGivenDigitSet'></a>902 Numbers At Most N Given Digit Set

[小明](https://www.bilibili.com/video/BV19A411j7Wf?spm_id_from=333.999.0.0)

###  3.484. <a name='-1'></a>904-水果成篮

[哈哈哈](https://www.bilibili.com/video/BV19i4y1M7Xn?spm_id_from=333.999.0.0)

###  3.485. <a name='SortArrayByParity'></a>905 Sort Array By Parity

[小明](https://www.bilibili.com/video/BV1Xk4y117rK?spm_id_from=333.999.0.0)

###  3.486. <a name='SuperPalindromes'></a>906 Super Palindromes

[小明](https://www.bilibili.com/video/BV1LA41157Wf?spm_id_from=333.999.0.0)

###  3.487. <a name='SnakesandLadders'></a>909. Snakes and Ladders

[小梦想家](https://www.bilibili.com/video/BV1cy4y1W7u9?spm_id_from=333.999.0.0)

###  3.488. <a name='SmallestRangeII'></a>910 Smallest Range II

[小明](https://www.bilibili.com/video/BV1p5411H7mS?spm_id_from=333.999.0.0)

###  3.489. <a name='WordSubsetse'></a>916 Word Subsetse

[小明](https://www.bilibili.com/video/BV1vh411S7r3?spm_id_from=333.999.0.0)

###  3.490. <a name='MaximumSumCircularSub'></a>918 Maximum Sum Circular Sub

[小明](https://www.bilibili.com/video/BV1c5411s7jZ?spm_id_from=333.999.0.0)

###  3.491. <a name='SumWithMultiplicity'></a>923. 3Sum With Multiplicity 

[花花酱](https://www.bilibili.com/video/BV14t411o7QT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pv41187sq?spm_id_from=333.999.0.0)

###  3.492. <a name='FlipStringtoMonotoneIncreasing'></a>926. Flip String to Monotone Increasing

[花花酱](https://www.bilibili.com/video/BV1ft411R7qv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Vh411i7Wg?spm_id_from=333.999.0.0)

###  3.493. <a name='-1'></a>930-和相同的二元子数组(滑动窗口+前缀和)

[哈哈哈](https://www.bilibili.com/video/BV1iy4y1T7M3?spm_id_from=333.999.0.0)

###  3.494. <a name='NumberofRecentCalls'></a>933 Number of Recent Calls

[小明](https://www.bilibili.com/video/BV1gA41177jm?spm_id_from=333.999.0.0)

###  3.495. <a name='ShortestBridge'></a>934. Shortest Bridge

[花花酱](https://www.bilibili.com/video/BV19t411y7rL?spm_id_from=333.999.0.0)

###  3.496. <a name='StampingTheSequence'></a>936 Stamping The Sequence

[小明](https://www.bilibili.com/video/BV1d64y1D7fq?spm_id_from=333.999.0.0)

###  3.497. <a name='RangeSumofBST'></a>938 Range Sum of BST

[小明](https://www.bilibili.com/video/BV1WV411a7VR?spm_id_from=333.999.0.0)

###  3.498. <a name='ValidMountainArray'></a>941 Valid Mountain Array

[小明](https://www.bilibili.com/video/BV1n5411G7qs?spm_id_from=333.999.0.0)

###  3.499. <a name='FindtheShortestSuperstring'></a>943. Find the Shortest Superstring

[花花酱](https://www.bilibili.com/video/BV1yt411171k?spm_id_from=333.999.0.0)

###  3.500. <a name='Python-'></a>946-Python-栈的压入、弹出序列

[哈哈哈](https://www.bilibili.com/video/BV1JD4y1o7ZD?spm_id_from=333.999.0.0)

###  3.501. <a name='ValidateStackSequences'></a>946 Validate Stack Sequences

[小明](https://www.bilibili.com/video/BV1fz4y1y7rS?spm_id_from=333.999.0.0)

###  3.502. <a name='MostStonesRemovedwithSame'></a>947. 移除最多的同行或同列石头 Most Stones Removed with Same

[官方](https://www.bilibili.com/video/BV1Nr4y1K7Gj?spm_id_from=333.999.0.0)

###  3.503. <a name='BagofTokens'></a>948 Bag of Tokens

[小明](https://www.bilibili.com/video/BV1MK411P7K6?spm_id_from=333.999.0.0)

###  3.504. <a name='LargestTimeforGivenDigits'></a>949 Largest Time for Given Digits

[小明](https://www.bilibili.com/video/BV13v41117QS?spm_id_from=333.999.0.0)

###  3.505. <a name='LargestComponentSizebyCommo'></a>952 Largest Component Size by Commo

[小明](https://www.bilibili.com/video/BV1oK4y1h7Jt?spm_id_from=333.999.0.0)

###  3.506. <a name='VerifyinganAlienDictionary'></a>953 Verifying an Alien Dictionary

[小明](https://www.bilibili.com/video/BV1C64y1S7tT?spm_id_from=333.999.0.0)

###  3.507. <a name='ArrayofDoubledPairs'></a>954 Array of Doubled Pairs

[小明](https://www.bilibili.com/video/BV1Hq4y1S7xR?spm_id_from=333.999.0.0)

###  3.508. <a name='RegionsCutBySlashes'></a>959. 由斜杠划分区域 Regions Cut By Slashes

[官方](https://www.bilibili.com/video/BV1Ry4y117HD?spm_id_from=333.999.0.0)

###  3.509. <a name='LeastOperatorstoExpressNumber'></a>964. Least Operators to Express Number

[花花酱](https://www.bilibili.com/video/BV1Pt411k7qn?spm_id_from=333.999.0.0)

###  3.510. <a name='VowelSpellchecker'></a>966 Vowel Spellchecker

[小明](https://www.bilibili.com/video/BV1oK4y1T7kR?spm_id_from=333.999.0.0)

###  3.511. <a name='NumbersWithSameConsecutiveDifferences'></a>967. Numbers With Same Consecutive Differences

[花花酱](https://www.bilibili.com/video/BV1gt411B7oG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

###  3.512. <a name='BinaryTreeCameras'></a>968 Binary Tree Cameras

[小明](https://www.bilibili.com/video/BV1Q5411u72B?spm_id_from=333.999.0.0)

###  3.513. <a name='PancakeSorting'></a>969 Pancake Sorting

[小明](https://www.bilibili.com/video/BV1hk4y127yJ?spm_id_from=333.999.0.0)

###  3.514. <a name='FlipBinaryTreeToMatchPreorder'></a>971 Flip Binary Tree To Match Preorder

[小明](https://www.bilibili.com/video/BV1NB4y1P7qL?spm_id_from=333.999.0.0)

###  3.515. <a name='KClosestPointstoOrigin'></a>973 K Closest Points to Origin

[小明](https://www.bilibili.com/video/BV1Vf4y1278J?spm_id_from=333.999.0.0)

###  3.516. <a name='KSubarraySumsDivisiblebyK'></a>974. 和可被 K 整除的子数组 Subarray Sums Divisible by K 

[官方](https://www.bilibili.com/video/BV19z4y1X79a?spm_id_from=333.999.0.0)

###  3.517. <a name='OddEvenJump'></a>975. Odd Even Jump

[花花酱](https://www.bilibili.com/video/BV1pt411p7M4?spm_id_from=333.999.0.0)

###  3.518. <a name='MiddleoftheLinkedList-1'></a>976 Middle of the Linked List

[小明](https://www.bilibili.com/video/BV1N5411t7Xm?spm_id_from=333.999.0.0)

###  3.519. <a name='SquaresofaSortedArray'></a>977 Squares of a Sorted Array

[小明](https://www.bilibili.com/video/BV1EX4y1u7Mb?spm_id_from=333.999.0.0)

###  3.520. <a name='LongestTurbulentSubarray'></a>978. 最长湍流子数组 Longest Turbulent Subarray 

[官方](https://www.bilibili.com/video/BV1PV411i73Y?spm_id_from=333.999.0.0)

###  3.521. <a name='UniquePathsIII'></a>980. Unique Paths III 

[花花酱](https://www.bilibili.com/video/BV1yt41187Si?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oK4y1a7Qp?spm_id_from=333.999.0.0)

###  3.522. <a name='MinimumCostForTickets'></a>983 Minimum Cost For Tickets

[小明](https://www.bilibili.com/video/BV1Wz4y1f7hG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1WK4y1t7pP?spm_id_from=333.999.0.0)

###  3.523. <a name='IntervalListIntersections'></a>986 Interval List Intersections

[小明](https://www.bilibili.com/video/BV1wg4y1z7Xz?spm_id_from=333.999.0.0)

###  3.524. <a name='VerticalOrderTraversalofaBinary'></a>987 Vertical Order Traversal of a Binary

[小明](https://www.bilibili.com/video/BV1yZ4y1M7CL?spm_id_from=333.999.0.0)

###  3.525. <a name='SatisfiabilityofEqualityEquations'></a>990. 等式方程的可满足性 Satisfiability of Equality Equations 

[官方](https://www.bilibili.com/video/BV1gz411i7kD?spm_id_from=333.999.0.0)

###  3.526. <a name='K-1'></a>992-K 个不同整数的子数组

[哈哈哈](https://www.bilibili.com/video/BV1t44y1q7th?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xy4y1Y7GL?spm_id_from=333.999.0.0)

###  3.527. <a name='-1'></a>993. 二叉树的堂兄弟节点

[小明](https://www.bilibili.com/video/BV17t4y11725?spm_id_from=333.999.0.0)

###  3.528. <a name='-1'></a>994-腐烂的橘子

[哈哈哈](https://www.bilibili.com/video/BV1Yp4y1D7Kg?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1bB4y1A7tG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qk4y1m7fz?spm_id_from=333.999.0.0)

###  3.529. <a name='-1'></a>993, 994, 995, 996

[花花酱](https://www.bilibili.com/video/BV1bb41117PB?spm_id_from=333.999.0.0)

###  3.530. <a name='FindtheTownJudge'></a>997 Find the Town Judge

[小明](https://www.bilibili.com/video/BV1Ka4y1i7Qt?spm_id_from=333.999.0.0)

###  3.531. <a name='MinimumCosttoMergeStones'></a>1000. Minimum Cost to Merge Stones

[花花酱](https://www.bilibili.com/video/BV1db411v7DG?spm_id_from=333.999.0.0)

###  3.532. <a name='GridIllumination'></a>1001 Grid Illumination

[小明](https://www.bilibili.com/video/BV1NT4y1V7Vk?spm_id_from=333.999.0.0)

###  3.533. <a name='III-1'></a>1004-最大连续1的个数 III

[哈哈哈](https://www.bilibili.com/video/BV1Zg411L7Qu?spm_id_from=333.999.0.0)

###  3.534. <a name='MinimumDominoRotationsForEq'></a>1007 Minimum Domino Rotations For Eq

[小明](https://www.bilibili.com/video/BV1br4y1w7TM?spm_id_from=333.999.0.0)

###  3.535. <a name='ConstructBinarySearchTreefrom'></a>1008 Construct Binary Search Tree from

[小明](https://www.bilibili.com/video/BV1yk4y1R7oF?spm_id_from=333.999.0.0)

###  3.536. <a name='ComplementofBase10Integer'></a>1009 Complement of Base 10 Integer

[小明](https://www.bilibili.com/video/BV1oK4y187ZM?spm_id_from=333.999.0.0)

###  3.537. <a name='PairsofSongsWithTotalDurations'></a>1010 Pairs of Songs With Total Durations 

[小明](https://www.bilibili.com/video/BV1t64y1f7hc?spm_id_from=333.999.0.0)

###  3.538. <a name='PartitionArrayIntoThreePartsWithEqu'></a>1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ

[官方](https://www.bilibili.com/video/BV1ZK4y1t7Sf?spm_id_from=333.999.0.0)

###  3.539. <a name='SmallestIntegerDivisiblebyK'></a>1015 Smallest Integer Divisible by K

[小明](https://www.bilibili.com/video/BV1PZ4y1G7iU?spm_id_from=333.999.0.0)

###  3.540. <a name='NextGreaterNodeInLinkedList'></a>1019. Next Greater Node In Linked List

[花花酱](https://www.bilibili.com/video/BV12b411s77J?spm_id_from=333.999.0.0)

###  3.541. <a name='SumofRootToLeafBinaryNumbers'></a>1022 Sum of Root To Leaf Binary Numbers

[小明](https://www.bilibili.com/video/BV11A411E7AN?spm_id_from=333.999.0.0)

###  3.542. <a name='-1'></a>1025,1026,1027,1028

[花花酱](https://www.bilibili.com/video/BV1Nb411j7qr?spm_id_from=333.999.0.0)

###  3.543. <a name='VideoStitching'></a>1024. Video Stitching

[花花酱](https://www.bilibili.com/video/BV1kb411u7Qk?spm_id_from=333.999.0.0)

###  3.544. <a name='MaximumDifferenceBetweenNod'></a>1026 Maximum Difference Between Nod

[小明](https://www.bilibili.com/video/BV1fi4y157ZS?spm_id_from=333.999.0.0)

###  3.545. <a name='TwoCityScheduling'></a>1029 Two City Scheduling

[小明](https://www.bilibili.com/video/BV1t54y1Q7G8?spm_id_from=333.999.0.0)

###  3.546. <a name='StreamofCharacters'></a>1032 Stream of Characters

[小明](https://www.bilibili.com/video/BV15T4y1L7RG?spm_id_from=333.999.0.0)

###  3.547. <a name='UncrossedLines'></a>1035 Uncrossed Lines

[小明](https://www.bilibili.com/video/BV1si4y1s79e?spm_id_from=333.999.0.0)

###  3.548. <a name='RobotBoundedInCircle'></a>1041 Robot Bounded In Circle

[小明](https://www.bilibili.com/video/BV1dk4y1y7RH?spm_id_from=333.999.0.0)

###  3.549. <a name='PartitionArrayforMaximumSum'></a>1043. Partition Array for Maximum Sum

[花花酱](https://www.bilibili.com/video/BV154411J7so?spm_id_from=333.999.0.0)

###  3.550. <a name='LongestDuplicateSubstring'></a>1044 Longest Duplicate Substring

[小明](https://www.bilibili.com/video/BV1Kv411B7a3?spm_id_from=333.999.0.0)

###  3.551. <a name='LastStoneWeight'></a>1046 Last Stone Weight

[小明](https://www.bilibili.com/video/BV1w54y197Ln?spm_id_from=333.999.0.0)

###  3.552. <a name='LongestStringChain'></a>1048 Longest String Chain

[小明](https://www.bilibili.com/video/BV17K4y1G7et?spm_id_from=333.999.0.0)



###  3.553. <a name='ShortestWaytoFormString'></a>1055.Shortest Way to Form String 形成字符串的最短路径

[图灵](https://www.bilibili.com/video/BV1SZ4y1G7WX?spm_id_from=333.999.0.0)

###  3.554. <a name='-1'></a>1091-二进制矩阵中的最短路径

[哈哈哈](https://www.bilibili.com/video/BV17k4y1r7EP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ro4y197kU?spm_id_from=333.999.0.0)

###  3.555. <a name='CarPooling'></a>1094 Car Pooling

[小明](https://www.bilibili.com/video/BV1Xk4y1k7UX?spm_id_from=333.999.0.0)

###  3.556. <a name='FindinMountainArray'></a>1095. Find in Mountain Array

[花花酱](https://www.bilibili.com/video/BV1m5411V7x7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK4115778?spm_id_from=333.999.0.0)

###  3.557. <a name='FillingBookcaseShelves'></a>1105. Filling Bookcase Shelves

[花花酱](https://www.bilibili.com/video/BV1Mx411X7Ks?spm_id_from=333.999.0.0)

###  3.558. <a name='ParsingABooleanExpression'></a>1106. Parsing A Boolean Expression

[花花酱](https://www.bilibili.com/video/BV1Cx411X7aF?spm_id_from=333.999.0.0)

###  3.559. <a name='DeleteNodesAndReturnForest'></a>1110. Delete Nodes And Return Forest

[花花酱](https://www.bilibili.com/video/BV1u4411977H?spm_id_from=333.999.0.0)

###  3.560. <a name='MaximumNestingDepthofTwoValidParentheses'></a>1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses

[官方](https://www.bilibili.com/video/BV11a4y1v7Bb?spm_id_from=333.999.0.0)

###  3.561. <a name='threading'></a>1114 - 1115 - 1116 - 多线程 threading

[花花酱](https://www.bilibili.com/video/BV12t411P79a?spm_id_from=333.999.0.0)

###  3.562. <a name='LowestCommonAncestorofDeepestLeaves'></a>1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖

[小明](https://www.bilibili.com/video/BV16f4y1q7eA?spm_id_from=333.999.0.0)

###  3.563. <a name='LongestWell-PerformingInterval'></a>1124. Longest Well-Performing Interval

[花花酱](https://www.bilibili.com/video/BV1Et41157Jw?spm_id_from=333.999.0.0)

###  3.564. <a name='SmallestSufficientTeam'></a>1125. Smallest Sufficient Team

[花花酱](https://www.bilibili.com/video/BV14t411G7WL?spm_id_from=333.999.0.0)

###  3.565. <a name='NumberofEquivalentDominoPairs'></a>1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs

[官方](https://www.bilibili.com/video/BV1fV411q7ZY?spm_id_from=333.999.0.0)

###  3.566. <a name='ShortestPathwithAlternatingColors'></a>1129. Shortest Path with Alternating Colors

[花花酱](https://www.bilibili.com/video/BV1Et411J7Dh?spm_id_from=333.999.0.0)

###  3.567. <a name='N-thTribonacciNumber'></a>1137. N-th Tribonacci Number

[3:55 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

###  3.568. <a name='StoneGameII'></a>1140. Stone Game II

[花花酱](https://www.bilibili.com/video/BV1Gt411c7hM?spm_id_from=333.999.0.0)

###  3.569. <a name='LongestCommonSubsequence'></a>1143 Longest Common Subsequence

[小明](https://www.bilibili.com/video/BV19Z4y1W7Xi?spm_id_from=333.999.0.0)

```scala
package com.zhourui.leetcode
import com.zhourui.codech.BaseExtension

//问题转化为dp[0...i][0..j]是否存在公共字串
//1.text1[i]==text2[j] && dp[i-1][j-1]存在公共字串
//2.否则从已有的dp中选择最大值 max(dp[i-1][j], dp[i][j-1]);
package lc1143{



  object Solution {
    def longestCommonSubsequence(text1: String, text2: String): Int = {
      val m = text1.length
      val n = text2.length
      //val dp = Array.ofDim[Int](1001,1001)
      val dp = Array.fill(1001,1001)(0)
      for (i<- 1 to m) { // must have space?
        for (j<- 1 to n) {
          dp(i)(j) = if (text1(i-1)== text2(j-1)) dp(i-1)(j-1)+1 else Math.max(dp(i-1)(j),dp(i)(j-1))
        }
      }
      dp(m)(n)
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.longestCommonSubsequence("abcde", "ace") == 3)
    }
    val name = "1143 Longest common sequence"
  }
}

```

###  3.570. <a name='BinaryTreeColoringGame'></a>1145. Binary Tree Coloring Game

[花花酱](https://www.bilibili.com/video/BV1ft411K7Gf?spm_id_from=333.999.0.0)

###  3.571. <a name='NumberofDiceRollsWithTargetSum'></a>1155. Number of Dice Rolls With Target Sum

[花花酱](https://www.bilibili.com/video/BV1t4411Q7JN?spm_id_from=333.999.0.0)

###  3.572. <a name='FindWordsThatCanBeFormedbyCharacters'></a>1160. 拼写单词 Find Words That Can Be Formed by Characters 

[官方](https://www.bilibili.com/video/BV1Lt4y1Q7Yx?spm_id_from=333.999.0.0)

###  3.573. <a name='DinnerPlateStacks'></a>1172. Dinner Plate Stacks

[花花酱](https://www.bilibili.com/video/BV1E4411z7xb?spm_id_from=333.999.0.0)

###  3.574. <a name='NumberofValidWordsforEachPuzzle'></a>1178. Number of Valid Words for Each Puzzle

[花花酱](https://www.bilibili.com/video/BV1x441117vz?spm_id_from=333.999.0.0)

###  3.575. <a name='MakeArrayStrictlyIncreasing'></a>1187. Make Array Strictly Increasing

[花花酱](https://www.bilibili.com/video/BV1sJ411N7jD?spm_id_from=333.999.0.0)

###  3.576. <a name='K-ConcatenationMaximumSum'></a>1191. K-Concatenation Maximum Sum

[花花酱](https://www.bilibili.com/video/BV1AJ411w756?spm_id_from=333.999.0.0)

###  3.577. <a name='UglyNumberIII'></a>1201. Ugly Number III

[花花酱](https://www.bilibili.com/video/BV1QJ411M7Jx?spm_id_from=333.999.0.0)

###  3.578. <a name='SmallestStringWithSwaps'></a>1202. Smallest String With Swaps

[花花酱](https://www.bilibili.com/video/BV1PJ411T7Wq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Yh41127VH?spm_id_from=333.999.0.0)

###  3.579. <a name='SortItemsbyGroupsRespectingDependencies'></a>1203. 项目管理 Sort Items by Groups Respecting Dependencies

[官方](https://www.bilibili.com/video/BV1iy4y1m7ye?spm_id_from=333.999.0.0)

###  3.580. <a name='DesignSkiplist'></a>1206. Design Skiplist 

[花花酱](https://www.bilibili.com/video/BV1kT4y1F7Nr?spm_id_from=333.999.0.0)

###  3.581. <a name='RemoveAllAdjacentDuplicatesin'></a>1209 Remove All Adjacent Duplicates in 

[小明](https://www.bilibili.com/video/BV1qA411L7z9?spm_id_from=333.999.0.0)

###  3.582. <a name='MinimumCosttoMoveChips'></a>1217 Minimum Cost to Move Chips

[小明](https://www.bilibili.com/video/BV1zt4y1e7fK?spm_id_from=333.999.0.0)

###  3.583. <a name='LongestArithmeticSubsequenceofGivenDifference'></a>1218. Longest Arithmetic Subsequence of Given Difference

[花花酱](https://www.bilibili.com/video/BV1tE411f73y?spm_id_from=333.999.0.0)

###  3.584. <a name='CountVowelsPermutation'></a>1220. Count Vowels Permutation

[花花酱](https://www.bilibili.com/video/BV1FJ411c7pT?spm_id_from=333.999.0.0)

###  3.585. <a name='DiceRollSimulation'></a>1223 Dice Roll Simulation

[花花酱](https://www.bilibili.com/video/BV17E411k7PR?spm_id_from=333.999.0.0)

###  3.586. <a name='TilingaRectanglewiththeFewestSquares'></a>1240 Tiling a Rectangle with the Fewest Squares

[花花酱](https://www.bilibili.com/video/BV1UE411t7Gb?spm_id_from=333.999.0.0)

###  3.587. <a name='-1'></a>1248-统计「优美子数组」

[哈哈哈](https://www.bilibili.com/video/BV1FU4y1H76T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wk4y1r7t7?spm_id_from=333.999.0.0)

###  3.588. <a name='MinimumRemovetoMakeValidPare'></a>1249 Minimum Remove to Make Valid Pare

[小明](https://www.bilibili.com/video/BV1wK4y1X7G7?spm_id_from=333.999.0.0)

###  3.589. <a name='-1'></a>1252 1253 1254 1255

[花花酱](https://www.bilibili.com/video/BV1kE411Y7rg?spm_id_from=333.999.0.0)

###  3.590. <a name='MinimumMovestoMoveaBoxtoTheirTarget'></a>1263. Minimum Moves to Move a Box to Their Target

[花花酱](https://www.bilibili.com/video/BV1AJ411Q7B6?spm_id_from=333.999.0.0)

###  3.591. <a name='-1'></a>1277-统计全为1的正方形子矩阵

[哈哈哈](https://www.bilibili.com/video/BV1nk4y1k7vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Kp4y1X7n4?spm_id_from=333.999.0.0)

###  3.592. <a name='PalindromePartitioningIII'></a>1278. Palindrome Partitioning III

[花花酱](https://www.bilibili.com/video/BV1HJ411q7nc?spm_id_from=333.999.0.0)

###  3.593. <a name='FindtheSmallestDivisorGivena'></a>1283 Find the Smallest Divisor Given a

[小明](https://www.bilibili.com/video/BV1Fv411r7Nw?spm_id_from=333.999.0.0)

###  3.594. <a name='MinimumNumberofFlipstoConvertBinaryMatrix'></a>1284. Minimum Number of Flips to Convert Binary Matrix

[花花酱](https://www.bilibili.com/video/BV1nJ411y7m1?spm_id_from=333.999.0.0)

###  3.595. <a name='ConvertBinaryNumberinaLinkedList'></a>1290. 二进制链表转整数 (Convert Binary Number in a Linked List

[洛阳](https://www.bilibili.com/video/BV1kc411h7Rs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nD4y1R7QH?spm_id_from=333.999.0.0)

###  3.596. <a name='SequentialDigits'></a>1291 Sequential Digits

[小明](https://www.bilibili.com/video/BV11v411C7so?spm_id_from=333.999.0.0)

###  3.597. <a name='ShortestPathinaGridwithObstaclesElimination'></a>1293. Shortest Path in a Grid with Obstacles Elimination

[花花酱](https://www.bilibili.com/video/BV1VJ411k72A?spm_id_from=333.999.0.0)

###  3.598. <a name='DivideArrayinSetsofKConsecutiveNumbers'></a>1296. Divide Array in Sets of K Consecutive Numbers

[花花酱](https://www.bilibili.com/video/BV1gJ411e7cS?spm_id_from=333.999.0.0)

###  3.599. <a name='NumberofPathswithMaxScore'></a>1301. Number of Paths with Max Score

[花花酱](https://www.bilibili.com/video/BV1pJ411a7ry?spm_id_from=333.999.0.0)

###  3.600. <a name='DeepestLeavesSum'></a>1302 Deepest Leaves Sum

[小明](https://www.bilibili.com/video/BV1Bb4y1D7Cp?spm_id_from=333.999.0.0)

###  3.601. <a name='AllElementsinTwoBinarySearch'></a>1305 All Elements in Two Binary Search

[小明](https://www.bilibili.com/video/BV1kK411N7az?spm_id_from=333.999.0.0)

###  3.602. <a name='JumpGameIII'></a>1306 Jump Game III

[小明](https://www.bilibili.com/video/BV13y4y1q7Gi?spm_id_from=333.999.0.0)

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0:
            return True

        n = len(arr)
        used = {start}
        q = collections.deque([start])

        while len(q) > 0:
            u = q.popleft()
            for v in [u + arr[u], u - arr[u]]:
                if 0 <= v < n and v not in used:
                    if arr[v] == 0:
                        return True
                    q.append(v)
                    used.add(v)
        
        return False

```

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(site, n):
            if flag[0]:
                return
            if arr[site] == 0:
                flag[0] = True
                return
            see[site] = True
            for next_site in (site+arr[site], site-arr[site]):
                if 0 <= next_site < n and see[next_site] == False:
                    dfs(next_site, n)
        n = len(arr)
        flag = [False]
        see = [False] * n
        dfs(start, n)
        return flag[0]
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()

        def dfs(index):
            if index in seen:
                return False

            seen.add(index)
            if index < 0 or index >= len(arr):
                return False

            if arr[index] == 0:
                return True

            return dfs(index + arr[index]) or dfs(index - arr[index])

        return dfs(start)
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()
        queue = [(start, 0)]

        while queue:
            index, step = queue.pop(0)

            if index in seen:
                continue

            seen.add(index)

            if index < 0 or index >= len(arr):
                continue

            if arr[index] == 0:
                return True

            queue.extend([(index + arr[index], step+1), (index - arr[index], step+1)])

        return False

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(index,d):
            if index<0 or index>=len(arr) or len(d)!=len(set(d)):return False
            if arr[index]==0:return True
            return dfs(index+arr[index],d+[index+arr[index]]) or  dfs(index-arr[index],d+[index-arr[index]])
        return dfs(start,[start])

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start]==0:return True
        q=collections.deque([start])
        visited={start}
        while q:
            node=q.popleft()
            for n in [node+arr[node],node-arr[node]]:
                if 0<=n<len(arr) and n not in visited:
                    if arr[n]==0:return True
                    q.append(n)
                    visited.add(n)
        return False

bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        q, v, n = [start], {start}, len(arr)
        while q:
            p = []
            for i in q:
                if not arr[i]:
                    return True
                for j in i - arr[i], i + arr[i]:
                    if 0 <= j < n and j not in v:
                        p.append(j)
                        v.add(j)
            q = p
        return False
dfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        n, v = len(arr), set()
        def f(i):
            if not arr[i]:
                return True
            elif i not in v:
                v.add(i)
                return 0 <= i - arr[i] < n and f(i - arr[i]) or 0 <= i + arr[i] < n and f(i + arr[i])
        return f(start)

python bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        l, mark, queue= len(arr), [1 for i in range(len(arr))], [start]
        while len(queue)!=0:
            n = len(queue)
            for i in range(n):
                tmp = queue.pop()
                if arr[tmp]==0:
                    return True
                mark[tmp] = 0
                for cur in tmp+arr[tmp], tmp-arr[tmp]:
                    if 0<=cur<l and mark[cur]:
                        queue.insert(0, cur)
        return False
```

###  3.603. <a name='XORQueriesofaSubarray'></a>1310. XOR Queries of a Subarray

[花花酱](https://www.bilibili.com/video/BV1oJ411L78Y?spm_id_from=333.999.0.0)

###  3.604. <a name='MinimumInsertionStepstoMakeaStringPalindrom'></a>1312. Minimum Insertion Steps to Make a String Palindrom

[花花酱](https://www.bilibili.com/video/BV1HJ411L7b2?spm_id_from=333.999.0.0)

###  3.605. <a name='MinimumDistancetoTypeaWordUsingTwoFinger'></a>1320. Minimum Distance to Type a Word Using Two Finger

[花花酱](https://www.bilibili.com/video/BV11J411n7fN?spm_id_from=333.999.0.0)

###  3.606. <a name='SorttheMatrixDiagonally'></a>1329 Sort the Matrix Diagonally

[小明](https://www.bilibili.com/video/BV1hU4y147b1?spm_id_from=333.999.0.0)

###  3.607. <a name='RemovePalindromicSubsequences'></a>1332 Remove Palindromic Subsequences

[小明](https://www.bilibili.com/video/BV1tK4y1D7aV?spm_id_from=333.999.0.0)

###  3.608. <a name='FindtheCityWithSmallestNumberofNeighbors'></a>1334. Find the City With Smallest Number of Neighbors

[花花酱](https://www.bilibili.com/video/BV1b7411z7Tb?spm_id_from=333.999.0.0)

###  3.609. <a name='MinimumDifficultyofaJobSchedule'></a>1335. Minimum Difficulty of a Job Schedule

[花花酱](https://www.bilibili.com/video/BV1K7411r7xj?spm_id_from=333.999.0.0)

###  3.610. <a name='TheKWeakestRowsinaMatrix'></a>1337 The K Weakest Rows in a Matrix

[小明](https://www.bilibili.com/video/BV1bX4y157ju?spm_id_from=333.999.0.0)

###  3.611. <a name='MaximumProductofSplitt'></a>1339 Maximum Product of Splitt

[小明](https://www.bilibili.com/video/BV1Ch411i7yS?spm_id_from=333.999.0.0)

###  3.612. <a name='JumpGameV'></a>1340. Jump Game V

[花花酱](https://www.bilibili.com/video/BV1h7411W7wS?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        pathdic = defaultdict(list)
        n = len(arr)
        if n<=1: return n
        indegrees = [0]*n
        for i in range(n):
            for j in range(i+1,n):
                if arr[j]<arr[i] and j-i<=d:
                    pathdic[i].append(j)
                    indegrees[j] += 1
                else:
                    break
            for j in range(i-1, -1, -1):
                if arr[j]<arr[i] and i-j<=d:
                    pathdic[i].append(j)
                    indegrees[j] += 1
                else:
                    break
        # 拓扑排序
        queue = Deque()
        for i,degree in enumerate(indegrees):
            if degree == 0:
                queue.append((i,1))
        ans = 1
        while queue:
            node, level = queue.popleft()
            for nx_node in pathdic[node]:
                ans = max(ans, level+1)
                indegrees[nx_node] -= 1
                if indegrees[nx_node] == 0:
                    queue.append((nx_node, level+1))
        return ans

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        D = {}
        l = len(arr)
        def P(n):
            if n in D:
                return D[n]
            t = 1
            for i in range(1, d + 1):
                if n + i >= l or arr[n] <= arr[n + i]:
                    break
                t = max(t, 1 + P(n + i))
            for i in range(1, d + 1):
                if n - i < 0 or arr[n] <= arr[n - i]:
                    break
                t = max(t, 1 + P(n - i))
            D[n] = t
            return t
        return max(P(i) for i in range(l))
```

```py
记忆化 DFS

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        n = len(arr)
        @lru_cache(None)
        def helper(i):
            res = 0
            for j in range(i + 1, i + d + 1):
                if j >= n or arr[j] >= arr[i]:
                    break
                res = max(res, helper(j))
            for j in range(i - 1, i - d - 1, -1):
                if j < 0 or arr[j] >= arr[i]:
                    break
                res = max(res, helper(j))
            return res + 1
        return max(helper(i) for i in range(n))
```

```py
排序之后对向两边进行拓展

#python3
class Solution:
	def maxJumps(self,arr,d):
		fans=1
		size=len(arr)
		has,dp=[[0]*size for _ in range(2)]
		for i in sorted(range(size),key=arr.__getitem__):
			tans=has[i]=1
			for j in range(i+1,min(size,i+d+1)):
				if not has[j] or arr[j]==arr[i]:
					break
				tans=max(tans,dp[j]+1)
			for j in range(i-1,max(-1,i-d-1),-1):
				if not has[j] or arr[j]==arr[i]:
					break
				tans=max(tans,dp[j]+1)
			dp[i]=tans
			fans=max(fans,tans)
		return fans

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        # 不能往比自己的高的跳
        # 能跳的区间内不能有比自己高的
        # dp[i]从 i开始的最大跳跃
        n = len(arr)
        height = [(jump,i) for i, jump in enumerate(arr)]
        height = sorted(height, key=lambda x: x[0])
        dp = [1 for _ in range(n)]
        #print(idx)
        #idx1 = map(lambda x: x[1], idx)
        for jump, i in height:
            cur = 1
            for j in range(i-1, max(-1, i - d) - 1, -1): # 向左跳
                if arr[j] >= jump: break
                cur = max(dp[j] + 1,cur)

            for j in range(i + 1, min(n, i + d + 1)):
                if arr[j] >= jump: break
                cur = max(dp[j] + 1, cur)
            dp[i] = cur
        return max(dp)

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        seen = dict()

        def dfs(pos):
            if pos in seen:
                return
            seen[pos] = 1

            i = pos - 1
            while i >= 0 and pos - i <= d and arr[pos] > arr[i]:
                dfs(i)
                seen[pos] = max(seen[pos], seen[i] + 1)
                i -= 1
            i = pos + 1
            while i < len(arr) and i - pos <= d and arr[pos] > arr[i]:
                dfs(i)
                seen[pos] = max(seen[pos], seen[i] + 1)
                i += 1

        for i in range(len(arr)):
            dfs(i)
        print(seen)
        return max(seen.values())

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/jump-game-v/solution/tiao-yue-you-xi-v-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  3.613. <a name='MaximumStudentsTakingExam'></a>1349. Maximum Students Taking Exam

[花花酱](https://www.bilibili.com/video/BV1w7411V7eC?spm_id_from=333.999.0.0)

###  3.614. <a name='MaximumNumberofEventsThatCanBeAttended'></a>1353. Maximum Number of Events That Can Be Attended 

[花花酱](https://www.bilibili.com/video/BV1C7411j7YJ?spm_id_from=333.999.0.0)

###  3.615. <a name='ConstructTargetArrayWithMultipleSums'></a>1354. Construct Target Array With Multiple Sums

[花花酱](https://www.bilibili.com/video/BV1g7411c793?spm_id_from=333.999.0.0)

###  3.616. <a name='MinimumCosttoMakeatLeastOneValidPath'></a>1368. Minimum Cost to Make at Least One Valid Path

[花花酱](https://www.bilibili.com/video/BV1oE411E74t?spm_id_from=333.999.0.0)

###  3.617. <a name='FindtheLongestSubstringContainingVowelsinEve'></a>1371. Find the Longest Substring Containing Vowels in Eve

[花花酱](https://www.bilibili.com/video/BV1CE411K7hb?spm_id_from=333.999.0.0)

###  3.618. <a name='MaximumSumBSTinBinaryTree'></a>1373. Maximum Sum BST in Binary Tree

[花花酱](https://www.bilibili.com/video/BV17E411u797?spm_id_from=333.999.0.0)

###  3.619. <a name='FrogPositionAfterTSeconds'></a>1377. Frog Position After T Seconds

[花花酱](https://www.bilibili.com/video/BV1mE411K7vc?spm_id_from=333.999.0.0)

###  3.620. <a name='FindCorrespondingNodeofBinaryTreeinaClone'></a>1379 Find Corresponding Node of Binary Tree in a Clone

[小明](https://www.bilibili.com/video/BV1A54y147HN?spm_id_from=333.999.0.0)

###  3.621. <a name='BalanceaBinarySearchTree'></a>1382. Balance a Binary Search Tree

[花花酱](https://www.bilibili.com/video/BV1y7411f7v2?spm_id_from=333.999.0.0)

###  3.622. <a name='CountNumberofTeams'></a>1395. Count Number of Teams

[花花酱](https://www.bilibili.com/video/BV1cc411h73E?spm_id_from=333.999.0.0)

###  3.623. <a name='DesignUndergroundSystem'></a>1396 Design Underground System

[小明](https://www.bilibili.com/video/BV1uA411N7q6?spm_id_from=333.999.0.0)

###  3.624. <a name='StoneGameIII'></a>1406. Stone Game III

[花花酱](https://www.bilibili.com/video/BV1zT4y1G7Tb?spm_id_from=333.999.0.0)

###  3.625. <a name='QueriesonaPermutationWithKey'></a>1409. Queries on a Permutation With Key

[花花酱](https://www.bilibili.com/video/BV1mz411b7Uw?spm_id_from=333.999.0.0)

###  3.626. <a name='RestoreTheArray'></a>1416. Restore The Array

[花花酱](https://www.bilibili.com/video/BV1gK4y1k7Rv?spm_id_from=333.999.0.0)

###  3.627. <a name='DiagonalTraverseII'></a>1424. Diagonal Traverse II

[花花酱](https://www.bilibili.com/video/BV1r5411x7Tm?spm_id_from=333.999.0.0)

###  3.628. <a name='ConstrainedSubsetSum'></a>1425. Constrained Subset Sum

[花花酱](https://www.bilibili.com/video/BV13t4y1m7fD?spm_id_from=333.999.0.0)

###  3.629. <a name='CountingElements'></a>1426  Counting Elements

[小明](https://www.bilibili.com/video/BV1Eg4y187vx?spm_id_from=333.999.0.0)

###  3.630. <a name='KidsWiththeGreatestNumberofCandie'></a>1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie

[官方](https://www.bilibili.com/video/BV1vD4y1D7yo?spm_id_from=333.999.0.0)

###  3.631. <a name='CheckIfAll1sAreatLeastLength'></a>1437 Check If All 1's Are at Least Length

[小明](https://www.bilibili.com/video/BV1Yo4y1R78P?spm_id_from=333.999.0.0)

###  3.632. <a name='LongestContinuousSubarrayWithAbsolute'></a>1438. Longest Continuous Subarray With Absolute

[花花酱](https://www.bilibili.com/video/BV1Cf4y1m7aN?spm_id_from=333.999.0.0)

###  3.633. <a name='BuildanArrayWithStackOperations'></a>1441 Build an Array With Stack Operations

[小明](https://www.bilibili.com/video/BV1Gg4y167ZD?spm_id_from=333.999.0.0)

###  3.634. <a name='CountTripletsThatCanFormTwoArraysofEqual'></a>1442. Count Triplets That Can Form Two Arrays of Equal

[花花酱](https://www.bilibili.com/video/BV17g4y1B7yo?spm_id_from=333.999.0.0)

###  3.635. <a name='MinimumTimetoCollectAllApplesinaTree'></a>1443. Minimum Time to Collect All Apples in a Tree

[花花酱](https://www.bilibili.com/video/BV1e541147oZ?spm_id_from=333.999.0.0)

###  3.636. <a name='NumberofWaysofCuttingaPizza'></a>1444. Number of Ways of Cutting a Pizza

[花花酱](https://www.bilibili.com/video/BV1CK411W7nR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gg4y1B7zS?spm_id_from=333.999.0.0)

###  3.637. <a name='ConsecutiveCharacters'></a>1446 Consecutive Characters

[小明](https://www.bilibili.com/video/BV1QA411j7Qt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pp4y1Q7Rh?spm_id_from=333.999.0.0)

###  3.638. <a name='CountGoodNodesinBinaryTree'></a>1448 Count Good Nodes in Binary Tree

[小明](https://www.bilibili.com/video/BV1Zg4y1q7kc?spm_id_from=333.999.0.0)

###  3.639. <a name='FormLargestIntegerWithDigitsThatAdd'></a>1449. Form Largest Integer With Digits That Add

[花花酱](https://www.bilibili.com/video/BV19Q4y1A7Rf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1j54y1D7vf?spm_id_from=333.999.0.0)

###  3.640. <a name='RearrangeWordsinaSentence'></a>1451 Rearrange Words in a Sentence

[小明](https://www.bilibili.com/video/BV1UA411t7Eg?spm_id_from=333.999.0.0)

###  3.641. <a name='MaximumNumberofDartsInsideofaCircularDartb'></a>1453 Maximum Number of Darts Inside of a Circular Dartb

[小明](https://www.bilibili.com/video/BV1Ut4y117jp?spm_id_from=333.999.0.0)

###  3.642. <a name='Pseudo-PalindromicPathsinaBin'></a>1457 Pseudo-Palindromic Paths in a Bin

[小明](https://www.bilibili.com/video/BV1t54y1t7KK?spm_id_from=333.999.0.0)

###  3.643. <a name='CheckIfaStringContainsAllBinar'></a>1461 Check If a String Contains All Binar

[小明](https://www.bilibili.com/video/BV13Z4y1w7K9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oU4y1p7Tr?spm_id_from=333.999.0.0)

###  3.644. <a name='CherryPickupII'></a>1463 Cherry Pickup II

[小明](https://www.bilibili.com/video/BV1AA411s7Tc?spm_id_from=333.999.0.0)

###  3.645. <a name='PaintHouseIII'></a>1473. Paint House III

[花花酱](https://www.bilibili.com/video/BV15K411p7nT?spm_id_from=333.999.0.0)

###  3.646. <a name='FinalPricesWithaSpecialDiscountinaSho'></a>1475. Final Prices With a Special Discount in a Sho

[花花酱](https://www.bilibili.com/video/BV1na4y1Y7VU?spm_id_from=333.999.0.0)

###  3.647. <a name='KthAncestorofaTreeNode'></a>1483. Kth Ancestor of a Tree Node

[花花酱](https://www.bilibili.com/video/BV1kt4y1X7fk?spm_id_from=333.999.0.0)

###  3.648. <a name='AvoidFloodinTheCity'></a>1488. Avoid Flood in The City

[花花酱](https://www.bilibili.com/video/BV1af4y1y7uW?spm_id_from=333.999.0.0)

###  3.649. <a name='FindCriticalandPseudo-CriticalEdgesin'></a>1489. Find Critical and Pseudo-Critical Edges in

[花花酱](https://www.bilibili.com/video/BV1cV41167oi?spm_id_from=333.999.0.0)

###  3.650. <a name='ThekthFactorofn'></a>1492 The kth Factor of n

[小明](https://www.bilibili.com/video/BV1ha4y1H7vz?spm_id_from=333.999.0.0)

###  3.651. <a name='LongestSubarrayof1sAfterDeletingOne'></a>1493. Longest Subarray of 1's After Deleting One

[花花酱](https://www.bilibili.com/video/BV1rC4y18751?spm_id_from=333.999.0.0)

###  3.652. <a name='MaxValueofEquation'></a>1499. Max Value of Equation

[花花酱](https://www.bilibili.com/video/BV1VK411H7zy?spm_id_from=333.999.0.0)

###  3.653. <a name='CanMakeArithmeticProgressionFromSequence'></a>1502 Can Make Arithmetic Progression From Sequence

[小明](https://www.bilibili.com/video/BV12T4y177vU?spm_id_from=333.999.0.0)

###  3.654. <a name='LastMomentBeforeAllAntsFallOutofaPlank'></a>1503 Last Moment Before All Ants Fall Out of a Plank

[小明](https://www.bilibili.com/video/BV1Fg4y1i7na?spm_id_from=333.999.0.0)

###  3.655. <a name='MinimumPossibleIntegerAfteratMostKAdjacent'></a>1505. Minimum Possible Integer After at Most K Adjacent

[花花酱](https://www.bilibili.com/video/BV1YD4y1S7BQ?spm_id_from=333.999.0.0)

###  3.656. <a name='RangeSumofSortedSubarraySums'></a>1508. Range Sum of Sorted Subarray Sums

[花花酱](https://www.bilibili.com/video/BV1fg4y1v7qe?spm_id_from=333.999.0.0)

###  3.657. <a name='StoneGameIV'></a>1510 Stone Game IV

[小明](https://www.bilibili.com/video/BV1pr4y1w7ao?spm_id_from=333.999.0.0)

###  3.658. <a name='PathwithMaximumProbability'></a>1514 Path with Maximum Probability

[小明](https://www.bilibili.com/video/BV1Ak4y1B7yR?spm_id_from=333.999.0.0)

###  3.659. <a name='BestPositionforaServiceCentre'></a>1515 Best Position for a Service Centre

[小明](https://www.bilibili.com/video/BV1UA411e7PC?spm_id_from=333.999.0.0)

###  3.660. <a name='MaximumNumberofNon-OverlappingSubstrings'></a>1520. Maximum Number of Non-Overlapping Substrings

[花花酱](https://www.bilibili.com/video/BV1yz4y1D7p3?spm_id_from=333.999.0.0)

###  3.661. <a name='NumberofGoodLeafNodesPairs'></a>1530. Number of Good Leaf Nodes Pairs

[花花酱](https://www.bilibili.com/video/BV1bv411q7SD?spm_id_from=333.999.0.0)

###  3.662. <a name='StringCompressionII'></a>1531. String Compression II

[花花酱](https://www.bilibili.com/video/BV1aK4y1v7B9?spm_id_from=333.999.0.0)

###  3.663. <a name='CountGoodTriplets'></a>1534 Count Good Triplets

[小明](https://www.bilibili.com/video/BV11k4y1m7rV?spm_id_from=333.999.0.0)

###  3.664. <a name='FindtheWinnerofanArrayGame'></a>1535 Find the Winner of an Array Game

[小明](https://www.bilibili.com/video/BV1Xp4y1i7ey?spm_id_from=333.999.0.0)

###  3.665. <a name='GettheMaximumScore'></a>1537. Get the Maximum Score

[小梦想家](https://www.bilibili.com/video/BV1KC4y1t7P8?spm_id_from=333.999.0.0)

###  3.666. <a name='KthMissingPositiveNumber'></a>1539. Kth Missing Positive Number

[小梦想家](https://www.bilibili.com/video/BV1SC4y147Eo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK4y1p7E3?spm_id_from=333.999.0.0)

###  3.667. <a name='FindLongestAwesomeSubstring'></a>1542. Find Longest Awesome Substring

[花花酱](https://www.bilibili.com/video/BV1ZD4y1U79Y?spm_id_from=333.999.0.0)

###  3.668. <a name='MaximumNumberofNon-OverlappingSubarraysWithSum'></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum

[小梦想家](https://www.bilibili.com/video/BV1LA411n7L8?spm_id_from=333.999.0.0)

###  3.669. <a name='ThreeConsecutiveOdds'></a>1550. Three Consecutive Odds

[小梦想家](https://www.bilibili.com/video/BV1aV411m7fy?spm_id_from=333.999.0.0)

###  3.670. <a name='MinimumOperationstoMakeArray'></a>1551 Minimum Operations to Make Array

[小明](https://www.bilibili.com/video/BV1u64y1S7fx?spm_id_from=333.999.0.0)

###  3.671. <a name='MinimumNumberofDaystoEatNOranges'></a>1553. Minimum Number of Days to Eat N Oranges

[花花酱](https://www.bilibili.com/video/BV1Qf4y197Zk?spm_id_from=333.999.0.0)

###  3.672. <a name='ThousandSeparator'></a>1556. Thousand Separator

[小梦想家](https://www.bilibili.com/video/BV1Ka4y177HV?spm_id_from=333.999.0.0)

###  3.673. <a name='MinimumNumbersofFunctionCallstoMakeTarget'></a>1558. Minimum Numbers of Function Calls to Make Target

[花花酱](https://www.bilibili.com/video/BV1xC4y1t7Q3?spm_id_from=333.999.0.0)

###  3.674. <a name='StoneGameV'></a>1563. Stone Game V 

[花花酱](https://www.bilibili.com/video/BV1B54y1U77f?spm_id_from=333.999.0.0)

###  3.675. <a name='NumberofWaystoReorderArraytoGetSa'></a>1569. Number of Ways to Reorder Array to Get Sa

[花花酱](https://www.bilibili.com/video/BV1pZ4y1T7TY?spm_id_from=333.999.0.0)

###  3.676. <a name='NumberofWaystoSplitaString'></a>1573. Number of Ways to Split a String

[花花酱](https://www.bilibili.com/video/BV1bi4y1u7c3?spm_id_from=333.999.0.0)

###  3.677. <a name='CheckIfStringIsTransformableWith'></a>1585. Check If String Is Transformable With

[花花酱](https://www.bilibili.com/video/BV1a54y1m75Y?spm_id_from=333.999.0.0)

###  3.678. <a name='SplitaStringIntotheMaxNumberofUniqueSubstri'></a>1593. Split a String Into the Max Number of Unique Substri

[花花酱](https://www.bilibili.com/video/BV14y4y1k77x?spm_id_from=333.999.0.0) 

###  3.679. <a name='MinimumCosttoConnectTwoGroupsofPoints'></a>1595. Minimum Cost to Connect Two Groups of Points

[花花酱](https://www.bilibili.com/video/BV1Xf4y1D7SW?spm_id_from=333.999.0.0)

###  3.680. <a name='NumberofSetsofKNon-OverlappingLine'></a>1621. Number of Sets of K Non-Overlapping Line

[花花酱](https://www.bilibili.com/video/BV1JV411y7eK?spm_id_from=333.999.0.0)

###  3.681. <a name='PathWithMinimumEffort'></a>1631. Path With Minimum Effort

[花花酱](https://www.bilibili.com/video/BV1tr4y1w725?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ft4y1z71X?spm_id_from=333.999.0.0)

###  3.682. <a name='RankTransformofaMatrix'></a>1632 Rank Transform of a Matrix

[小明](https://www.bilibili.com/video/BV1KX4y1F7UA?spm_id_from=333.999.0.0)

###  3.683. <a name='CheckArrayFormationThrough'></a>1640 Check Array Formation Through

[小明](https://www.bilibili.com/video/BV1uh411274P?spm_id_from=333.999.0.0)

###  3.684. <a name='CountSortedVowelStrings'></a>1641 Count Sorted Vowel Strings

[小明](https://www.bilibili.com/video/BV1jf4y1k7bJ?spm_id_from=333.999.0.0)

###  3.685. <a name='FurthestBuildingYouCanReach'></a>1642. Furthest Building You Can Reach

[花花酱](https://www.bilibili.com/video/BV1az4y1C7Pk?spm_id_from=333.999.0.0)

###  3.686. <a name='GetMaximuminGeneratedArray'></a>1646 Get Maximum in Generated Array

[小明](https://www.bilibili.com/video/BV1W54y1s7mg?spm_id_from=333.999.0.0)

###  3.687. <a name='SellDiminishing-ValuedColoredBalls'></a>1648. Sell Diminishing-Valued Colored Balls

[花花酱](https://www.bilibili.com/video/BV11z4y1C7PC?spm_id_from=333.999.0.0)

###  3.688. <a name='CreateSortedArraythroughInstru'></a>1649 Create Sorted Array through Instru

[小明](https://www.bilibili.com/video/BV1ua4y1H7KK?spm_id_from=333.999.0.0)

###  3.689. <a name='DistributeRepeatingIntegers'></a>1655. Distribute Repeating Integers

[花花酱](https://www.bilibili.com/video/BV1qt4y1a7Lm?spm_id_from=333.999.0.0)

###  3.690. <a name='DetermineifTwoStringsAreClose'></a>1657 Determine if Two Strings Are Close

[小明](https://www.bilibili.com/video/BV18z4y1S779?spm_id_from=333.999.0.0)

###  3.691. <a name='MinimumOperationstoReduceX'></a>1658 Minimum Operations to Reduce X

[小明](https://www.bilibili.com/video/BV18t4y1z7Hq?spm_id_from=333.999.0.0)

###  3.692. <a name='MaximizeGridHappiness'></a>1659. Maximize Grid Happiness

[花花酱](https://www.bilibili.com/video/BV1kf4y1v7Js?spm_id_from=333.999.0.0)

###  3.693. <a name='CheckIfTwoStringArraysareEqui'></a>1662 Check If Two String Arrays are Equi

[小明](https://www.bilibili.com/video/BV1LV411t7v4?spm_id_from=333.999.0.0)

###  3.694. <a name='SmallestStringWithAGivenNumer'></a>1663 Smallest String With A Given Numer

[小明](https://www.bilibili.com/video/BV1gv411e7Ly?spm_id_from=333.999.0.0)

###  3.695. <a name='FindtheMostCompetitiveSubseq'></a>1673 Find the Most Competitive Subseq

[小明](https://www.bilibili.com/video/BV1yK4y1H7ni?spm_id_from=333.999.0.0)

###  3.696. <a name='MinimumMovestoMakeArrayComplement'></a>1674. Minimum Moves to Make Array Complement

[花花酱](https://www.bilibili.com/video/BV1qz4y1k7Cm?spm_id_from=333.999.0.0)

###  3.697. <a name='MinimizeDeviationinArray'></a>1675. Minimize Deviation in Array

[花花酱](https://www.bilibili.com/video/BV15541157p6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16f4y167uf?spm_id_from=333.999.0.0)

###  3.698. <a name='MaxNumberofK-SumPairs'></a>1679 Max Number of K-Sum Pairs】

[小明](https://www.bilibili.com/video/BV16t4y1z7kY?spm_id_from=333.999.0.0)

###  3.699. <a name='ConcatenationofConsecutiveBina'></a>1680 Concatenation of Consecutive Bina

[小明](https://www.bilibili.com/video/BV1Py4y117o5?spm_id_from=333.999.0.0)

###  3.700. <a name='MinimumIncompatibility'></a>1681. Minimum Incompatibility

[花花酱](https://www.bilibili.com/video/BV16p4y1z79z?spm_id_from=333.999.0.0)

###  3.701. <a name='StoneGameVII'></a>1690. Stone Game VII

[花花酱](https://www.bilibili.com/video/BV1wf4y1e7xH?spm_id_from=333.999.0.0)

###  3.702. <a name='JumpGameVI'></a>1696. Jump Game VI

[花花酱](https://www.bilibili.com/video/BV1554y1t7Tz?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        
        
        # dp[i] = max(dp[j])+ nums[i] for j in range(i - k, i)
        
        dp = [0] * len(nums)
        dp[0] = nums[0]
        
        q = [0]
        for i in range(1, len(nums)):
            while q and i - q[0] > k:
                q.pop(0)
            dp[i] = dp[q[0]] + nums[i]
            while q and dp[q[-1]] <= dp[i]:
                q.pop(-1)
            q.append(i)     
        return dp[-1]
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        from queue import PriorityQueue
        ans, q = nums[0], PriorityQueue()
        q.put([-nums[0], 0])
        for i in range(1, len(nums)):
            while not q.empty():
                top = q.get()
                if i - top[-1] <= k:
                    q.put(top)
                    break
            ans = -top[0] + nums[i]
            q.put([-ans, i])
        return ans
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        #维护当前最大值  方法1：最大堆  方法2:单调递减队列（队首）
        n = len(nums)
        maxHeap = []
        heapq.heapify(maxHeap)
        heapq.heappush(maxHeap, (-nums[0], 0) )
        res = nums[0]

        for i in range(1, n):
            while maxHeap and i - maxHeap[0][1] > k:    #index的距离太大，以后i越来越大，top()就没用了
                heapq.heappop(maxHeap)
            res = -maxHeap[0][0] + nums[i]
            heapq.heappush(maxHeap, (-res, i) )         #dp的思想
        return res
```

###  3.703. <a name='DetermineifStringHalvesAreAlike'></a>1704 Determine if String Halves Are Alike

[小明](https://www.bilibili.com/video/BV1WA41157sf?spm_id_from=333.999.0.0)

###  3.704. <a name='MaximumXORWithanElementFromArray'></a>1707. Maximum XOR With an Element From Array

[花花酱](https://www.bilibili.com/video/BV13v411t742?spm_id_from=333.999.0.0)

###  3.705. <a name='MinimumOperationstoMakeaSubsequence'></a>1713. Minimum Operations to Make a Subsequence

[花花酱](https://www.bilibili.com/video/BV1Yy4y127DQ?spm_id_from=333.999.0.0)

###  3.706. <a name='SwappingNodesinaLinkedList'></a>1721 Swapping Nodes in a Linked List

[小明](https://www.bilibili.com/video/BV1Ji4y1P7Xc?spm_id_from=333.999.0.0)

###  3.707. <a name='LargestSubmatrixWithRearrangements'></a>1727. Largest Submatrix With Rearrangements

[花花酱](https://www.bilibili.com/video/BV1XT4y1N7gy?spm_id_from=333.999.0.0)

###  3.708. <a name='PalindromePartitioningIV'></a>1745. Palindrome Partitioning IV

[花花酱](https://www.bilibili.com/video/BV1yo4y1R75T?spm_id_from=333.999.0.0)

###  3.709. <a name='MinimumLimitofBallsinaBag'></a>1760. Minimum Limit of Balls in a Bag

[花花酱](https://www.bilibili.com/video/BV1bK4y1H7Ly?spm_id_from=333.999.0.0)

###  3.710. <a name='MaximumScorefromPerformingMultiplication'></a>1770. Maximum Score from Performing Multiplication

[花花酱](https://www.bilibili.com/video/BV1Li4y1T7j6?spm_id_from=333.999.0.0)

###  3.711. <a name='MaximizePalindromeLengthFromSubsequences'></a>1771. Maximize Palindrome Length From Subsequences

[花花酱](https://www.bilibili.com/video/BV1Cp4y1H7Xq?spm_id_from=333.999.0.0)

###  3.712. <a name='EqualSumArraysWithMinimumNumberofOperatio'></a>1775. Equal Sum Arrays With Minimum Number of Operatio

[花花酱](https://www.bilibili.com/video/BV1Di4y1T7nF?spm_id_from=333.999.0.0)

###  3.713. <a name='NumberofRestrictedPathsFromFirsttoLastNode'></a>1786. Number of Restricted Paths From First to Last Node

[花花酱](https://www.bilibili.com/video/BV1Df4y147TB?spm_id_from=333.999.0.0)

###  3.714. <a name='MaximumAveragePassRatio'></a>1792. Maximum Average Pass Ratio

[花花酱](https://www.bilibili.com/video/BV1qb4y197zc?spm_id_from=333.999.0.0)

###  3.715. <a name='MaximizeScoreAfterNOperations'></a>1799. Maximize Score After N Operations

[花花酱](https://www.bilibili.com/video/BV1Sf4y1x7Cy?spm_id_from=333.999.0.0)

###  3.716. <a name='MaximumNumberofGroupsGettingFreshDonuts'></a>1815. Maximum Number of Groups Getting Fresh Donuts

[花花酱](https://www.bilibili.com/video/BV1CU4y187tk?spm_id_from=333.999.0.0)

###  3.717. <a name='FrequencyoftheMostFrequentElement'></a>1838. Frequency of the Most Frequent Element

[花花酱](https://www.bilibili.com/video/BV1Ai4y1P7Yt?spm_id_from=333.999.0.0)

###  3.718. <a name='ClosestRoom'></a>1847. Closest Room

[花花酱](https://www.bilibili.com/video/BV1cy4y1x7sz?spm_id_from=333.999.0.0)

###  3.719. <a name='StoneGameVIII'></a>1872. Stone Game VIII

[花花酱](https://www.bilibili.com/video/BV1vb4y1z7wx?spm_id_from=333.999.0.0)

###  3.720. <a name='s'></a>s
