

## 78题

### `& 1` 可以用于判断奇偶

```s
i >> j & 1

------------------------------------

i = 7 = 4 + 2 + 1 = (二进制) 111

i >> 0 & 1 = 1

i >> 1 & 1 = 1

i >> 2 & 1 = 1

------------------------------------

i = 5 = 4 + 0 + 1 = (二进制) 101

i >> 0 & 1 = 1

i >> 1 & 1 = 0

i >> 2 & 1 = 1
```

## 137题

```s
ans = 0

for i in range(32):
    ans |= (1 << i)
# 逐位赋值
```

## 187题

把字符串变成二进制

```py
bin = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
for char in string:
    x = (x << 2) | bin[char]
```

滑动窗口的两种表现方式

```py
x = ((x << 2) | bin[s[i + resLen - 1]]) & ((1 << (resLen * 2)) - 1)
# (x << 2) 滑动窗口右移动， & ((1 << (resLen * 2)) - 1) 滑动窗口左移

x >>= 2  # remove the left char
x += bin[s[i]] << 18 # add the right char
```

```s
(1 << 32) - 1
```

## 190题 类似 231题

```py
(b & (-b)) # b & (-b)找到最后一个 1
b &= b-1 # 消掉最后一个1
ans |=  (1 << 31) // (最后一个 1，如1000)
```

## 260题，类似389题

用 ^ 来消除不同数字，

或字母，但字母必须先要转成数字

ord(ch)

chr(ans)

## 318题

```py
for i in s:
    res |= 1 << (ord(i)-97) # ord('a') = 97，将字符串转化为二进制
return res
```

## 338题 【动态规划 + 位运算😜】

```py
bits[i >> 1] + (i & 1) # 最右边的 1 or 0
bits[i & (i - 1)] + 1 # 只去掉最右边的 1
```

## 342题 4 的幂

```py
 (n & (n - 1)) == 0 and n % 3 == 1
```
        
0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0）

0x55555555 = 1010101010101010101010101010101 (偶数位为0，奇数位为1）

0x33333333 = 110011001100110011001100110011 (1和0每隔两位交替出现)

0xcccccccc = 11001100110011001100110011001100 (0和1每隔两位交替出现)

0x0f0f0f0f = 00001111000011110000111100001111 (1和0每隔四位交替出现)

0xf0f0f0f0 = 11110000111100001111000011110000 (0和1每隔四位交替出现)

给int类型赋值的话，0X7FFFFFFF代表最大值，0X80000000代表最小值

## 371题

细节：

需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，

那么可能会得到错误的答案。

这是因为「有符号整数类型」（即 int 类型）的第 31 个二进制位（即最高位）是补码意义下的符号位，对应着 -2^{31}

而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2^{31}

因此在某些语言（例如 Python ）中需要对最高位进行特殊判断。

时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围

空间复杂度：O(1)

```PY

MASK = 0x100000000 # 2 ^ 32
0xFFFFFFFF # 2 ^ 32 - 1
0X7FFFFFFF # 代表最大值 # 1 << 31 - 1
0X80000000 # 代表最小值 # 1 << 31
0xffffffff = 1111 1111 1111 1111 1111 1111 1111 1111 # (8个F的二进制形式, 一个F占4个字节 ) 

0b100000000000000000000000000000000
0b1 0000000000000000000000000000000 # 代表最小值， ~ 源码 + 1 = 补码
0b1 111111111111111111111111111111 # 代表最大值
```

## 405题

```py
# 这两个计算等效
print(31 & 15)
print(31 % 16)
```

## 461题

```py
# 统计 1 的个数的递归函数
def func(n):
    return 0 if n <= 0 else 1 + func(n & (n-1))
return func(？？)
```









用 x & 1 == 1 判断 x 的奇偶性

用 x&(x-1) 把 x 最右边的 1 改成 0

if(n & 1 == 1){
    // n 是个奇数。
}

如果让你求解 m 的 n 次方，并且不能使用系统自带的 pow 函数，你会怎么做呢？这还不简单，连续让 n 个 m 相乘就行了，代码如下：

int pow(int n){
    int tmp = 1;
    for(int i = 1; i <= n; i++) {
        tmp = tmp * m;
    }
    return tmp;
}
不过你要是这样做的话，我只能呵呵，时间复杂度为 O(n) 了，怕是小学生都会！如果让你用位运算来做，你会怎么做呢？

我举个例子吧，例如 n = 13，则 n 的二进制表示为 1101, 那么 m 的 13 次方可以拆解为:

m^1101 = m^0001 * m^0100 * m^1000。

我们可以通过 & 1和 >>1 来逐位读取 1101，为1时将该位代表的乘数累乘到最终结果。直接看代码吧，反而容易理解：

int pow(int n){
    int sum = 1;
    int tmp = m;
    while(n != 0){
        if(n & 1 == 1){
            sum *= tmp;
        }
        tmp *= tmp;
        n = n >> 1;
    }

    return sum;
}
时间复杂度近为 O(logn)，而且看起来很牛逼。

5、找出不大于N的最大的2的幂指数
传统的做法就是让 1 不断着乘以 2，代码如下：

int findN(int N){
    int sum = 1;
   while(true){
        if(sum * 2 > N){
            return sum;
        }
        sum = sum * 2;
   }
}
这样做的话，时间复杂度是 O(logn)，那如果改成位运算，该怎么做呢？我刚才说了，如果要弄成位运算的方式，很多时候我们把某个数拆成二进制，然后看看有哪些发现。这里我举个例子吧。

例如 N = 19，那么转换成二进制就是 00010011（这里为了方便，我采用8位的二进制来表示）。那么我们要找的数就是，把二进制中最左边的 1 保留，后面的 1 全部变为 0。即我们的目标数是 00010000。那么如何获得这个数呢？相应解法如下：

1、找到最左边的 1，然后把它右边的所有 0 变成 1

图片
2、把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。

3、把 得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 >> 1 = 00010000。

那么问题来了，第一步中把最左边 1 中后面的 0 转化为 1 该怎么弄呢？我先给出代码再解释吧。下面这段代码就可以把最左边 1 中后面的 0 全部转化为 1，

n |= n >> 1;
n |= n >> 2;
n |= n >> 4;
就是通过把 n 右移并且做或运算即可得到。我解释下吧，我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复下去….

最终的代码如下

int findN(int n){
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8 // 整型一般是 32 位，上面我是假设 8 位。
    return (n + 1) >> 1;
}
这种做法的时间复杂度近似 O(1)，重点是，高逼格。

“异或”是一个无进位加法，说白了就是把进位砍掉。比如01^01=00。

“与”可以用来获取进位，比如01&01=01，然后再把结果左移一位，就可以获取进位结果。



根据上面两个技巧，假设有 12+7：

根据分析，完成题解：



 1//JAVA
 2class Solution {
 3    public int getSum(int a, int b){
 4        while(b != 0){
 5            int temp = a ^ b;
 6            b = (a & b) << 1;
 7            a = temp;
 8        }
 9        return a;
10    }
11}

1、使用 x & 1 == 1 判断奇偶数。（注意，一些编辑器底层会把用%判断奇偶数的代码，自动优化成位运算）

2、不使用第三个数，交换两个数。x = x ^ y ， y = x ^ y ， x = x ^ y。（早些年喜欢问到，现在如果谁再问，大家会觉得很low）

3、两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身。（对于找数这块，异或往往有一些别样的用处。）

4、x & (x - 1) ，可以将最右边的 1 设置为 0。（这个技巧可以用来检测 2的幂，或者检测一个整数二进制中 1 的个数，又或者别人问你一个数变成另一个数其中改变了多少个bit位，统统都是它）

5、i+(~i)=-1，i 取反再与 i 相加，相当于把所有二进制位设为1，其十进制结果为-1。

6、对于int32而言，使用 n >> 31取得 n 的正负号。并且可以通过 (n ^ (n >> 31)) - (n >> 31) 来得到绝对值。（n为正，n >> 31 的所有位等于0。若n为负数，n >> 31 的所有位等于1，其值等于-1）

7、使用 (x ^ y) >= 0 来判断符号是否相同。（如果两个数都是正数,则二进制的第一位均为0,x^y=0；如果两个数都是负数,则二进制的第一位均为1；x^y=0 如果两个数符号相反,则二进制的第一位相反,x^y=1。有0的情况例外，^相同得0，不同得1）

1. 计算汉明权重（Hamming Weight）



图片

就是让你返回 n 的二进制表示中有几个 1。因为 n & (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。

int hammingWeight(uint32_t n) {
    int res = 0;
    while (n != 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}


2. 判断一个数是不是 2 的指数

一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：

2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100
如果使用位运算技巧就很简单了（注意运算符优先级，括号不可以省略）：

bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}
3. 查找只出现一次的元素

图片

这里就可以运用异或运算的性质：

一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。

对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：

int singleNumber(vector<int>& nums) {
    int res = 0;
    for (int n : nums) {
        res ^= n;
    }
    return res;
}

二进制枚举
在遇到子集问题的处理时候，我们有时候会借助二进制枚举来遍历各种状态(效率大于 dfs回溯)。这种就属于排列组合的问题了，对于每个物品(位置)来说，就是使用和不使用的两个状态，而在二进制中刚好可以用 1 和 0 来表示。而在实现上，通过枚举数字范围分析每个二进制数字各符号位上的特征进行计算求解操作即可。

二进制枚举的代码实现为：

for(int i = 0; i < (1<<n); i++) //从0～2^n-1个状态
{
for(int j = 0; j < n; j++) //遍历二进制的每一位 共n位
  {
if(i & (1 << j))//判断二进制数字i的第j位是否存在
    {
//操作或者输出
    }
  }
}

不用加减乘除做加法
题目描述：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

分析：这道题咋一听可能没啥思路，简单研究一下位运算还是能独立推出来和理解的。

当然，解决这题前，需要了解上面的四种位运算。还要知道二进制的运算：0+0=0，0+1=1,1+1=0(进位)

对于加法的一个二进制运算。如果不进位那么就是非常容易的。这时候相同位都为 0 则为 0，0 和 1 则为 1。满足这种运算的异或(不相同取 1，相同取 0)和或(有一个 1 则为 1)都能满足.

但事实肯定有进位的运算啊！看到上面操作的不足之后，我们肯定还需要解决进位的问题对于进位的两数相加，这种核心思想为：

用两个数，一个正常 m 相加(不考虑进位的)。用异或 a^b 就是满足这种要求，先不考虑进位(如果没进位那么就是最终结果)。另一个专门考虑进位的 n。两个 1 需要进位。所以我们用 a&b 与记录需要进位的。但是还有个问题，进位的要往上面进位，所以就变成这个需要进位的数左移一位。

然后就变成 m+n 重新迭代开始上面直到不需要进位的(即 n=0 时候)。

实现代码为：

public class Solution {
public int Add(int num1,int num2) {
/*
   *  5+3   5^3(0110)   5&3(0001) 
   *  0101    
   *  0011 
   */
int a=num1^num2;
int b=num1&num2;
  b=b<<1;
if(b==0)return a;
else {
return Add(a, b);
  }        
  }
}
当然，这里也可以科普一下二进制求加法：average = （a&b） + ((a^b)>>1) ;

二进制中 1 的个数
这是一道经典题，其具体题目要求输入一个整数，输出该数二进制表示中 1 的个数(其中负数用补码表示)。

对于这个问题，不用位运算将它转成二进制字符串直接枚举字符'1'的个数也可以直接求出来，但是这样做是没有灵魂的并且效率比较差。这里提供两种解决思路

法一：大家知道每个类型的数据它的背后实际都是二进制操作。大家知道 int 的数据类型的范围是(-2^31,2^31 -1)。并且 int 有 32 位。但是并非 32 位全部用来表示数据。真正用来表示数据大小的也是 31 位。最高位用来表示正负。

首先要知道：

其次还要知道位运算&与。两个十进制与运算.每一位同 1 为 1。所以我们用 2 的正数次幂与知道的数分别进行与运算操作。如果结果不为 0，那么就说明这位为 1。(前面 31 个都是大于 0 的，最后一个与结果是负数但是如果该位为 1，那么结果肯定不为 0)

https://mp.weixin.qq.com/s/INYjYfwhPU7uZcNmzBTpNQ

具体代码实现为：

public int NumberOf1(int n) {
int va=0;
for(int i=0;i<32;i++)
  {
if((n&(1<<i))!=0)
    {           
      va++;
    }
  }
return va;       
}
法二是运用 n&(n-1)。n 如果不为 0，那么 n-1 就是二进制，第一个为 1 的变为0，后面全为 1。

这样的 n&(n-1)一次运算就相当于把最后一个 1 变成 0。这样一直到运算的数为 0 停止计算次数就好了，如下图共进行三次运算那么 n 的二进制中就有三个 1。

实现代码为：

public class Solution {
public int NumberOf1(int n) {
int count=0;
while (n!=0) {
     n=n&(n-1);
     count++;
    }
return count;
 }
}
只出现一次的(一个)数字①
问题描述：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？

分析：这是一道简单的面试题，面试官常问怎么样用不太复杂的方法找出数组中仅出现一次的数字(其他均出现两次)，暴力枚举或者使用其他的存储结构都不够优化，而这个问题最高效的答案就是使用位运算。

首先你要注意两点：

0 和任意数字进行异或操作结果为数字本身.

两个相同的数字进行异或的结果为 0.

具体的操作就是用 0 开始和数组中每个数进行异或，得到的值和下个数进行异或，最终获得的值就是出现一次(奇数次)的值。

class Solution {
public int singleNumber(int[] nums) {
int value=0;
for(int i=0;i<nums.length;i++)
        {
value^=nums[i];
        }
return value;
    }
}
只出现一次的(一个)数字②
问题描述：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？

分析：这题和上一题的思路略有不同，这题其他数字出现了 3 次。那么我们如果直接使用位运算异或操作的话无法直接找到结果，就需要巧妙的运用二进制的其他特性：判断整除求余操作。即判断所有数字二进制 1 的总个数和 0 的总个数，一定有一个不是三的整数倍，如果 0 不是三的整数倍那么就说明结果的该位二进制数字为 0，同理否则为 1。

在具体的操作实现上，问题中给出数组中的数据在 int 范围之内，那么我们就可以在实现上可以对 int 的 32 个位每个位进行依次判断，该位 1 的个数求余 3 后是否为 1，如果为 1 说明结果该位二进制为 1，可以将结果加上去。最终得到的值即为答案。

具体代码为：

class Solution {
public int singleNumber(int[] nums) {
int value=0;
for(int i=0;i<32;i++)
        {
int sum=0;
for(int num:nums)
            {
if(((num>>i)&1)==1)
                {
                    sum++;
                }
            }
if(sum%3==1)
value+=(1<<i);
        }
return value;
    }
}
只出现一次的(两个)数字③
题目描述：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

思路：上面的问题处理和理解起来可能比较容易，但是这个问题可能稍微复杂一点，但是这题可以通过特殊的手段转化为上面只出现一次的一个数字问题来解决，当然核心的位运算也是异或^。

具体思路就是想办法将数组逻辑上一分为二！

先异或一遍到最后得到一个数，得到的肯定是 a^b (假设两个数值分别为a和b)的值。在看异或^的属性：不同为 1，相同为 0。 也就是说最终这个结果的二进制为 1 的位置上 a 和 b 是不相同的。而我们可以找到这个第一个不同的位，然后将数组中的数分成两份，该位为 0 的进行异或求解得到其中一个结果 a，该位为 1 的进行异或求解得到另一个结果 b。

具体可以参考下图流程：

实现代码为：

public int[] singleNumbers(int[] nums) {
int value[]=new int[2];
if(nums.length==2)
return  nums;
int val=0;//异或求的值
for(int i=0;i<nums.length;i++)
    {
        val^=nums[i];
    }
int index=getFirst1(val);
int num1=0,num2=0;
for(int i=0;i<nums.length;i++)
    {
if(((nums[i]>>index)&1)==0)//如果这个数第index为0 和num1异或
            num1^=nums[i];
else//否则和 num2 异或
            num2^=nums[i];
    }
value[0]=num1;
value[1]=num2;
return  value;
}

private int getFirst1(int val) {
int index=0;
while (((val&1)==0&&index<32))
    {
        val>>=1;// val=val/2
        index++;
    }
return index;
}