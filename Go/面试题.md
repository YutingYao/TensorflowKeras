<https://golang.design/go-questions/slice/vs-array/>

<https://space.bilibili.com/396637753>

<https://space.bilibili.com/490799619>

<https://space.bilibili.com/567195437>

<https://space.bilibili.com/497224134>

<https://www.bilibili.com/video/BV1hv411x7we>

<https://www.bilibili.com/video/BV1EL4y1P7hh>

<https://space.bilibili.com/401571418>

<https://www.bilibili.com/video/BV1Ju41167BL>

<https://space.bilibili.com/1897036286/channel/collectiondetail?sid=569368>

<https://github.com/aceld/golang>

<https://github.com/xiaobaiTech/golangFamily>

[为什么大公司一定要使用DevOps?](https://www.bilibili.com/video/BV1Ra41127ko)

## ★ 对go语言认识？为什么学go？用go做过什么？

部署起来极其方便

go build server.go

静态语言，在【编译的时候】检查出大多数问题

语言层面的并发

有强大的标准库：

1. 高效的 runtime 系统调度机制
2. 高效的 垃圾回收
3. 丰富的 标准库：包括【网络通信、socket、RPC协议、同步机制、进程、线程、Goroutine、channel】等一些【并发操作】

简单易学

1. 25个关键字
2. 内嵌C语言
3. 面向对象(继承、多态、封装)
4. 跨平台

大厂领军

1. google做的
2. kubernetes、docker
3. facebook
4. tencent腾讯
5. 百度

编译和执行速度都名列前茅

应用场景：云计算平台、数据库、微服务、区块链

缺点：

1. 【包管理】不完善，第三库，都托管在github上，对代码稳定性有很大风险
2. 没有 Exception 只有 Error


## ★ Go main函数的特点？

## golang 基础 interface 等基本原理搞清楚，gmp goorutine 基本原理，】

## 关于go写的网站，用过框架吗（没有

## golang 代码，分析一段调用了多次defer XXX的函数输出结果

## 1 Golang中除了加【Mutex锁】以外还有哪些方式安全读写【共享变量】

## ★ 【无缓冲Channel】的发送和接收是否同步

## ★ go有缓冲与无缓冲的channel区别，在一个已经关闭了的channel发送&接受数据会发生什么

## ★ 【Golang并发机制】以及它所使用的【CSP并发模型】

## ★ Golang中常用的【并发模型】

## ★ Go中对nil的Slice和【空Slice】的处理是一致的吗

## ★ go的slice和array什么区别？传参的区别呢？

- slice是基于array实现的，它的底层是array，
- 它自己本身非常小，可以理解为对底层array的抽象。
- 因为基于array实现，所以它的底层的内存是连续分配的，
- 效率非常高，还可以通过【索引】获得【数据】。
- slice本身并不是动态array或者array【指针】。
- 它内部实现的数据结构通过【指针】引用底层array，设定相关属性将数据读写操作限定在指定的区域内。
- slice本身是一个只读对象，其工作机制类似array【指针】的一种封装。
- slice对象非常小，是因为它是只有 3 个字段的数据结构：
  1. 指向底层array的【指针】
  2. slice的长度
  3. slice的容量

## [3]int 和 [4]int 是同一个类型吗？

不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。

## slice 的底层

slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。

数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。

而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。

数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。

```go
// runtime/slice.go
type slice struct {
 array unsafe.Pointer // 元素指针
 len   int // 长度 
 cap   int // 容量
}
```

## 为什么 slice 元素是可寻址的？

因为 slice 底层结构其实是一个匿名array，既然array的元素是可寻址的，那slice的元素自然也可以寻址。

## ★【协程、线程、进程】的区别？延申讲到Go语言实现协程？线程独占哪些资源？

## ★ 如果一个【线程】卡住了，【进程】会不会卡住？

## ★ 如果一个【协程】卡住了，【线程】会不会卡住？

## ★ go协程交替打印奇数偶数

## ★ Golang的【内存模型】中为什么【小对象】多了会造成【GC压力】

## 8 Go中【数据竞争】问题怎么解决

## 9 什么是channel，为什么它可以做到【线程安全】

## ★ Golang垃圾回收算法

## ★ GC的触发条件

## ★ go gc过程

## 12 Go的GPM如何调度

## ★ 【并发编程】概念是什么

## 14 Go语言的【栈空间管理】是怎么样的

## 15 Goroutine和Channel的作用分别是什么

## 16 怎么查看【Goroutine的数量】

## ★ Go中的锁有哪些

## ★ 用Go锁怎么解决缓存击穿的问题

## 18 怎么限制【Goroutine的数量】

## 19 Channel是同步的，还是异步的

## 20 【Goroutine和线程】的区别

## 21 Go的Struct能不能比较

## 22 Go的【defer原理】是什么

## 23 Go的select可以用于什么

## ★ Go的【Context包】的用途是什么

## 25 【Go主协程】如何等其余协程完再操作

## ★ Go的Slice如何扩容

<https://www.bilibili.com/video/BV1JP4y1g7kw>

<https://golang.design/go-questions/slice/grow/>

在1.18版本之前：

在原来的slice容量oldcap小于1024的时候，新 slice 的容量newcap的确是oldcap的2倍。

但是，当oldcap大于等于 1024 的时候，情况就有变化了。当向 slice 中添加元素 1280 的时候，原来的slice 的容量为 1280，之后newcap变成了 1696，两者并不是 1.25 倍的关系（1696/1280=1.325）。添加完 1696 后，新的容量 2304 当然也不是 1696 的 1.25 倍。

在1.18版本之后：

在原来的slice 容量oldcap小于256的时候，新 slice 的容量newcap的确是oldcap 的2倍。

但是，当oldcap容量大于等于 256 的时候，情况就有变化了。当向 slice 中添加元素 512 的时候，老 slice 的容量为 512，之后变成了 848，两者并没有符合newcap = oldcap+(oldcap+3*256)/4 的策略（512+（512+3*256）/4）=832。添加完 848 后，新的容量 1280 当然也不是 按照之前策略所计算出的的1252。

难道现在网上各种文章中的扩容策略并不是正确的吗。我们直接搬出源码：源码面前，了无秘密。

从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 growslice 函数，所以我们直接看它的代码。

假设现在有一个长度为 2 的slice，对其进行扩容，增加三个元素

```go
sli := []int{1,2}
sli = append(sli, 3, 4, 5)
```

对于扩容后的slice，长度为 5，这一点没有任何争议。

但容量呢？难道也是 5？

经过运行验证，实际的容量为 6 。

什么情况？这 6 是如何计算出来的呢？

`Go 的内存分配规律`

```s
// class  bytes/obj  bytes/span  objects  tail waste  max waste
//     1          8        8192     1024           0     87.50%
//     2         16        8192      512           0     43.75%
//     3         32        8192      256           0     46.88%
//     4         48        8192      170          32     31.52%
...
//    17        256        8192       32           0      5.86%
//    18        288        8192       28         128     12.16%
//    19        320        8192       25         192     11.80%
//    20        352        8192       23          96      9.88%
//    21        384        8192       21         128      9.51%
//    22        416        8192       19         288     10.71%
//    23        448        8192       18         128      8.37%
//    24        480        8192       17          32      6.82%
//    25        512        8192       16           0      6.05%
...
//    66      32768       32768        1           0     12.50%

从上面这个表格中，可以总结出一些规律。

在小于16字节时，每次以8个字节增加

当大于16小于2^8时，每次以16字节增加

当大于28小于29时以32字节增加
```

元素类型为 int 的slice，每个 int 占用为 8 个字节，由于我们计算出的 newcap 为 5，因此新的slice，最少最少要占用 5*8 = 40 个字节。

如果是 32 byte，就是不够用了，

因此 只能选择 48 这个档位去分配内存。

有了实际分配的内存，再反回去计算容量，就是扩容后真实的slice容量，也就是 48/8 = 6

## Go 中切片扩容的策略是这样的

⚫ 首先判断，如果【新申请容量】大于 2 倍的旧容量，最终容量就是【新申请容量】
⚫ 否则判断，如果【旧切片长度】小于 1024，则最终容量就是旧容量的两倍
⚫ 否则判断，如果【旧切片长度】大于等于 1024，则最终容量从旧容量开始循环
增加原来的 1/4, 直到最终容量大于等于新申请的容量
⚫ 如果最终容量计算值溢出，则最终容量就是【新申请容量】

## ★ Go中的map如何实现【顺序读取】

## ★ go的map怎么实现的，Map底层介绍？出现【哈希碰撞】的情况下，Map底层会发生什么？Map删除一个数据，底层会发生什么

## ★ Map多个协程去写有什么问题，怎么解决

## ★ 写代码：用waitGroup控制多协程去读map

## ★ 写代码：用两个【协程】和【锁】去写map

## ★ map怎么实现【并发安全】。读写锁

## ★ sync包中map（没使用过

## 28 Go中CAS是怎么回事

## 29 Go中的【逃逸分析】是什么

## 30 Go【值接收者】和【【指针】接收者】的区别

## 31 Go的【对象】在【内存】中是怎样分配的

## 32 栈的【内存】是怎么分配的

## 33 【堆内存】管理怎么分配的

## 35 在Go函数中为什么会发生【内存泄露】

## ★ Go中new和make的区别

## 37 G0的作用

## 41 Go中的http包的实现原理

## 42 Goroutine发生了【泄漏】如何检测

## 43 Go函数返回【局部变量】的【指针】是否安全

## 44 Go中两个Nil可能不相等吗

## 46 为何【GPM调度】要有P
