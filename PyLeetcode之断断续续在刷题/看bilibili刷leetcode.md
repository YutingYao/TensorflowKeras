<!-- vscode-markdown-toc -->
* 1. [经验](#)
* 2. [算法](#-1)
* 3. [题目](#-1)
	* 3.1. [1 Two Sum](#TwoSum)
	* 3.2. [2. Add Two Numbers](#AddTwoNumbers)
	* 3.3. [3. 数组中重复的数字 Longest Substring Without Repeating Characters](#LongestSubstringWithoutRepeatingCharacters)
	* 3.4. [4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays](#MedianofTwoSortedArrays)
	* 3.5. [5. Longest Palindromic Substring -最长回文子串](#LongestPalindromicSubstring-)
	* 3.6. [6. ZigZag Conversion](#ZigZagConversion)
	* 3.7. [7 Reverse Integer](#ReverseInteger)
	* 3.8. [8. String to Integer(atoi)](#StringtoIntegeratoi)
	* 3.9. [9-Palindrome](#Palindrome)
	* 3.10. [11. Container With Most Water](#ContainerWithMostWater)
	* 3.11. [12. Integer to Roman](#IntegertoRoman)
	* 3.12. [13. 机器人的运动范围](#-1)
	* 3.13. [13. Roman to Integer](#RomantoInteger)
	* 3.14. [14-Longest common prefix](#Longestcommonprefix)
	* 3.15. [15. 3Sum](#Sum)
	* 3.16. [16. 3Sum Closest](#SumClosest)
	* 3.17. [17. Letter Combinations of a Phone Number](#LetterCombinationsofaPhoneNumber)
	* 3.18. [19-Remove Nth Node From End of List](#RemoveNthNodeFromEndofList)
	* 3.19. [20-Valid parentheses](#Validparentheses)
	* 3.20. [21-Merge two sorted lists](#Mergetwosortedlists)
	* 3.21. [22. Generate Parentheses](#GenerateParentheses)
	* 3.22. [23. Merge k Sorted Lists](#MergekSortedLists)
	* 3.23. [24-Swap Nodes in Pairs](#SwapNodesinPairs)
	* 3.24. [26-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray)
	* 3.25. [27-python-Remove element](#python-Removeelement)
	* 3.26. [28-Implement str](#Implementstr)
	* 3.27. [31 Next Permutation](#NextPermutation)
	* 3.28. [32 Longest Valid Parentheses](#LongestValidParentheses)
	* 3.29. [33. Search in Rotated Sorted Array](#SearchinRotatedSortedArray)
	* 3.30. [34-在排序数组中查找元素的第一个](#-1)
	* 3.31. [35-搜索插入位置](#-1)
	* 3.32. [36-有效的数独](#-1)
	* 3.33. [37. Sudoku Solver 解数独](#SudokuSolver)
	* 3.34. [38-Count and say](#Countandsay)
	* 3.35. [39. Combination Sum 39-组合总和](#CombinationSum39-)
	* 3.36. [40. Combination Sum II 40-组合总和 II](#CombinationSumII40-II)
	* 3.37. [41 First Missing Positive](#FirstMissingPositive)
	* 3.38. [42. Trapping Rain Water](#TrappingRainWater)
	* 3.39. [45 Jump Game II](#JumpGameII)
	* 3.40. [46-把数字翻译成字符串](#-1)
	* 3.41. [46-全排列](#-1)
	* 3.42. [47-全排列 II-剪枝版](#II-)
	* 3.43. [48. 旋转图像 Rotate Image](#RotateImage)
	* 3.44. [49 Group Anagrams](#GroupAnagrams)
	* 3.45. [50 Pow(x, n)](#Powxn)
	* 3.46. [51. 数组中的逆序对](#-1)
	* 3.47. [53-Maximum subarray](#Maximumsubarray)
	* 3.48. [54. Spiral Matrix](#SpiralMatrix)
	* 3.49. [55 Jump Game](#JumpGame)
	* 3.50. [56-I. 数组中数字出现的次数](#I.)
	* 3.51. [56. Merge Intervals](#MergeIntervals)
	* 3.52. [57. Insert Interval](#InsertInterval)
	* 3.53. [58. Lengh of Last Words](#LenghofLastWords)
	* 3.54. [59 - II. 队列的最大值 LCOF](#II.LCOF)
	* 3.55. [59. Spiral Matrix II](#SpiralMatrixII)
	* 3.56. [61. Rotate List](#RotateList)
	* 3.57. [62-不同路径](#-1)
	* 3.58. [63 Unique Paths II](#UniquePathsII)
	* 3.59. [64. Minimum Path Sum 64-最小路径和](#MinimumPathSum64-)
	* 3.60. [65 Valid Number](#ValidNumber)
	* 3.61. [66-Plus one](#Plusone)
	* 3.62. [67-Add Binary](#AddBinary)
	* 3.63. [69 Sqrt(x)](#Sqrtx)
	* 3.64. [70. Climbing Stairs](#ClimbingStairs)
	* 3.65. [71. Simplify Path](#SimplifyPath)
	* 3.66. [72. Edit Distance 72-编辑距离](#EditDistance72-)
	* 3.67. [73. Set Matrix Zeroes](#SetMatrixZeroes)
* 4. [74 Search a 2D Matrix](#Searcha2DMatrix)
	* 4.1. [75. Sort Colors](#SortColors)
	* 4.2. [76-最小覆盖子串](#-1)
	* 4.3. [77. 组合](#-1)
	* 4.4. [78. Subsets 78-子集](#Subsets78-)
	* 4.5. [79. Word Search](#WordSearch)
	* 4.6. [80 Remove Duplicates from Sorted Array II](#RemoveDuplicatesfromSortedArrayII)
	* 4.7. [82. 删除排序链表中的重复元素 II(Remove Duplicates from Sorted List](#IIRemoveDuplicatesfromSortedList)
	* 4.8. [83-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray-1)
	* 4.9. [84. 柱状图中最大的矩形 Largest Rectangle in Histogram](#LargestRectangleinHistogram)
	* 4.10. [86. 分隔链表(Partition List)](#PartitionList)
	* 4.11. [87. Scramble String](#ScrambleString)
	* 4.12. [88-Merge sorted array](#Mergesortedarray)
	* 4.13. [89](#-1)
	* 4.14. [90-子集 II](#II)
	* 4.15. [91. Decode Ways](#DecodeWays)
	* 4.16. [92-Reverse Linked List II](#ReverseLinkedListII)
	* 4.17. [93](#-1)
	* 4.18. [94-Inorder wih stack](#Inorderwihstack)
	* 4.19. [94-Binary Tree Inorder Traversal](#BinaryTreeInorderTraversal)
	* 4.20. [96. Unique Binary Search Trees](#UniqueBinarySearchTrees)
	* 4.21. [98. Validate Binary Search Tree 98-验证二叉搜索树](#ValidateBinarySearchTree98-)
	* 4.22. [100-Same Tree](#SameTree)
	* 4.23. [101-Symmetric tree](#Symmetrictree)
	* 4.24. [102-Binary Tree Level Order Traversal](#BinaryTreeLevelOrderTraversal)
	* 4.25. [103. Binary Tree Zigzag Level Order Traversal](#BinaryTreeZigzagLevelOrderTraversal)
	* 4.26. [104-Maximum Depth of Binary](#MaximumDepthofBinary)
	* 4.27. [105-从前序与中序遍历序列构](#-1)
	* 4.28. [106-从中序与后序遍历序列构造二叉树](#-1)
	* 4.29. [107-Binary Tree Level Order Traversal II](#BinaryTreeLevelOrderTraversalII)
	* 4.30. [108 Convert Sorted Array to Binary Search Tree](#ConvertSortedArraytoBinarySearchTree)
	* 4.31. [110-Balanced Binary Tree](#BalancedBinaryTree)
	* 4.32. [111-Minimum Depth of Binary Tree](#MinimumDepthofBinaryTree)
	* 4.33. [112-Path Sum](#PathSum)
	* 4.34. [113. 二叉树中和为某一值的路径](#-1)
	* 4.35. [115. Distinct Subsequences](#DistinctSubsequences)
	* 4.36. [116. Populating Next Right Pointers in Each Node](#PopulatingNextRightPointersinEachNode)
	* 4.37. [117 Populating Next Right Pointers in Ea](#PopulatingNextRightPointersinEa)
	* 4.38. [118-Pascal's Triangle](#PascalsTriangle)
	* 4.39. [119-Pascal's Triangle II](#PascalsTriangleII)
	* 4.40. [120 Triangle](#Triangle)
	* 4.41. [121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机](#BestTimetoBuyandSellStock121-)
	* 4.42. [122-买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II](#II122-BestTimetoBuyandSellStockII)
	* 4.43. [123-买卖股票的最佳时机 III](#III)
	* 4.44. [124. Binary Tree Maximum Path Sum](#BinaryTreeMaximumPathSum)
	* 4.45. [125-Valid Palindrome](#ValidPalindrome)
	* 4.46. [126. Word Ladder II](#WordLadderII)
	* 4.47. [127. Word Ladder](#WordLadder)
	* 4.48. [128. Longest Consecutive Sequence](#LongestConsecutiveSequence)
	* 4.49. [129 Sum Root to Leaf Numbers](#SumRoottoLeafNumbers)
	* 4.50. [130. Surrounded Regions 130-被围绕的区域](#SurroundedRegions130-)
	* 4.51. [131-分割回文串](#-1)
	* 4.52. [132. Palindrome Partitioning II](#PalindromePartitioningII)
	* 4.53. [133. Clone Graph](#CloneGraph)
	* 4.54. [134. Gas Station](#GasStation)
	* 4.55. [138 Copy List with Random Pointer](#CopyListwithRandomPointer)
	* 4.56. [136-Single Number](#SingleNumber)
	* 4.57. [137 Single Number II](#SingleNumberII)
	* 4.58. [139 Word Break](#WordBreak)
	* 4.59. [140 Word Break II](#WordBreakII)
	* 4.60. [141-Linked List Cycle](#LinkedListCycle)
	* 4.61. [142 Linked List Cycle II](#LinkedListCycleII)
	* 4.62. [143 Reorder List](#ReorderList)
	* 4.63. [144-Preorder with stack](#Preorderwithstack)
	* 4.64. [144-Binary Tree Preorder Traversal](#BinaryTreePreorderTraversal)
	* 4.65. [145-Postorder with stack](#Postorderwithstack)
	* 4.66. [145-Binary Tree Postorder Traversal](#BinaryTreePostorderTraversal)
	* 4.67. [146 LRU Cache](#LRUCache)
	* 4.68. [147 Insertion Sort List](#InsertionSortList)
	* 4.69. [148. Sort List](#SortList)
	* 4.70. [149. Max Points on a Line](#MaxPointsonaLine)
	* 4.71. [150. Evaluate Reverse Polish Notation](#EvaluateReversePolishNotation)
	* 4.72. [151. Reverse Words in a String](#ReverseWordsinaString)
	* 4.73. [152-乘积最大子数组](#-1)
	* 4.74. [153-寻找旋转排序数组中的最小值](#-1)
	* 4.75. [154 Find Minimum in Rotated Sorted Arr](#FindMinimuminRotatedSortedArr)
	* 4.76. [155-Min Stack](#MinStack)
	* 4.77. [160-Intersection of Two Linked Lists](#IntersectionofTwoLinkedLists)
	* 4.78. [162. Find Peak Element](#FindPeakElement)
	* 4.79. [165. Compare Version Numbers](#CompareVersionNumbers)
	* 4.80. [166. Fraction to Recurring Decimal](#FractiontoRecurringDecimal)
	* 4.81. [167-Two Sum II - Input array is sorted](#TwoSumII-Inputarrayissorted)
	* 4.82. [168-Excel Sheet Column Title](#ExcelSheetColumnTitle)
	* 4.83. [169. Majority Element](#MajorityElement)
	* 4.84. [171. Excel Sheet Column Number](#ExcelSheetColumnNumber)
	* 4.85. [172-Factorial Trailing Zeroes](#FactorialTrailingZeroes)
	* 4.86. [173 Binary Search Tree Iterator](#BinarySearchTreeIterator)
	* 4.87. [174 Dungeon Game](#DungeonGame)
	* 4.88. [179 Largest Number](#LargestNumber)
	* 4.89. [186. Reverse Words in a String II](#ReverseWordsinaStringII)
	* 4.90. [187 Repeated DNA Sequences](#RepeatedDNASequences)
	* 4.91. [188 Best Time to Buy and Sell Stock IV](#BestTimetoBuyandSellStockIV)
	* 4.92. [189. Rotate Array](#RotateArray)
	* 4.93. [190. Reverse Bits](#ReverseBits)
	* 4.94. [191 Number of 1 Bits](#Numberof1Bits)
	* 4.95. [198. House Robber 198-打家劫舍](#HouseRobber198-)
	* 4.96. [199 Binary Tree Right Side View](#BinaryTreeRightSideView)
	* 4.97. [200-岛屿数量](#-1)
	* 4.98. [201 Bitwise AND of Numbers Range](#BitwiseANDofNumbersRange)
	* 4.99. [202. 快乐数 Happy Number](#HappyNumber)
	* 4.100. [203. Remove Linked List Elements](#RemoveLinkedListElements)
	* 4.101. [204-Count Primes](#CountPrimes)
	* 4.102. [205. isomorphic strings](#isomorphicstrings)
	* 4.103. [206-Reverse Linked List](#ReverseLinkedList)
	* 4.104. [207-课程表](#-1)
	* 4.105. [208. Implement Trie (Prefix Tree)](#ImplementTriePrefixTree)
	* 4.106. [209-长度最小的子数组](#-1)
	* 4.107. [210. Course Schedule II 210-课程表II](#CourseScheduleII210-II)
	* 4.108. [211 Add and Search Word](#AddandSearchWord)
	* 4.109. [212. Word Search II](#WordSearchII)
	* 4.110. [213. House Robber II 213-打家劫舍II](#HouseRobberII213-II)
	* 4.111. [216. Combination Sum III 216-组合总和 III](#CombinationSumIII216-III)
	* 4.112. [217. Contains Duplicate](#ContainsDuplicate)
	* 4.113. [218. The Skyline Problem](#TheSkylineProblem)
	* 4.114. [219. Contains Duplicate II](#ContainsDuplicateII)
	* 4.115. [220 Contains Duplicate III](#ContainsDuplicateIII)
	* 4.116. [221-最大正方形](#-1)
	* 4.117. [222. Count Complete Tree Nodes](#CountCompleteTreeNodes)
	* 4.118. [223. Rectangle Area](#RectangleArea)
	* 4.119. [225-Implement Stack using Queues](#ImplementStackusingQueues)
	* 4.120. [226-翻转二叉树](#-1)
	* 4.121. [227 Basic Calculator II](#BasicCalculatorII)
	* 4.122. [228 Summary Ranges](#SummaryRanges)
	* 4.123. [229. Majority Element II](#MajorityElementII)
	* 4.124. [230 Kth Smallest Element in a B](#KthSmallestElementinaB)
	* 4.125. [231. Power of Two](#PowerofTwo)
	* 4.126. [232-Implement Queue using Stacks](#ImplementQueueusingStacks)
	* 4.127. [234. Palindrome Linked List](#PalindromeLinkedList)
	* 4.128. [235. Lowest Common Ancestor of a Binary Search Tree](#LowestCommonAncestorofaBinarySearchTree)
	* 4.129. [236-二叉树的最近公共祖先](#-1)
	* 4.130. [237. Delete Node in a Linked List](#DeleteNodeinaLinkedList)
	* 4.131. [238 Product of Array Except Self](#ProductofArrayExceptSelf)
	* 4.132. [239. Sliding Window Maximum](#SlidingWindowMaximum)
	* 4.133. [240. 二维数组的查找](#-1)
	* 4.134. [242. Valid Anagram](#ValidAnagram)
	* 4.135. [243. Shortest Word Distance](#ShortestWordDistance)
	* 4.136. [246. Strobogrammatic Number](#StrobogrammaticNumber)
	* 4.137. [257-二叉树的所有路径](#-1)
	* 4.138. [258. Add Digits](#AddDigits)
	* 4.139. [260-只出现一次的数字 III](#III-1)
	* 4.140. [263 Ugly Number](#UglyNumber)
	* 4.141. [264. Ugly Number II](#UglyNumberII)
	* 4.142. [268 Missing Number](#MissingNumber)
	* 4.143. [270. Closest Binary Search Tree Value](#ClosestBinarySearchTreeValue)
	* 4.144. [274 H-Index](#H-Index)
	* 4.145. [278. First Bad Version](#FirstBadVersion)
	* 4.146. [279 Perfect Squares](#PerfectSquares)
	* 4.147. [282. Expression Add Operators](#ExpressionAddOperators)
	* 4.148. [283. Move Zeros](#MoveZeros)
	* 4.149. [284 Peeking Iterator](#PeekingIterator)
	* 4.150. [287 Find the Duplicate Number](#FindtheDuplicateNumber)
	* 4.151. [289. Game of Life](#GameofLife)
	* 4.152. [290. Word Pattern](#WordPattern)
	* 4.153. [297. Serialize and Deserialize Binary Tree](#SerializeandDeserializeBinaryTree)
	* 4.154. [299. Bulls and Cows](#BullsandCows)
	* 4.155. [300 Longest Increasing Subsequence 最长上升子序列](#LongestIncreasingSubsequence)
	* 4.156. [301. Remove Invalid Parentheses](#RemoveInvalidParentheses)
	* 4.157. [303-区域和检索 - 数组不可变](#-1)
	* 4.158. [304. Range Sum Query 2D](#RangeSumQuery2D)
	* 4.159. [309. Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期](#BestTimetoBuyandSellStockwithCooldown309-)
	* 4.160. [310 Minimum Height Trees](#MinimumHeightTrees)
	* 4.161. [312 Burst Balloons](#BurstBalloons)
	* 4.162. [315. Count of Smaller Numbers After Self](#CountofSmallerNumbersAfterSelf)
	* 4.163. [316 Remove Duplicate Letters](#RemoveDuplicateLetters)
	* 4.164. [321. Create Maximum Number](#CreateMaximumNumber)
	* 4.165. [322. Coin Change](#CoinChange)
	* 4.166. [326. Power of Three](#PowerofThree)
	* 4.167. [328. 奇偶链表 (Odd Even Linked List)](#OddEvenLinkedList)
	* 4.168. [329. Longest Increasing Path in a Matrix](#LongestIncreasingPathinaMatrix)
	* 4.169. [332 Reconstruct Itinerary](#ReconstructItinerary)
	* 4.170. [334 Increasing Triplet Subseque](#IncreasingTripletSubseque)
	* 4.171. [337 House Robber III](#HouseRobberIII)
	* 4.172. [338 Counting Bits](#CountingBits)
	* 4.173. [342. Power of Four](#PowerofFour)
	* 4.174. [343-整数拆分](#-1)
	* 4.175. [344. Reverse String](#ReverseString)
	* 4.176. [345. Reverse Vowels of a String](#ReverseVowelsofaString)
	* 4.177. [346 Moving Average from Data Stream](#MovingAveragefromDataStream)
	* 4.178. [347. Top K Frequent Elements](#TopKFrequentElements)
	* 4.179. [349. Intersection of Two Arrays](#IntersectionofTwoArrays)
	* 4.180. [350. Intersection of Two Arrays II](#IntersectionofTwoArraysII)
	* 4.181. [355. 设计推特 Design Twitter](#DesignTwitter)
	* 4.182. [359 Logger Rate Limiter](#LoggerRateLimiter)
	* 4.183. [367. Valid Perfect Square](#ValidPerfectSquare)
	* 4.184. [368 Largest Divisible Subset](#LargestDivisibleSubset)
	* 4.185. [373. Find K Pairs with Smallest Sums查找和最小的k对数字](#FindKPairswithSmallestSumsk)
	* 4.186. [374. Guess Number Higher or Lower](#GuessNumberHigherorLower)
	* 4.187. [376-摆动序列](#-1)
	* 4.188. [377. Combination Sum IV](#CombinationSumIV)
	* 4.189. [378-有序矩阵中第K小的元素](#K)
	* 4.190. [380 Insert Delete GetRandom O(1)](#InsertDeleteGetRandomO1)
	* 4.191. [382 Linked List Random Node](#LinkedListRandomNode)
	* 4.192. [383 Ransom Note](#RansomNote)
	* 4.193. [387. First Unique Character in a String](#FirstUniqueCharacterinaString)
	* 4.194. [389. Find the Difference](#FindtheDifference)
	* 4.195. [391. Perfect Rectangle](#PerfectRectangle)
	* 4.196. [392. Is Subsequence](#IsSubsequence)
	* 4.197. [393. UTF-8 Validation](#UTF-8Validation)
	* 4.198. [394 Decode String](#DecodeString)
	* 4.199. [395 Longest Substring with At Least K](#LongestSubstringwithAtLeastK)
	* 4.200. [399. Evaluate Division](#EvaluateDivision)
	* 4.201. [402 Remove K Digits](#RemoveKDigits)
	* 4.202. [404. Sum of Left Leaves](#SumofLeftLeaves)
	* 4.203. [405-Convert a Number to Hexadecimal](#ConvertaNumbertoHexadecimal)
	* 4.204. [406. Queue Reconstruction by Height](#QueueReconstructionbyHeight)
	* 4.205. [408. Valid Word Abbreviation](#ValidWordAbbreviation)
	* 4.206. [409. Longest Palindrome](#LongestPalindrome)
	* 4.207. [410. Split Array Largest Sum](#SplitArrayLargestSum)
	* 4.208. [412. Fizz Buzz](#FizzBuzz)
	* 4.209. [413-等差数列划分](#-1)
	* 4.210. [414. Third Maximum Number](#ThirdMaximumNumber)
	* 4.211. [415-Add Strings](#AddStrings)
	* 4.212. [416. Partition Equal Subset Sum](#PartitionEqualSubsetSum)
	* 4.213. [417. Pacific Atlantic Water Flow](#PacificAtlanticWaterFlow)
	* 4.214. [419. Battleships in a Board](#BattleshipsinaBoard)
	* 4.215. [421 Maximum XOR of Two Numbers in an Array](#MaximumXORofTwoNumbersinanArray)
	* 4.216. [423 Reconstruct Original Digits from English](#ReconstructOriginalDigitsfromEnglish)
	* 4.217. [424. 替换后的最长重复字符 Longest Repeating Character Replacem](#LongestRepeatingCharacterReplacem)
	* 4.218. [429. N-ary Tree Level Order Traversal](#N-aryTreeLevelOrderTraversal)
	* 4.219. [430 Flatten a Multilevel Doubly Linked List](#FlattenaMultilevelDoublyLinkedList)
	* 4.220. [432. All O`one Data Structure](#AllOoneDataStructure)
	* 4.221. [435-Non-overlapping Intervals](#Non-overlappingIntervals)
	* 4.222. [436 Find Right Interval](#FindRightInterval)
	* 4.223. [437 Path Sum III](#PathSumIII)
	* 4.224. [438. Find All Anagrams in a String](#FindAllAnagramsinaString)
	* 4.225. [441 Arranging Coins](#ArrangingCoins)
	* 4.226. [442 Find All Duplicates in an Array](#FindAllDuplicatesinanArray)
	* 4.227. [443. String Compression](#StringCompression)
	* 4.228. [445-Add Two Numbers II](#AddTwoNumbersII)
	* 4.229. [447. Number of Boomerangs](#NumberofBoomerangs)
	* 4.230. [448. Find All Numbers Disappeared in an Array](#FindAllNumbersDisappearedinanArray)
	* 4.231. [449. Serialize and Deserialize BST](#SerializeandDeserializeBST)
	* 4.232. [450. Delete Node in a BST](#DeleteNodeinaBST)
	* 4.233. [451 Sort Characters By Frequency](#SortCharactersByFrequency)
	* 4.234. [454 4Sum II](#SumII)
	* 4.235. [452. Minimum Number of Arrows to Burst Balloons](#MinimumNumberofArrowstoBurstBalloons)
	* 4.236. [455-Assign Cookies](#AssignCookies)
	* 4.237. [456 132 Pattern](#Pattern)
	* 4.238. [458 Poor Pigs](#PoorPigs)
	* 4.239. [459 Repeated Substring Pattern](#RepeatedSubstringPattern)
	* 4.240. [460. LFU Cache / O(1)](#LFUCacheO1)
	* 4.241. [461 Hamming Distance](#HammingDistance)
	* 4.242. [463 Island Perimeter](#IslandPerimeter)
	* 4.243. [464. Can I Win](#CanIWin)
	* 4.244. [466. 统计重复个数 Count The Repetitions](#CountTheRepetitions)
	* 4.245. [468 Validate IP Address](#ValidateIPAddress)
	* 4.246. [470. Implement Rand10() Using Rand7()](#ImplementRand10UsingRand7)
	* 4.247. [475. Heaters](#Heaters)
	* 4.248. [476. Number Complement](#NumberComplement)
	* 4.249. [477. Total Hamming Distance](#TotalHammingDistance)
	* 4.250. [478 Generate Random Point in a Circle](#GenerateRandomPointinaCircle)
	* 4.251. [480. Sliding Window Median](#SlidingWindowMedian)
	* 4.252. [484 Find Permutation](#FindPermutation)
	* 4.253. [485. Max Consecutive Ones](#MaxConsecutiveOnes)
	* 4.254. [486. Predict the Winner](#PredicttheWinner)
	* 4.255. [490 The Maze](#TheMaze)
	* 4.256. [494. Target Sum](#TargetSum)
	* 4.257. [495 Teemo Attacking](#TeemoAttacking)
	* 4.258. [496. 下一个更大元素 I (Next Greater Element I)](#INextGreaterElementI)
	* 4.259. [497 Random Point in Non-overlapping](#RandomPointinNon-overlapping)
	* 4.260. [500. Keyboard Row](#KeyboardRow)
	* 4.261. [503-Next Greater Element II](#NextGreaterElementII)
	* 4.262. [504-Base 7](#Base7)
	* 4.263. [509. Fibonacci Number](#FibonacciNumber)
	* 4.264. [516. Longest Palindromic Subsequence](#LongestPalindromicSubsequence)
	* 4.265. [518 Coin Change 2](#CoinChange2)
	* 4.266. [520. Detect Capital](#DetectCapital)
	* 4.267. [525. Contiguous Array](#ContiguousArray)
	* 4.268. [526 Beautiful Arrangement](#BeautifulArrangement)
	* 4.269. [528 Random Pick with Weight](#RandomPickwithWeight)
	* 4.270. [530. Minimum Absolute Difference in BST](#MinimumAbsoluteDifferenceinBST)
	* 4.271. [532 K-diff Pairs in an Array](#K-diffPairsinanArray)
	* 4.272. [535. Encode and Decode TinyURL](#EncodeandDecodeTinyURL)
	* 4.273. [537 Complex Number Multiplicatin](#ComplexNumberMultiplicatin)
	* 4.274. [538 Convert BST to Greater Tree](#ConvertBSTtoGreaterTree)
	* 4.275. [540. Single Element in a Sorted Array 540-有序数组中的单一元素](#SingleElementinaSortedArray540-)
	* 4.276. [542. 01 矩阵 01 Matrix](#Matrix)
	* 4.277. [543 Diameter of Binary Tree](#DiameterofBinaryTree)
	* 4.278. [546 Remove Boxes](#RemoveBoxes)
	* 4.279. [547-朋友圈](#-1)
	* 4.280. [554 Brick Wall](#BrickWall)
	* 4.281. [556 Next Greater Element III](#NextGreaterElementIII)
	* 4.282. [560. Subarray Sum Equals K 和为K的子数组](#SubarraySumEqualsKK)
	* 4.283. [563 Binary Tree Tilt](#BinaryTreeTilt)
	* 4.284. [567. Permutation in String 567-字符串的排列](#PermutationinString567-)
	* 4.285. [572-另一个树的子树](#-1)
	* 4.286. [575 Distribute Candies](#DistributeCandies)
	* 4.287. [576. Out of Boundary Paths](#OutofBoundaryPaths)
	* 4.288. [581 Shortest Unsorted Continuous Suba](#ShortestUnsortedContinuousSuba)
	* 4.289. [589 N-ary Tree Preorder Traversal](#N-aryTreePreorderTraversal)
	* 4.290. [593 Valid Square](#ValidSquare)
	* 4.291. [594 Longest Harmonious Subsequence](#LongestHarmoniousSubsequence)
	* 4.292. [605 Can Place Flowers](#CanPlaceFlowers)
	* 4.293. [621. Task Scheduler](#TaskScheduler)
	* 4.294. [622 Design Circular Queue](#DesignCircularQueue)
	* 4.295. [623 Add One Row to Tree](#AddOneRowtoTree)
	* 4.296. [633-Sum of Square Numbers](#SumofSquareNumbers)
	* 4.297. [636. Exclusive Time of Functions](#ExclusiveTimeofFunctions)
	* 4.298. [637 Average of Levels in Binary Tree](#AverageofLevelsinBinaryTree)
	* 4.299. [639. Decode Ways II](#DecodeWaysII)
	* 4.300. [643. Maximum Average Subarray I](#MaximumAverageSubarrayI)
	* 4.301. [645-错误的集合](#-1)
	* 4.302. [646-最长数对链](#-1)
	* 4.303. [647 Palindromic Substrings](#PalindromicSubstrings)
	* 4.304. [650-只有两个键的键盘](#-1)
	* 4.305. [652. Find Duplicate Subtrees](#FindDuplicateSubtrees)
	* 4.306. [653. Two Sum IV](#TwoSumIV)
	* 4.307. [662. Maximum Width of Binary Tree](#MaximumWidthofBinaryTree)
	* 4.308. [667 Beautiful Arrangement II](#BeautifulArrangementII)
	* 4.309. [668. Kth Smallest Number in Multiplication Table](#KthSmallestNumberinMultiplicationTable)
	* 4.310. [669 Trim a Binary Search Tree](#TrimaBinarySearchTree)
	* 4.311. [673 Number of Longest Increasing Subse](#NumberofLongestIncreasingSubse)
	* 4.312. [678 Valid Parenthesis String](#ValidParenthesisString)
	* 4.313. [680-Valid Palindrome II](#ValidPalindromeII)
	* 4.314. [683. K Empty Slots](#KEmptySlots)
	* 4.315. [684. Redundant Connection 684-冗余连接](#RedundantConnection684-)
	* 4.316. [685. Redundant Connection II](#RedundantConnectionII)
	* 4.317. [687. Longest Univalue Path](#LongestUnivaluePath)
	* 4.318. [688. Knight Probability in Chessboard](#KnightProbabilityinChessboard)
	* 4.319. [690. Employee Importance](#EmployeeImportance)
	* 4.320. [692. Top K Frequent Words](#TopKFrequentWords)
	* 4.321. [695-岛屿的最大面积](#-1)
	* 4.322. [696 Count Binary Substrings](#CountBinarySubstrings)
	* 4.323. [699. Falling Squares](#FallingSquares)
	* 4.324. [700 Search in a Binary Search Tree](#SearchinaBinarySearchTree)
	* 4.325. [701 Insert into a Binary Search Tree](#InsertintoaBinarySearchTree)
	* 4.326. [703.Kth Largest Element in a Stream数据流中的第K大元素](#KthLargestElementinaStreamK)
	* 4.327. [704.Binary Search二分查找](#BinarySearch)
	* 4.328. [705 Design HashSet](#DesignHashSet)
	* 4.329. [706. Design HashMap设计哈希映射](#DesignHashMap)
	* 4.330. [707. Design Linked List](#DesignLinkedList)
	* 4.331. [712. Minimum ASCII Delete Sum for Two Strings](#MinimumASCIIDeleteSumforTwoStrings)
	* 4.332. [713 Subarray Product Less Than K](#SubarrayProductLessThanK)
	* 4.333. [714-买卖股票的最佳时机含手续费](#-1)
	* 4.334. [715. Range Module](#RangeModule)
	* 4.335. [719. Find K-th Smallest Pair Distance](#FindK-thSmallestPairDistance)
	* 4.336. [720. Longest Word in Dictionary](#LongestWordinDictionary)
	* 4.337. [724. Find Pivot Index](#FindPivotIndex)
	* 4.338. [725. Split Linked List in Parts](#SplitLinkedListinParts)
	* 4.339. [726. Number of Atoms](#NumberofAtoms)
	* 4.340. [730. Count Different Palindromic Subsequences](#CountDifferentPalindromicSubsequences)
	* 4.341. [732. My Calendar III](#MyCalendarIII)
	* 4.342. [733. 图像渲染 Flood Fill](#FloodFill)
	* 4.343. [735 Asteroid Collision](#AsteroidCollision)
	* 4.344. [737. Sentence Similarity II](#SentenceSimilarityII)
	* 4.345. [739-Daily Temperatures](#DailyTemperatures)
	* 4.346. [740. Delete and Earn](#DeleteandEarn)
	* 4.347. [741. Cherry Pickup](#CherryPickup)
	* 4.348. [743. Network Delay Time](#NetworkDelayTime)
	* 4.349. [745. Prefix and Suffix Search](#PrefixandSuffixSearch)
	* 4.350. [746. Min Cost Climbing Stairs](#MinCostClimbingStairs)
	* 4.351. [748. Shortest Completing Word](#ShortestCompletingWord)
	* 4.352. [752. Open the Lock](#OpentheLock)
	* 4.353. [763 Partition Labels](#PartitionLabels)
	* 4.354. [765. 情侣牵手 Couples Holding Hands](#CouplesHoldingHands)
	* 4.355. [769. Max Chunks To Make Sorted](#MaxChunksToMakeSorted)
	* 4.356. [771 Jewels and Stones](#JewelsandStones)
	* 4.357. [773. Sliding Puzzle](#SlidingPuzzle)
	* 4.358. [775. Global and Local Inversions](#GlobalandLocalInversions)
	* 4.359. [778. Swim in Rising Water](#SwiminRisingWater)
	* 4.360. [784. Letter Case Permutation](#LetterCasePermutation)
	* 4.361. [785-判断二分图](#-1)
	* 4.362. [786. K-th Smallest Prime Fraction](#K-thSmallestPrimeFraction)
	* 4.363. [787. Cheapest Flights Within K Stops](#CheapestFlightsWithinKStops)
	* 4.364. [790. Domino and Tromino Tiling](#DominoandTrominoTiling)
	* 4.365. [792. Number of Matching Subsequences](#NumberofMatchingSubsequences)
	* 4.366. [797 All Paths From Source to Target](#AllPathsFromSourcetoTarget)
	* 4.367. [799 Champagne Tower](#ChampagneTower)
	* 4.368. [801. Minimum Swaps To Make Sequences Increasing](#MinimumSwapsToMakeSequencesIncreasing)
	* 4.369. [803. Bricks Falling When Hit](#BricksFallingWhenHit)
	* 4.370. [804 Unique Morse Code Words](#UniqueMorseCodeWords)
	* 4.371. [813. Largest Sum of Averages](#LargestSumofAverages)
	* 4.372. [815. Bus Routes](#BusRoutes)
	* 4.373. [817. Linked List Components](#LinkedListComponents)
	* 4.374. [818. Race Car (上)](#RaceCar)
	* 4.375. [821 Shortest Distance to a Character](#ShortestDistancetoaCharacter)
	* 4.376. [823. Binary Trees With Factors](#BinaryTreesWithFactors)
	* 4.377. [824 Goat Latin](#GoatLatin)
	* 4.378. [827. Making A Large Island](#MakingALargeIsland)
	* 4.379. [832 Flipping an Image](#FlippinganImage)
	* 4.380. [835 Image Overlap](#ImageOverlap)
	* 4.381. [837. 新 21 点 New 21 Game](#New21Game)
	* 4.382. [841 Keys and Rooms](#KeysandRooms)
	* 4.383. [842. Split Array into Fibonacci Sequence](#SplitArrayintoFibonacciSequence)
	* 4.384. [844 Backspace String Compare](#BackspaceStringCompare)
	* 4.385. [845 Longest Mountain in Array](#LongestMountaininArray)
	* 4.386. [847 Shortest Path Visiting All Nodes](#ShortestPathVisitingAllNodes)
	* 4.387. [849 Maximize Distance to Closest Person](#MaximizeDistancetoClosestPerson)
	* 4.388. [856. Score of Parentheses](#ScoreofParentheses)
	* 4.389. [858 Mirror Reflection](#MirrorReflection)
	* 4.390. [859 Buddy Strings](#BuddyStrings)
	* 4.391. [863. All Nodes Distance K in Binary Tree](#AllNodesDistanceKinBinaryTree)
	* 4.392. [864. Shortest Path to Get All Keys](#ShortestPathtoGetAllKeys)
	* 4.393. [869 Reordered Power of 2](#ReorderedPowerof2)
	* 4.394. [865. Smallest Subtree with all the Deepest Nodes](#SmallestSubtreewithalltheDeepestNodes)
	* 4.395. [871. Minimum Number of Refueling Stops](#MinimumNumberofRefuelingStops)
	* 4.396. [873. Length of Longest Fibonacci Subsequence](#LengthofLongestFibonacciSubsequence)
	* 4.397. [875.Koko Eating Bananas科科吃香蕉](#KokoEatingBananas)
	* 4.398. [876.Middle of the Linked List 链表的中间结点](#MiddleoftheLinkedList)
	* 4.399. [877 Stone Game](#StoneGame)
	* 4.400. [879. Profitable Schemes](#ProfitableSchemes)
	* 4.401. [880 Decoded String at Index](#DecodedStringatIndex)
	* 4.402. [881 Boats to Save People](#BoatstoSavePeople)
	* 4.403. [882. Reachable Nodes In Subdivided Graph](#ReachableNodesInSubdividedGraph)
	* 4.404. [886. Possible Bipartition](#PossibleBipartition)
	* 4.405. [887. Super Egg Drop](#SuperEggDrop)
	* 4.406. [889. Construct Binary Tree from Preorder and Postorder](#ConstructBinaryTreefromPreorderandPostorder)
	* 4.407. [891. Sum of Subsequence Widths](#SumofSubsequenceWidths)
	* 4.408. [894. All Possible Full Binary Trees](#AllPossibleFullBinaryTrees)
	* 4.409. [895. Maximum Frequency Stack](#MaximumFrequencyStack)
	* 4.410. [898. Bitwise ORs of Subarrays](#BitwiseORsofSubarrays)
	* 4.411. [901. Online Stock Span](#OnlineStockSpan)
	* 4.412. [902 Numbers At Most N Given Digit Set](#NumbersAtMostNGivenDigitSet)
	* 4.413. [904-水果成篮](#-1)
	* 4.414. [905 Sort Array By Parity](#SortArrayByParity)
	* 4.415. [906 Super Palindromes](#SuperPalindromes)
	* 4.416. [909. Snakes and Ladders](#SnakesandLadders)
	* 4.417. [910 Smallest Range II](#SmallestRangeII)
	* 4.418. [916 Word Subsetse](#WordSubsetse)
	* 4.419. [918 Maximum Sum Circular Sub](#MaximumSumCircularSub)
	* 4.420. [923. 3Sum With Multiplicity](#SumWithMultiplicity)
	* 4.421. [926. Flip String to Monotone Increasing](#FlipStringtoMonotoneIncreasing)
	* 4.422. [930-和相同的二元子数组(滑动窗口+前缀和)](#-1)
	* 4.423. [933 Number of Recent Calls](#NumberofRecentCalls)
	* 4.424. [934. Shortest Bridge](#ShortestBridge)
	* 4.425. [936 Stamping The Sequence](#StampingTheSequence)
	* 4.426. [938 Range Sum of BST](#RangeSumofBST)
	* 4.427. [941 Valid Mountain Array](#ValidMountainArray)
	* 4.428. [943. Find the Shortest Superstring](#FindtheShortestSuperstring)
	* 4.429. [946-Python-栈的压入、弹出序列](#Python-)
	* 4.430. [946 Validate Stack Sequences](#ValidateStackSequences)
	* 4.431. [947. 移除最多的同行或同列石头 Most Stones Removed with Same](#MostStonesRemovedwithSame)
	* 4.432. [948 Bag of Tokens](#BagofTokens)
	* 4.433. [949 Largest Time for Given Digits](#LargestTimeforGivenDigits)
	* 4.434. [952 Largest Component Size by Commo](#LargestComponentSizebyCommo)
	* 4.435. [953 Verifying an Alien Dictionary](#VerifyinganAlienDictionary)
	* 4.436. [954 Array of Doubled Pairs](#ArrayofDoubledPairs)
	* 4.437. [959. 由斜杠划分区域 Regions Cut By Slashes](#RegionsCutBySlashes)
	* 4.438. [964. Least Operators to Express Number](#LeastOperatorstoExpressNumber)
	* 4.439. [966 Vowel Spellchecker](#VowelSpellchecker)
	* 4.440. [967. Numbers With Same Consecutive Differences](#NumbersWithSameConsecutiveDifferences)
	* 4.441. [968 Binary Tree Cameras](#BinaryTreeCameras)
	* 4.442. [969 Pancake Sorting](#PancakeSorting)
	* 4.443. [971 Flip Binary Tree To Match Preorder](#FlipBinaryTreeToMatchPreorder)
	* 4.444. [973 K Closest Points to Origin](#KClosestPointstoOrigin)
	* 4.445. [974. 和可被 K 整除的子数组 Subarray Sums Divisible by K](#KSubarraySumsDivisiblebyK)
	* 4.446. [975. Odd Even Jump](#OddEvenJump)
	* 4.447. [976 Middle of the Linked List](#MiddleoftheLinkedList-1)
	* 4.448. [977 Squares of a Sorted Array](#SquaresofaSortedArray)
	* 4.449. [978. 最长湍流子数组 Longest Turbulent Subarray](#LongestTurbulentSubarray)
	* 4.450. [980. Unique Paths III](#UniquePathsIII)
	* 4.451. [983 Minimum Cost For Tickets](#MinimumCostForTickets)
	* 4.452. [986 Interval List Intersections](#IntervalListIntersections)
	* 4.453. [987 Vertical Order Traversal of a Binary](#VerticalOrderTraversalofaBinary)
	* 4.454. [990. 等式方程的可满足性 Satisfiability of Equality Equations](#SatisfiabilityofEqualityEquations)
	* 4.455. [992-K 个不同整数的子数组](#K-1)
	* 4.456. [993. 二叉树的堂兄弟节点](#-1)
	* 4.457. [994-腐烂的橘子](#-1)
	* 4.458. [993, 994, 995, 996](#-1)
	* 4.459. [997 Find the Town Judge](#FindtheTownJudge)
	* 4.460. [1000. Minimum Cost to Merge Stones](#MinimumCosttoMergeStones)
	* 4.461. [1001 Grid Illumination](#GridIllumination)
	* 4.462. [1004-最大连续1的个数 III](#III-1)
	* 4.463. [1007 Minimum Domino Rotations For Eq](#MinimumDominoRotationsForEq)
	* 4.464. [1008 Construct Binary Search Tree from](#ConstructBinarySearchTreefrom)
	* 4.465. [1009 Complement of Base 10 Integer](#ComplementofBase10Integer)
	* 4.466. [1010 Pairs of Songs With Total Durations](#PairsofSongsWithTotalDurations)
	* 4.467. [1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ](#PartitionArrayIntoThreePartsWithEqu)
	* 4.468. [1015 Smallest Integer Divisible by K](#SmallestIntegerDivisiblebyK)
	* 4.469. [1019. Next Greater Node In Linked List](#NextGreaterNodeInLinkedList)
	* 4.470. [1022 Sum of Root To Leaf Binary Numbers](#SumofRootToLeafBinaryNumbers)
	* 4.471. [1025,1026,1027,1028](#-1)
	* 4.472. [1024. Video Stitching](#VideoStitching)
	* 4.473. [1026 Maximum Difference Between Nod](#MaximumDifferenceBetweenNod)
	* 4.474. [1029 Two City Scheduling](#TwoCityScheduling)
	* 4.475. [1032 Stream of Characters](#StreamofCharacters)
	* 4.476. [1035 Uncrossed Lines](#UncrossedLines)
	* 4.477. [1041 Robot Bounded In Circle](#RobotBoundedInCircle)
	* 4.478. [1043. Partition Array for Maximum Sum](#PartitionArrayforMaximumSum)
	* 4.479. [1044 Longest Duplicate Substring](#LongestDuplicateSubstring)
	* 4.480. [1046 Last Stone Weight](#LastStoneWeight)
	* 4.481. [1048 Longest String Chain](#LongestStringChain)
	* 4.482. [1055.Shortest Way to Form String 形成字符串的最短路径](#ShortestWaytoFormString)
	* 4.483. [1091-二进制矩阵中的最短路径](#-1)
	* 4.484. [1094 Car Pooling](#CarPooling)
	* 4.485. [1095. Find in Mountain Array](#FindinMountainArray)
	* 4.486. [1105. Filling Bookcase Shelves](#FillingBookcaseShelves)
	* 4.487. [1106. Parsing A Boolean Expression](#ParsingABooleanExpression)
	* 4.488. [1110. Delete Nodes And Return Forest](#DeleteNodesAndReturnForest)
	* 4.489. [1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses](#MaximumNestingDepthofTwoValidParentheses)
	* 4.490. [1114 - 1115 - 1116 - 多线程 threading](#threading)
	* 4.491. [1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖](#LowestCommonAncestorofDeepestLeaves)
	* 4.492. [1124. Longest Well-Performing Interval](#LongestWell-PerformingInterval)
	* 4.493. [1125. Smallest Sufficient Team](#SmallestSufficientTeam)
	* 4.494. [1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs](#NumberofEquivalentDominoPairs)
	* 4.495. [1129. Shortest Path with Alternating Colors](#ShortestPathwithAlternatingColors)
	* 4.496. [1137. N-th Tribonacci Number](#N-thTribonacciNumber)
	* 4.497. [1140. Stone Game II](#StoneGameII)
	* 4.498. [1143 Longest Common Subsequence](#LongestCommonSubsequence)
	* 4.499. [1145. Binary Tree Coloring Game](#BinaryTreeColoringGame)
	* 4.500. [1155. Number of Dice Rolls With Target Sum](#NumberofDiceRollsWithTargetSum)
	* 4.501. [1160. 拼写单词 Find Words That Can Be Formed by Characters](#FindWordsThatCanBeFormedbyCharacters)
	* 4.502. [1172. Dinner Plate Stacks](#DinnerPlateStacks)
	* 4.503. [1178. Number of Valid Words for Each Puzzle](#NumberofValidWordsforEachPuzzle)
	* 4.504. [1187. Make Array Strictly Increasing](#MakeArrayStrictlyIncreasing)
	* 4.505. [1191. K-Concatenation Maximum Sum](#K-ConcatenationMaximumSum)
	* 4.506. [1201. Ugly Number III](#UglyNumberIII)
	* 4.507. [1202. Smallest String With Swaps](#SmallestStringWithSwaps)
	* 4.508. [1203. 项目管理 Sort Items by Groups Respecting Dependencies](#SortItemsbyGroupsRespectingDependencies)
	* 4.509. [1206. Design Skiplist](#DesignSkiplist)
	* 4.510. [1209 Remove All Adjacent Duplicates in](#RemoveAllAdjacentDuplicatesin)
	* 4.511. [1217 Minimum Cost to Move Chips](#MinimumCosttoMoveChips)
	* 4.512. [1218. Longest Arithmetic Subsequence of Given Difference](#LongestArithmeticSubsequenceofGivenDifference)
	* 4.513. [1220. Count Vowels Permutation](#CountVowelsPermutation)
	* 4.514. [1223 Dice Roll Simulation](#DiceRollSimulation)
	* 4.515. [1240 Tiling a Rectangle with the Fewest Squares](#TilingaRectanglewiththeFewestSquares)
	* 4.516. [1248-统计「优美子数组」](#-1)
	* 4.517. [1249 Minimum Remove to Make Valid Pare](#MinimumRemovetoMakeValidPare)
	* 4.518. [1252 1253 1254 1255](#-1)
	* 4.519. [1263. Minimum Moves to Move a Box to Their Target](#MinimumMovestoMoveaBoxtoTheirTarget)
	* 4.520. [1277-统计全为1的正方形子矩阵](#-1)
	* 4.521. [1278. Palindrome Partitioning III](#PalindromePartitioningIII)
	* 4.522. [1283 Find the Smallest Divisor Given a](#FindtheSmallestDivisorGivena)
	* 4.523. [1284. Minimum Number of Flips to Convert Binary Matrix](#MinimumNumberofFlipstoConvertBinaryMatrix)
	* 4.524. [1290. 二进制链表转整数 (Convert Binary Number in a Linked List](#ConvertBinaryNumberinaLinkedList)
	* 4.525. [1291 Sequential Digits](#SequentialDigits)
	* 4.526. [1293. Shortest Path in a Grid with Obstacles Elimination](#ShortestPathinaGridwithObstaclesElimination)
	* 4.527. [1296. Divide Array in Sets of K Consecutive Numbers](#DivideArrayinSetsofKConsecutiveNumbers)
	* 4.528. [1301. Number of Paths with Max Score](#NumberofPathswithMaxScore)
	* 4.529. [1302 Deepest Leaves Sum](#DeepestLeavesSum)
	* 4.530. [1305 All Elements in Two Binary Search](#AllElementsinTwoBinarySearch)
	* 4.531. [1306 Jump Game III](#JumpGameIII)
	* 4.532. [1310. XOR Queries of a Subarray](#XORQueriesofaSubarray)
	* 4.533. [1312. Minimum Insertion Steps to Make a String Palindrom](#MinimumInsertionStepstoMakeaStringPalindrom)
	* 4.534. [1320. Minimum Distance to Type a Word Using Two Finger](#MinimumDistancetoTypeaWordUsingTwoFinger)
	* 4.535. [1329 Sort the Matrix Diagonally](#SorttheMatrixDiagonally)
	* 4.536. [1332 Remove Palindromic Subsequences](#RemovePalindromicSubsequences)
	* 4.537. [1334. Find the City With Smallest Number of Neighbors](#FindtheCityWithSmallestNumberofNeighbors)
	* 4.538. [1335. Minimum Difficulty of a Job Schedule](#MinimumDifficultyofaJobSchedule)
	* 4.539. [1337 The K Weakest Rows in a Matrix](#TheKWeakestRowsinaMatrix)
	* 4.540. [1339 Maximum Product of Splitt](#MaximumProductofSplitt)
	* 4.541. [1340. Jump Game V](#JumpGameV)
	* 4.542. [1349. Maximum Students Taking Exam](#MaximumStudentsTakingExam)
	* 4.543. [1353. Maximum Number of Events That Can Be Attended](#MaximumNumberofEventsThatCanBeAttended)
	* 4.544. [1354. Construct Target Array With Multiple Sums](#ConstructTargetArrayWithMultipleSums)
	* 4.545. [1368. Minimum Cost to Make at Least One Valid Path](#MinimumCosttoMakeatLeastOneValidPath)
	* 4.546. [1371. Find the Longest Substring Containing Vowels in Eve](#FindtheLongestSubstringContainingVowelsinEve)
	* 4.547. [1373. Maximum Sum BST in Binary Tree](#MaximumSumBSTinBinaryTree)
	* 4.548. [1377. Frog Position After T Seconds](#FrogPositionAfterTSeconds)
	* 4.549. [1379 Find Corresponding Node of Binary Tree in a Clone](#FindCorrespondingNodeofBinaryTreeinaClone)
	* 4.550. [1382. Balance a Binary Search Tree](#BalanceaBinarySearchTree)
	* 4.551. [1395. Count Number of Teams](#CountNumberofTeams)
	* 4.552. [1396 Design Underground System](#DesignUndergroundSystem)
	* 4.553. [1406. Stone Game III](#StoneGameIII)
	* 4.554. [1409. Queries on a Permutation With Key](#QueriesonaPermutationWithKey)
	* 4.555. [1416. Restore The Array](#RestoreTheArray)
	* 4.556. [1424. Diagonal Traverse II](#DiagonalTraverseII)
	* 4.557. [1425. Constrained Subset Sum](#ConstrainedSubsetSum)
	* 4.558. [1426  Counting Elements](#CountingElements)
	* 4.559. [1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie](#KidsWiththeGreatestNumberofCandie)
	* 4.560. [1437 Check If All 1's Are at Least Length](#CheckIfAll1sAreatLeastLength)
	* 4.561. [1438. Longest Continuous Subarray With Absolute](#LongestContinuousSubarrayWithAbsolute)
	* 4.562. [1441 Build an Array With Stack Operations](#BuildanArrayWithStackOperations)
	* 4.563. [1442. Count Triplets That Can Form Two Arrays of Equal](#CountTripletsThatCanFormTwoArraysofEqual)
	* 4.564. [1443. Minimum Time to Collect All Apples in a Tree](#MinimumTimetoCollectAllApplesinaTree)
	* 4.565. [1444. Number of Ways of Cutting a Pizza](#NumberofWaysofCuttingaPizza)
	* 4.566. [1446 Consecutive Characters](#ConsecutiveCharacters)
	* 4.567. [1448 Count Good Nodes in Binary Tree](#CountGoodNodesinBinaryTree)
	* 4.568. [1449. Form Largest Integer With Digits That Add](#FormLargestIntegerWithDigitsThatAdd)
	* 4.569. [1451 Rearrange Words in a Sentence](#RearrangeWordsinaSentence)
	* 4.570. [1453 Maximum Number of Darts Inside of a Circular Dartb](#MaximumNumberofDartsInsideofaCircularDartb)
	* 4.571. [1457 Pseudo-Palindromic Paths in a Bin](#Pseudo-PalindromicPathsinaBin)
	* 4.572. [1461 Check If a String Contains All Binar](#CheckIfaStringContainsAllBinar)
	* 4.573. [1463 Cherry Pickup II](#CherryPickupII)
	* 4.574. [1473. Paint House III](#PaintHouseIII)
	* 4.575. [1475. Final Prices With a Special Discount in a Sho](#FinalPricesWithaSpecialDiscountinaSho)
	* 4.576. [1483. Kth Ancestor of a Tree Node](#KthAncestorofaTreeNode)
	* 4.577. [1488. Avoid Flood in The City](#AvoidFloodinTheCity)
* 5. [1489. Find Critical and Pseudo-Critical Edges in](#FindCriticalandPseudo-CriticalEdgesin)
	* 5.1. [1492 The kth Factor of n](#ThekthFactorofn)
	* 5.2. [1493. Longest Subarray of 1's After Deleting One](#LongestSubarrayof1sAfterDeletingOne)
	* 5.3. [1499. Max Value of Equation](#MaxValueofEquation)
	* 5.4. [1502 Can Make Arithmetic Progression From Sequence](#CanMakeArithmeticProgressionFromSequence)
	* 5.5. [1503 Last Moment Before All Ants Fall Out of a Plank](#LastMomentBeforeAllAntsFallOutofaPlank)
	* 5.6. [1505. Minimum Possible Integer After at Most K Adjacent](#MinimumPossibleIntegerAfteratMostKAdjacent)
	* 5.7. [1508. Range Sum of Sorted Subarray Sums](#RangeSumofSortedSubarraySums)
	* 5.8. [1510 Stone Game IV](#StoneGameIV)
	* 5.9. [1514 Path with Maximum Probability](#PathwithMaximumProbability)
	* 5.10. [1515 Best Position for a Service Centre](#BestPositionforaServiceCentre)
	* 5.11. [1520. Maximum Number of Non-Overlapping Substrings](#MaximumNumberofNon-OverlappingSubstrings)
	* 5.12. [1530. Number of Good Leaf Nodes Pairs](#NumberofGoodLeafNodesPairs)
	* 5.13. [1531. String Compression II](#StringCompressionII)
	* 5.14. [1534 Count Good Triplets](#CountGoodTriplets)
	* 5.15. [1535 Find the Winner of an Array Game](#FindtheWinnerofanArrayGame)
	* 5.16. [1537. Get the Maximum Score](#GettheMaximumScore)
	* 5.17. [1539. Kth Missing Positive Number](#KthMissingPositiveNumber)
	* 5.18. [1542. Find Longest Awesome Substring](#FindLongestAwesomeSubstring)
	* 5.19. [1546. Maximum Number of Non-Overlapping Subarrays With Sum](#MaximumNumberofNon-OverlappingSubarraysWithSum)
	* 5.20. [1550. Three Consecutive Odds](#ThreeConsecutiveOdds)
	* 5.21. [1551 Minimum Operations to Make Array](#MinimumOperationstoMakeArray)
	* 5.22. [1553. Minimum Number of Days to Eat N Oranges](#MinimumNumberofDaystoEatNOranges)
	* 5.23. [1556. Thousand Separator](#ThousandSeparator)
	* 5.24. [1558. Minimum Numbers of Function Calls to Make Target](#MinimumNumbersofFunctionCallstoMakeTarget)
	* 5.25. [1563. Stone Game V](#StoneGameV)
	* 5.26. [1569. Number of Ways to Reorder Array to Get Sa](#NumberofWaystoReorderArraytoGetSa)
	* 5.27. [1573. Number of Ways to Split a String](#NumberofWaystoSplitaString)
	* 5.28. [1585. Check If String Is Transformable With](#CheckIfStringIsTransformableWith)
	* 5.29. [1593. Split a String Into the Max Number of Unique Substri](#SplitaStringIntotheMaxNumberofUniqueSubstri)
	* 5.30. [1595. Minimum Cost to Connect Two Groups of Points](#MinimumCosttoConnectTwoGroupsofPoints)
	* 5.31. [1621. Number of Sets of K Non-Overlapping Line](#NumberofSetsofKNon-OverlappingLine)
	* 5.32. [1631. Path With Minimum Effort](#PathWithMinimumEffort)
	* 5.33. [1632 Rank Transform of a Matrix](#RankTransformofaMatrix)
	* 5.34. [1640 Check Array Formation Through](#CheckArrayFormationThrough)
	* 5.35. [1641 Count Sorted Vowel Strings](#CountSortedVowelStrings)
	* 5.36. [1642. Furthest Building You Can Reach](#FurthestBuildingYouCanReach)
	* 5.37. [1646 Get Maximum in Generated Array](#GetMaximuminGeneratedArray)
	* 5.38. [1648. Sell Diminishing-Valued Colored Balls](#SellDiminishing-ValuedColoredBalls)
	* 5.39. [1649 Create Sorted Array through Instru](#CreateSortedArraythroughInstru)
	* 5.40. [1655. Distribute Repeating Integers](#DistributeRepeatingIntegers)
	* 5.41. [1657 Determine if Two Strings Are Close](#DetermineifTwoStringsAreClose)
	* 5.42. [1658 Minimum Operations to Reduce X](#MinimumOperationstoReduceX)
	* 5.43. [1659. Maximize Grid Happiness](#MaximizeGridHappiness)
	* 5.44. [1662 Check If Two String Arrays are Equi](#CheckIfTwoStringArraysareEqui)
	* 5.45. [1663 Smallest String With A Given Numer](#SmallestStringWithAGivenNumer)
	* 5.46. [1673 Find the Most Competitive Subseq](#FindtheMostCompetitiveSubseq)
	* 5.47. [1674. Minimum Moves to Make Array Complement](#MinimumMovestoMakeArrayComplement)
	* 5.48. [1675. Minimize Deviation in Array](#MinimizeDeviationinArray)
	* 5.49. [1679 Max Number of K-Sum Pairs】](#MaxNumberofK-SumPairs)
	* 5.50. [1680 Concatenation of Consecutive Bina](#ConcatenationofConsecutiveBina)
	* 5.51. [1681. Minimum Incompatibility](#MinimumIncompatibility)
	* 5.52. [1690. Stone Game VII](#StoneGameVII)
	* 5.53. [1696. Jump Game VI](#JumpGameVI)
	* 5.54. [1704 Determine if String Halves Are Alike](#DetermineifStringHalvesAreAlike)
	* 5.55. [1707. Maximum XOR With an Element From Array](#MaximumXORWithanElementFromArray)
	* 5.56. [1713. Minimum Operations to Make a Subsequence](#MinimumOperationstoMakeaSubsequence)
	* 5.57. [1721 Swapping Nodes in a Linked List](#SwappingNodesinaLinkedList)
	* 5.58. [1727. Largest Submatrix With Rearrangements](#LargestSubmatrixWithRearrangements)
	* 5.59. [1745. Palindrome Partitioning IV](#PalindromePartitioningIV)
	* 5.60. [1760. Minimum Limit of Balls in a Bag](#MinimumLimitofBallsinaBag)
	* 5.61. [1770. Maximum Score from Performing Multiplication](#MaximumScorefromPerformingMultiplication)
	* 5.62. [1771. Maximize Palindrome Length From Subsequences](#MaximizePalindromeLengthFromSubsequences)
	* 5.63. [1775. Equal Sum Arrays With Minimum Number of Operatio](#EqualSumArraysWithMinimumNumberofOperatio)
	* 5.64. [1786. Number of Restricted Paths From First to Last Node](#NumberofRestrictedPathsFromFirsttoLastNode)
	* 5.65. [1792. Maximum Average Pass Ratio](#MaximumAveragePassRatio)
	* 5.66. [1799. Maximize Score After N Operations](#MaximizeScoreAfterNOperations)
	* 5.67. [1815. Maximum Number of Groups Getting Fresh Donuts](#MaximumNumberofGroupsGettingFreshDonuts)
	* 5.68. [1838. Frequency of the Most Frequent Element](#FrequencyoftheMostFrequentElement)
	* 5.69. [1847. Closest Room](#ClosestRoom)
	* 5.70. [1872. Stone Game VIII](#StoneGameVIII)
	* 5.71. [s](#s)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->


##  1. <a name=''></a>经验

[花花酱](https://www.bilibili.com/video/BV14E411R7Wa?spm_id_from=333.999.0.0)

[Leetcode刷题阶段性总结（一些建议与思考）哈哈哈](https://www.bilibili.com/video/BV14K4y1a7Yk?spm_id_from=333.999.0.0)

[LeetCode题库过千，刷题改如何规划？【刷题规划系列】](https://www.bilibili.com/video/BV1Xp4y1a7Z3?spm_id_from=333.999.0.0)

[如何正确刷题？LeetCode刷题误区和刷题方法论分享](https://www.bilibili.com/video/BV1nz4y197U3?spm_id_from=333.999.0.0)

[算法新手如何刷力扣（LeetCode）？【干货分享】](https://www.bilibili.com/video/BV17K411J7yR?spm_id_from=333.999.0.0)

[硅谷资深技术面试官教你拿顶级科技公司 Offer【面试篇】](https://www.bilibili.com/video/BV1fV411y743?spm_id_from=333.999.0.0)

[ACM 金牌大神是如何学算法的？【LeetCode 干货】](https://www.bilibili.com/video/BV1gv411179E?spm_id_from=333.999.0.0)

[硅谷资深技术面试官教你拿顶级科技公司 Offer【准备篇】](https://www.bilibili.com/video/BV1Kf4y197Rk?spm_id_from=333.999.0.0)

[BAT 大厂 Offer 收割机是怎样炼成的？技术面试通关全攻略](https://www.bilibili.com/video/BV1E5411h7Jr?spm_id_from=333.999.0.0)

##  2. <a name='-1'></a>算法

[图灵星球 - 什么是数据结构和算法？二分搜索剖析](https://www.bilibili.com/video/BV1H7411n79u?spm_id_from=333.999.0.0)

[图灵星球 - 时间复杂度和空间复杂度，大O表示法](https://www.bilibili.com/video/BV14j411f7DJ?spm_id_from=333.999.0.0)

[图灵星球 - 排序算法：插入排序，快排，归并排序](https://www.bilibili.com/video/BV1QE41177ST?spm_id_from=333.999.0.0)

[图灵星球 - 链表 Linked List【数据结构和算法入门4】](https://www.bilibili.com/video/BV1rE411g788?spm_id_from=333.999.0.0)

[图灵星球 - 堆栈Stack, 队列Queue【数据结构和算法入门5】](https://www.bilibili.com/video/BV1QE41137tw?spm_id_from=333.999.0.0)

[图灵星球 - 哈希表HashMap【数据结构和算法入门6】](https://www.bilibili.com/video/BV1si4y1b7Rs?spm_id_from=333.999.0.0)

[图灵星球 - 二叉搜索树（排序二叉树），树的遍历（前序、中序、后序）](https://www.bilibili.com/video/BV1qQ4y1M7Z4?spm_id_from=333.999.0.0)

[图灵星球 - 优先队列PriorityQueue，堆Heap](https://www.bilibili.com/video/BV1ti4y1879c?spm_id_from=333.999.0.0)

[图灵星球 - 图Graph, 深度优先遍历(DFS), 广度优先遍历(BFS)](https://www.bilibili.com/video/BV1254y1976m?spm_id_from=333.999.0.0)

[图灵星球 - Array题型：双指针Two Pointers套路](https://www.bilibili.com/video/BV1V54y1Q7bd?spm_id_from=333.999.0.0)

[图灵星球 - 二分查找Binary Search套路和解题模板](https://www.bilibili.com/video/BV1Ng4y1q7E3?spm_id_from=333.999.0.0)

[图灵星球 - Linked List链表题型解题套路和模板](https://www.bilibili.com/video/BV1QD4y1D7av?spm_id_from=333.999.0.0)

[图灵星球 - Stack堆栈解题套路](https://www.bilibili.com/video/BV1Hi4y1x7fX?spm_id_from=333.999.0.0)

[图灵星球 - Heap堆解题套路](https://www.bilibili.com/video/BV1XZ4y1M799?spm_id_from=333.999.0.0)

[图灵星球 - 哈希表HashMap解题套路](https://www.bilibili.com/video/BV1KC4y1h7zV?spm_id_from=333.999.0.0)

[图灵星球 - 树Tree题型广度优先搜索BFS套路](https://www.bilibili.com/video/BV1T5411e7D2?spm_id_from=333.999.0.0)

[图灵星球 - 树Tree深度优先搜索DFS解题套路](https://www.bilibili.com/video/BV1xT4y1E7TD?spm_id_from=333.999.0.0)

[图灵星球 - Graph图BFS广度优先搜索套路](https://www.bilibili.com/video/BV1HA411v753?spm_id_from=333.999.0.0)

[图灵星球 - Graph图Best-First Search题型套路](https://www.bilibili.com/video/BV1NK4y1v75h?spm_id_from=333.999.0.0)

[图灵星球 - Graph图DFS深度优先搜索题型套路](https://www.bilibili.com/video/BV1vv411q769?spm_id_from=333.999.0.0)

[图灵星球 - Search, Dynamic Programming1](https://www.bilibili.com/video/BV1hf4y197w3?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming1D解题套路](https://www.bilibili.com/video/BV1CD4y127CZ?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D解题套路](https://www.bilibili.com/video/BV1sk4y1y7Dv?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D进阶解题套路](https://www.bilibili.com/video/BV12k4y127nP?spm_id_from=333.999.0.0)

[图灵星球 - DynamicProgramming2D高级解题套路](https://www.bilibili.com/video/BV14z4y1f7hH?spm_id_from=333.999.0.0)

[图灵星球 - Backtracking回溯解题套路](https://www.bilibili.com/video/BV1Ty4y1E7RM?spm_id_from=333.999.0.0)

[哈哈哈 DSU(并查集实现)-Python](https://www.bilibili.com/video/BV19K4y1b7vT?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(广度优先遍历BFS)(1)](https://www.bilibili.com/video/BV1H7411D7Nm?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(深度优先遍历DFS)(2)](https://www.bilibili.com/video/BV1H7411D73V?spm_id_from=333.999.0.0)

[哈哈哈 二分查找(Binary Search)合集](https://www.bilibili.com/video/BV1254y1B7xK?spm_id_from=333.999.0.0)

[哈哈哈 Bubble_sort(用Python实现冒泡排序)(1)](https://www.bilibili.com/video/BV19E411E7df?spm_id_from=333.999.0.0)

[哈哈哈 Selected_sort(用Python实现选择排序)(2)](https://www.bilibili.com/video/BV1AE411t7Pr?spm_id_from=333.999.0.0)

[哈哈哈 Single linked list-Python(链表功能扩展-有条件翻转链表)（2）](https://www.bilibili.com/video/BV1n7411G7rc?spm_id_from=333.999.0.0)

[哈哈哈 Inserted_sort(用Python实现插入排序)(3)](https://www.bilibili.com/video/BV1SE411p7zn?spm_id_from=333.999.0.0)

[哈哈哈 Tree-Python(深度优先遍历的迭代实现)(3)](https://www.bilibili.com/video/BV1V54y197qo?spm_id_from=333.999.0.0)

[哈哈哈 Shell_sort(用Python实现希尔排序)(4)](https://www.bilibili.com/video/BV1SE411T7t1?spm_id_from=333.999.0.0)

[哈哈哈 Quick_sort(用Python实现快速排序)(5)](https://www.bilibili.com/video/BV1d7411R75g?spm_id_from=333.999.0.0)

[哈哈哈 Merge_sort(用Python实现合并排序)(6)](https://www.bilibili.com/video/BV1gE411c7PR?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV16b411N7o7?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV1hb411P7C2?spm_id_from=333.999.0.0)

[DP 花花酱](https://www.bilibili.com/video/BV1wb4y1b7df?spm_id_from=333.999.0.0)

[Maximum Subarray DP 花花酱](https://www.bilibili.com/video/BV1yg411A7D4?spm_id_from=333.999.0.0)

[Maximum Product Subarray DP 花花酱](https://www.bilibili.com/video/BV18q4y1z7TC?spm_id_from=333.999.0.0)

[Fast Power for DP 花花酱](https://www.bilibili.com/video/BV1Je411s7NM?spm_id_from=333.999.0.0)

[Best Time to Buy and Sell Stock DP 花花酱](https://www.bilibili.com/video/BV1Tg411P7S9?spm_id_from=333.999.0.0)

[Disjoint-set/Union-find Forest 花花酱](https://www.bilibili.com/video/BV1jW411d7vi?spm_id_from=333.999.0.0)

[Best Time to Buy and Sell Stock with  DP 花花酱](https://www.bilibili.com/video/BV1sq4y1q768?spm_id_from=333.999.0.0)

[二叉树 花花酱](https://www.bilibili.com/video/BV1Gt411e7zm?spm_id_from=333.999.0.0)

[背包问题 花花酱](https://www.bilibili.com/video/BV1ot411m7wv?spm_id_from=333.999.0.0)

[背包问题 2 花花酱](https://www.bilibili.com/video/BV1Dt411U7eM?spm_id_from=333.999.0.0)

[最小生成树 (Minimum Spanning Tree)  花花酱](https://www.bilibili.com/video/BV1A7411Y7mT?spm_id_from=333.999.0.0)

[Binary Search 花花酱](https://www.bilibili.com/video/BV1yW411Z7um?spm_id_from=333.999.0.0)

[Binary Search II 花花酱](https://www.bilibili.com/video/BV1ub411V7gs?spm_id_from=333.999.0.0)

[Fenwick Tree / Binary Indexed Tree 花花酱](https://www.bilibili.com/video/BV1EW411d75F?spm_id_from=333.999.0.0)

[Input Size V.S. Time Complexity 花花酱](https://www.bilibili.com/video/BV1jW411d7a2?spm_id_from=333.999.0.0)

[Time/Space Complexity of Recursive Algorithms 花花酱](https://www.bilibili.com/video/BV1JW411d714?spm_id_from=333.999.0.0)

[Segment Tree 花花酱](https://www.bilibili.com/video/BV1bb411y78M?spm_id_from=333.999.0.0)

[Min Heap 花花酱](https://www.bilibili.com/video/BV1cy4y1q7P1?spm_id_from=333.999.0.0)

[Amortized Analysis 均摊分析 花花酱](https://www.bilibili.com/video/BV1NW411C7v7?spm_id_from=333.999.0.0)

[Recursion unrolling and performance measurement](https://www.bilibili.com/video/BV1Gt411r7MS?spm_id_from=333.999.0.0)


##  3. <a name='-1'></a>题目

###  3.1. <a name='TwoSum'></a>1 Two Sum

[哈哈哈](https://www.bilibili.com/video/BV1rE411Y7UN?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV19b411v7qp?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zf4y1G7W4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rv411k7VY?spm_id_from=333.999.0.0)

暴力求解：

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i] + nums [j] == target:
                    return [i,j]
```

查找表法:

* 哈希表(不需要维护表的顺序性)

* 平衡二叉搜素树

* 时间复杂度:O(n)

* 时间复杂度:O(n)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i,n in enumerate(nums):
            if n in dic:
                return [dic[n],i]
            dic[target - n] = i
```

```scala
object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        
        val nums_map = scala.collection.mutable.HashMap[Int, Int]()
        
        var result: Array[Int] = Array(0,0)
        
        var i = 0
        
        while(result.sum == 0) {
            
            val complement = target - nums(i)
            
            if (nums_map.contains(complement)) {
                result(0) = i
                result(1) = nums_map(complement)
            } else {
                nums_map(nums(i)) = i
            }
            
            i += 1
        }

        result     
    }
}



// Brute-force method, which takes more than two times of running time than the method above
object Solution {
    def twoSum(nums: Array[Int], target: Int): Array[Int] = {
        
        val result = for {i <- 0 until (nums.length - 1);
            j <- (i+1) until nums.length
            if nums(i) + nums(j) == target} yield Array(i, j)
        
        result(0)
        
    }
}
```

###  3.2. <a name='AddTwoNumbers'></a>2. Add Two Numbers

[花花酱](https://www.bilibili.com/video/BV1EJ411h72z?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1gJ411V7gJ?spm_id_from=333.999.0.0)

[小梦想](https://www.bilibili.com/video/BV1Wb411e77s?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1rZ4y1j7V3?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DA411L7YQ?spm_id_from=333.999.0.0)

* 时间复杂度:O(max(m,n))

* 时间复杂度:O(max(m,n))

特殊情况：

两个链表的长度不同。

进位

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = pointer = ListNode(0) # 易错点：定义一个dummy和一个pointer，都指向ListNode(0)
        carry = 0 # 易错点：carry需要先赋值
        while l1 or l2 or carry: # 易错点：carry要存在
            # 易错点：l1,l2不一定存在，所以不能写成：sumNode = l1 + l2
            # 易错点：调用listnode要有.val
            sumNode = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            tail = sumNode % 10
            carry = sumNode // 10
            pointer.next = ListNode(tail)
            pointer = pointer.next
            # # l1,l2不一定存在，所以不能写成：l1 = l1.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
```

###  3.3. <a name='LongestSubstringWithoutRepeatingCharacters'></a>3. 数组中重复的数字 Longest Substring Without Repeating Characters

[哈哈哈](https://www.bilibili.com/video/BV1h54y1B7No?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1CJ411G7Nn?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1va4y1J7Gx?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ob411n7mv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K411M7d2?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DK4y1b7xp?spm_id_from=333.999.0.0)

方法一：暴力解法

* 时间复杂度: 2个指针遍历字符串O(n2) + hashset判断是否重复O(n) = O(n3)

* 时间复杂度: O(m), m 为所有可能出现的情况

方法二：涉及 sub 的问题，可以使用 “滑动窗口”

特殊情况：

* 字符串为空
  
* 字符串均为重复字符串

* 时间复杂度: O(n) + hashset判断是否重复O(n) = O(n3)

* 时间复杂度: O(m), m 为所有可能出现的情况

```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dic = {}
        start = 0
        res = 0
        for i, char in enumerate(s):
            if char in dic and start <= dic[char]:
                # 易错点: and start <= dic[char]: 
                # 含义为"tmmzuxt",
                # start在m，当有新的t进来时，上一个t在start的前面，所以，此时的start不需要修改
                start = dic[char] + 1 # 易错点: 这里的dic[char]还是前一个,且 +1
            else:
                res = max(res,i-start+1) # 易错点: +1
            dic[char] = i # 易错点: dic[char]滞后更新
        return res
```

###  3.4. <a name='MedianofTwoSortedArrays'></a>4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays

[官方](https://www.bilibili.com/video/BV1Xv411z76J?spm_id_from=333.999.0.0)

###  3.5. <a name='LongestPalindromicSubstring-'></a>5. Longest Palindromic Substring -最长回文子串

[花花酱](https://www.bilibili.com/video/BV18J411j7Pb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1ra4y1Y7Gx?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7P6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1so4y1o765?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1L54y1D7pa?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n3),在两个for循环里面，还做了一次遍历

* 时间复杂度:O(1)

中心扩散法：

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.4sfvjkqc4qo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ur1lzo89kk0.png)

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        strLen = len(s)
        if strLen == 1:
            return s

        mid = 0
        strStart = strEnd = 0
        maxLen = 1



        while mid < strLen:

            # 优化：
            if strLen - mid <= maxLen/2:
                break

            start = end = mid
            
            # 第一步：
            while end + 1 < strLen and s[end] == s[end+1]: # 注意边界
                end += 1

            # 第二步：
            while  end + 1 < strLen and start > 0 and s[start-1] == s[end+1]: # 注意边界
                start -= 1
                end += 1
            
            # 第三步：
            if end - start + 1 > maxLen:
                maxLen = end - start + 1
                strStart = start
                strEnd = end

            mid += 1

        return s[strStart:strEnd+1]
```

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s


        def getLen(l,r) -> int:
            while l>=0 and r<lenStr and s[l] == s[r]: # 注意：边界
                l -= 1
                r += 1
            return r - l - 1 # 注意：是 “-1”

        start = 0  
        end = 1 # 注意：在第一次的时候，end = 1
        maxmaxLen = maxLen = 1

        for mid in range(lenStr):
            maxLen = max(getLen(mid,mid),getLen(mid,mid+1))
            
            if maxLen > maxmaxLen:
                maxmaxLen = maxLen
                start = mid - (maxLen-1) // 2 #易错点：-1，最好背一背
                end = start + maxLen
        return s[start:end]
```

动态规划法：

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.67y5euem0vo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.90ngy2t8j3k.png)

* 时间复杂度:O(n2)

* 时间复杂度:O(n2)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)
        maxlen = maxmaxlen = 1
        start = 0

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s

        dp = [[False for _ in range(lenStr)] for _ in range(lenStr)]
        for i in range(lenStr):
            dp[1][1] = True 
            # dp[1][1]是正确写法，dp[1,1]是错误写法

        for j in range(1,lenStr): # 把三角形画出来，先j，再i，
            for i in range(j):
                if s[i] == s[j]:
                    if j-i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i+1][j-1]
                if dp[i][j]:
                    maxlen = j-i+1
                    if maxlen > maxmaxlen:
                        maxmaxlen = maxlen
                        start = i
        return s[start:start+maxmaxlen]
```

Manacher算法：

不要求

###  3.6. <a name='ZigZagConversion'></a>6. ZigZag Conversion

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7uH?spm_id_from=333.999.0.0)

###  3.7. <a name='ReverseInteger'></a>7 Reverse Integer

[哈哈哈](https://www.bilibili.com/video/BV1sE411e73m?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7bM?spm_id_from=333.999.0.0)

* 时间复杂度:O(log10(n)), 每次迭代都会除以10

* 时间复杂度:O(1)

```py
class Solution:
    def reverse(self, x: int) -> int:
        res = 0 
        a = abs(x)

        if a < 10:
            return x

        while a != 0:
            tmp = a % 10
            res = res * 10 + tmp
            a = a // 10
        # 要注意return和while的相对位置
        # 不要写在while循环内部

        if x > 0 and res < 1<<31:
            return res 
        elif x<0 and res <= 1<<31:
            return -res
        else:
            return 0
```

```scala
object Solution {
    def reverse(x: Int): Int = {
        
        // METHOD-1
        if (x == 0) {
            0
        } else { 
            val xx = math.abs(x).toString.reverse
            var start_to_record = false
            val temp = collection.mutable.ArrayBuffer[Char]()

            for (x <- xx) {

                if (start_to_record == false && x != '0') {
                    start_to_record = true
                }

                if (start_to_record) {
                    temp += x
                }

            }

            try {
                ({if (x >= 0) "" else "-"} + temp.mkString).toInt    
            } catch {
                case e: java.lang.NumberFormatException => 0
            } 
        }
        
        
        // METHOD-2
        if (x == 0) {
            0
        } else {
            
            val xx = math.abs(x).toString.reverse
            
            // find the first element not equaling to 0
            // Here I used method `.find`. It finds and returns the first element of the list satisfying a predicate, if any.
            // `.find` returns Some(*), so need to use `.get`
            val intermediate_result = xx.slice(xx.zipWithIndex.find(_._1 != '0').get._2, xx.length)
            
            // 1. Use if-else to handle possible negative integers.
            // 2. use try-catch to handle cases like "1534236469"
            //      which will cause exception java.lang.NumberFormatException: For input string: "9646324351"
            //      due to Int.MaxValue is 2147483647
            try {
                ({if (x >= 0) "" else "-"} + intermediate_result).toInt    
            } catch {
                case e: java.lang.NumberFormatException => 0
            }

        }  
    }
}
```

###  3.8. <a name='StringtoIntegeratoi'></a>8. String to Integer(atoi)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7pz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1AZ4y1s7TD?spm_id_from=333.999.0.0)

* 时间复杂度:O(n)

* 时间复杂度:O(1)

|模式|描述|
|---|---|
|^|匹配字符串的开头|
|[...]|用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'|
|*|匹配0个或多个的表达式。|
|?|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式|
|+|匹配1个或多个的表达式。|
|\d|匹配任意数字，等价于 [0-9]。|
|\D|匹配任意非数字，等价于 [^0-9]。|

[正则表达式中小括号、中括号、大括号的作用](https://blog.csdn.net/weixin_45621662/article/details/103921232)

```py
class Solution:
    def myAtoi(self, s: str) -> int:
        import re
        at_oi_re = re.compile('^[ ]*([+-]?\d+)')
        # 易错点：要注意中括号[]和小括号()的区别
        # 易错点：要注意小括号()的位置，小括号的作用是匹配并提取，所以+-要包括起来
        # 易错点：不能漏掉*？

        # 字符串的 开头 匹配 0个或多个[空格]
        # 匹配 0个或多个[+-]
        # 匹配 0个或多个[0-9]
        if not at_oi_re.search(s):
            return 0
        res = int(at_oi_re.findall(s)[0])
        # 易错点：findall返回一个列表，所以必须有[0]
        # 易错点：必须有int()
        return min(max(res, -(1<<31)), (1<<31) - 1) # 在两者之间，背一背
        # 要加小括号(1<<31)
```

###  3.9. <a name='Palindrome'></a>9-Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1hJ411S7kt?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7YG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Af4y1m7kk?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return True if str(x) == str(x)[::-1] else False
```

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False

        if x < 10:
            return True

        bkp = x
        res = 0

        while x != 0:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return bkp == res
```

翻转一半字符法：

* 时间复杂度:O(log10(n)), 每次迭代都会除以10

* 时间复杂度:O(1)

经过尝试，这个方法在边界处理上容易出错，不推荐。

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 10 and x >= 0:
            return True

        if x < 0 or x % 10 == 0:
            return False

        res = 0

        # 翻转一半字符串

        while x > res:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return x == res or x == res//10
```

###  3.10. <a name='ContainerWithMostWater'></a>11. Container With Most Water 

[花花酱](https://www.bilibili.com/video/BV1CW41167qB?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Gn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1A5411E7oM?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1TK41157jH?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

双指针法：

由于盛水面积由较短边控制，所以，指针放在两端，每次只移动较短边。因为，移动较长边的话。一定仍然是不变的。

* 时间复杂度:O(n)

* 时间复杂度:O(1)



```py
# 这个写起来超级简单！
# NO BUG
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        maxRes = res = 0
        while left < right:
            res = (right - left)*min(height[left],height[right])
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
            maxRes = max(maxRes,res)
        return maxRes
```

###  3.11. <a name='IntegertoRoman'></a>12. Integer to Roman

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Wf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hN411Q7ka?spm_id_from=333.999.0.0)

```py
# 这个写起来超级简单！
# NO BUG
class Solution:
    def intToRoman(self, num: int) -> str:
        strlist = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        numlist = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        res = ''
        for i in range(len(numlist)):
            while num >= numlist[i]:
                num -= numlist[i]
                res = res + strlist[i]
        return res
```

```py
# 其他方法
class Solution:

    VALUE_SYMBOLS = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]
    print(type(VALUE_SYMBOLS))
    def intToRoman(self, num: int) -> str:
        roman = list()
        for value, symbol in Solution.VALUE_SYMBOLS:
            while num >= value:
                print("-"*20)
                print(num)
                num -= value
                roman.append(symbol)
                print(roman)
            if num == 0:
                break
        return "".join(roman)
```

###  3.12. <a name='-1'></a>13. 机器人的运动范围 

[官方](https://www.bilibili.com/video/BV1dz411B7rt?spm_id_from=333.999.0.0)

###  3.13. <a name='RomantoInteger'></a>13. Roman to Integer

[花花酱](https://www.bilibili.com/video/BV1vJ411J7Up?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1hJ411S7kQ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7ue?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1cp4y1H75L?spm_id_from=333.999.0.0)

```py
# 看不懂下方代码，就看小明的讲解
class Solution:
    def romanToInt(self, s: str) -> int:
        dic = {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}
        res = 0
        for i in range(len(s)-1):
            if dic[s[i]] < dic[s[i+1]]:
                res -= dic[s[i]]
            else:
                res += dic[s[i]]
        res += dic[s[-1]]
        return res
```

###  3.14. <a name='Longestcommonprefix'></a>14-Longest common prefix

[哈哈哈](https://www.bilibili.com/video/BV1cJ411D7qU?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Eb411i7QN?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1tV411k7GY?spm_id_from=333.999.0.0)

* 时间复杂度:O(mn),m是字符串平均长度,n是字符串数量

* 时间复杂度:O(1)

```py
# 参考了小梦想家,首次学习while true循环:
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        lookup = set()
        res = ''
        i = 0
        while True:
            # 由于string的长度是不确定的，所以
            try:
                lookup = set(string[i] for string in strs)
                if len(lookup) == 1:
                    res += lookup.pop()
                    i += 1
                else:
                    break
            except Exception as e:
                break
        return res
```

```py
# 如果不使用try catch
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if strs == [""]:
            return strs[0]
        lookup = set()
        res = ''
        i = 0
        minlen = min(len(string) for string in strs)
        while i< minlen:
            lookup = set(string[i] for string in strs)
            if len(lookup) == 1:
                res += lookup.pop()
                i += 1
            else:
                break
        return res
```

###  3.15. <a name='Sum'></a>15. 3Sum

[花花酱](https://www.bilibili.com/video/BV1wp4y1W72o?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Tb411578b?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19K4y1s7co?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19i4y1s7VZ?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n3)

* 时间复杂度:O(1)

双指针法：

先排序：时间复杂度:O(n log(n)) + O(n2)

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        # nums.sort() # 另一种写法
        nums = sorted(nums)
        res = []
        for i in range(n-2):
            # 优化部分：
            if nums[i] > 0: break
            if nums[i] + nums[i+1] + nums[i+2] > 0: break
            # 这个写法不对：if i+1 < n-2 and nums[i] == nums[i+1]: continue
            # 这样可能直接跳过了[-1,-1,2,3]的前三个
            # 这个写法是正确的↓：
            if i - 1 >= 0 and nums[i] == nums[i-1]: continue
            if nums[i] + nums[n-2] + nums[n-1] < 0:continue
            # 双指针部分：
            left = i + 1
            right = n - 1
            while left < right: 
                if nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                elif nums[i] + nums[left] + nums[right] < 0:
                    left += 1
                else:
                    res.append([nums[i],nums[left],nums[right]])
                    # 去重：
                    while nums[left] == nums[left + 1] and left + 1 < right: # 注意边界
                        left += 1
                    left +=1
                    while nums[right] == nums[right - 1] and left < right - 1: # 注意边界
                        right -= 1
                    right -=1
        return res
```

###  3.16. <a name='SumClosest'></a>16. 3Sum Closest

[小梦想家](https://www.bilibili.com/video/BV11441187Rr?spm_id_from=333.999.0.0)

```py
# 和上一题差不多
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        minAim = sum(nums[0:3]) - target
        n = len(nums)
        for i in range(n-2):
            left = i+1
            right = n-1
            while left<right:
                aim = nums[i] + nums[left] + nums[right] - target
                if abs(aim) < abs(minAim): minAim = aim
                if aim == 0: 
                    return target
                elif aim > 0:
                    right -= 1
                else:
                    left += 1
        return minAim + target
```

```py
# （python）三重暴力破解 O(n**3)

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        result=1000
        for i in range(0,len(nums)):
            for j in range(i+1,len(nums)):
                for k in range(j+1,len(nums)):
                    a=nums[i]+nums[j]+nums[k]-target
                    if abs(a) < result:
                        result=abs(a)
                        end=nums[i]+nums[j]+nums[k]
        return end
```

###  3.17. <a name='LetterCombinationsofaPhoneNumber'></a>17. Letter Combinations of a Phone Number 

[花花酱](https://www.bilibili.com/video/BV1PW411y7r2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7sL?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ti4y1A73M?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Sp4y1r7YP?spm_id_from=333.999.0.0)

深度优先 or 广度优先

* 时间复杂度:O(3m × 4n), m是对应3个字母的数字, n是对应4个字母的数字

* 时间复杂度:O(3m × 4n), m是对应3个字母的数字, n是对应4个字母的数字

```py
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: # 易错点：一定要判断判断字符串是否为空
            return [] 
        dic = {'2':'abc','3':'def','4':'ghi','5':'kjl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        res = [char for char in dic[digits[0]]] # 前面的排在前面
        for num in digits[1:]:
            res = [string + char for string in res for char in dic[num]]
        return res
```

```py
class Solution:
    def letterCombinations(self, digits):
        if not digits:
            return list()
        
        phoneMap = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }

        groups = (phoneMap[digit] for digit in digits)
        return ["".join(combination) for combination in itertools.product(*groups)]
```

###  3.18. <a name='RemoveNthNodeFromEndofList'></a>19-Remove Nth Node From End of List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7DQ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1eL411n7KE?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1654y1R7Xe?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1KK4y1E7st?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Z5411c79y?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ccdr2kcw7c0.png)

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        fast = ListNode(0)
        slow = ListNode(0)
        fast.next = head
        slow.next = head
        for _ in range(n):
            fast = fast.next

        # 易错点：
        # 要考虑特殊情况，比如说，链表长度和n一样时

        if fast.next == None: # 易错点：== 千万不要写错
            return head.next

        while fast.next != None:
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next

        return head
```

###  3.19. <a name='Validparentheses'></a>20-Valid parentheses

[哈哈哈](https://www.bilibili.com/video/BV1DJ41127uA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7ek?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Hr4y1M7Sc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1sC4y1H7Hs?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1QA411L7y7?spm_id_from=333.999.0.0)

先进后出，所以用栈

* 时间复杂度:O(n)

* 时间复杂度:O(n)

```py
# 这道题背一背！
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{':'}','[':']','(':')'}
        stack = [] # stack 要提前定义好
        for char in s:
            if char in dic: # 是“key”
                stack.append(char) # 一个char进来，要么被append
            elif not stack or dic[stack.pop()] != char: 
                # 如果上一步不被append就是不对的
                # 如果这一步不匹配也是不对的
                return False
        return not stack # 如果append上了，但没有被完全pop也是不对的
```

###  3.20. <a name='Mergetwosortedlists'></a>21-Merge two sorted lists

[哈哈哈](https://www.bilibili.com/video/BV1rJ41127ry?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7D7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1my4y127bK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1qZ4y1j7Jb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ck4y1k7J9?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(M+N)

* 时间复杂度:O(1)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        cur = dummy # dummy是固定节点，cur是移动指针
        while list1 and list2: # 这里是and
            if list1.val < list2.val: # 易错点：这里是list.val，而不是list
                cur.next = list1
                list1 = list1.next # 向后进一位
            else:
                cur.next = list2
                list2 = list2.next # 向后进一位
            cur = cur.next # 向后进一位
        cur.next = list1 or list2 # 易错点：这里是cur.next，而不是cur。这里是or
        # 等效于：
        # if list1:
        #     cur.next = list1
        # else:
        #     cur.next = list2
        return dummy.next
```

递归解法：

* 时间复杂度:O(M+N)

* 时间复杂度:O(M+N)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        elif not list2:
            return list1
        elif list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next,list2) # 找到较小头结点，提取出来
            return list1
        else:
            list2.next = self.mergeTwoLists(list1,list2.next) # 找到较小头结点，提取出来
            return list2
```

###  3.21. <a name='GenerateParentheses'></a>22. Generate Parentheses

[小梦想家](https://www.bilibili.com/video/BV1hb411i7t7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vK4y1b744?spm_id_from=333.999.0.0)

回溯法：

* 时间复杂度:O($\frac{4^n}{\sqrt{n}}$)

* 时间复杂度:O($\frac{4^n}{\sqrt{n}}$)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.ud5vx6kpbvk.png" width="50%">

```py
# 基于小梦想家
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm,res):
            if left == 0 and right == 0:
                res.append(itm)
                # 错误写法：return res = res.append(itm)，这里不需要return
            if left > right: # 相当于n-left<n-right,表示残余的部分
                return
            if left > 0:
                helper(left-1,right,itm + '(',res)
                # 错误写法：return item = '(' + helper(left-1,right,itm,res)，这里不需要return
            if right > 0:
                helper(left,right-1,itm + ')',res)
                # 错误写法：return item = ')' + helper(left,right-1,itm,res)，这里不需要return
        
        res = []
        helper(n,n,'',res)
        return res
```

```py
# 基于上方答案修改
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm,res):
            if left == 0 and right == 0:
                res.append(itm)
                return # 这里return写不写居然都ac了，可能是因为没有循环吧
            if left > 0:
                helper(left-1,right,itm + '(',res)
            if right > left:
                helper(left,right-1,itm + ')',res)
        
        res = []
        helper(n,n,'',res)
        return res
```

```py
# 基于上方答案修改，helper中的删除res

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def helper(left,right,itm):
            if left == 0 and right == 0:
                res.append(itm)
                return # 这里return写不写居然都ac了，可能是因为没有循环吧
            if left > 0:
                helper(left-1,right,itm + '(')
            if right > left:
                helper(left,right-1,itm + ')')
        
        res = []
        helper(n,n,'')
        return res
```

```py
class Solution:
    def generateParenthesis(self, n):
        ans = []
        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(''.join(S))
                return
            if left < n:
                S.append('(')
                backtrack(S, left+1, right)
                S.pop()
                # 参考上方，可以直接把'('写到递归函数里面，这样就不需要还原现场。
            if right < left:
                S.append(')')
                backtrack(S, left, right+1)
                S.pop()

        backtrack([], 0, 0)
        return ans
# 上方答案，修改后如下：
```

```py
# 上方答案，修改后如下：
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def backtrack(S, left, right):
            if len(S) == 2 * n:
                ans.append(S)
                return
            if left < n:
                backtrack(S + '(', left+1, right)
            if right < left:
                backtrack(S + ')', left, right+1)

        ans = []
        backtrack('', 0, 0)
        return ans
```

```py
# 作者说：头皮发麻。我感觉我是天才，
# 作者说：你们不知道用最基本的单位“()”进行组装吗。
# 作者说：绝对是原创一次过

class Solution:
    def generateParenthesis(self, n):
        if n == 1:
            return list({'()'})
        res = set()
        for i in self.generateParenthesis(n - 1):
            for j in range(len(i) + 2):
                res.add(i[0:j] + '()' + i[j:])
        return list(res)


# 我的模仿😐
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 这是我写的愚蠢的结束条件：
        # if len(res[0]) == n:
        #     return
        if n == 1:
            return ['()']

        res = set()
        for itm in self.generateParenthesis(n-1):
            for j in range(len(itm)+1): # 如果item的长度为4，那么就有5个可以插入的位置
                # 错误写法：
                # itm = itm[:j] + '()' + itm[j:]
                # res = res.add(itm)
                # 错误写法：
                # res = res.add(itm[:j] + '()' + itm[j:])
                # 正确写法：
                res.add(itm[:j] + '()' + itm[j:])
        return list(res)
```

```py
# 相当于比上一层少了一层循环。
# 不懂是不是动态规划，每新增一对括号，
# 就是在上一次的结果的各个位置插入一个"()"，用集合防止重复

class Solution:
    def generateParenthesis(self, n):
        result = {''}
        for i in range(n):
            temp = set()
            for s in result:  # 在上一次的结果的所有字符串的各个位置上插入'()'
                for j in range(len(s) + 1):
                    temp.add(s[:j] + '()' + s[j:])
            result = temp
        return list(result)
```

```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        stack=[('',0,0)]
        ans=[]
        while stack:
            print("stack: ",stack)

            p,left,right=stack.pop() # 先把p弹出来
            
            if left==right==n: #如果符合条件,就回收
                ans.append(p)
                continue
            
            if left<n: #如果符合条件,就加left
                stack.append((p+'(',left+1,right))
            if right<n and right<left: #如果符合条件,就加right
                stack.append((p+')',left,right+1))
        return ans

# 我的模仿😐 
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack = [('',0,0)]
        res = []
        while stack:
            itm, left, right = stack.pop()
            if left == right == n:
                # 错误写法：res = res.append(itm)
                res.append(itm)
                # continue 写或者不写都能ac，我迷惑了

            if left < n:
                # 错误写法：itm, left, right = itm + '(', left + 1, right
                # 错误写法：stack.append(itm + '(', left + 1, right),应该要有双层括号
                stack.append((itm + '(', left + 1, right))
            if right < left:
                # 错误写法：itm, left, right = itm + ')', left, right + 1
                # 错误写法：stack.append(itm + ')', left, right + 1),应该要有双层括号
                stack.append((itm + ')', left, right + 1))
        return res
```

```py
# 比较费脑子，可以不看😐 
class Solution:
    def generateParenthesis(self, n):
        if n == 0:
            return [""]
        if n == 1:
            return ["()"]
        # 这两行其实可有可无：
        # elif n == 2: 
        #     return ["()()", "(())"] 
        result = []
        for i in range(n):
            j = n - 1 - i
            temp1 = self.generateParenthesis(i)
            temp2 = self.generateParenthesis(j)
            result.extend(["(%s)%s" % (p, q) for p in temp1 for q in temp2])
        return result
# result.extend(["(%s)%s" % (p, q) for p in temp1 for q in temp2]) 这句是什么意思呀？
# %是格式化字符串输出，extend是把结果凑起来。这行代码干的事其实是递归生成括号。
# 如果把所有的情况分解拆开，发现最底层的形式无非n=0, 1这2种情况，
# 那么我们其实可以让括号一层一层包裹起来。这行代码其实就是一层一层包裹括号。
# for循环里面存在重复计算吧，比如说n=7的时候，i=2,j=4计算了2和4个括号的全排列，i=4，j=2的时候又计算了一遍，其实可以只计算一半，然后全排列的时候p和q调一下位置就行了。

# 我的模仿😐 
class Solution:
    def generateParenthesis(self, n):
        res = []
        if n == 0:
            return ['']
        if n == 1:
            return ['()']
        for i in range(n):
            j = n-1-i
            tmplist1 = self.generateParenthesis(i)
            tmplist2 = self.generateParenthesis(j)
            # 错误写法：return res.extend(['(%s)%s' for item1 in tmplist1 for item2 in temlist2])
            res.extend(['(%s)%s' % (item1,item2) for item1 in tmplist1 for item2 in tmplist2])
        return res
```



###  3.22. <a name='MergekSortedLists'></a>23. Merge k Sorted Lists

[花花酱](https://www.bilibili.com/video/BV1X4411u7xF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1178e?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK41157mu?spm_id_from=333.999.0.0)

暴力求解法：

* 时间复杂度: O(N) + O(N logN) + O(N)

* 空间复杂度: O(N) + O(N)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.65tcjjz2oy80.png" width="50%">

```py
# so easy，一遍过
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        arr = []
        for listhead in lists:
            while listhead:
                arr.append(listhead.val)
                listhead = listhead.next
        arr.sort()
        dummy = ListNode(0)
        cur = dummy
        for value in arr:
            cur.next = ListNode(value)
            cur = cur.next
        return dummy.next
```

优先队列：

* 时间复杂度: O(N logk) 

* 空间复杂度: O(N) + O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3tftyqf2g4s0.png" width="50%">

```py
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        q = []  # 易错点：先要定义一个空
        dummy = ListNode(0)
        cur = dummy
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(q,(lists[i].val,i))  # 易错点：要可以排序的
                lists[i] = lists[i].next # 易错点：注意，向后一位
        while q: # 易错点：注意这个循环条件
            val, idx = heapq.heappop(q)
            cur.next = ListNode(val)
            cur = cur.next
            if lists[idx]:
                heapq.heappush(q,(lists[idx].val,idx))
                lists[idx] = lists[idx].next # 易错点：注意，向后一位
        return dummy.next
```

两两合并：

* 时间复杂度: O(N logk) 

* 空间复杂度: O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.60itjgowwpo0.png" width="50%">

```py
class Solution:
    def merge2Lists(self, list1, list2):
        dummy = ListNode(0)
        cur = dummy # dummy是固定节点，cur是移动指针
        while list1 and list2: # 这里是and
            if list1.val < list2.val: # 易错点：这里是list.val，而不是list
                cur.next = list1
                list1 = list1.next # 向后进一位
            else:
                cur.next = list2
                list2 = list2.next # 向后进一位
            cur = cur.next # 向后进一位
        cur.next = list1 or list2 # 易错点：这里是cur.next，而不是cur。这里是or
        return dummy.next

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:     
        amount = len(lists)
        interval = 1
        while amount > interval:
            for i in range(0,amount-interval,2*interval):
                lists[i] = self.merge2Lists(lists[i], lists[i+interval]) # 易错点：方括号和小括号不要用错
            interval *= 2
        return lists[0] if amount>0 else None
```

###  3.23. <a name='SwapNodesinPairs'></a>24-Swap Nodes in Pairs

[哈哈哈](https://www.bilibili.com/video/BV1M7411n7FT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV13J411V7hG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ih411f7YK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1VC4y1s75E?spm_id_from=333.999.0.0)

```py
# 方法一：递归
class Solution(object):
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # 这样写也可以：
        # if not head or not head.next:
        #     return head
        if not head:
            return None
        if not head.next:
            return head
        tmp = head.next
        head.next = self.swapPairs(head.next.next)
        tmp.next = head
        return tmp # 易错点：注意，新的头已经变成了tmp
``` 

```py
# 方法二：迭代
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head # 易错点：这句话不要漏
        cur = dummy
        while cur.next and cur.next.next:

            first = cur.next
            second = cur.next.next
            
            # 把图画出来
            first.next = second.next
            second.next = first
            cur.next = second

            cur = cur.next.next
        return dummy.next
```

###  3.24. <a name='Removeduplicatesfromsortedarray'></a>26-Remove duplicates from sorted array

[哈哈哈](https://www.bilibili.com/video/BV1UJ411m7Pz?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i77e?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV13V41177Mq?spm_id_from=333.999.0.0)

> for循环法：

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if n == 0: return 0
        left = 0
        for right in range(1, n):
            if nums[right] != nums[left]:
                left += 1
                nums[left] = nums[right]
        return left + 1

# 😁我的模仿
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        count = 0 #注意：count是从0开始的
        for i in range(len(nums)):
            if nums[i] != nums[count]:
                count += 1
                nums[count] = nums[i]
        return count + 1
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.xxd39w8j94g.png" width="30%">

> while循环法

```py
class Solution(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i = 0
        while i < (len(nums) - 1):
            if nums[i] == nums[i+1]:
                nums.remove(nums[i])
                等效于：nums.pop(i)
            else:
                i += 1
        return len(nums)

# 😁我的模仿：
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        i = 0
        while i < len(nums) - 1:
            if nums[i] == nums[i+1]:
                nums.pop(i)
                i -= 1 # 当pop以后，i指针不应该变化
            i += 1
        return len(nums)
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6zs7v6d4w740.png" width="60%">

```scala

object Solution {
    def removeDuplicates(nums: Array[Int]): Int = {
        
        // Two-pointer idea
        
        if (nums.length == 0){
            0
        } else {
            // if the Array is not empty, we start from index 1 rather than 0
            // since the 1st element (at index 0) will be included for sure.
            // For the same reason, the initial value of `count` is 1 instead of 0
            
            var count = 1
            
            // NOTE: start from 1 rathr than 0 here
            for (i <- 1 until nums.length) {
                if (nums(i) != nums(count-1)) {
                    nums(count) = nums(i)
                    count += 1
                }
            }
            
            count
        }
         
    }
}
```

###  3.25. <a name='python-Removeelement'></a>27-python-Remove element

[哈哈哈](https://www.bilibili.com/video/BV1mJ411m7ir?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7hZ?spm_id_from=333.999.0.0)

和上面一体差不多，很简单

```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        while i < len(nums):
            if nums[i] == val:
                nums.pop(i)
            else:
                i += 1
        return len(nums)
```

###  3.26. <a name='Implementstr'></a>28-Implement str

[哈哈哈](https://www.bilibili.com/video/BV1eL411n7YS?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1BJ41117d6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1UK411K7zB?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7cG?spm_id_from=333.999.0.0)

解法一：直接用.index()

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "":
            return 0
        if needle in haystack:
            return haystack.index(needle)
        else:
            return -1
```

解法二：在对整个needle字符串比较

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        for i in range(len(haystack)-len(needle)+1):
            if haystack[i:i+len(needle)] == needle:
                return i 
        return -1
```

###  3.27. <a name='NextPermutation'></a>31 Next Permutation

[小明](https://www.bilibili.com/video/BV1Uz4y1m72N?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1SK4y1V7ch?spm_id_from=333.999.0.0)

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # 关键在于从后往前，找到非递减序列
        i = len(nums) - 2
        while i >= 0:
            if nums[i] >= nums[i+1]:
                i -= 1
            else:
                # 寻找i后面比i大的数，交换位置,并且排序
                for j in range(len(nums)-1,i,-1): # 易错点:len(nums)-1,i的区间
                    # 12(3)5(4)
                    if nums[j] > nums[i]:
                        nums[i],nums[j] = nums[j],nums[i]
                        nums[i+1:] = sorted(nums[i+1:])
                        return
        nums.reverse() # 易错点:对于[3,2,1]这种情况，i = 0
```

###  3.28. <a name='LongestValidParentheses'></a>32 Longest Valid Parentheses

[小明](https://www.bilibili.com/video/BV1RZ4y1F7nJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1yi4y1G74d?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n) 

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6dkova4yjvk0.png)

```py
# 背一背吧，好难。
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0]*n
        if n == 0: return 0
        for i in range(n):
            if s[i] == ')' and s[i-dp[i-1]-1] == '(' and i - dp[i-1] - 1 >= 0:
                dp[i] = 2 + dp[i-1] + dp[i-dp[i-1]-2]
        return max(dp)
```

栈：

* 时间复杂度: O(n) 

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1dgqk0ervhb4.png)

```py
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = maxlength = 0
        for i,c in enumerate(s):
            if c == '(':
                stack.append(i)
            if c == ')':
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    length = i - stack[-1]
                    maxlength = max(maxlength,length)
        return maxlength

```

###  3.29. <a name='SearchinRotatedSortedArray'></a>33. Search in Rotated Sorted Array

[小梦想家](https://www.bilibili.com/video/BV1gJ411V7Sq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV14t4y127hK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16A41147Fp?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # 定义第一个元素和最后一个元素
        left, right = 0, len(nums) - 1
        while left <= right:
            # 找到二分的位置：
            # mid = l + ((r - l) >> 2)
            # mid = (l + r) // 2
            mid = (right + left) // 2
            # 第一步
            if nums[mid] == target:
                return mid

            # --------------第二步：核心代码--------------
            # 只存在一个上升序列
            if nums[mid] < nums[right]:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
            else:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            # --------------第二步：核心代码--------------
        return -1

# 我的模仿！啊😋

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1

        while l <= r:
            m = (l+r) // 2
            if nums[m] == target:
                return m
            if nums[l] <= nums[m]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else: 
                    l = m + 1
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else: 
                    r = m - 1
        
        return -1
```

```py
# 这道题简直是在跟我开玩笑（狗头）

class Solution(object):
    def search(self, nums, target):
        return nums.index(target) if target in nums else -1
```

###  3.30. <a name='-1'></a>34-在排序数组中查找元素的第一个

[哈哈哈](https://www.bilibili.com/video/BV1Zv411y71t?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1GU4y1j7dq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ef4y1v7Vz?spm_id_from=333.999.0.0)

```py
# Python 二分法

class Solution:
    def searchRange(self, nums, target):
        left = 0
        right = len(nums)-1
        res = [0,0]
        
        if target not in nums:
            return [-1,-1]

        # 寻找左侧边界
        while(left<=right):
            mid = (right + left) // 2
            if nums[mid] == target:
                right = mid - 1 # 结束条件
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[0] = left

        # 寻找右侧边界
        right = len(nums)-1
        while left<=right:
            mid = (right + left) // 2
            if nums[mid] == target:
                left = mid + 1 # 结束条件
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[1] = right

        return res
```

```py
# 二分搜索算法返回首个不小于（即：等于或大于）target的元素的下标，这样只需进行两次相似的二分搜索即可

# 这种方法很漂亮，但是很容易出错，不推荐。

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        start = self.binarySearch(nums, target)
        end = self.binarySearch(nums, target+1)
        if start < end:
            return [start,end-1]
        else:
            return [-1,-1]
    
    def binarySearch(self, nums, target):
        l = 0
        r = len(nums)  # 精华,千万不能-1，
        while l < r: # 精华,千万不能包括==，
            m = (l + r) // 2
            # 由于这里存在多个重复数字，所以简单的二分查找不顶用
            # 这里的思想是找到left
            if target > nums[m]: # 精华,千万不能包括==，不然left不能移动
                l = m + 1 # 精华
            else:
                r = m
        return l

```

###  3.31. <a name='-1'></a>35-搜索插入位置

[哈哈哈](https://www.bilibili.com/video/BV1HD4y1m7U2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411i7Aj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1dA411a7CB?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1wf4y1m7Ue?spm_id_from=333.999.0.0)

* 时间复杂度: O(logn) 

* 空间复杂度: O(1)

```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if target == nums[m]:
                return m
            elif target < nums[m]:
                r = m - 1
            else: 
                l = m + 1
        return l #易错点：记住，这里需要输出，且输出left
```

###  3.32. <a name='-1'></a>36-有效的数独

[哈哈哈](https://www.bilibili.com/video/BV1Cf4y1R7PR?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1MJ411p7FT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ZL4y1e7oo?spm_id_from=333.999.0.0)

```py
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        cols = [set() for _ in range(9)]
        rows = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if board[i][j] in cols[j] or \
                    board[i][j] in rows[i] or \
                    board[i][j] in grids[i//3][j//3]:
                        return False
                    else:
                        cols[j].add(board[i][j])
                        rows[i].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])
        return True
```

```scala
object Solution {
    def isValidSudoku(board: Array[Array[Char]]): Boolean = {
        
        
        import util.control.Breaks._
        
        def check_a_single_array(l: Array[Char]): Boolean = {
            // input: Array of char, an Array of 9 elments to check using the three rules
            // return: Boolean, if the array given can pass the exam
            val temp = l.filter(_ != '.')
            if (temp.length != temp.distinct.length) {
                false
            } else {
                true
            }
        }
        
        
        var error_flag = 0
        
        breakable {
            
            // check rule-1
            for (i <- 0 until 9) {
                if (check_a_single_array(board(i)) ==  false) {
                    error_flag += 1
                    break
                }
              }

            // check rule-2
            for (i <- 0 until 9) {
                val temp_list = board.map(_(i))
                
                if (check_a_single_array(temp_list) == false) {
                    error_flag += 1
                    break
                }
            }
            
            // check rule-3
            for (i <- 0 until 3; j <- 0 until 3) {
                // get each 3x3 sub-boxes and flatten it to a 9-length Array
                val temp_list = board.slice(i * 3, i * 3 + 3).flatMap(_.slice(j * 3, j*3 + 3))
                
                if (check_a_single_array(temp_list) == false) {
                    error_flag += 1
                    break
                }
            }
 
        }

 
        if (error_flag > 0) false else true
         
    }
}
```

###  3.33. <a name='SudokuSolver'></a>37. Sudoku Solver 解数独

[花花酱](https://www.bilibili.com/video/BV1Tt41137Xr?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1f5411h7er?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3k462gpgb5k0.png)

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if  board[i][j] not in rows[i] and \
                        board[i][j] not in cols[j] and \
                        board[i][j] not in grids[i//3][j//3]:
                        rows[i].add(board[i][j])
                        cols[j].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])

        def dfs(i,j):
            if board[i][j] != '.': # 被数字填满

                if i == 8 and j == 8:
                    self.flag = True
                    return
                if j < 8:
                    dfs(i,j+1)
                if j == 8:
                    dfs(i+1,0)
                    
            else:
                for num in range(1,10):
                    item = str(num)
                    if  item not in rows[i] and \
                        item not in cols[j] and \
                        item not in grids[i//3][j//3]:
                        board[i][j] = item
                        rows[i].add(item)
                        cols[j].add(item)
                        grids[i//3][j//3].add(item)

                        # 易错点:注意缩进关系
                        if i == 8 and j == 8:
                            self.flag = True
                            return
                        if j < 8:
                            dfs(i,j+1)
                        if j == 8:
                            dfs(i+1,0)
                        if self.flag:
                            return
                            
                        board[i][j] = '.'
                        rows[i].remove(item)
                        cols[j].remove(item)
                        grids[i//3][j//3].remove(item)

        self.flag = False
        dfs(0,0)

```

###  3.34. <a name='Countandsay'></a>38-Count and say

[哈哈哈](https://www.bilibili.com/video/BV1QJ411R7MF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i717?spm_id_from=333.999.0.0)

```py
import itertools
class Solution:
    def countAndSay(self, n: int) -> str:
        res = '1'
        for _ in range(n-1):
            res = ''.join([str(len(list(g))) + k for k,g in itertools.groupby(res)])
        return res
```

```py
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1: 
            return '1'

        res = ''
        count = 1
        s = self.countAndSay(n-1)
        for i in range(len(s)):
            if i+1 < len(s) and s[i] == s[i+1]:
                count += 1
            else:
                res += str(count) + s[i]
                count = 1
        return res
```

```py
# 我的模仿😋

class Solution:
    def countAndSay(self, n: int) -> str:
        s = '1'
        for _ in range(n-1):
            tmp = ''
            count = 1  # 易错点：count的位置
            for j in range(len(s)):
                if j+1 < len(s) and s[j] == s[j+1]:
                    count += 1
                else:
                    tmp += str(count) + s[j]
                    count = 1  # 易错点：count重新置为1
            s = tmp
        return s
```


###  3.35. <a name='CombinationSum39-'></a>39. Combination Sum 39-组合总和

[花花酱](https://www.bilibili.com/video/BV1gb411u7dy?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Wz411e79d?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12Z4y157nE?spm_id_from=333.999.0.0)

![Snipaste_2021-12-18_11-30-10](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/Snipaste_2021-12-18_11-30-10.5b1q5zh7t4w0.png)

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []

        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:]) 
                # 易错点，这里是res.append(path[:])，而不是res.append(path)
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    path.append(candidates[i])
                    dfs(i)
                    path.pop()
        dfs(0)
        return res
```

###  3.36. <a name='CombinationSumII40-II'></a>40. Combination Sum II 40-组合总和 II

[花花酱](https://www.bilibili.com/video/BV1Pb411u7Yd?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gT4y1J7JE?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        candidates.sort()
        # candidates.reverse()
        def dfs(firstIdx):
            if sum(path) == target:
                res.append(path[:])
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    # 易错点：需要剪枝
                    if i > firstIdx and candidates[i] == candidates[i-1]: continue
                    # [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]会超时
                    path.append(candidates[i])
                    dfs(i+1)
                    path.pop()
        dfs(0)
        return res
```

###  3.37. <a name='FirstMissingPositive'></a>41 First Missing Positive

[小明](https://www.bilibili.com/video/BV1fy4y1k7pV?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums.append(0)
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0 or nums[i] >= n:
                nums[i] = 0
        # for num in nums:
            # if num >= n or num <= 0:
            #     num = 0
            # 易错点：for num in nums,其中num只能进行读操作，不能进行写操作。
            # 容易出错
        
        for num in nums:
            nums[num % n] += n  
            # 易错点：% n,一定要取余数，不然会index out of range

        for i,num in enumerate(nums):
            if num < n:
                return i

        return n
```

###  3.38. <a name='TrappingRainWater'></a>42. Trapping Rain Water

[花花酱](https://www.bilibili.com/video/BV1hJ41177gG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fi4y1t7BP?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        
        n = len(height)
        leftMax = [height[0]] + [0] * (n - 1)
        for i in range(1, n):
            leftMax[i] = max(leftMax[i - 1], height[i])

        rightMax = [0] * (n - 1) + [height[n - 1]]
        for i in range(n - 2, -1, -1):
            rightMax[i] = max(rightMax[i + 1], height[i])

        ans = sum(min(leftMax[i], rightMax[i]) - height[i] for i in range(n))
        return ans
```

栈：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        stack = list()
        n = len(height)
        
        for i, h in enumerate(height):
            while stack and h > height[stack[-1]]:
                top = stack.pop()
                if not stack:
                    break
                left = stack[-1]
                currWidth = i - left - 1
                currHeight = min(height[left], height[i]) - height[top]
                ans += currWidth * currHeight
            stack.append(i)
        
        return ans
```

双指针：

* 时间复杂度: O(n)

* 空间复杂度: O(1)

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        leftMax = rightMax = 0

        while left < right:
            leftMax = max(leftMax, height[left])
            rightMax = max(rightMax, height[right])
            if height[left] < height[right]:
                ans += leftMax - height[left]
                left += 1
            else:
                ans += rightMax - height[right]
                right -= 1
        
        return ans

#   😋我的模仿

class Solution:
    def trap(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        leftmax = 0
        rightmax = 0
        res = 0
        while left < right:
            if height[left] < height[right]:
                leftmax = max(leftmax,height[left])
                # 易错点：注意res和left的次序：先res，后left
                res += leftmax-height[left] 
                left += 1
            else:
                rightmax = max(rightmax,height[right])
                # 易错点：注意res和right的次序：先res，后right
                res += rightmax-height[right]
                right -= 1
        return res
```

###  3.39. <a name='JumpGameII'></a>45 Jump Game II

[小明](https://www.bilibili.com/video/BV1fb4y1Z77x?spm_id_from=333.999.0.0)

```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        maxPos, end, step = 0, 0, 0
        for i in range(n - 1):
            if maxPos >= i:
                maxPos = max(maxPos, i + nums[i])
                if i == end:
                    end = maxPos
                    step += 1
        return step

#   😋我的模仿

class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        jump = 0
        cover = 0
        stop = 0
        i = 0
        while cover >= i and i < n-1: 
            #易错点：是n-1，不是n，只要调到最后一格就算成功
            cover = max(cover,i + nums[i])
            if i == stop:
                jump += 1
                stop = cover
            i += 1
        return jump
```

###  3.40. <a name='-1'></a>46-把数字翻译成字符串

[哈哈哈](https://www.bilibili.com/video/BV1Bz411i7cs?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411W7eC?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n)

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.66thg6sgm600.png)

```py
class Solution:
    def translateNum(self, num: int) -> int:
        s = str(num)
        n = len(s)
        dp = [1]*n
        if '10' <= s[0:2] <= '25':
            dp[1] = 2
        for i in range(2,n):
            if '10' <= s[i-1:i+1] <= '25':
                dp[i] = dp[i-1] + dp[i-2]
            else:
                dp[i] = dp[i-1]
        return dp[-1]
```

###  3.41. <a name='-1'></a>46-全排列

[哈哈哈](https://www.bilibili.com/video/BV1YA411v7zF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7fm?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oa4y1v7Kz?spm_id_from=333.999.0.0)

```py
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        # n = len(nums)
        def dfs(nums):
            # 易错点：if len(path) == n:
            if not nums: # 判断条件应该是这个
                res.append(path[:]) # 易错点：path[:]
                return
            else:
                for i in range(len(nums)):
                    path.append(nums[i])
                    dfs(nums[:i]+nums[i+1:]) # 易错点：n是不断变小的
                    path.pop()
        dfs(nums)
        return res

# 另一种写法😋
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def dfs(nums,path):
            if not nums: 
                res.append(path[:]) 
                return
            else:
                for i in range(len(nums)):
                    dfs(nums[:i]+nums[i+1:],path + [nums[i]]) 
        dfs(nums,[])
        return res
```

###  3.42. <a name='II-'></a>47-全排列 II-剪枝版

[哈哈哈](https://www.bilibili.com/video/BV1Ev411672A?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1qK4y1x7Qs?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1z54y1a7rQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        def dfs(nums,path):
            if not nums:
                res.append(path[:])
            else:
                for i in range(len(nums)):
                    if i>0 and nums[i] == nums[i-1]:
                        continue
                    dfs(nums[:i]+nums[i+1:],path + [nums[i]])

        dfs(nums,[])
        return res
```

###  3.43. <a name='RotateImage'></a>48. 旋转图像 Rotate Image

[官方](https://www.bilibili.com/video/BV1mf4y1e7ox?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Wy4y1s7fs?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3kl7avrsvhi0.png" width="30%">

```py
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n//2):
            for j in range((n+1)//2):
                matrix[i][j],matrix[j][n-1-i],matrix[n-1-i][n-1-j],matrix[n-1-j][i] = \
                matrix[n-1-j][i],matrix[i][j],matrix[j][n-1-i],matrix[n-1-i][n-1-j]
        return matrix
```

###  3.44. <a name='GroupAnagrams'></a>49 Group Anagrams

[小明](https://www.bilibili.com/video/BV1n5411t79G?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Yf4y1e7gJ?spm_id_from=333.999.0.0)

```py
# 质数对应字母 乘积哈希
# 这个思想可以学习！但我还没看
from functools import reduce
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]
        chars = "abcdefghijklmnopqrstuvwxyz"
        ch_pr = {chars[i]:prime[i] for i in range(26)}
        for s in strs:
            keys = reduce(lambda x,y :x*y,[ch_pr[i] for i in s], 1)
            if keys in dic:
                dic[keys].append(s)
            else:
                dic[keys] = [s]
        return list(dic.values())
```

```py
# python3 : 常规做法

class Solution:
    def groupAnagrams(self, strs):
        res = []
        dic = {}
        for s in strs:
            keys = "".join(sorted(s))
            if keys not in dic:
                dic[keys] = [s]
            else:
                dic[keys].append(s)
        return list(dic.values())

# 我的模仿😋

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        dic = {}
        for s in strs:
            keys = ''.join(sorted(s)) #易错点：s被sorted以后，会变成list
            if keys not in dic:
                dic[keys] = [s] #易错点：[s],而不是s
            else:
                dic[keys].append(s)
        # print(dic.values())输出dict_values([['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']])
        return list(dic.values())
```

```py
# 更简单的写法：
class Solution:
    def groupAnagrams(self, strs):
        dic = collections.defaultdict(list)

        for s in strs:
            keys = "".join(sorted(s))
            dic[keys].append(s)
        
        return list(dic.values())
```

```scala
object Solution {
    def groupAnagrams(strs: Array[String]): List[List[String]] = {
        
        import collection.mutable.HashMap
        import collection.mutable.ListBuffer
        
        val mapping = HashMap[String, ListBuffer[String]]()
        
        for (s <- strs) {
            if (mapping.contains(s.sorted)) {
                mapping(s.sorted) += s
            } else {
                mapping(s.sorted) = ListBuffer(s)
            }
        }
        

        mapping.values.map(_.toList).toList

    }
}
```

###  3.45. <a name='Powxn'></a>50 Pow(x, n)

[小明](https://www.bilibili.com/video/BV1W54y1q7CV?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ai4y147kr?spm_id_from=333.999.0.0)

```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        res = 1

        if n < 0:
            x = 1/x
            n = -n

        if n == 0:
            return res

        while n>0:
            if n % 2 == 1:
                res *= x
            n >>= 1
            # 等价于 n //= 2
            x *= x
        return res
```

###  3.46. <a name='-1'></a>51. 数组中的逆序对

[官方](https://www.bilibili.com/video/BV1Qk4y1r7u5?spm_id_from=333.999.0.0)

###  3.47. <a name='Maximumsubarray'></a>53-Maximum subarray

[哈哈哈](https://www.bilibili.com/video/BV1QJ411R75H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7dn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11A41187AR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ta4y1i7Sh?spm_id_from=333.999.0.0)

贪心

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5qrso4wuc440.png)

```py
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = preSum = nums[0]
        for num in nums[1:]:
            preSum = max(preSum + num, num)
            res = max(res,preSum)
        return res
```

时间复杂度：O(n)
时间复杂度：O(1)

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        
        // IDEA:
        // Go through the whole Array,
        // and change each element into the possible maximum sum of the subarray ENDING at its index 
        
        // During each iteration, the element at i-th index will be updated into the possible maximum sum of subarray ENDING at i-th index
        // then for (i+1)th index, if updated i-th value is positive, it can be used to update (i+1)th value as well.
        
        for (i <- Range(1, nums.length)) {
            if (nums(i-1) > 0) {
                nums(i) += nums(i-1)
            }
        }
        
        nums.max
    }
}
```

###  3.48. <a name='SpiralMatrix'></a>54. Spiral Matrix

[小梦想家](https://www.bilibili.com/video/BV1N7411h7i1?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        # print(list(matrix.pop(0)))
        print(list(zip(*matrix)))
        print(list(zip(*matrix))[::-1])
        return matrix and list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])
        # 含义是，如果matrix为空，则返回matrix
```

```py
return a and b
 
等价于
 
return b if a else a
```

```py
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res += matrix.pop(0) # 易错点：注意是+=
            matrix = list(zip(*matrix))[::-1] # 易错点：注意[::-1]的摆放
        return res
```

###  3.49. <a name='JumpGame'></a>55 Jump Game

[小明](https://www.bilibili.com/video/BV14K4y1b7Fw?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1be411s7XX?spm_id_from=333.999.0.0)

```py
# 首选while循环😁
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)
        i = 0

        while cover >= i:
            cover = max(cover, i+nums[i])
            if cover >= n -  1:
                return True
            i += 1
        return False



# 精简一下的for循环😁
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)

        for i in range(n):
            if i <= cover: # 易错点：在判断下一个cover前，先要判断i是否能够到达
                cover = max(cover, i+nums[i])
                # if cover == i:
                    # return False # 易错点：应该考虑特殊情况[0,1,2]

                if cover >= n -  1:
                    return True
        return False
```

```py
object Solution {
    def canJump(nums: Array[Int]): Boolean = {
        
        // We should look at this probelm in REVERSE ORDER:
        // The target is to check whether we can arrive at the last index,
        // then we should reversely check the elements,
        // meanwhile, update the smallest index that we must arrive (`target`) in order to arrive at the last index
        
        // For example, if the i-2 index index is 2,
        // we know we can make it as long as the earlier elements can send us to i-2 index.
        // My target should be updated to i-2 index rather than the last index.
        
        val n = nums.length 
     
        var target = n-1 // the initial target
        var i = n - 2
        
        // update the target
        while (i > 0) {
            if (nums(i) + i >= target) {
                target = i
            }
            i -= 1
        }
        
        // check if the first element can trigger the "chain effect"
        if (nums(0) >= target) {
            true
        } else {
            false
        }
 
    }
}
```

###  3.50. <a name='I.'></a>56-I. 数组中数字出现的次数

[官方](https://www.bilibili.com/video/BV1Qe411s7Kc?spm_id_from=333.999.0.0)

###  3.51. <a name='MergeIntervals'></a>56. Merge Intervals

[花花酱](https://www.bilibili.com/video/BV11t411J7zV?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1w7411a7Wo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411a7t4?spm_id_from=333.999.0.0)

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        # 等价于：intervals.sort(key = lambda x: x[0])
        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1],interval[1])
                # 易错点：不是interval[1]，而是max(res[-1][1],interval[1])
                # 比如，[[1,4],[2,3]]
        return res
```

```py
# 不使用额外的储存空间，直接在原矩阵上面修改的原地算法（反正排序的时候已经修改了原矩阵）：
# pop(i)操作和append()操作耗时一样吗。
# 如果你直接intervals.pop()而不是intervals.pop(i) ，那耗时一样，都是o(1)，
# 但是你指定位置pop，那就是o(n)了。

class Solution:
    def merge(self, intervals):
        intervals.sort()
        i = 1
        while(i < len(intervals)):
            if intervals[i][0] > intervals[i-1][1]:
                i += 1
            else:
                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])
                intervals.pop(i)       
        return intervals
```

###  3.52. <a name='InsertInterval'></a>57. Insert Interval 

[花花酱](https://www.bilibili.com/video/BV11t411J74e?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ja4y1j7cG?spm_id_from=333.999.0.0)

```py
# 根据上一问修改。
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        intervals.append(newInterval)
        intervals.sort()
        res = []
        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1],interval[1])
        return res
```

###  3.53. <a name='LenghofLastWords'></a>58. Lengh of Last Words

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7so?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ay4y1y7d2?spm_id_from=333.999.0.0)

```py
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        s.strip()
        return len(s.split()[-1]) if s else 0
```

```py
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        res = 0
        tmp = 0
        for i in range(len(s)):
            if s[i] == ' ':
                tmp = 0
            else:
                tmp += 1
                res = tmp # 易错点：用res存储tmp变量，防止末尾的空格
        return res
```

###  3.54. <a name='II.LCOF'></a>59 - II. 队列的最大值 LCOF

[官方](https://www.bilibili.com/video/BV1L54y1z7ae?spm_id_from=333.999.0.0)

###  3.55. <a name='SpiralMatrixII'></a>59. Spiral Matrix II 

[小梦想家](https://www.bilibili.com/video/BV1J741157Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1q5411G7MY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res = [[0 for _ in range(n)] for _ in range(n)]
        x,y,dx,dy = 0,0,0,1 
        # 0,1 -> 1,0 -> 0,-1 -> -1,0
        for num in range(1,n*n + 1):
            res[x][y] = num

            if not 0 <= x+dx < n or not 0 <= y+dy < n or res[x+dx][y+dy] != 0:
            # 易错点：or res[x+dx][y+dy] != 0 顺序很重要，一定要在最后
                dx,dy = dy, -dx

            x += dx
            y += dy
        return res
```

###  3.56. <a name='RotateList'></a>61. Rotate List

[花花酱](https://www.bilibili.com/video/BV14y4y1r728?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV117411L7UG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jK411N7e6?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Xk4y1d7gF?spm_id_from=333.999.0.0)

```py
# python 解法 思路：先把链表首尾相连，再找到位置断开循环
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 易错点：要排除一些特殊情况
        if not head or not head.next:
            return head
            
        cur = head
        nodeNum = 1
        # 链接成一个环
        while cur.next:
            cur = cur.next
            nodeNum += 1
        cur.next = head


        # cur指针指向开头
        cur = cur.next
        # steps到达new head的前一个node
        steps = nodeNum - k % nodeNum - 1
        for _ in range(steps):
            cur = cur.next


        res = cur.next
        cur.next = None
        return res
```

###  3.57. <a name='-1'></a>62-不同路径

[哈哈哈](https://www.bilibili.com/video/BV1mC4y1W7Je?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sg4y1v7PM?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1cp4y167qx?spm_id_from=333.999.0.0)

二维动态规划：

时间复杂度：O(mn)

空间复杂度：O(mn)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 易错点：dp千万不要写错
        # 其他写法：dp = [[1 for i in range(n)] for j in range(m)]
        # 其他写法：dp = [[1]*n]*m
        dp = [[1]*n] + [[1]+[0]*(n-1) for _ in range(m-1)]
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

一维动态规划：

时间复杂度：O(mn)

空间复杂度：O(n)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 易错点：dp千万不要写错
        dp = [1]*n
        for i in range(1,m):
            for j in range(1,n):
                dp[j] += dp[j-1]
        return dp[-1]
```

###  3.58. <a name='UniquePathsII'></a>63 Unique Paths II

[小明](https://www.bilibili.com/video/BV1Sv411L7qe?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pp4y1v7KR?spm_id_from=333.999.0.0)

```py
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        # 易错点：注意边界上也可能有obstacle
        # 易错点：dp = [[0]*(n+1)]*(m+1)这些写法是错误的
        dp = [[0]*(n+1) for _ in range(m+1)]
        # 易错点：dp[1][1] = 1,这个数字会被重新计算，所以应该写成：
        dp[0][1] = 1
        # 构建了一个大一圈的矩阵，但实际计算的时候，仍然是mn的大小
        for i in range(1,m+1):
            for j in range(1,n+1):
                if not obstacleGrid[i-1][j-1]:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        print(dp)
        return dp[-1][-1]
```

###  3.59. <a name='MinimumPathSum64-'></a>64. Minimum Path Sum 64-最小路径和

[花花酱](https://www.bilibili.com/video/BV12W411679S?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ka4y1i7Vu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1JC4y1x7j1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vi4y1u7a6?spm_id_from=333.999.0.0)

```py
# 可以直接在原数组上进行记忆，不需要额外的空间
# so easy,直接AC
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0:
                    continue
                if i == 0:
                    grid[i][j] += grid[i][j-1]
                if j == 0:
                    grid[i][j] += grid[i-1][j]
                if i > 0 and j > 0:
                    grid[i][j] += min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
```

###  3.60. <a name='ValidNumber'></a>65 Valid Number

[小明](https://www.bilibili.com/video/BV1hK4y1975b?spm_id_from=333.999.0.0)

###  3.61. <a name='Plusone'></a>66-Plus one

[哈哈哈](https://www.bilibili.com/video/BV1jJ411d7Ry?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7b1?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gi4y137GW?spm_id_from=333.999.0.0)

```py
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        for i in range(len(digits)-1,-1,-1):
            if digits[i] == 9:
                digits[i] = 0
            else:
                digits[i] += 1
                return digits
        return [1] + digits

# 简单题重拳出击，最后一位加1，
# 等于10就进位，没有进位就输出，
# 进位到头就在output前面加个1，简单易懂
```

###  3.62. <a name='AddBinary'></a>67-Add Binary

[哈哈哈（常规方法）](https://www.bilibili.com/video/BV1N7411F73K?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV17J411d7G1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7Bo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Q5411h7gc?spm_id_from=333.999.0.0)

常规做法:

```py
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        res = ''
        carry = 0
        i = len(a)-1
        j = len(b)-1
        while i >= 0 or j >= 0 or carry: # 易错点： 不要漏 or carry
            val = carry
            if i >= 0: val += int(a[i]) # 易错点：[i],不要写成(i)
            if j >= 0: val += int(b[j])
            carry = val // 2
            res += str(val % 2)
            i -= 1
            j -= 1
        return res[::-1]
```

###  3.63. <a name='Sqrtx'></a>69 Sqrt(x)

[花花酱](https://www.bilibili.com/video/BV1WW411C7YN?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gJ411R7XR?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7TN?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1PK411s72g?spm_id_from=333.999.0.0)

袖珍计算器:

时间复杂度：O(1)

空间复杂度：O(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        ans = int(math.exp(0.5 * math.log(x)))
        return ans + 1 if (ans + 1) ** 2 <= x else ans
```

二分查找:

时间复杂度：O(logN)

空间复杂度：O(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r, ans = 0, x, -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans

# 二分法不需要ans
# 但是不好理解

class Solution:
    def mySqrt(self, x: int) -> int:
        l = 0
        r = x
        while l <= r:
            m = (l + r) // 2 # l和1，不要打错，哈哈哈
            if m**2 > x:
                r = m - 1
            else:
                l = m + 1
        return r
```

牛顿迭代法:

时间复杂度：O(logN)

空间复杂度：O(1)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3g2xmodb40u0.png)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1:
            return x
        
        C, res = float(x), float(x)
        while True:
            xi = 0.5 * (res + C / res)
            if abs(res - xi) < 1e-7:
                break
            res = xi
        
        return int(res)

class Solution:
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        if x <= 1:
            return x
        res = x # 初始值
        c = x # 牛顿迭代法中的常数
        while res > c / res:
            res = (res + c / res) // 2
        return int(res)
```

```py


牛顿迭代法：https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division


```

###  3.64. <a name='ClimbingStairs'></a>70. Climbing Stairs

[5:32 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gJ411R7X1?spm_id_from=333.999.0.0)

[哈哈哈 70(重制版)](https://www.bilibili.com/video/BV1G54y197eZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7s9?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DZ4y1H7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ki4y1u7tn?spm_id_from=333.999.0.0)

```py
class Solution:
    def climbStairs(self, n: int) -> int:
        b1, b2 = 1, 1
        for i in range(n-1):
            b1, b2 = b2, b1 + b2
        return b2

# 我的模仿

class Solution:
    def climbStairs(self, n: int) -> int:
        dp0 = 1
        dp1 = 1
        for _ in range(n-1):
            dp1, dp0 = dp0 + dp1, dp1
            # 用2个数字分别存储
        return dp1
```

###  3.65. <a name='SimplifyPath'></a>71. Simplify Path

[小梦想家](https://www.bilibili.com/video/BV1V7411w7jX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1D5411J72c?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def simplifyPath(self, path):
        stack = []
        for i in path.split('/'):
            if i not in ['', '.', '..']:
                stack.append(i)
            elif i == '..' and stack:
                stack.pop()
        return "/" + "/".join(stack)
```

```py
# cool
from os.path import abspath

class Solution:
    def simplifyPath(self, path: str) -> str:
        return abspath(path)

from functools import reduce
class Solution:
    def simplifyPath(self, path: str) -> str:
        return "/"+"/".join(reduce(lambda x, y: x[:-1] if y == ".." else x + [y] if y and y != "." else x, path.split("/"), []))

# 等效于:

class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        for i in path.split('/'):
            if i == '..':
                if stack:
                    stack.pop()
                else:
                    continue
            elif i and i != '.': # 注意这里是elif,而不是if
                stack.append(i)
        return "/" + "/".join(stack)
```

###  3.66. <a name='EditDistance72-'></a>72. Edit Distance 72-编辑距离

[花花酱](https://www.bilibili.com/video/BV1cb411u7uX?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wv411P7aQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13Z4y1W7UB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ea4y147FK?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5kci5ryyi3k0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7fq2ehol7rg0.png)

```py
#@author:leacoder
#@des:  动态规划  编辑距离

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
        # 初始
        for i in range(len1+1):
            DP[i][0] = i
        for j in range(len2+1):
            DP[0][j] = j
        for i in range(1,len1+1):
            for j in range(1,len2+1):
                
                if word1[i - 1] == word2[j -1]:
                    DP[i][j] =  DP[i-1][j-1]
                else:
                    DP[i][j]  =  min(DP[i-1][j] + 1,DP[i][j-1] + 1,DP[i-1][j-1]+1)
        return DP[len1][len2]

# 换个写法

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2+1)] for _ in range(len1+1)]
        
        for i in range(0,len1+1):
            for j in range(0,len2+1):
                if i == 0:               # 初始化
                    DP[i][j] = j
                elif j == 0:             # 初始化
                    DP[i][j] = i
                elif word1[i - 1] == word2[j -1]:
                    DP[i][j] =  DP[i-1][j-1]
                else:
                    DP[i][j]  =  min(DP[i-1][j],DP[i][j-1],DP[i-1][j-1]) + 1
                    
        return DP[-1][-1]
```

```py
比较好理解，but会超时，哭唧唧

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        @cache
        def dp(i, j) -> int:
            if i == -1:
                return j + 1
            if j == -1:
                return i + 1
            # 做出选择
            if word1[i] == word2[j]:
                return dp(i - 1, j - 1) # 什么都不做
            else:
                return min(
                    dp(i, j-1) + 1,  # insert
                    dp(i-1, j) + 1,  # delete
                    dp(i-1, j-1) + 1 # replace
                )
        return dp(len(word1)-1, len(word2)-1)
```

###  3.67. <a name='SetMatrixZeroes'></a>73. Set Matrix Zeroes

[小梦想家](https://www.bilibili.com/video/BV1W7411T7rX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1X64y1Y7kG?spm_id_from=333.999.0.0)

```py
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        tmp = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 0:
                    tmp.append([i,j])
        for r,c in tmp:
            for j in range(len(matrix[0])):
                matrix[r][j] = 0
            for i in range(len(matrix)):
                matrix[i][c] = 0
        return matrix
```

##  4. <a name='Searcha2DMatrix'></a>74 Search a 2D Matrix

[小明](https://www.bilibili.com/video/BV1aK4y1h7Bb?spm_id_from=333.999.0.0)

```py
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        l = 0
        r = m*n-1
        while l <= r:
            mid = (l + r) // 2
            midRow = mid // n
            midCol = mid % n
            if matrix[midRow][midCol] == target:
                return True
            elif matrix[midRow][midCol] > target:
                r = mid - 1 # 易错点：+1,-1不要写反了
            else:
                l = mid + 1
        return False
```

###  4.1. <a name='SortColors'></a>75. Sort Colors

[小梦想家](https://www.bilibili.com/video/BV1rE411n7mL?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ua4y1v7yd?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1tz4y1o7n5?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5l1bfbznzwc0.png)

```py
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        idx, left, right = 0, 0, len(nums) - 1
        while idx <= right:
            if nums[idx] == 2 and idx < right:
                nums[idx], nums[right] = nums[right], 2
                right -= 1
            elif nums[idx] == 0 and idx > left:
                nums[idx], nums[left] = nums[left], 0
                left += 1
            else:
                idx += 1
```

###  4.2. <a name='-1'></a>76-最小覆盖子串

[哈哈哈](https://www.bilibili.com/video/BV1PM4y1K7p6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK4y1t7Qd?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ud8tslp4vz4.png)

```py
class Solution:
    def minWindow(self, s: str, t: str) -> str:
    
        def isContains(windic,targetdic):
            for key in targetdic:
                if windic[key] < targetdic[key]:
                    return False # 只要有一个不满足，则不满足
            return True

        
        tdic = defaultdict(int)
        wdic = defaultdict(int)
        for char in t:
        	tdic[char] += 1
        for char in t:
            wdic[char] = 0

        minlen = len(s)
        l = 0
        res = ''

        for r in range(len(s)): 
            # 右边界移动,并把右边界加入字典
            if s[r] in tdic:
                wdic[s[r]] += 1
            while isContains(wdic,tdic):
                if r-l+1 <= minlen:
                    # 满足包含条件，并且minlen
                    minlen = r-l+1
                    res = s[l:r+1]
                if s[l] in wdic:
                    wdic[s[l]] -= 1
                l += 1 # 如果window满足条件，那就收缩左边界，但需要进行如上操作
        return res
```

###  4.3. <a name='-1'></a>77. 组合

```py
class Solution:
    def combine(self, n, k):
            res = []
            path = []
            def backtrack(StartIndex):
                if len(path) == k:
                    res.append(path[:])
                    return
                for i in range(StartIndex, n+1):
                    path.append(i)
                    backtrack(i+1)
                    path.pop()
            backtrack(1)
            return res
```

###  4.4. <a name='Subsets78-'></a>78. Subsets 78-子集

[花花酱](https://www.bilibili.com/video/BV1jt411k7py?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1HD4y1Q7Te?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1s7pq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1154y1R72Q?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = [[]]
        for num in nums:
            res.extend([tmp+[num] for tmp in res])
        return res  

# bfs
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        q=[[]]
        n=len(nums)
        for i in range(n):
            for j in range(len(q)):
                q.append(q[j]+[nums[i]])
        return q

        # 等效

        res = [[]]
        n = len(nums)
        for num in nums:
            for subres in res[:]:
                res.append(subres+[num])
        return res

# 注意代码中res[:]是必须的，因为切片是引用新的对象，
# 此时在循环中res[:]是不更新的，而res是不断有元素push进去的，很trick
```

```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  
        path = []  
        def backtrack(startIndex):
            res.append(path[:])  #收集子集，要放在终止添加的上面，否则会漏掉自己
            for i in range(startIndex,len(nums)):  #当startIndex已经大于数组的长度了，就终止了，for循环本来也结束了，所以不需要终止条件
                path.append(nums[i])
                backtrack(i+1)  #递归
                path.pop()  #回溯
        backtrack(0)
        return res
```

###  4.5. <a name='WordSearch'></a>79. Word Search

[小梦想家](https://www.bilibili.com/video/BV1yE411g7Tb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iZ4y1T78D?spm_id_from=333.999.0.0)

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def dfs(i, j, word):
            # 单词是否出现在以i，j为起点的网格中
            # word[0] 和 word[1:] 划分
            # 结束条件：
            if len(word) == 1:
                return word[0] == board[i][j]
            # 结束条件：
            if board[i][j] != word[0]:
                return False
            
            # 设置现场
            visit[i][j] = True
            for dire in direction: # 对四个方向进行搜索
                newi, newj = i + dire[0], j + dire[1]
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]) and not visit[newi][newj]:
                    if dfs(newi, newj, word[1:]): # dfs成功
                        return True
            # 还原现场
            visit[i][j] = False

        direction = [(0,1), (0, -1), (1, 0), (-1, 0)]
        m = len(board)
        n = len(board[0])
        visit = [[False]*n for _ in range(m)]
        for i in range(m): # 遍历所有格子作为单词起点
            for j in range(n):
                if dfs(i,j,word): # dfs成功
                    return True
        return False
```

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def check(i: int, j: int, k: int) -> bool:
            if board[i][j] != word[k]:
                return False
            if k == len(word) - 1: # k + 1等价于word[1:]
                return True
            
            visited.add((i, j)) # 用集合表示visited
            for di, dj in directions:
                newi, newj = i + di, j + dj
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]):
                    if (newi, newj) not in visited:
                        if check(newi, newj, k + 1): # k + 1等价于word[1:]
                            return True
            visited.remove((i, j)) # 用集合表示visited

        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        h, w = len(board), len(board[0])
        visited = set() # 用集合表示visited
        for i in range(h):
            for j in range(w):
                if check(i, j, 0):
                    return True
        
        return False
```

###  4.6. <a name='RemoveDuplicatesfromSortedArrayII'></a>80 Remove Duplicates from Sorted Array II

[小明](https://www.bilibili.com/video/BV1vy4y1S7sN?spm_id_from=333.999.0.0)

###  4.7. <a name='IIRemoveDuplicatesfromSortedList'></a>82. 删除排序链表中的重复元素 II(Remove Duplicates from Sorted List

[洛阳](https://www.bilibili.com/video/BV1Fi4y187pj?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0,head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                while cur.next.next and cur.next.val == cur.next.next.val:
                    cur.next = cur.next.next # 删去重复节点的前一个
                cur.next = cur.next.next # 删去重复节点的剩余一个
            else:
                cur =  cur.next
        return dummy.next

# 另一种写法
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0,head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                x = cur.next.val
                while cur.next and cur.next.val == x:
                    cur.next = cur.next.next
            else:
                cur =  cur.next
        return dummy.next
```

###  4.8. <a name='Removeduplicatesfromsortedarray-1'></a>83-Remove duplicates from sorted array

[哈哈哈](https://www.bilibili.com/video/BV1yJ411R7FZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7s7?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1zK411L7Gg?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur =  cur.next
        return head
```

###  4.9. <a name='LargestRectangleinHistogram'></a>84. 柱状图中最大的矩形 Largest Rectangle in Histogram

[官方](https://www.bilibili.com/video/BV16D4y1D7ed?spm_id_from=333.999.0.0)

###  4.10. <a name='PartitionList'></a>86. 分隔链表(Partition List)

[洛阳](https://www.bilibili.com/video/BV1t64y1u7Ei?spm_id_from=333.999.0.0)

```py
        dummy1 = ListNode(0)
        dummy2 = ListNode(0)
        slow,fast,cur = dummy1, dummy2, head
        while cur:
            if cur.val < x:
                slow.next = cur # dummy1 指向第一个小于x的node
                slow = slow.next
            else:
                fast.next = cur # dummy2 指向第一个大于x的node
                fast = fast.next
            cur = cur.next
        slow.next = dummy2.next
        fast.next = None
        return dummy1.next
```

###  4.11. <a name='ScrambleString'></a>87. Scramble String

[花花酱](https://www.bilibili.com/video/BV1QE41137MG?spm_id_from=333.999.0.0)

###  4.12. <a name='Mergesortedarray'></a>88-Merge sorted array

[哈哈哈](https://www.bilibili.com/video/BV14J411X7JE?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7bg?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1g54y1s7ZG?spm_id_from=333.999.0.0)

直接合并后排序

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

双指针

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        sorted = []
        p1, p2 = 0, 0
        while p1 < m or p2 < n:
            if p1 == m:
                sorted.append(nums2[p2])
                p2 += 1
            elif p2 == n:
                sorted.append(nums1[p1])
                p1 += 1
            elif nums1[p1] < nums2[p2]:
                sorted.append(nums1[p1])
                p1 += 1
            else:
                sorted.append(nums2[p2])
                p2 += 1
        nums1[:] = sorted

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

逆向双指针

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        p1, p2 = m - 1, n - 1
        tail = m + n - 1
        while p1 >= 0 or p2 >= 0:
            if p1 == -1:
                nums1[tail] = nums2[p2]
                p2 -= 1
            elif p2 == -1:
                nums1[tail] = nums1[p1]
                p1 -= 1
            elif nums1[p1] > nums2[p2]:
                nums1[tail] = nums1[p1]
                p1 -= 1
            else:
                nums1[tail] = nums2[p2]
                p2 -= 1
            tail -= 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  4.13. <a name='-1'></a>89

```py
class Solution:
    def grayCode(self, n):
        def recur(i):
            # 终止条件
            if i==0:
                return ['0']
            if i==1:
                return ['0','1']
            print("当i是",i)
            # 循环迭代
            # dfs(6) -> dfs(5) -> dfs(4) -> dfs(3) -> dfs(2) -> dfs(1)
            # dfs(6) -> dfs(5) -> dfs(4) -> dfs(3) -> dfs(2) -> last = ['0','1'] return ['00', '01', '11', '10']
            # dfs(6) -> dfs(5) -> dfs(4) -> dfs(3) -> last = ['00', '01', '11', '10'] return 三位数的
            # dfs(6) -> last = 5位数的 return 6位数的
            lastBinaryList = recur(i-1)
            print("当i是",i,"last:",lastBinaryList)

            return ['0'+BinStr for BinStr in lastBinaryList]+['1'+l for l in lastBinaryList[::-1]]
        ans = recur(n)
        print("ans:",ans)
        return [int(a,2) for a in ans] # int(a,2)把二进制转化成10进制

class Solution(object):
    def grayCode(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        result = [(i>>1)^i for i in range(pow(2,n))]
        print("pow(2,n): ",pow(2,n))
        for i in range(pow(2,n)):
            print("(i>>1):",(i>>1)," (i>>1)^i:",(i>>1)^i)
        return result

class Solution:
    def grayCode(self, n):
        res, head = [0], 1
        for i in range(n):
            for j in range(len(res) - 1, -1, -1): # 逆序，背一背
                res.append(head + res[j])
            head <<= 1 # head就是2**i
        return res

class Solution:
    def grayCode(self, n):
        if n == 0:
            return [0]
        ans = [0, 1]
        for i in range(1, n):
            print("ans[::-1]:",ans[::-1])
            for num in ans[::-1]: # 逆序，背一背，因为最后一位必须是2的n次方
                ans.append(2**i+num)
        return ans
```

###  4.14. <a name='II'></a>90-子集 II

[哈哈哈](https://www.bilibili.com/video/BV11z4y1Q7Hd?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        res = [[]]
        for i in range(len(nums)):
            print([nums[i]])
            print(res)
            print([tmp for tmp in res])
            print("整体判断是否重复：",[nums[i] in res],"=> 如果有一个为true，则返回true")
            print("单个判断是否重复：",[nums[i] in tmp for tmp in res],"=> 如果有一个为true，则返回true")
            # -----------核心算法-----------
            if any(nums[i] in tmp for tmp in res):
                print("遇到重复的元素，则在重复得最多的元素上，继续叠加")
                print("index() 函数用于从列表中找出某个值第一个匹配项的索引位置:",i - nums.index(nums[i]))
                res.extend([tmp+[nums[i]] for tmp in res if tmp.count(nums[i]) == i - nums.index(nums[i])])
            # -----------核心算法-----------
            else:
                res.extend([tmp+[nums[i]] for tmp in res])
        return res
```

```py
class Solution:
    def subsetsWithDup(self, nums):
        res = [[]]
        nums.sort()
        for i in range(len(nums)):
            for j in range(len(res)):
                if res[j] + [nums[i]] not in res:
                    res.append(res[j] + [nums[i]]) 
        return res
```

###  4.15. <a name='DecodeWays'></a>91. Decode Ways

[花花酱](https://www.bilibili.com/video/BV1Lb411y7ec?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1G7M5?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        f = [1] + [0] * n
        print(f)
        for i in range(1, n + 1):
            if s[i - 1] != '0':
                f[i] += f[i - 1] # [1, 1, 2, 3, 5, 8] 如果我是0，那么我就是前面退2位的情况
            print(s[i-2:i]) # 包括i-1和i-2
            if i > 1 and s[i - 2] != '0' and int(s[i-2:i]) <= 26:
                f[i] += f[i - 2] # [1, 1, 2, 3, 5, 8] 如果前一位是0，那么我就是前面1位的情况
            print(f)
        return f[n]
```

```py
# python dp

# 跟爬楼梯类似，就是边界条件处理太恶心了

class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp = [0] * (n+1)
        dp[0] = 1
        print(dp)
        for i in range(1, n+1):
            if s[i-1] != '0':
                dp[i] += dp[i-1]
            if i > 1 and s[i-2] != '0' and int(s[i-2:i]) <= 26:
                dp[i] += dp[i-2]
            print(dp)
        return dp[-1]
```

###  4.16. <a name='ReverseLinkedListII'></a>92-Reverse Linked List II

[哈哈哈](https://www.bilibili.com/video/BV1n7411G7N4?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV19c411h7UE?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        # 设置 dummyNode 是这一类问题的一般做法
        dummy_node = ListNode(-1)
        dummy_node.next = head # 第一步，-> head
        pre = dummy_node
        for _ in range(left - 1):
            pre = pre.next

        cur = pre.next
        for _ in range(right - left):
            tmp = cur.next # 创建tmp
            cur.next = tmp.next # 第三步，-> 
            tmp.next = pre.next # 第三步，-> 
            pre.next = tmp # 第三步，-> 
        return dummy_node.next

# py3 头插法

class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        dummy=ListNode(None)
        dummy.next=head # 第一步，-> head
        pre=dummy
        for _ in range(m-1):
            pre=pre.next
        cur=pre.next
        for _ in range(n-m):
            temp=cur.next
            cur.next=temp.next
            temp.next=pre.next
            pre.next=temp
        return dummy.next
```

###  4.17. <a name='-1'></a>93

```py
# python 一个for循环， 三条 if。

class Solution(object):
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        self.res = []

        def backtrack(s, tmp):
            if len(s) == 0 and len(tmp) == 4:
                self.res.append('.'.join(tmp))
                return
            if len(tmp) < 4:
                for i in range(min(3, len(s))):
                    p, n = s[:i + 1], s[i + 1:]
                    if p and 0 <= int(p) <= 255 and str(int(p)) == p:
                        backtrack(n, tmp + [p])

        backtrack(s, [])
        return self.res
```

```py
class Solution(object):
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        ans = []
        path = []
        def backtrack(path, startIndex):
            if len(path) == 4:
                if startIndex == len(s):
                    ans.append(".".join(path[:]))
                    return
            for i in range(startIndex+1, min(startIndex+4, len(s)+1)):  # 剪枝
                string = s[startIndex:i]
                if not 0 <= int(string) <= 255:
                    continue
                if not string == "0" and not string.lstrip('0') == string:
                    continue
                path.append(string)
                backtrack(path, i)
                path.pop()

        backtrack([], 0)
        return ans
```

###  4.18. <a name='Inorderwihstack'></a>94-Inorder wih stack

[哈哈哈](https://www.bilibili.com/video/BV1uV411o78x?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1o54y1B7Z8?spm_id_from=333.999.0.0)



###  4.19. <a name='BinaryTreeInorderTraversal'></a>94-Binary Tree Inorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7g5?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1mV411Y7T1?spm_id_from=333.999.0.0)

```py

递归

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        res = []
        res.extend(self.inorderTraversal(root.left))
        res.append(root.val)
        res.extend(self.inorderTraversal(root.right))
        return res

2.迭代

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def add_all_left(node):
            while node:
                stack.append(node)
                node = node.left

        stack, res = [], []
        add_all_left(root)
        while stack:
            cur = stack.pop()
            res.append(cur.val)
            add_all_left(cur.right)
        return res

morris （将二叉树转化为链表，即每一个node都只可能有右孩子）

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        while root:
            if root.left:
                # find out predecessor
                predecessor = root.left
                while predecessor.right:
                    predecessor = predecessor.right
                # link predecessor to root
                predecessor.right = root
                # set left child of root to None
                temp = root
                root = root.left
                temp.left = None
            else:
                res.append(root.val)
                root = root.right
        return res
```

```py
# 中序遍历 先遍历左子树->根节点->右子树
# 如果是递归做法则递归遍历左子树，访问根节点，递归遍历右子树
# 非递归过程即:先访问..最左子树..结点，再访问其父节点，再访问其兄弟
# while循环条件 中序遍历需先判断当前结点是否存在，若存在则将该节点放入栈中，再将当前结点设置为结点的左孩子，
# 若不存在则取栈顶元素为cur，当且仅当栈空cur也为空，循环结束。
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]: 
        stack, ret = [], []
        cur = root
        while stack or cur:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                ret.append(cur.val)
                cur = cur.right
        return ret

递归，顺序为先往左找，然后添加改点的值，然后往右找

理解了递归的思想就很容易能做出来了，速度也很快

执行用时：24 ms, 在所有 Python3 提交中击败了97.27%的用户
内存消耗：14.8 MB, 在所有 Python3 提交中击败了92.29%的用户
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if root == None:
            return []
        self.ans = []
        self.findTheTree(root)
        return self.ans

    def findTheTree(self, treeNode):
        if treeNode.left != None:
            self.findTheTree(treeNode.left)
        self.ans.append(treeNode.val)
        if treeNode.right != None:
            self.findTheTree(treeNode.right)
```

```py
# 前序遍历-递归-LC144_二叉树的前序遍历
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # 保存结果
        result = []
        
        def traversal(root: TreeNode):
            if root == None:
                return
            result.append(root.val) # 前序
            traversal(root.left)    # 左
            traversal(root.right)   # 右

        traversal(root)
        return result

# 中序遍历-递归-LC94_二叉树的中序遍历
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            result.append(root.val) # 中序
            traversal(root.right)   # 右

        traversal(root)
        return result

# 后序遍历-递归-LC145_二叉树的后序遍历
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            traversal(root.right)   # 右
            result.append(root.val) # 后序

        traversal(root)
        return result
```

```scala
object Solution {
    def inorderTraversal(root: TreeNode): List[Int] = {
   
        val result = collection.mutable.ArrayBuffer[Int]()

        def FUN_traverse(node: TreeNode): Unit = {
            if (node != null) {
                // 1st: LEFT
                FUN_traverse(node.left)
                // 2nd: current node value
                result += node.value
                // 3rd: RIGHT 
                FUN_traverse(node.right)
            }
        }

        FUN_traverse(root)
        result.toList
    }
}
```

```py

```

###  4.20. <a name='UniqueBinarySearchTrees'></a>96. Unique Binary Search Trees

[小梦想家](https://www.bilibili.com/video/BV1xV411Y731?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1e5411W72t?spm_id_from=333.999.0.0)

```py
class Solution:
    def numTrees(self, n: int) -> int:
        d = [1] + [0] * n
        for i in range(1, n + 1): # 遍历根节点
            d[i] = sum(d[j] * d[i - 1 - j] for j in range(i)) # 枚举左子数大小，相应的右子树大小为 i - 1 - j
        return d[n]
```

```py
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [0] * (n+1)
        dp[0] = 1
        dp[1] = 1
        
        for i in range(2,n+1): # 遍历根节点
            print("i:",i)
            for j in range(1,i+1):
                print("j-1:",j-1,"i-j:",i-j)
                dp[i] += dp[j-1] * dp[i-j] # 枚举左子数大小，相应的右子树大小为 i - 1 - j
        return dp[-1]

class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0]*(1+n) 
        dp[0] = 1
        for t in range(1, 1+n): # 遍历根节点
            print("t:",t)
            for l in range(t): # 枚举左子数大小，相应的右子树大小为 t-1-l
                print("l:",l,"t-1-l:",t-1-l)
                dp[t] += dp[l] * dp[t-1-l]
        return dp[-1]

class Solution:
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        G = [0]*(n+1)
        G[0], G[1] = 1, 1

        for i in range(2, n+1):
            for j in range(1, i+1):
                G[i] += G[j-1] * G[i-j]

        return G[n]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        C = 1
        for i in range(0, n):
            C = C * 2*(2*i+1)/(i+2)
        return int(C)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  4.21. <a name='ValidateBinarySearchTree98-'></a>98. Validate Binary Search Tree 98-验证二叉搜索树

[花花酱](https://www.bilibili.com/video/BV12t411Y7TP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Wz4y1R7dF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Hv411478d?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Fi4y147Ng?spm_id_from=333.999.0.0)

```py
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def helper(node, lower = float('-inf'), upper = float('inf')) -> bool:
            if not node:
                return True
            
            val = node.val
            if val <= lower or val >= upper:
                return False

            if not helper(node.right, val, upper):
                return False
            if not helper(node.left, lower, val):
                return False
            return True

        return helper(root)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, inorder = [], float('-inf')
        
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            # 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if root.val <= inorder:
                return False
            inorder = root.val
            root = root.right

        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
解法一递归，更加pythonic的代码

class Solution:
    def isValidBST(self, root):
        
        def BFS(root, left, right):
            if root is None:
                return True
            
            if left < root.val < right:
                return BFS(root.left, left, root.val) and BFS(root.right, root.val, right)
            else:
                return False

        return BFS(root, -float('inf'), float('inf'))

岂不是可以直接：

class Solution:
    def isValidBST(self, root):
        def fun(node, lower, upper):
            if not node:
                return True
            return lower < node.val < upper and fun(node.left, lower, node.val) and fun(node.right, node.val, upper)

        return fun(root, float('-inf'), float('inf'))

每次往下传入下一个节点以及数据的下限L和上限H（随着不断往下遍历，该区间会越来越窄）

首先判断该点的值是否在区间内，然后看看左右节点是否非空，非空则继续往下走

对于左节点来说，下限不变，上限为当前节点的值

对于右节点来说，上限不变，下限为当前节点的值

执行用时：40 ms, 在所有 Python3 提交中击败了83.77%的用户
内存消耗：17.1 MB, 在所有 Python3 提交中击败了96.89%的用户

class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        self.isOK = True
        self.validate(root,  -(2 ** 31) - 1, 2 ** 31)
        return self.isOK

    def validate(self, t, L, H):  #t为结点，L为最低值，H为最高值
        if self.isOK:
            if t.val >= H or t.val <= L:
                self.isOK = False
            if t.left != None:
                self.validate(t.left, L, t.val)
            if t.right != None:
                self.validate(t.right, t.val, H)
```

###  4.22. <a name='SameTree'></a>100-Same Tree 

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7ti?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vf4y1R7Ue?spm_id_from=333.999.0.0)

```py
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        if not p or not q:
            return False
        
        queue1 = collections.deque([p])
        queue2 = collections.deque([q])

        while queue1 and queue2:
            node1 = queue1.popleft()
            node2 = queue2.popleft()
            if node1.val != node2.val:
                return False
            left1, right1 = node1.left, node1.right
            left2, right2 = node2.left, node2.right
            if (not left1) ^ (not left2):
                return False
            if (not right1) ^ (not right2):
                return False
            if left1:
                queue1.append(left1)
            if right1:
                queue1.append(right1)
            if left2:
                queue2.append(left2)
            if right2:
                queue2.append(right2)

        return not queue1 and not queue2

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py

class Solution:
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """
        if not p and not q:
            return True
        elif p is not None and q is not None:
            if p.val == q.val:
                return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
            else:
                return False
        else:
            return False

# 递归法
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q: return True
        elif not p or not q: return False
        elif p.val != q.val: return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
# 迭代法
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q: return True
        if not p or not q: return False
        que = collections.deque()
        que.append(p)
        que.append(q)
        while que:
            leftNode = que.popleft()
            rightNode = que.popleft()
            if not leftNode and not rightNode: continue 
            if not leftNode or not rightNode or leftNode.val != rightNode.val: return False 
            que.append(leftNode.left)
            que.append(rightNode.left)
            que.append(leftNode.right)
            que.append(rightNode.right)
        return True

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        return str(p)==str(q)
```

###  4.23. <a name='Symmetrictree'></a>101-Symmetric tree

[哈哈哈](https://www.bilibili.com/video/BV1VJ41197KD?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xv41167z8?spm_id_from=333.999.0.0)

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        '''非递归,从root开始,把比较顺序写下,然后考虑如何用队列或栈实现这个顺序'''
        if root is None:
            return True
        s=[root.left,root.right]
        while s:
            node1=s.pop()
            node2=s.pop()
            if node1 is None and node2 is None:
                pass
            elif (node1 and node2 is None) or (node2 and node1 is None):
                return False
            else:
                if node1.val !=node2.val:
                    return False
                s.append(node1.left)
                s.append(node2.right)
                s.append(node1.right)
                s.append(node2.left)
        return True

    def is_symmetric(self, left:TreeNode ,right:TreeNode)->bool:
        '''左树是否镜像于右树'''
        if left is None and right is None:
            return True
        
        if left is not None and right is not None and left.val ==right.val and \
            self.is_symmetric(left.left,right.right) and self.is_symmetric(left.right,right.left):
            return True
        
        return False

    def isSymmetric_1(self, root: TreeNode) -> bool:
        '''递归'''
        if root is None:
            return True
        return self.is_symmetric(root.left,root.right)
```

```py
Python 递归：

class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        def check(node1, node2):
            if not node1 and not node2:
                return True
            elif not node1 or not node2:
                return False
            
            if node1.val != node2.val:
                return False
            return check(node1.left, node2.right) and check(node1.right, node2.left)
        
        return check(root, root)
Python 迭代：其实就是层序遍历，然后检查每一层是不是回文数组

class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        queue = [root]
        
        while(queue):
            next_queue = list()
            layer = list()
            for node in queue:
                if not node:
                    layer.append(None)
                    continue
                next_queue.append(node.left)
                next_queue.append(node.right)
                
                layer.append(node.val)
                
            if layer != layer[::-1]:
                return False
            queue = next_queue
            
        return True

分别传入左右子节点，主要是递归的 base case 需要理清楚：

要么都为空，要么都不为空
如果两个节点的值不一样，返回 false
递归条件就是 node1 的左子节点和 node2 的右子节点比较，node1 的右子节点与 node2 的左子节点比较。

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        return self._isSymmetric(root.left, root.right)
    
    def _isSymmetric(self, node1, node2):
        if not node1 and not node2: # 如果两个节点都为空，返回真
            return True
        if not node1 or not node2:
            return False
        if node1.val != node2.val:
            return False
        return self._isSymmetric(node1.left, node2.right) and self._isSymmetric(node1.right, node2.left)
```

###  4.24. <a name='BinaryTreeLevelOrderTraversal'></a>102-Binary Tree Level Order Traversal

[哈哈哈](https://www.bilibili.com/video/BV1W54y197Lc?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14T4y1u7Wk?spm_id_from=333.999.0.0)

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        '''队列'''
        if root is None:
            return []
        q=[root]
        ret=[]
        while q:
            size=len(q)#当前层的个数!!!
            t=[]
            for _ in range(size):
                node=q.pop(0)
                t.append(node.val)

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            ret.append(t)
        return ret
```

```py
# 这个BFS模板真的是万能啊，除了本题，116、117等题也随便套。

class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        ans = []
        queue = [root] # 队列
        while queue:
            temp = []
            lenQ = len(queue) # 队列
            for i in range(lenQ):
                print("lenQ:",lenQ," i:",i)
                node = queue.pop(0) # 队列,lenQ有几次，就pop几次
                temp.append(node.val) 
                if node.left:
                    queue.append(node.left) # 队列
                if node.right:
                    queue.append(node.right) # 队列
            ans.append(temp)
        return ans

class Solution:
    def levelOrder(self, root: TreeNode):
        from collections import deque
        queue = deque() # 队列
        result = []
        if not root:
            return []
        queue.append(root) # 队列
        while queue: # 队列
            current_level_size = len(queue) # 队列
            current_level = [] # level【】
            for _ in range(current_level_size): # 队列,lenQ有几次，就pop几次
                node = queue.popleft() # 队列,lenQ有几次，就pop几次
                current_level.append(node.val) # level【】
                if node.left:
                    queue.append(node.left) # 队列
                if node.right:
                    queue.append(node.right) # 队列
            result.append(current_level) # level【】
        return result
```

```py
# py两分钟打完一次提交bug free，go因为尝试了下hash的无序性wa了一次，狗rust编译了10次以上才过，费老jb劲了

# py 用字典存层（py字典是有序的，所以最好用，其他语言都不好写）。
import collections
class Solution:
    def levelOrder(self, root):
        dic = collections.defaultdict(list)
        # --------------------- recurHelper ---------------------
        def recurHelper(node, level):
            if node:
                dic[level].append(node.val)
                recurHelper(node.left, level + 1)
                recurHelper(node.right, level + 1)
        recurHelper(root, 0) # 传入 (root, 0)
        # --------------------- recurHelper ---------------------
        
        return [*dic.values()]

# 递归

# ```python
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        res = []
        self.recurHelper(root, 0, res)
        return res
    
    def recurHelper(self, node, level, res):
        if not node: return
        if len(res) < level + 1:
            res.append([])
        res[level].append(node.val)
        self.recurHelper(node.left, level+1, res)
        self.recurHelper(node.right, level+1, res)
```

###  4.25. <a name='BinaryTreeZigzagLevelOrderTraversal'></a>103. Binary Tree Zigzag Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1NE411M7Fm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15h411Z7h5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GA411W7NY?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root: return []

        que = []
        res = []
        que.append(root)
        index = 1 # flag
        while que:
            temp = []
            for _ in range(len(que)):
                cur = que.pop(0)
                temp.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            index += 1 # flag
            if not index % 2: # flag
                res.append(temp[:])
            else:
                res.append(temp[::-1])
        return res

# python 双端duque
from collections import deque
class Solution:
    def zigzagLevelOrder(self, root):
        q = deque([root])
        res = []
        flag = True # flag
        while q and q[0]:
            n = len(q)
            temp = []
            for i in range(n):
                node = q.popleft()
                temp.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if flag: # flag
                res.append(temp)
            else:
                res.append(temp[::-1])  # [::-1]反转
            flag = bool(1-flag) # flag
        return res
```

```py
# 先层次遍历，再对相应层数进行翻转。 python 执行用时，在所有python3提交中击败了96.87%的用户。

class Solution:
    def zigzagLevelOrder(self, root):
        stack = []
        def dfs(node, level, res):
            if not node:
                return
            if level >= len(res):
                res.append([])
            res[level].append(node.val)
            dfs(node.left, level + 1, res)
            dfs(node.right, level + 1, res)

        dfs(root, 0, stack)
        for i in range(1, len(stack), 2): # flag，各两个逆序
            stack[i] = stack[i][::-1]
        return stack

# 递归

class Solution:
    def zigzagLevelOrder(self, root):
        res = []
        if not root:
            return []
        
        def dfs(node, level):
            if len(res) == level:
                res.append([])
            
            if level % 2:
                res[level].insert(0, node.val)
            else:
                res[level].append(node.val)

            if node.left:
                dfs(node.left, level+1)
            if node.right:
                dfs(node.right, level+1)
            
        dfs(root, 0)
        return res
```

###  4.26. <a name='MaximumDepthofBinary'></a>104-Maximum Depth of Binary

[哈哈哈](https://www.bilibili.com/video/BV1AJ411Q7xG?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1u54y1D7Nx?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tK41137GM?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        '''树的最大深度,递归。层次遍历也行'''
        if root is None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

```py

```

###  4.27. <a name='-1'></a>105-从前序与中序遍历序列构

[哈哈哈](https://www.bilibili.com/video/BV1uv411B73D?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1x54y1d7e8?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1ry4y1U7ZR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14A411q7Nv?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        '''可以考虑传递下标，减少数组拷贝的时间'''
        if len(preorder)==0:
            return None
        root_val=preorder[0]
        i=inorder.index(root_val)
        left_inorder=inorder[:i]
        right_inorder=inorder[i+1:]
        left_preorder=preorder[1:1+i]
        right_preorder=preorder[1+i:]

        return TreeNode(root_val,self.buildTree(left_preorder,left_inorder),self.buildTree(right_preorder,right_inorder))
```

```py
class Solution:
    def buildTree(self, preorder, inorder):
        if not preorder:return None

        x = preorder.pop(0) #前序第一个为root
        root = TreeNode(x)
        i = inorder.index(x) #中序遍历 root 的index

        root.left = self.buildTree(preorder[:i], inorder[:i])
        root.right = self.buildTree(preorder[i:], inorder[i+1:])
        return root

class Solution:
    def buildTree(self, preorder, inorder):
        if inorder:
            t = TreeNode(preorder.pop(0))
            i = inorder.index(t.val)
            t.left = self.buildTree(preorder, inorder[: i])
            t.right = self.buildTree(preorder, inorder[i + 1:])
            return t

# 递归构造，非常简洁！
# 改变了参数 preorder
# 方法一样，但是没用index ，大佬提醒了这个用法，
# 效率低是因为index函数复杂度是O（n），但是实际可以用哈希表将这个过程优化成O（1）
class Solution(object):
    def buildTree(self, preorder, inorder):
        if not preorder: 
            return None
        
        x = preorder.pop(0)
        node = TreeNode(x)
        i = inorder.index(x)
        
        node.left = self.buildTree(preorder[:i], inorder[:i])
        node.right = self.buildTree(preorder[i:], inorder[i+1:])
        return node
```

###  4.28. <a name='-1'></a>106-从中序与后序遍历序列构造二叉树

[哈哈哈](https://www.bilibili.com/video/BV1r5411W7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jh411Z7y8?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        '''传递下标'''
        index={}#元素在中序的下标
        for i in range(len(inorder)):
            index[inorder[i]]=i

        def build(inorder: List[int], postorder: List[int],i_l,i_r,p_l,p_r) -> TreeNode:
            if i_l>i_r:
                return None
            root_val=postorder[p_r]
            i=index[root_val]

            return TreeNode(root_val,build(inorder,postorder,i_l,i-1,p_l,p_l+(i-i_l-1)),\
                    build(inorder,postorder,i+1,i_r,p_l+(i-i_l),p_r-1))
        return build(inorder,postorder,0,len(inorder)-1,0,len(postorder)-1)

    def buildTree_1(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if len(postorder)==0:
            return None
        root_val=postorder[-1]
        i=inorder.index(root_val)

        left_inorder=inorder[:i]
        right_inorder=inorder[i+1:]
        left_postorder=postorder[:i]
        right_postorder=postorder[i:len(postorder)-1]#左闭右开!!
        return TreeNode(root_val,self.buildTree(left_inorder,left_postorder),self.buildTree(right_inorder,right_postorder))
```

```py
# 递归构造，非常简洁！90%

class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        
        if not inorder:
            return None
        
        x = postorder.pop()
        i = inorder.index(x)
        
        node = TreeNode(x)
        node.left = self.buildTree(inorder[:i], postorder[:i])
        node.right = self.buildTree(inorder[i+1:], postorder[i:])
        return node

class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        if not postorder:
            return None
        root = TreeNode(postorder[-1])#创建树
        n = inorder.index(root.val)
        root.left = self.buildTree(inorder[:n],postorder[:n])
        root.right = self.buildTree(inorder[n+1:],postorder[n:-1])
        return root

class Solution(object):
    def buildTree(self, inorder, postorder):
        if postorder == inorder == []:
            return None
        else:
            rootVal = postorder[-1]
            root = TreeNode(rootVal)
            print("rootVal:",rootVal)
            print("inorder:",inorder)
            k = inorder.index(rootVal)
            root.left = self.buildTree(inorder[:k],postorder[:k])
            root.right = self.buildTree(inorder[k+1:],postorder[k:-1])
            return root  
```

###  4.29. <a name='BinaryTreeLevelOrderTraversalII'></a>107-Binary Tree Level Order Traversal II

[哈哈哈](https://www.bilibili.com/video/BV1eJ411z7d6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1yK411n76R?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qA411i7P4?spm_id_from=333.999.0.0)


```py
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        '''层次遍历的逆序'''
        if root is None:
            return []
        q=[root]
        ret=[]
        while q:
            size=len(q)# 当前层节点的个数
            t=[]
            for _ in range(size):
                node=q.pop(0)
                t.append(node.val)

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            ret.append(t)
        return ret[::-1]
```

```py

```
###  4.30. <a name='ConvertSortedArraytoBinarySearchTree'></a>108 Convert Sorted Array to Binary Search Tree 

[花花酱](https://www.bilibili.com/video/BV1F7411H7tH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1JJ411q74U?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wa411c7tS?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left > right:
                return None

            # 总是选择中间位置左边的数字作为根节点
            mid = (left + right) // 2

            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(nums) - 1)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left > right:
                return None

            # 总是选择中间位置右边的数字作为根节点
            mid = (left + right + 1) // 2

            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(nums) - 1)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left > right:
                return None

            # 选择任意一个中间位置数字作为根节点
            mid = (left + right + randint(0, 1)) // 2

            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(nums) - 1)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
递归法：

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def buildaTree(left,right):
            if left > right: return None  #左闭右闭的区间，当区间 left > right的时候，就是空节点,当left = right的时候，不为空
            mid = left + (right - left) // 2 #保证数据不会越界
            val = nums[mid]
            root = TreeNode(val)
            root.left = buildaTree(left,mid - 1)
            root.right = buildaTree(mid + 1,right)
            return root
        root = buildaTree(0,len(nums) - 1)  #左闭右闭区间
        return root

简单递归就行

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid+1:])
        return root
```

### 109题. 有序链表转换二叉搜索树

https://www.bilibili.com/video/BV19a4y157U8?spm_id_from=333.999.0.0

https://www.bilibili.com/video/BV1ff4y197dS?spm_id_from=333.999.0.0

```py
class Solution:
    def sortedListToBST(self, head) -> TreeNode:
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)
            
        fast = slow = pre = head # pre切断
        while fast and fast.next:
            pre = slow # pre切断
            slow = slow.next
            fast = fast.next.next
        node = TreeNode(slow.val)
        # print(head.val,node.val,last.val)
        node.right = self.sortedListToBST(slow.next) # 从mid+1到tail
        pre.next = None # pre切断
        node.left = self.sortedListToBST(head) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        return node

class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        ###找到中间节点 断开   去掉中间节点
        ### 左子树等于递归 左边那段   右子树等于递归右边那段
        fast = head
        slow = head
        pre =  head
        if not head:
            return 
        while(fast and fast.next):
            fast = fast.next.next
            pre = slow
            slow  = slow.next
        root = TreeNode(slow.val)
        if slow==fast:
            return root 
        pre.next = None
        root.left = self.sortedListToBST(head) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        root.right = self.sortedListToBST(slow.next) # 从mid+1到tail
        return root
```

https://www.bilibili.com/video/BV19K411T73P?p=2&spm_id_from=pageDriver

```py
# py3 递归+快慢指针法。
# 不用断开链表，分别用head和tail定义链首和链尾，
# 链表区间为左闭右开，即 [ head , tail ）。

class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        return self.helper(head,None)

    def helper(self,head,tail):
        if head==tail:
            return
        slow=head
        fast=head
        while fast!=tail and fast.next!=tail:
            slow=slow.next
            fast=fast.next.next
        root=TreeNode(slow.val)
        root.left=self.helper(head,slow) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        root.right=self.helper(slow.next,tail) # 从mid+1到tail
        return root

class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getMedian(head: ListNode, tail: ListNode) -> ListNode:
            fast = slow = head
            while fast != tail and fast.next != tail:
                fast = fast.next.next
                slow = slow.next
            return slow
        
        def buildTree(left: ListNode, right: ListNode) -> TreeNode:
            if left == right:
                return None
            mid = getMedian(left, right)
            root = TreeNode(mid.val)
            root.left = buildTree(left, mid) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
            root.right = buildTree(mid.next, right) # 从mid+1到tail
            return root
        
        return buildTree(head, None)
```

```py

```

```py

```

###  4.31. <a name='BalancedBinaryTree'></a>110-Balanced Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1NJ411v7b1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Lb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sV411b7hR?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            return max(height(root.left), height(root.right)) + 1

        if not root:
            return True
        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            leftHeight = height(root.left)
            rightHeight = height(root.right)
            if leftHeight == -1 or rightHeight == -1 or abs(leftHeight - rightHeight) > 1:
                return -1
            else:
                return max(leftHeight, rightHeight) + 1

        return height(root) >= 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/balanced-binary-tree/solution/ping-heng-er-cha-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

沙发。直接在递归高度的过程中判断每个节点是否平衡不就好了。时间和空间复杂度都是O(n)。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def helper(node):
            if not node:  return 0
            left_depth = helper(node.left)
            right_depth = helper(node.right)
            if abs(left_depth - right_depth) > 1:
                flag[0] = False
            return max(left_depth, right_depth) + 1
        flag = [True]
        helper(root)
        return flag[0]

其实就是二叉树先序遍历和后序遍历的区别，每种遍历方式都有它的用武之地。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        ans = True
        
        def post_order(root):
            nonlocal ans
            if not root or not ans:
                return 0
            l = post_order(root.left)
            r = post_order(root.right)
            if abs(l-r) > 1:
                ans = False
            return max(l, r) + 1
        
        post_order(root)
        return ans
```

```py

```

###  4.32. <a name='MinimumDepthofBinaryTree'></a>111-Minimum Depth of Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1E7411k7KY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1XZ4y1G7xM?spm_id_from=333.999.0.0)

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        if root.left is not None and root.right is None:#较高一层的值
            return 1+self.minDepth(root.left)
        if root.right is not None and root.left is None:
            return 1+self.minDepth(root.right)
        return 1+min(self.minDepth(root.left),self.minDepth(root.right))

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        """
        :type root: TreeNode
        :rtype: int
        """
        if root:
            if root.left and root.right:
                return 1+min(self.minDepth(root.left),self.minDepth(root.right))
            elif root.left:
                return 1+self.minDepth(root.left)
            elif root.right:
                return 1+self.minDepth(root.right)
            else:
                return 1
        else:
            return 0
递归
```

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        if not root.left and not root.right:
            return 1
        
        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth)
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth)
        
        return min_depth + 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        que = collections.deque([(root, 1)])
        while que:
            node, depth = que.popleft()
            if not node.left and not node.right:
                return depth
            if node.left:
                que.append((node.left, depth + 1))
            if node.right:
                que.append((node.right, depth + 1))
        
        return 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  4.33. <a name='PathSum'></a>112-Path Sum

[哈哈哈](https://www.bilibili.com/video/BV1T7411r7Yr?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1pb411e7r7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1uK411T7kX?spm_id_from=333.999.0.0)

```py
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        '''递归'''
        if root is None:
            return False
        if root.val==targetSum:
            return True
        return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
```

```py
典型的得用DFS做的题目，不断深入每个节点，只要找到一个即可

dfs函数包括当前节点和当前路径总和

如果当前节点为叶子节点，并且路径总和等于目标值，就改变ans为True

否则就继续深入当前节点的左右节点

class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root == None:
            return False
        self.target = targetSum
        self.ans = False
        self.dfs(root, 0)
        return self.ans

    def dfs(self, r, sumNum):
        if not r.left and not r.right:
            if sumNum + r.val == self.target:
                self.ans = True
        else:
            if r.left:
                self.dfs(r.left,  sumNum + r.val)
            if r.right:
                self.dfs(r.right, sumNum + r.val)

class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que_node = collections.deque([root])
        que_val = collections.deque([root.val])
        while que_node:
            now = que_node.popleft()
            temp = que_val.popleft()
            if not now.left and not now.right:
                if temp == sum:
                    return True
                continue
            if now.left:
                que_node.append(now.left)
                que_val.append(now.left.val + temp)
            if now.right:
                que_node.append(now.right)
                que_val.append(now.right.val + temp)
        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right:
            return sum == root.val
        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  4.34. <a name='-1'></a>113. 二叉树中和为某一值的路径

[哈哈哈](https://www.bilibili.com/video/BV1P54y1i73U?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1k54y177fu?spm_id_from=333.999.0.0)

```py
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        '''dfs+路径记录'''
        path=[]
        ret=[]
        def dfs(root,targetSum):
            if root is None:
                return
            
            path.append(root.val)
            if root.val==targetSum and root.left is None and root.right is None:
                ret.append(path.copy())#!!!!拷贝

            dfs(root.left,targetSum-root.val)
            dfs(root.right,targetSum-root.val)
            path.pop()
        dfs(root,targetSum)
        return ret
```

```py
class Solution:
    def pathSum(self, root: TreeNode, sum: int):
        res = []
        def dfs(root, tmp, sum):
            nonlocal res
            if not root:
                return 
            
            sum -= root.val # 对于每一个node，当前node的sum = 总和sum - root的值
            if not root.left and not root.right and sum == 0: # 结束条件
                res.append(tmp + [root.val])
            dfs(root.left, tmp + [root.val], sum)
            dfs(root.right, tmp + [root.val], sum)
            return res
        
        dfs(root, [], sum)
        return res

class Solution:
    def pathSum(self, root, targetSum: int):
        res = list()
        path = list()
        
        def dfs(node, sum):
            if not node:
                return
            path.append(node.val)
            sum -= node.val # 对于每一个node，当前node的sum = 总和sum - root的值
            if not node.left and not node.right and sum == 0: # 结束条件
                res.append(path[:])
            dfs(node.left, sum)
            dfs(node.right, sum)
            path.pop()
        
        dfs(root, targetSum)
        return res
```

```py
# 注意宁愿写几次curList + [root.val] 也不要直接传一个list进去，因为list pass by reference的亏已经吃过了

# ```python
class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        res = []
        self.auxPathSum(root, sum, [], res)
        return res
    def auxPathSum(self, root, sum, path, res):
        if not root:
            return
        sum -= root.val # 对于每一个node，当前node的sum = 总和sum - root的值
        if sum == 0 and not root.left and not root.right:
            res.append(path + [root.val])
            return 
        if root.left:
            self.auxPathSum(root.left, sum, path + [root.val], res) 
        if root.right:
            self.auxPathSum(root.right, sum, path + [root.val], res)
```

### 114题. 二叉树展开为链表

https://www.bilibili.com/video/BV1T7411A7S8?from=search&seid=15731266160913668837&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6tma3pncods0.png" width="80%">

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5csg54lu3lw0.png" width="50%">

```py
class Solution:
    def flatten(self, root: TreeNode) -> None:
        if not root:
            return
        
        stack = [root]
        prev = None
        
        while stack:
            curr = stack.pop()
            if prev:
                prev.left = None
                prev.right = curr
            left, right = curr.left, curr.right
            if right:
                stack.append(right)
            if left:
                stack.append(left)
            prev = curr

        return root

class Solution:
    def flatten(self, root: TreeNode) -> None:
        preorderList = list()
        stack = list()
        node = root

        while node or stack:
            while node:
                preorderList.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        
        size = len(preorderList)
        for i in range(1, size):
            prev, curr = preorderList[i - 1], preorderList[i]
            prev.left = None
            prev.right = curr
```

```py
class Solution(object):
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: void Do not return anything, modify root in-place instead.
        """
        if not root:
            return
        #把子树备份一下
        left_node = root.left
        right_node = root.right
        root.left = None #记得把左子树置空
        #先把左右子树捋直
        self.flatten(left_node)
        self.flatten(right_node)
        if left_node:
            root.right = left_node #把捋直的左子树放到右边
            while left_node.right: #找到现在右子树的最后一个node
                left_node = left_node.right 
            left_node.right = right_node #左子树接上右子树



        return root
```

###  4.35. <a name='DistinctSubsequences'></a>115. Distinct Subsequences

[花花酱](https://www.bilibili.com/video/BV1EW411d7PC?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV185411G7F6?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        if m < n:
            return 0
        
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][n] = 1
        
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if s[i] == t[j]:
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]
                else:
                    dp[i][j] = dp[i + 1][j]
        
        return dp[0][0]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/distinct-subsequences/solution/bu-tong-de-zi-xu-lie-by-leetcode-solutio-urw3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]
        for i in range(len(s)):
            dp[i][0] = 1
        for j in range(1, len(t)):
            dp[0][j] = 0
        for i in range(1, len(s)+1):
            for j in range(1, len(t)+1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
Python3:

class SolutionDP2:
    """
    既然dp[i]只用到dp[i - 1]的状态，
    我们可以通过缓存dp[i - 1]的状态来对dp进行压缩，
    减少空间复杂度。
    （原理等同同于滚动数组）
    """
    
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(s), len(t)
        if n1 < n2:
            return 0

        dp = [0 for _ in range(n2 + 1)]
        dp[0] = 1

        for i in range(1, n1 + 1):
            # 必须深拷贝
            # 不然prev[i]和dp[i]是同一个地址的引用
            prev = dp.copy()
            # 剪枝，保证s的长度大于等于t
            # 因为对于任意i，i > n1, dp[i] = 0
            # 没必要跟新状态。 
            end = i if i < n2 else n2
            for j in range(1, end + 1):
                if s[i - 1] == t[j - 1]:
                    dp[j] = prev[j - 1] + prev[j]
                else:
                    dp[j] = prev[j]
        return dp[-1]
```

###  4.36. <a name='PopulatingNextRightPointersinEachNode'></a>116. Populating Next Right Pointers in Each Node

[花花酱](https://www.bilibili.com/video/BV1b4411R7G4?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1zQ4y1M75t?spm_id_from=333.999.0.0)

```py
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if root is None:
            return None
        
        q=[root]
        while q:
            size=len(q)
            last=None
            for _ in range(size):
                node=q.pop(0)
                if last:
                    last.next=node
                last=node

                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
        
        return root
```

```py
# BFS版本

class Solution:
    # 层次遍历
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        q = deque([root])
        while q:
            sz = len(q)
            for i in range(sz):
                cur = q.popleft()
                if i < sz - 1:
                    cur.next = q[0]
                if cur.left:
                    q.append(cur.left)
                if cur.right:
                    q.append(cur.right)
            
        return root

# DFS版本，只要关注两棵子树的next指针构建即可

class Solution:
    # DFS
    def connect(self, root: 'Node') -> 'Node':
        if not root: return
        def dfs(root1, root2):
            if not (root1 and root2): return 
            root1.next = root2
            dfs(root1.left, root1.right)
            dfs(root1.right, root2.left)
            dfs(root2.left, root2.right)
        
        dfs(root.left, root.right)
        return root

# Python递归，先序遍历，感觉很容易理解，速度还可以，只是空间复杂度用了递归所以差了点

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        def f(root):
            if root:
                p,q=root.left,root.right
                while p:
                    p.next=q
                    p,q=p.right,q.left
                f(root.left)
                f(root.right)
            return
        f(root)
        return root
```

###  4.37. <a name='PopulatingNextRightPointersinEa'></a>117 Populating Next Right Pointers in Ea

[小明](https://www.bilibili.com/video/BV1np4y1r7fQ?spm_id_from=333.999.0.0)


###  4.38. <a name='PascalsTriangle'></a>118-Pascal's Triangle

[哈哈哈](https://www.bilibili.com/video/BV1T741167KS?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7tJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1D54y147NY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        ret = list()
        for i in range(numRows):
            row = list()
            for j in range(0, i + 1):
                if j == 0 or j == i:
                    row.append(1)
                else:
                    row.append(ret[i - 1][j] + ret[i - 1][j - 1])
            ret.append(row)
        return ret

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/pascals-triangle/solution/yang-hui-san-jiao-by-leetcode-solution-lew9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

库函数重拳出击！

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        return [[comb(i, j) for j in range(i + 1)] for i in range(numRows)]
```

```py
class Solution:
    def generate(self, numRows):
        """
        :type numRows: int
        :rtype: List[List[int]]
        """
        result = []
        for i in range(numRows):
            now = [1]*(i+1)
            if i >= 2:
                for n in range(1,i):
                    now[n] = pre[n-1]+pre[n]
            result += [now]
            pre = now
        return result

头尾为1，中间的第j个为上一层的第j-1个和j个的和，即：

第i行lst[j] = ans[i-1][j-1] + ans[i-1][j]

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        ans = [[1]]
        for i in range(1, numRows):
            lst = [0 for _ in range(i+1)]
            lst[0], lst[-1] = 1, 1
            for j in range(1,i):  
                lst[j] = ans[i-1][j-1] + ans[i-1][j]
            ans.append(lst)
        return ans

计算好上一层的，用上一层的计算下一层

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        ans = []
        # 遍历每一层
        for i in range(1,numRows+1):
            tmp_lis = []
            # 遍历一层中的每一个元素
            for j in range(i):
                if j == 0 or j == i-1:
                    tmp_lis.append(1)
                else:
                    tmp_lis.append(ans[i-2][j-1] + ans[i-2][j])
            ans.append(tmp_lis)
        return ans
```

###  4.39. <a name='PascalsTriangleII'></a>119-Pascal's Triangle II

[哈哈哈](https://www.bilibili.com/video/BV187411B7Hj?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7hA?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ni4y1g7Lv?spm_id_from=333.999.0.0)

```py
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        r = [1]
        for i in range(rowIndex):
            r.append(0)
            j = i + 1
            while j > 0:
                r[j] = r[j] + r[j - 1]
                j -= 1
        return r
```

```py
# 方法 1：生成一半，另一半对称生成的一半
class Solution1:
    def generate(self, rowIndex):
        cur = []
        for i in range(rowIndex + 1):
            # 每行首个元素为 1
            temp = [1]
            # 由上一行生成当前行前一半的元素
            for j in range(i // 2):
                temp += [pre[j] + pre[j + 1]]
            # 对称生成另一半后合并，并组成新杨辉三角
            cur = temp + temp[::-1][(i + 1) % 2:]
            pre = cur
        return cur


# 方法 2：直接循环计算生成
class Solution2:
    def generate(self, rowIndex):
        cur = [1]
        for i in range(1, rowIndex + 1):
            # 每行首个元素为 1
            temp = [1]
            # 由上一行循环生成当前行元素（除两端）
            for j in range(1, i):
                temp += [pre[j - 1] + pre[j]]
            # 添加最后一个元素 1，并组成新杨辉三角
            cur = temp + [1]
            pre = cur
        return cur


# 方法 3：先直接生成所需空间（用 1 填充），再循环计算更新生成
class Solution3:
    def generate(self, rowIndex):
        for i in range(rowIndex + 1):
            # 用 1 先填充每行所有元素
            cur = [1] * (i + 1)
            # 由上一行循环生成当前行元素（除两端）
            for j in range(1, i):
                cur[j] = pre[j - 1] + pre[j]
            pre = cur
        return cur


# 方法 4：使用公式
# 组合公式C(n,i) = n!/(i!*(n-i)!)
# 则第(i+1)项是第i项的倍数=(n-i)/(i+1)
class Solution4:
    def generate(self, rowIndex):
        temp = 1
        res = []
        for i in range(rowIndex + 1):
            res.append(temp)
            temp = temp * (rowIndex - i) // (i + 1)
        return res


# 方法 5：使用公式生成一半
class Solution5:
    def generate(self, rowIndex):
        temp = 1
        res = []
        # 生成前半部分
        for i in range((rowIndex) // 2 + 1):
            res.append(temp)
            temp = temp * (rowIndex - i) // (i + 1)
        # 前半部分与其镜像对称的后半部分合并
        return res + res[::-1][(rowIndex + 1) % 2:]


# 方法 6：当前行等于上一行前后添零累加：[1,4,6,4,1] = [0,1,3,3,1] + [1,3,3,1,0]
class Solution6:
    def generate(self, rowIndex):
        res = [1]
        for i in range(rowIndex + 1):
            # temp1, temp2 = [0] + res, res + [0]
            # res = [temp1[j] + temp2[j] for j in range(i + 1)]
            res = [([0] + res)[j] + (res + [0])[j] for j in range(i + 1)]
        return res

大伙儿新年好啊

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        return [*accumulate(range(rowIndex), lambda x,i: x*(rowIndex-i)//(i+1), initial=1)]
```

###  4.40. <a name='Triangle'></a>120 Triangle

[小明](https://www.bilibili.com/video/BV1m54y1L7Af?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumTotal(self, triangle):
        n = len(triangle)
        f = [[0] * n for _ in range(n)]
        f[0][0] = triangle[0][0]

        for i in range(1, n):
            f[i][0] = f[i - 1][0] + triangle[i][0]
            for j in range(1, i):
                f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        
        return min(f[n - 1])
```

```py
class Solution:
    def minimumTotal(self, triangle):
        n = len(triangle)
        f = [0] * n
        f[0] = triangle[0][0]

        for i in range(1, n):
            f[i] = f[i - 1] + triangle[i][i]
            for j in range(i - 1, 0, -1):
                f[j] = min(f[j - 1], f[j]) + triangle[i][j]
            f[0] += triangle[i][0]
        
        return min(f)
```

###  4.41. <a name='BestTimetoBuyandSellStock121-'></a>121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机

[花花酱](https://www.bilibili.com/video/BV1oW411C7UB?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1cZ4y1K7HP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1D7411s7A1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7by?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16z4y1Z7jD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1hA411t76C?spm_id_from=333.999.0.0)

###  4.42. <a name='II122-BestTimetoBuyandSellStockII'></a>122-买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II

[哈哈哈](https://www.bilibili.com/video/BV12K411A7rL?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d7411x78d?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7iq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Fk4y1R7ve?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y1L7LG?spm_id_from=333.999.0.0)

###  4.43. <a name='III'></a>123-买卖股票的最佳时机 III

[哈哈哈](https://www.bilibili.com/video/BV1Xp4y1k7aD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rk4y117z8?spm_id_from=333.999.0.0)

###  4.44. <a name='BinaryTreeMaximumPathSum'></a>124. Binary Tree Maximum Path Sum

[花花酱](https://www.bilibili.com/video/BV1ct411r7qw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CT4y1g7bR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qT4y1J71C?spm_id_from=333.999.0.0)

###  4.45. <a name='ValidPalindrome'></a>125-Valid Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1d7411n7cF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7ML?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17h411Z7ey?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

###  4.46. <a name='WordLadderII'></a>126. Word Ladder II

[花花酱](https://www.bilibili.com/video/BV1yt411Y7gH?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV16K4y1j7hX?spm_id_from=333.999.0.0)

###  4.47. <a name='WordLadder'></a>127. Word Ladder

[花花酱](https://www.bilibili.com/video/BV1yt411Y7Me?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1BK4y157k1?spm_id_from=333.999.0.0)

###  4.48. <a name='LongestConsecutiveSequence'></a>128. Longest Consecutive Sequence

[花花酱](https://www.bilibili.com/video/BV14t411Y7cg?spm_id_from=333.999.0.0)

###  4.49. <a name='SumRoottoLeafNumbers'></a>129 Sum Root to Leaf Numbers

[小明](https://www.bilibili.com/video/BV1VK411H7o5?spm_id_from=333.999.0.0)

###  4.50. <a name='SurroundedRegions130-'></a>130. Surrounded Regions 130-被围绕的区域

[花花酱](https://www.bilibili.com/video/BV1dE411f7U4?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV18y4y1j7JH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411k7TH?spm_id_from=333.999.0.0)

###  4.51. <a name='-1'></a>131-分割回文串

[哈哈哈](https://www.bilibili.com/video/BV1dK411p7eU?spm_id_from=333.999.0.0)

###  4.52. <a name='PalindromePartitioningII'></a>132. Palindrome Partitioning II

[花花酱](https://www.bilibili.com/video/BV1NJ411v7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1944y1C71s?spm_id_from=333.999.0.0)

###  4.53. <a name='CloneGraph'></a>133. Clone Graph

[小梦想家](https://www.bilibili.com/video/BV1wA411T7SM?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV18i4y1c7FE?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12K411A7Zb?spm_id_from=333.999.0.0)

###  4.54. <a name='GasStation'></a>134. Gas Station

[小梦想家](https://www.bilibili.com/video/BV1BC4y1472f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1754y1176F?spm_id_from=333.999.0.0)

###  4.55. <a name='CopyListwithRandomPointer'></a>138 Copy List with Random Pointer

[小明](https://www.bilibili.com/video/BV1BN411R7a8?spm_id_from=333.999.0.0)

###  4.56. <a name='SingleNumber'></a>136-Single Number

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7bf?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Sp4y1D7M3?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7PU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pa4y1t7tr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.distinct.filter(x => nums.filter(_ == x).length != 2)(0)
    }
}
```

###  4.57. <a name='SingleNumberII'></a>137 Single Number II

[小明](https://www.bilibili.com/video/BV1Hv411B7rd?spm_id_from=333.999.0.0)

###  4.58. <a name='WordBreak'></a>139 Word Break

[小明](https://www.bilibili.com/video/BV1p54y1k7vf?spm_id_from=333.999.0.0)

###  4.59. <a name='WordBreakII'></a>140 Word Break II

[小明](https://www.bilibili.com/video/BV1ht4y1X7DJ?spm_id_from=333.999.0.0)

###  4.60. <a name='LinkedListCycle'></a>141-Linked List Cycle

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7ta?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411H7XP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1KX4y157vh?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1PA411b7gq?spm_id_from=333.999.0.0)

###  4.61. <a name='LinkedListCycleII'></a>142 Linked List Cycle II

[小明](https://www.bilibili.com/video/BV1W5411L7AF?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV15e41147EY?spm_id_from=333.999.0.0)

###  4.62. <a name='ReorderList'></a>143 Reorder List

[小明](https://www.bilibili.com/video/BV1Jf4y1Q7y7?spm_id_from=333.999.0.0)

###  4.63. <a name='Preorderwithstack'></a>144-Preorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1HT4y1G74i?spm_id_from=333.999.0.0)

###  4.64. <a name='BinaryTreePreorderTraversal'></a>144-Binary Tree Preorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7NZ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Ch411Q74P?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1RD4y1D7C7?spm_id_from=333.999.0.0)

###  4.65. <a name='Postorderwithstack'></a>145-Postorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1Ti4y187jL?spm_id_from=333.999.0.0)

###  4.66. <a name='BinaryTreePostorderTraversal'></a>145-Binary Tree Postorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7ub?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1uv411h7Gc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1xZ4y1H7uS?spm_id_from=333.999.0.0)

###  4.67. <a name='LRUCache'></a>146 LRU Cache 

[花花酱](https://www.bilibili.com/video/BV19b411c7ue?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7c6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1t7zj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ZQ4y1A74H?spm_id_from=333.999.0.0)

###  4.68. <a name='InsertionSortList'></a>147 Insertion Sort List

[小明](https://www.bilibili.com/video/BV1F54y1k7oU?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Ti4y187pN?spm_id_from=333.999.0.0)

###  4.69. <a name='SortList'></a>148. Sort List

[花花酱](https://www.bilibili.com/video/BV1jW411d7z7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK411A7Gm?spm_id_from=333.999.0.0)

###  4.70. <a name='MaxPointsonaLine'></a>149. Max Points on a Line

[花花酱](https://www.bilibili.com/video/BV1zb411u7WW?spm_id_from=333.999.0.0)

###  4.71. <a name='EvaluateReversePolishNotation'></a>150. Evaluate Reverse Polish Notation

[花花酱](https://www.bilibili.com/video/BV14f4y127K8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16B4y1P7Nx?spm_id_from=333.999.0.0)

###  4.72. <a name='ReverseWordsinaString'></a>151. Reverse Words in a String

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7g4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rT4y1g7AJ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ei4y1V7yA?spm_id_from=333.999.0.0)

###  4.73. <a name='-1'></a>152-乘积最大子数组

[哈哈哈](https://www.bilibili.com/video/BV12a4y1i76G?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iK411K7yG?spm_id_from=333.999.0.0)

###  4.74. <a name='-1'></a>153-寻找旋转排序数组中的最小值

[哈哈哈](https://www.bilibili.com/video/BV1bT4y1w7yK?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1yK411L7rp?spm_id_from=333.999.0.0)

###  4.75. <a name='FindMinimuminRotatedSortedArr'></a>154 Find Minimum in Rotated Sorted Arr

[小明](https://www.bilibili.com/video/BV1ik4y1B7de?spm_id_from=333.999.0.0)

###  4.76. <a name='MinStack'></a>155-Min Stack

[哈哈哈](https://www.bilibili.com/video/BV1H74118748?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1r77W?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ja4y1Y7vY?spm_id_from=333.999.0.0)

###  4.77. <a name='IntersectionofTwoLinkedLists'></a>160-Intersection of Two Linked Lists

[哈哈哈](https://www.bilibili.com/video/BV1n741187X6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411H7uq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K4y1J7wx?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1np4y1y789?spm_id_from=333.999.0.0)

###  4.78. <a name='FindPeakElement'></a>162. Find Peak Element

[小梦想家](https://www.bilibili.com/video/BV1Rb411n7dT?spm_id_from=333.999.0.0)

###  4.79. <a name='CompareVersionNumbers'></a>165. Compare Version Numbers

[小梦想家](https://www.bilibili.com/video/BV19K4y1C7L3?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pk4y117dF?spm_id_from=333.999.0.0)

###  4.80. <a name='FractiontoRecurringDecimal'></a>166. Fraction to Recurring Decimal

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7PE?spm_id_from=333.999.0.0)

###  4.81. <a name='TwoSumII-Inputarrayissorted'></a>167-Two Sum II - Input array is sorted

[哈哈哈](https://www.bilibili.com/video/BV167411h7ou?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7id?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1VZ4y1M7eu?spm_id_from=333.999.0.0)

###  4.82. <a name='ExcelSheetColumnTitle'></a>168-Excel Sheet Column Title

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7FY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H777?spm_id_from=333.999.0.0)

###  4.83. <a name='MajorityElement'></a>169. Majority Element

[花花酱](https://www.bilibili.com/video/BV1hb411c7bF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7pW?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ff4y1U7Vn?spm_id_from=333.999.0.0)

###  4.84. <a name='ExcelSheetColumnNumber'></a>171. Excel Sheet Column Number

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7nT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1h541187Sv?spm_id_from=333.999.0.0)

###  4.85. <a name='FactorialTrailingZeroes'></a>172-Factorial Trailing Zeroes

[哈哈哈](https://www.bilibili.com/video/BV1hE411n7TM?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7tS?spm_id_from=333.999.0.0)

###  4.86. <a name='BinarySearchTreeIterator'></a>173 Binary Search Tree Iterator

[小明](https://www.bilibili.com/video/BV1qK41137h1?spm_id_from=333.999.0.0)

###  4.87. <a name='DungeonGame'></a>174 Dungeon Game

[小明](https://www.bilibili.com/video/BV1TK411W7T1?spm_id_from=333.999.0.0)

###  4.88. <a name='LargestNumber'></a>179 Largest Number

[小明](https://www.bilibili.com/video/BV1mV411m7aN?spm_id_from=333.999.0.0)

###  4.89. <a name='ReverseWordsinaStringII'></a>186. Reverse Words in a String II 

[哈哈哈](https://www.bilibili.com/video/BV1GV411Z7fo?spm_id_from=333.999.0.0)

###  4.90. <a name='RepeatedDNASequences'></a>187 Repeated DNA Sequences

[小明](https://www.bilibili.com/video/BV1mp4y1r7v5?spm_id_from=333.999.0.0)

###  4.91. <a name='BestTimetoBuyandSellStockIV'></a>188 Best Time to Buy and Sell Stock IV

[小明](https://www.bilibili.com/video/BV1f54y1k7cX?spm_id_from=333.999.0.0)

###  4.92. <a name='RotateArray'></a>189. Rotate Array 

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Yy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N541177Bk?spm_id_from=333.999.0.0)

###  4.93. <a name='ReverseBits'></a>190. Reverse Bits

[花花酱](https://www.bilibili.com/video/BV1NJ411k7VP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qv411i7Wg?spm_id_from=333.999.0.0)

###  4.94. <a name='Numberof1Bits'></a>191 Number of 1 Bits

[小明](https://www.bilibili.com/video/BV1i5411J7SA?spm_id_from=333.999.0.0)

###  4.95. <a name='HouseRobber198-'></a>198. House Robber 198-打家劫舍

[12:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1tW411676f?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1u64y1M7PA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7hu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gZ4y1N75c?spm_id_from=333.999.0.0)、

[官方](https://www.bilibili.com/video/BV18g4y1i7f9?spm_id_from=333.999.0.0)

###  4.96. <a name='BinaryTreeRightSideView'></a>199 Binary Tree Right Side View

[小明](https://www.bilibili.com/video/BV1854y1W7CB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xK4y1b7Wh?spm_id_from=333.999.0.0)

###  4.97. <a name='-1'></a>200-岛屿数量

[哈哈哈](https://www.bilibili.com/video/BV15K411p72j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Cg4y1i7dZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1KK4y1U7Ds?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1E64y1T7Nk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Np4y1977S?spm_id_from=333.999.0.0)

###  4.98. <a name='BitwiseANDofNumbersRange'></a>201 Bitwise AND of Numbers Range

[小明](https://www.bilibili.com/video/BV1dT4y1g75m?spm_id_from=333.999.0.0)

###  4.99. <a name='HappyNumber'></a>202. 快乐数 Happy Number

[官方](https://www.bilibili.com/video/BV1Ca4y1v7Qr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CA41187LQ?spm_id_from=333.999.0.0)

###  4.100. <a name='RemoveLinkedListElements'></a>203. Remove Linked List Elements

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7bf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Yi4y137WA?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Sz411b7zw?spm_id_from=333.999.0.0)

###  4.101. <a name='CountPrimes'></a>204-Count Primes

[哈哈哈](https://www.bilibili.com/video/BV167411w7Sf?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7cV?spm_id_from=333.999.0.0)

###  4.102. <a name='isomorphicstrings'></a>205. isomorphic strings

[小梦想家](https://www.bilibili.com/video/BV1ab411H7ZS?spm_id_from=333.999.0.0)

###  4.103. <a name='ReverseLinkedList'></a>206-Reverse Linked List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7zr?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV16Q4y1M767?spm_id_from=333.999.0.0)

###  4.104. <a name='-1'></a>207-课程表

[花花酱](https://www.bilibili.com/video/BV1Ut411a74a?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV19k4y1r76s?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jz411B7UJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xp4y1Y7FJ?spm_id_from=333.999.0.0)

###  4.105. <a name='ImplementTriePrefixTree'></a>208. Implement Trie (Prefix Tree)

[花花酱](https://www.bilibili.com/video/BV1Ut411a74P?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zz4y1R7j8?spm_id_from=333.999.0.0)

###  4.106. <a name='-1'></a>209-长度最小的子数组

[哈哈哈](https://www.bilibili.com/video/BV1JZ4y1N7Rt?spm_id_from=333.999.0.0)

###  4.107. <a name='CourseScheduleII210-II'></a>210. Course Schedule II 210-课程表II

[花花酱](https://www.bilibili.com/video/BV1gW411y7Kb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ja4y147on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qt4y1X7oC?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kK411W7rL?spm_id_from=333.999.0.0)

###  4.108. <a name='AddandSearchWord'></a>211 Add and Search Word

[小明](https://www.bilibili.com/video/BV1x5411a77S?spm_id_from=333.999.0.0)

###  4.109. <a name='WordSearchII'></a>212. Word Search II

[花花酱](https://www.bilibili.com/video/BV184411d7i9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1G7NQ?spm_id_from=333.999.0.0)

###  4.110. <a name='HouseRobberII213-II'></a>213. House Robber II 213-打家劫舍II

[18:13 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ea4y147oh?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1GD4y1d7DS?spm_id_from=333.999.0.0)

###  4.111. <a name='CombinationSumIII216-III'></a>216. Combination Sum III 216-组合总和 III

[花花酱](https://www.bilibili.com/video/BV14b411u7q8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1SC4y1a7Vy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gz4y1Z7CV?spm_id_from=333.999.0.0)

###  4.112. <a name='ContainsDuplicate'></a>217. Contains Duplicate

[小梦想家](https://www.bilibili.com/video/BV1ab411H7Zw?spm_id_from=333.999.0.0)

###  4.113. <a name='TheSkylineProblem'></a>218. The Skyline Problem

[花花酱](https://www.bilibili.com/video/BV1hb411c7Q4?spm_id_from=333.999.0.0)

###  4.114. <a name='ContainsDuplicateII'></a>219. Contains Duplicate II

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ga?spm_id_from=333.999.0.0)

###  4.115. <a name='ContainsDuplicateIII'></a>220 Contains Duplicate III

[小明](https://www.bilibili.com/video/BV19h41197iw?spm_id_from=333.999.0.0)

###  4.116. <a name='-1'></a>221-最大正方形

[哈哈哈](https://www.bilibili.com/video/BV1XT4y137Gq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16K411575r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1mA411q7Sw?spm_id_from=333.999.0.0)

###  4.117. <a name='CountCompleteTreeNodes'></a>222. Count Complete Tree Nodes

[花花酱](https://www.bilibili.com/video/BV1n44y1E73D?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qz411i7bh?spm_id_from=333.999.0.0)

###  4.118. <a name='RectangleArea'></a>223. Rectangle Area

[小梦想家](https://www.bilibili.com/video/BV1Ck4y1z7Hp?spm_id_from=333.999.0.0)

###  4.119. <a name='ImplementStackusingQueues'></a>225-Implement Stack using Queues

[哈哈哈](https://www.bilibili.com/video/BV1p741177pK?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ep4y1Y77j?spm_id_from=333.999.0.0)

###  4.120. <a name='-1'></a>226-翻转二叉树

[哈哈哈](https://www.bilibili.com/video/BV1Sh411R7B2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73E?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FK411p7Co?spm_id_from=333.999.0.0)

###  4.121. <a name='BasicCalculatorII'></a>227 Basic Calculator II

[小明](https://www.bilibili.com/video/BV1Qy4y167Ax?spm_id_from=333.999.0.0)

###  4.122. <a name='SummaryRanges'></a>228 Summary Ranges

[小明](https://www.bilibili.com/video/BV1Et4y1i7YZ?spm_id_from=333.999.0.0)

###  4.123. <a name='MajorityElementII'></a>229. Majority Element II 

[哈哈哈](https://www.bilibili.com/video/BV12z411B7rS?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nK411P7qR?spm_id_from=333.999.0.0)

###  4.124. <a name='KthSmallestElementinaB'></a>230 Kth Smallest Element in a B

[小明](https://www.bilibili.com/video/BV1ha4y1i7dZ?spm_id_from=333.999.0.0)

###  4.125. <a name='PowerofTwo'></a>231. Power of Two

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rV411r7AL?spm_id_from=333.999.0.0)

###  4.126. <a name='ImplementQueueusingStacks'></a>232-Implement Queue using Stacks

[哈哈哈](https://www.bilibili.com/video/BV1p741177pp?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Gf4y147Vj?spm_id_from=333.999.0.0)

###  4.127. <a name='PalindromeLinkedList'></a>234. Palindrome Linked List

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ML?spm_id_from=333.999.0.0)

###  4.128. <a name='LowestCommonAncestorofaBinarySearchTree'></a>235. Lowest Common Ancestor of a Binary Search Tree

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7VY?spm_id_from=333.999.0.0)

###  4.129. <a name='-1'></a>236-二叉树的最近公共祖先

[哈哈哈](https://www.bilibili.com/video/BV1ov411172r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411p7dr?spm_id_from=333.999.0.0)

###  4.130. <a name='DeleteNodeinaLinkedList'></a>237. Delete Node in a Linked List

[小梦想家](https://www.bilibili.com/video/BV1rv411h7Lv?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1ap4y1C7JP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vt4y1y7eM?spm_id_from=333.999.0.0)

###  4.131. <a name='ProductofArrayExceptSelf'></a>238 Product of Array Except Self

[小明](https://www.bilibili.com/video/BV1oT4y1G78Y?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16z4y197oQ?spm_id_from=333.999.0.0)

###  4.132. <a name='SlidingWindowMaximum'></a>239. Sliding Window Maximum

[花花酱](https://www.bilibili.com/video/BV1WW411C763?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Bf4y1v758?spm_id_from=333.999.0.0)

###  4.133. <a name='-1'></a>240. 二维数组的查找

[哈哈哈](https://www.bilibili.com/video/BV1dz411i7jC?spm_id_from=333.999.0.0)

###  4.134. <a name='ValidAnagram'></a>242. Valid Anagram 

[小梦想家](https://www.bilibili.com/video/BV1Db411s78v?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hV411i73u?spm_id_from=333.999.0.0)

###  4.135. <a name='ShortestWordDistance'></a>243. Shortest Word Distance

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Ae?spm_id_from=333.999.0.0)

###  4.136. <a name='StrobogrammaticNumber'></a>246. Strobogrammatic Number

[小梦想家](https://www.bilibili.com/video/BV14b411g7zD?spm_id_from=333.999.0.0)

###  4.137. <a name='-1'></a>257-二叉树的所有路径

[哈哈哈](https://www.bilibili.com/video/BV1rf4y1X7He?spm_id_from=333.999.0.0)

###  4.138. <a name='AddDigits'></a>258. Add Digits

[小梦想家](https://www.bilibili.com/video/BV1ub41137cm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N54y1B7XU?spm_id_from=333.999.0.0)

###  4.139. <a name='III-1'></a>260-只出现一次的数字 III

[哈哈哈](https://www.bilibili.com/video/BV15Z4y1H7Sw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK411J7dN?spm_id_from=333.999.0.0)

###  4.140. <a name='UglyNumber'></a>263 Ugly Number

[花花酱](https://www.bilibili.com/video/BV11W411C7zd?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Mb41157Pa?spm_id_from=333.999.0.0)

###  4.141. <a name='UglyNumberII'></a>264. Ugly Number II

[花花酱](https://www.bilibili.com/video/BV1yW411C7Sm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vT4y1775u?spm_id_from=333.999.0.0)

###  4.142. <a name='MissingNumber'></a>268 Missing Number

[小明](https://www.bilibili.com/video/BV1LU4y1p7n7?spm_id_from=333.999.0.0)

###  4.143. <a name='ClosestBinarySearchTreeValue'></a>270. Closest Binary Search Tree Value

[哈哈哈](https://www.bilibili.com/video/BV1zy4y1a7mR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1fi4y1u7Sb?spm_id_from=333.999.0.0)

###  4.144. <a name='H-Index'></a>274 H-Index

[小明](https://www.bilibili.com/video/BV1ZV411z7Kx?spm_id_from=333.999.0.0)


###  4.145. <a name='FirstBadVersion'></a>278. First Bad Version

[小梦想家](https://www.bilibili.com/video/BV1rZ4y1P7YF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1cQ4y1N7dc?spm_id_from=333.999.0.0)

###  4.146. <a name='PerfectSquares'></a>279 Perfect Squares

[小明](https://www.bilibili.com/video/BV1r5411Y7MH?spm_id_from=333.999.0.0)

###  4.147. <a name='ExpressionAddOperators'></a>282. Expression Add Operators

[花花酱](https://www.bilibili.com/video/BV15W411C727?spm_id_from=333.999.0.0)

###  4.148. <a name='MoveZeros'></a>283. Move Zeros

[小梦想家](https://www.bilibili.com/video/BV1m441187Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ba4y1t7eK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Wp4y1y7pT?spm_id_from=333.999.0.0)

###  4.149. <a name='PeekingIterator'></a>284 Peeking Iterator

[小明](https://www.bilibili.com/video/BV1LN411R7U7?spm_id_from=333.999.0.0)

###  4.150. <a name='FindtheDuplicateNumber'></a>287 Find the Duplicate Number

[小明](https://www.bilibili.com/video/BV1Ug4y1v7mF?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pz4y1X7qR?spm_id_from=333.999.0.0)

###  4.151. <a name='GameofLife'></a>289. Game of Life

[花花酱](https://www.bilibili.com/video/BV14W411d7ji?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hp4y1B7D5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vz4y1R7DJ?spm_id_from=333.999.0.0)

###  4.152. <a name='WordPattern'></a>290. Word Pattern

[小梦想家](https://www.bilibili.com/video/BV1d4411V7mi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1N7wD?spm_id_from=333.999.0.0)

###  4.153. <a name='SerializeandDeserializeBinaryTree'></a>297. Serialize and Deserialize Binary Tree

[花花酱](https://www.bilibili.com/video/BV1Hb411c7cr?spm_id_from=333.999.0.0)

###  4.154. <a name='BullsandCows'></a>299. Bulls and Cows

[小梦想家](https://www.bilibili.com/video/BV1M64y1M7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1bh411R7n4?spm_id_from=333.999.0.0)

###  4.155. <a name='LongestIncreasingSubsequence'></a>300 Longest Increasing Subsequence 最长上升子序列

[花花酱](https://www.bilibili.com/video/BV1Wf4y1y7ou?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1rT4y1u7jV?spm_id_from=333.999.0.0)

###  4.156. <a name='RemoveInvalidParentheses'></a>301. Remove Invalid Parentheses

[花花酱](https://www.bilibili.com/video/BV1VW411y7Xd?spm_id_from=333.999.0.0)

###  4.157. <a name='-1'></a>303-区域和检索 - 数组不可变

[哈哈哈](https://www.bilibili.com/video/BV1RV411d76R?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV18441137fs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ho4y1U7wF?spm_id_from=333.999.0.0)

###  4.158. <a name='RangeSumQuery2D'></a>304. Range Sum Query 2D

[花花酱](https://www.bilibili.com/video/BV1Jb411k7LQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1R64y127jL?spm_id_from=333.999.0.0)

###  4.159. <a name='BestTimetoBuyandSellStockwithCooldown309-'></a>309. Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期

[花花酱](https://www.bilibili.com/video/BV1qW411C7Xc?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Vy4y1z7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13D4y1U7iU?spm_id_from=333.999.0.0)

###  4.160. <a name='MinimumHeightTrees'></a>310 Minimum Height Trees

[小明](https://www.bilibili.com/video/BV1eA411j7XQ?spm_id_from=333.999.0.0)

###  4.161. <a name='BurstBalloons'></a>312 Burst Balloons

[小明](https://www.bilibili.com/video/BV1Q64y1f7Vy?spm_id_from=333.999.0.0)

###  4.162. <a name='CountofSmallerNumbersAfterSelf'></a>315. Count of Smaller Numbers After Self

[花花酱](https://www.bilibili.com/video/BV1BW411C7TM?spm_id_from=333.999.0.0)

###  4.163. <a name='RemoveDuplicateLetters'></a>316 Remove Duplicate Letters

[小明](https://www.bilibili.com/video/BV1x54y1R7y7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Tz4y167pC?spm_id_from=333.999.0.0)

###  4.164. <a name='CreateMaximumNumber'></a>321. Create Maximum Number

[花花酱](https://www.bilibili.com/video/BV11W411U7NR?spm_id_from=333.999.0.0)

###  4.165. <a name='CoinChange'></a>322. Coin Change

[花花酱](https://www.bilibili.com/video/BV1SW411C7d1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1tz4y1d7XM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ty4y187dh?spm_id_from=333.999.0.0)

###  4.166. <a name='PowerofThree'></a>326. Power of Three

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7QC?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1h441137PM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sZ4y1F7Lr?spm_id_from=333.999.0.0)

###  4.167. <a name='OddEvenLinkedList'></a>328. 奇偶链表 (Odd Even Linked List)

[洛阳](https://www.bilibili.com/video/BV1v64y1u7AH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ag4y1B78z?spm_id_from=333.999.0.0)

###  4.168. <a name='LongestIncreasingPathinaMatrix'></a>329. Longest Increasing Path in a Matrix

[花花酱](https://www.bilibili.com/video/BV1mW411d7q8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK4y1K7SX?spm_id_from=333.999.0.0)

###  4.169. <a name='ReconstructItinerary'></a>332 Reconstruct Itinerary

[小明](https://www.bilibili.com/video/BV1qa4y1h7Ti?spm_id_from=333.999.0.0)

###  4.170. <a name='IncreasingTripletSubseque'></a>334 Increasing Triplet Subseque

[小明](https://www.bilibili.com/video/BV1Kr4y1F7m9?spm_id_from=333.999.0.0)

###  4.171. <a name='HouseRobberIII'></a>337 House Robber III

[小明](https://www.bilibili.com/video/BV1WD4y1X7JQ?spm_id_from=333.999.0.0)

###  4.172. <a name='CountingBits'></a>338 Counting Bits

[小明](https://www.bilibili.com/video/BV1VK411s7xi?spm_id_from=333.999.0.0)

###  4.173. <a name='PowerofFour'></a>342. Power of Four

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7D5?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1p5411a7h1?spm_id_from=333.999.0.0)

###  4.174. <a name='-1'></a>343-整数拆分

[哈哈哈](https://www.bilibili.com/video/BV1Dp4y1U79P?spm_id_from=333.999.0.0)

###  4.175. <a name='ReverseString'></a>344. Reverse String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7Ha?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nC4y1a7DR?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1nQ4y1R7nH?spm_id_from=333.999.0.0)

###  4.176. <a name='ReverseVowelsofaString'></a>345. Reverse Vowels of a String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7JH?spm_id_from=333.999.0.0)

###  4.177. <a name='MovingAveragefromDataStream'></a>346 Moving Average from Data Stream

[小明](https://www.bilibili.com/video/BV1xV411m73u?spm_id_from=333.999.0.0)

###  4.178. <a name='TopKFrequentElements'></a>347. Top K Frequent Elements 

[花花酱](https://www.bilibili.com/video/BV1Mt411371T?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sk4y1B7vj?spm_id_from=333.999.0.0)

###  4.179. <a name='IntersectionofTwoArrays'></a>349. Intersection of Two Arrays

[小梦想家](https://www.bilibili.com/video/BV1zx411o7i1?spm_id_from=333.999.0.0)

###  4.180. <a name='IntersectionofTwoArraysII'></a>350. Intersection of Two Arrays II 

[小梦想家](https://www.bilibili.com/video/BV1gx411X7q8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV165411879H?spm_id_from=333.999.0.0)

###  4.181. <a name='DesignTwitter'></a>355. 设计推特 Design Twitter

[官方](https://www.bilibili.com/video/BV1aQ4y1N72N?spm_id_from=333.999.0.0)

###  4.182. <a name='LoggerRateLimiter'></a>359 Logger Rate Limiter

[小明](https://www.bilibili.com/video/BV1k64y1F7dE?spm_id_from=333.999.0.0)

###  4.183. <a name='ValidPerfectSquare'></a>367. Valid Perfect Square

[小梦想家](https://www.bilibili.com/video/BV1Gx411X7Ke?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DT4y1377H?spm_id_from=333.999.0.0)

###  4.184. <a name='LargestDivisibleSubset'></a>368 Largest Divisible Subset

[小明](https://www.bilibili.com/video/BV15D4y1Q74b?spm_id_from=333.999.0.0)

###  4.185. <a name='FindKPairswithSmallestSumsk'></a>373. Find K Pairs with Smallest Sums查找和最小的k对数字

[图灵](https://www.bilibili.com/video/BV1Mv4y1Z79v?spm_id_from=333.999.0.0)

###  4.186. <a name='GuessNumberHigherorLower'></a>374. Guess Number Higher or Lower

[小梦想家](https://www.bilibili.com/video/BV1Hx41197ou?spm_id_from=333.999.0.0)

###  4.187. <a name='-1'></a>376-摆动序列

[哈哈哈](https://www.bilibili.com/video/BV1sk4y167wV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16X4y1376k?spm_id_from=333.999.0.0)

###  4.188. <a name='CombinationSumIV'></a>377. Combination Sum IV

[花花酱](https://www.bilibili.com/video/BV1gW411y7uz?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1zA411L7nu?spm_id_from=333.999.0.0)

###  4.189. <a name='K'></a>378-有序矩阵中第K小的元素

[哈哈哈](https://www.bilibili.com/video/BV1mT4y1w7u2?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Zy4y127qr?spm_id_from=333.999.0.0)

###  4.190. <a name='InsertDeleteGetRandomO1'></a>380 Insert Delete GetRandom O(1)

[小明](https://www.bilibili.com/video/BV1Fg4y1q7Ru?spm_id_from=333.999.0.0)

###  4.191. <a name='LinkedListRandomNode'></a>382 Linked List Random Node

[小明](https://www.bilibili.com/video/BV1xZ4y1G7ie?spm_id_from=333.999.0.0)

###  4.192. <a name='RansomNote'></a>383 Ransom Note

[小明](https://www.bilibili.com/video/BV1GQ4y1N7Q5?spm_id_from=333.999.0.0)

###  4.193. <a name='FirstUniqueCharacterinaString'></a>387. First Unique Character in a String

[小梦想家](https://www.bilibili.com/video/BV1y4411A7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1b541147WU?spm_id_from=333.999.0.0)

###  4.194. <a name='FindtheDifference'></a>389. Find the Difference

[小梦想家](https://www.bilibili.com/video/BV1Et411K7jP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

###  4.195. <a name='PerfectRectangle'></a>391. Perfect Rectangle

[花花酱](https://www.bilibili.com/video/BV184411c7cs?spm_id_from=333.999.0.0)

###  4.196. <a name='IsSubsequence'></a>392. Is Subsequence

[小梦想家](https://www.bilibili.com/video/BV1fg4y1q7eT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Za4y1a73v?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19f4y197yS?spm_id_from=333.999.0.0)

###  4.197. <a name='UTF-8Validation'></a>393. UTF-8 Validation

[花花酱](https://www.bilibili.com/video/BV1SE411w7no?spm_id_from=333.999.0.0)

###  4.198. <a name='DecodeString'></a>394 Decode String

[小明](https://www.bilibili.com/video/BV145411V75E?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GZ4y1p7pE?spm_id_from=333.999.0.0)

###  4.199. <a name='LongestSubstringwithAtLeastK'></a>395 Longest Substring with At Least K

[小明](https://www.bilibili.com/video/BV1hD4y1X7rq?spm_id_from=333.999.0.0)

###  4.200. <a name='EvaluateDivision'></a>399. Evaluate Division

[花花酱](https://www.bilibili.com/video/BV1iW41167Nb?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XU4y1s7Lk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ko4y1f7eK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rZ4y1N7CW?spm_id_from=333.999.0.0)

###  4.201. <a name='RemoveKDigits'></a>402 Remove K Digits

[小明](https://www.bilibili.com/video/BV1PV411C79X?spm_id_from=333.999.0.0)

###  4.202. <a name='SumofLeftLeaves'></a>404. Sum of Left Leaves

[小梦想家](https://www.bilibili.com/video/BV1Et411K7wa?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15a4y1779U?spm_id_from=333.999.0.0)

###  4.203. <a name='ConvertaNumbertoHexadecimal'></a>405-Convert a Number to Hexadecimal

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7ds?spm_id_from=333.999.0.0)

###  4.204. <a name='QueueReconstructionbyHeight'></a>406. Queue Reconstruction by Height 

[小明](https://www.bilibili.com/video/BV1xC4y1a72W?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV144411R7ch?spm_id_from=333.999.0.0)

###  4.205. <a name='ValidWordAbbreviation'></a>408. Valid Word Abbreviation

[小梦想家](https://www.bilibili.com/video/BV1A4411q74A?spm_id_from=333.999.0.0)

###  4.206. <a name='LongestPalindrome'></a>409. Longest Palindrome

[小梦想家](https://www.bilibili.com/video/BV1B441127W2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19C4y1479a?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Lk4y1z7PG?spm_id_from=333.999.0.0)

###  4.207. <a name='SplitArrayLargestSum'></a>410. Split Array Largest Sum

[花花酱](https://www.bilibili.com/video/BV14W411d7D4?spm_id_from=333.999.0.0)

###  4.208. <a name='FizzBuzz'></a>412. Fizz Buzz

[小梦想家](https://www.bilibili.com/video/BV1xE411R7yK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tD4y1m76j?spm_id_from=333.999.0.0)

###  4.209. <a name='-1'></a>413-等差数列划分

[哈哈哈](https://www.bilibili.com/video/BV13a4y1i7tR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13f4y167YZ?spm_id_from=333.999.0.0)

###  4.210. <a name='ThirdMaximumNumber'></a>414. Third Maximum Number

[小梦想家](https://www.bilibili.com/video/BV1UE411X7k1?spm_id_from=333.999.0.0)

###  4.211. <a name='AddStrings'></a>415-Add Strings

[哈哈哈](https://www.bilibili.com/video/BV18E411n7Cy?spm_id_from=333.999.0.0)

###  4.212. <a name='PartitionEqualSubsetSum'></a>416. Partition Equal Subset Sum

[花花酱](https://www.bilibili.com/video/BV1AW411y7So?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oZ4y1G7QY?spm_id_from=333.999.0.0)

###  4.213. <a name='PacificAtlanticWaterFlow'></a>417. Pacific Atlantic Water Flow

[花花酱](https://www.bilibili.com/video/BV1Kb411K7ty?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1by4y1h7ab?spm_id_from=333.999.0.0)

###  4.214. <a name='BattleshipsinaBoard'></a>419. Battleships in a Board 

[小梦想家](https://www.bilibili.com/video/BV1TJ411j7QZ?spm_id_from=333.999.0.0)

###  4.215. <a name='MaximumXORofTwoNumbersinanArray'></a>421 Maximum XOR of Two Numbers in an Array

[小明](https://www.bilibili.com/video/BV1s64y1F7Wm?spm_id_from=333.999.0.0)

###  4.216. <a name='ReconstructOriginalDigitsfromEnglish'></a>423 Reconstruct Original Digits from English

[小明](https://www.bilibili.com/video/BV1554y1h73S?spm_id_from=333.999.0.0)

###  4.217. <a name='LongestRepeatingCharacterReplacem'></a>424. 替换后的最长重复字符 Longest Repeating Character Replacem

[官方](https://www.bilibili.com/video/BV14r4y1K7rN?spm_id_from=333.999.0.0)

###  4.218. <a name='N-aryTreeLevelOrderTraversal'></a>429. N-ary Tree Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1CE411Q7BQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Uv411K77M?spm_id_from=333.999.0.0)

###  4.219. <a name='FlattenaMultilevelDoublyLinkedList'></a>430 Flatten a Multilevel Doubly Linked List

[小明](https://www.bilibili.com/video/BV1754y1q7Kb?spm_id_from=333.999.0.0)

###  4.220. <a name='AllOoneDataStructure'></a>432. All O`one Data Structure

[花花酱](https://www.bilibili.com/video/BV1XW411d7qR?spm_id_from=333.999.0.0)

###  4.221. <a name='Non-overlappingIntervals'></a>435-Non-overlapping Intervals

[哈哈哈](https://www.bilibili.com/video/BV1i7411p7pv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ak4y1U7f8?spm_id_from=333.999.0.0)

###  4.222. <a name='FindRightInterval'></a>436 Find Right Interval

[小明](https://www.bilibili.com/video/BV1YT4y1w7EP?spm_id_from=333.999.0.0)

###  4.223. <a name='PathSumIII'></a>437 Path Sum III

[小明](https://www.bilibili.com/video/BV1tZ4y1M7JR?spm_id_from=333.999.0.0)

###  4.224. <a name='FindAllAnagramsinaString'></a>438. Find All Anagrams in a String

[花花酱](https://www.bilibili.com/video/BV1iW411d7Nb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1254y1X7HV?spm_id_from=333.999.0.0)

###  4.225. <a name='ArrangingCoins'></a>441 Arranging Coins

[小明](https://www.bilibili.com/video/BV1eV411k7rg?spm_id_from=333.999.0.0)

###  4.226. <a name='FindAllDuplicatesinanArray'></a>442 Find All Duplicates in an Array

[小明](https://www.bilibili.com/video/BV1Lh411d7AD?spm_id_from=333.999.0.0)

###  4.227. <a name='StringCompression'></a>443. String Compression

[小梦想家](https://www.bilibili.com/video/BV1rE411f7Ld?spm_id_from=333.999.0.0)

###  4.228. <a name='AddTwoNumbersII'></a>445-Add Two Numbers II

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7Qz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pt4y1m78o?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17a4y1s7BG?spm_id_from=333.999.0.0)

###  4.229. <a name='NumberofBoomerangs'></a>447. Number of Boomerangs

[小梦想家](https://www.bilibili.com/video/BV1hE411o7V2?spm_id_from=333.999.0.0)

###  4.230. <a name='FindAllNumbersDisappearedinanArray'></a>448. Find All Numbers Disappeared in an Array

[小梦想家](https://www.bilibili.com/video/BV1SE411d7FM?spm_id_from=333.999.0.0)

###  4.231. <a name='SerializeandDeserializeBST'></a>449. Serialize and Deserialize BST

[花花酱](https://www.bilibili.com/video/BV1ab411c75V?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1r7FT?spm_id_from=333.999.0.0)

###  4.232. <a name='DeleteNodeinaBST'></a>450. Delete Node in a BST

[花花酱](https://www.bilibili.com/video/BV1XW411d7yU?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1YK4y1h7Mw?spm_id_from=333.999.0.0)

###  4.233. <a name='SortCharactersByFrequency'></a>451 Sort Characters By Frequency

[小明](https://www.bilibili.com/video/BV18v411z7iy?spm_id_from=333.999.0.0)

###  4.234. <a name='SumII'></a>454 4Sum II

[小明](https://www.bilibili.com/video/BV1ny4y1D7UL?spm_id_from=333.999.0.0)

###  4.235. <a name='MinimumNumberofArrowstoBurstBalloons'></a>452. Minimum Number of Arrows to Burst Balloons

[花花酱](https://www.bilibili.com/video/BV1bW411d77B?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1PZ4y1L7VM?spm_id_from=333.999.0.0)

###  4.236. <a name='AssignCookies'></a>455-Assign Cookies

[哈哈哈](https://www.bilibili.com/video/BV157411s7b9?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1YE411r7UN?spm_id_from=333.999.0.0)

###  4.237. <a name='Pattern'></a>456 132 Pattern

[小明](https://www.bilibili.com/video/BV18f4y1i734?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1SZ4y1x74J?spm_id_from=333.999.0.0)

###  4.238. <a name='PoorPigs'></a>458 Poor Pigs

[小明](https://www.bilibili.com/video/BV1g5411576M?spm_id_from=333.999.0.0)

###  4.239. <a name='RepeatedSubstringPattern'></a>459 Repeated Substring Pattern

[小明](https://www.bilibili.com/video/BV1Yt4y1S7XZ?spm_id_from=333.999.0.0)

###  4.240. <a name='LFUCacheO1'></a>460. LFU Cache / O(1)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7PR?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1Xb411c7m7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kA41147t8?spm_id_from=333.999.0.0)

###  4.241. <a name='HammingDistance'></a>461 Hamming Distance

[小明](https://www.bilibili.com/video/BV1M5411Y79g?spm_id_from=333.999.0.0)

###  4.242. <a name='IslandPerimeter'></a>463 Island Perimeter

[小明](https://www.bilibili.com/video/BV16V41167bF?spm_id_from=333.999.0.0)

###  4.243. <a name='CanIWin'></a>464. Can I Win

[花花酱](https://www.bilibili.com/video/BV1KW411o7m2?spm_id_from=333.999.0.0)

###  4.244. <a name='CountTheRepetitions'></a>466. 统计重复个数 Count The Repetitions

[官方](https://www.bilibili.com/video/BV1Qk4y1678m?spm_id_from=333.999.0.0)

###  4.245. <a name='ValidateIPAddress'></a>468 Validate IP Address

[小明](https://www.bilibili.com/video/BV1tg4y1q7Kq?spm_id_from=333.999.0.0)

###  4.246. <a name='ImplementRand10UsingRand7'></a>470. Implement Rand10() Using Rand7()

[花花酱](https://www.bilibili.com/video/BV1Ut411Z7KX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AD4y1m7Qb?spm_id_from=333.999.0.0)

###  4.247. <a name='Heaters'></a>475. Heaters

[小梦想家](https://www.bilibili.com/video/BV1vJ41117VH?spm_id_from=333.999.0.0)

###  4.248. <a name='NumberComplement'></a>476. Number Complement

[花花酱](https://www.bilibili.com/video/BV1PW411y7mv?spm_id_from=333.999.0.0)

###  4.249. <a name='TotalHammingDistance'></a>477. Total Hamming Distance

[花花酱](https://www.bilibili.com/video/BV1SW411r78m?spm_id_from=333.999.0.0)

###  4.250. <a name='GenerateRandomPointinaCircle'></a>478 Generate Random Point in a Circle

[小明](https://www.bilibili.com/video/BV1Nz4y127a1?spm_id_from=333.999.0.0)

###  4.251. <a name='SlidingWindowMedian'></a>480. Sliding Window Median

[花花酱](https://www.bilibili.com/video/BV15W411C7iy?spm_id_from=333.999.0.0)

###  4.252. <a name='FindPermutation'></a>484 Find Permutation

[小明](https://www.bilibili.com/video/BV1NT4y1L76i?spm_id_from=333.999.0.0)

###  4.253. <a name='MaxConsecutiveOnes'></a>485. Max Consecutive Ones

[小梦想家](https://www.bilibili.com/video/BV1zJ411R7SJ?spm_id_from=333.999.0.0)

###  4.254. <a name='PredicttheWinner'></a>486. Predict the Winner

[花花酱](https://www.bilibili.com/video/BV1kW411d7R2?spm_id_from=333.999.0.0)

###  4.255. <a name='TheMaze'></a>490 The Maze

[小明](https://www.bilibili.com/video/BV1az4y1f7Hn?spm_id_from=333.999.0.0)

###  4.256. <a name='TargetSum'></a>494. Target Sum

[花花酱](https://www.bilibili.com/video/BV1WW411C7Mp?spm_id_from=333.999.0.0)

[花花酱 下](https://www.bilibili.com/video/BV1WW411C7Mr?spm_id_from=333.999.0.0)

###  4.257. <a name='TeemoAttacking'></a>495 Teemo Attacking

[小明](https://www.bilibili.com/video/BV1LK4y1Y75e?spm_id_from=333.999.0.0)

###  4.258. <a name='INextGreaterElementI'></a>496. 下一个更大元素 I (Next Greater Element I)

[洛阳](https://www.bilibili.com/video/BV1Ce411W7pW?spm_id_from=333.999.0.0)

###  4.259. <a name='RandomPointinNon-overlapping'></a>497 Random Point in Non-overlapping

[小明](https://www.bilibili.com/video/BV12K4y1Y7r6?spm_id_from=333.999.0.0)

###  4.260. <a name='KeyboardRow'></a>500. Keyboard Row

[小梦想家](https://www.bilibili.com/video/BV1vJ411X7BR?spm_id_from=333.999.0.0)

###  4.261. <a name='NextGreaterElementII'></a>503-Next Greater Element II

[哈哈哈](https://www.bilibili.com/video/BV197411L77N?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1k5411t7Pa?spm_id_from=333.999.0.0)

###  4.262. <a name='Base7'></a>504-Base 7

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7o5?spm_id_from=333.999.0.0)

###  4.263. <a name='FibonacciNumber'></a>509. Fibonacci Number

[1:30 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15y4y147Re?spm_id_from=333.999.0.0)

###  4.264. <a name='LongestPalindromicSubsequence'></a>516. Longest Palindromic Subsequence

[花花酱](https://www.bilibili.com/video/BV18W411d7k2?spm_id_from=333.999.0.0)

###  4.265. <a name='CoinChange2'></a>518 Coin Change 2

[小明](https://www.bilibili.com/video/BV1jC4y1a7YT?spm_id_from=333.999.0.0)

###  4.266. <a name='DetectCapital'></a>520. Detect Capital

[小梦想家](https://www.bilibili.com/video/BV1NJ41197da?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xT4y1j7G4?spm_id_from=333.999.0.0)

###  4.267. <a name='ContiguousArray'></a>525. Contiguous Array

[花花酱](https://www.bilibili.com/video/BV14W411d7SD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV185411t7tu?spm_id_from=333.999.0.0)

###  4.268. <a name='BeautifulArrangement'></a>526 Beautiful Arrangement

[小明](https://www.bilibili.com/video/BV1DK411M7QR?spm_id_from=333.999.0.0)

###  4.269. <a name='RandomPickwithWeight'></a>528 Random Pick with Weight

[小明](https://www.bilibili.com/video/BV1UV411r7MK?spm_id_from=333.999.0.0)

###  4.270. <a name='MinimumAbsoluteDifferenceinBST'></a>530. Minimum Absolute Difference in BST

[花花酱](https://www.bilibili.com/video/BV1fW411k7eT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1FJ41147BB?spm_id_from=333.999.0.0)

###  4.271. <a name='K-diffPairsinanArray'></a>532 K-diff Pairs in an Array

[小明](https://www.bilibili.com/video/BV1MV41127o1?spm_id_from=333.999.0.0)

###  4.272. <a name='EncodeandDecodeTinyURL'></a>535. Encode and Decode TinyURL

[小梦想家](https://www.bilibili.com/video/BV1hb411e7zp?spm_id_from=333.999.0.0)

###  4.273. <a name='ComplexNumberMultiplicatin'></a>537 Complex Number Multiplicatin

[小明](https://www.bilibili.com/video/BV1sP4y1p7Px?spm_id_from=333.999.0.0)

###  4.274. <a name='ConvertBSTtoGreaterTree'></a>538 Convert BST to Greater Tree

[小明](https://www.bilibili.com/video/BV1k541177bt?spm_id_from=333.999.0.0)

###  4.275. <a name='SingleElementinaSortedArray540-'></a>540. Single Element in a Sorted Array 540-有序数组中的单一元素

[花花酱](https://www.bilibili.com/video/BV1gW411y7N3?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1P64y1F7cd?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Tg4y1B7Va?spm_id_from=333.999.0.0)

###  4.276. <a name='Matrix'></a>542. 01 矩阵 01 Matrix 

[官方](https://www.bilibili.com/video/BV1cZ4y1s727?spm_id_from=333.999.0.0)

###  4.277. <a name='DiameterofBinaryTree'></a>543 Diameter of Binary Tree

[小明](https://www.bilibili.com/video/BV12K4y1r78T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qA411t7LR?spm_id_from=333.999.0.0)

###  4.278. <a name='RemoveBoxes'></a>546 Remove Boxes

[花花酱](https://www.bilibili.com/video/BV11W411Z7jG?spm_id_from=333.999.0.0)

###  4.279. <a name='-1'></a>547-朋友圈

[哈哈哈](https://www.bilibili.com/video/BV1Ta411F7rk?spm_id_from=333.999.0.0)

###  4.280. <a name='BrickWall'></a>554 Brick Wall

[小明](https://www.bilibili.com/video/BV1mo4y1f7wc?spm_id_from=333.999.0.0)

###  4.281. <a name='NextGreaterElementIII'></a>556 Next Greater Element III

[小明](https://www.bilibili.com/video/BV19t4y167yb?spm_id_from=333.999.0.0)

###  4.282. <a name='SubarraySumEqualsKK'></a>560. Subarray Sum Equals K 和为K的子数组

[花花酱](https://www.bilibili.com/video/BV1XW411d71i?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d54y127ri?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vK4y1k7ku?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV13t4y1y7ya?spm_id_from=333.999.0.0)

###  4.283. <a name='BinaryTreeTilt'></a>563 Binary Tree Tilt

[小明](https://www.bilibili.com/video/BV1KV41117ho?spm_id_from=333.999.0.0)

###  4.284. <a name='PermutationinString567-'></a>567. Permutation in String 567-字符串的排列

[花花酱](https://www.bilibili.com/video/BV14W411d7g6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1z54y1C7qB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV175411E761?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1154y1X7qB?spm_id_from=333.999.0.0)

###  4.285. <a name='-1'></a>572-另一个树的子树

[哈哈哈](https://www.bilibili.com/video/BV1cA411t7zD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1wt4y197aB?spm_id_from=333.999.0.0)

###  4.286. <a name='DistributeCandies'></a>575 Distribute Candies

[小明](https://www.bilibili.com/video/BV11i4y1T7Pr?spm_id_from=333.999.0.0)

###  4.287. <a name='OutofBoundaryPaths'></a>576. Out of Boundary Paths

[花花酱](https://www.bilibili.com/video/BV18W411d7Cf?spm_id_from=333.999.0.0)

###  4.288. <a name='ShortestUnsortedContinuousSuba'></a>581 Shortest Unsorted Continuous Suba

[小明](https://www.bilibili.com/video/BV1Y54y1h7Xa?spm_id_from=333.999.0.0)

###  4.289. <a name='N-aryTreePreorderTraversal'></a>589 N-ary Tree Preorder Traversal

[小明](https://www.bilibili.com/video/BV1io4y1f7qT?spm_id_from=333.999.0.0)

###  4.290. <a name='ValidSquare'></a>593 Valid Square

[小明](https://www.bilibili.com/video/BV1j5411V73U?spm_id_from=333.999.0.0)

###  4.291. <a name='LongestHarmoniousSubsequence'></a>594 Longest Harmonious Subsequence

[小明](https://www.bilibili.com/video/BV1Pp4y1p7ss?spm_id_from=333.999.0.0)

###  4.292. <a name='CanPlaceFlowers'></a>605 Can Place Flowers

[小明](https://www.bilibili.com/video/BV1Uz4y1k7xU?spm_id_from=333.999.0.0)

###  4.293. <a name='TaskScheduler'></a>621. Task Scheduler

[花花酱](https://www.bilibili.com/video/BV1Wt411Y7Y9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1LZ4y1M7Bg?spm_id_from=333.999.0.0)

###  4.294. <a name='DesignCircularQueue'></a>622 Design Circular Queue

[小明](https://www.bilibili.com/video/BV1kV411n7Uk?spm_id_from=333.999.0.0)

###  4.295. <a name='AddOneRowtoTree'></a>623 Add One Row to Tree

[小明](https://www.bilibili.com/video/BV1AK4y1U7ud?spm_id_from=333.999.0.0)

###  4.296. <a name='SumofSquareNumbers'></a>633-Sum of Square Numbers

[哈哈哈](https://www.bilibili.com/video/BV1a7411h7on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qh411i7Yh?spm_id_from=333.999.0.0)

###  4.297. <a name='ExclusiveTimeofFunctions'></a>636. Exclusive Time of Functions

[花花酱](https://www.bilibili.com/video/BV1PW411o7Bh?spm_id_from=333.999.0.0)

###  4.298. <a name='AverageofLevelsinBinaryTree'></a>637 Average of Levels in Binary Tree

[小明](https://www.bilibili.com/video/BV1eb4y1976M?spm_id_from=333.999.0.0)

###  4.299. <a name='DecodeWaysII'></a>639. Decode Ways II

[花花酱](https://www.bilibili.com/video/BV1YW411r75q?spm_id_from=333.999.0.0)

###  4.300. <a name='MaximumAverageSubarrayI'></a>643. Maximum Average Subarray I

[小梦想家](https://www.bilibili.com/video/BV1dV411k7i6?spm_id_from=333.999.0.0)

###  4.301. <a name='-1'></a>645-错误的集合

[哈哈哈](https://www.bilibili.com/video/BV1az411e7zU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1479j?spm_id_from=333.999.0.0)

###  4.302. <a name='-1'></a>646-最长数对链

[哈哈哈](https://www.bilibili.com/video/BV1rz411q7pZ?spm_id_from=333.999.0.0)

###  4.303. <a name='PalindromicSubstrings'></a>647 Palindromic Substrings

[小明](https://www.bilibili.com/video/BV1g54y1h7uv?spm_id_from=333.999.0.0)

###  4.304. <a name='-1'></a>650-只有两个键的键盘

[哈哈哈](https://www.bilibili.com/video/BV1254y1z7ze?spm_id_from=333.999.0.0)

###  4.305. <a name='FindDuplicateSubtrees'></a>652. Find Duplicate Subtrees

[花花酱](https://www.bilibili.com/video/BV1cW411y7d1?spm_id_from=333.999.0.0)

###  4.306. <a name='TwoSumIV'></a>653. Two Sum IV

[小梦想家](https://www.bilibili.com/video/BV1Qz4y197h1?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AQ4y117mc?spm_id_from=333.999.0.0)

###  4.307. <a name='MaximumWidthofBinaryTree'></a>662. Maximum Width of Binary Tree

[花花酱](https://www.bilibili.com/video/BV1cv411q7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16a4y1h7fG?spm_id_from=333.999.0.0)

###  4.308. <a name='BeautifulArrangementII'></a>667 Beautiful Arrangement II

[小明](https://www.bilibili.com/video/BV1j54y1b7Br?spm_id_from=333.999.0.0)

###  4.309. <a name='KthSmallestNumberinMultiplicationTable'></a>668. Kth Smallest Number in Multiplication Table

[花花酱](https://www.bilibili.com/video/BV17W411C7ai?spm_id_from=333.999.0.0)

###  4.310. <a name='TrimaBinarySearchTree'></a>669 Trim a Binary Search Tree

[小明](https://www.bilibili.com/video/BV19y4y1J7fu?spm_id_from=333.999.0.0)

###  4.311. <a name='NumberofLongestIncreasingSubse'></a>673 Number of Longest Increasing Subse

[小明](https://www.bilibili.com/video/BV1gT4y1F7y3?spm_id_from=333.999.0.0)

###  4.312. <a name='ValidParenthesisString'></a>678 Valid Parenthesis String

[小明](https://www.bilibili.com/video/BV1ap4y1X7nu?spm_id_from=333.999.0.0)

###  4.313. <a name='ValidPalindromeII'></a>680-Valid Palindrome II

[哈哈哈](https://www.bilibili.com/video/BV167411h7x1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y147xn?spm_id_from=333.999.0.0)

###  4.314. <a name='KEmptySlots'></a>683. K Empty Slots

[花花酱](https://www.bilibili.com/video/BV1Jb411k7Yu?spm_id_from=333.999.0.0)

###  4.315. <a name='RedundantConnection684-'></a>684. Redundant Connection 684-冗余连接

[花花酱](https://www.bilibili.com/video/BV1mt411J79j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1oe411p7qF?spm_id_from=333.999.0.0)

###  4.316. <a name='RedundantConnectionII'></a>685. Redundant Connection II

[花花酱](https://www.bilibili.com/video/BV1St411J7Ur?spm_id_from=333.999.0.0)

###  4.317. <a name='LongestUnivaluePath'></a>687. Longest Univalue Path

[花花酱](https://www.bilibili.com/video/BV1wt411r7Pr?spm_id_from=333.999.0.0)

###  4.318. <a name='KnightProbabilityinChessboard'></a>688. Knight Probability in Chessboard

[花花酱](https://www.bilibili.com/video/BV1Hb411c7mu?spm_id_from=333.999.0.0)

###  4.319. <a name='EmployeeImportance'></a>690. Employee Importance

[花花酱](https://www.bilibili.com/video/BV1Ut411J7uC?spm_id_from=333.999.0.0)

###  4.320. <a name='TopKFrequentWords'></a>692. Top K Frequent Words

[花花酱](https://www.bilibili.com/video/BV1Mt41137eL?spm_id_from=333.999.0.0)

###  4.321. <a name='-1'></a>695-岛屿的最大面积

[哈哈哈](https://www.bilibili.com/video/BV1s54y1B77k?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wz4y1R7e6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1k64y1c798?spm_id_from=333.999.0.0)

###  4.322. <a name='CountBinarySubstrings'></a>696 Count Binary Substrings

[小明](https://www.bilibili.com/video/BV14p4y1b7nV?spm_id_from=333.999.0.0)

###  4.323. <a name='FallingSquares'></a>699. Falling Squares

[花花酱](https://www.bilibili.com/video/BV1Lt41137EM?spm_id_from=333.999.0.0)

###  4.324. <a name='SearchinaBinarySearchTree'></a>700 Search in a Binary Search Tree

[小明](https://www.bilibili.com/video/BV14z411e76U?spm_id_from=333.999.0.0)

###  4.325. <a name='InsertintoaBinarySearchTree'></a>701 Insert into a Binary Search Tree

[小明](https://www.bilibili.com/video/BV1q54y1k76s?spm_id_from=333.999.0.0)

###  4.326. <a name='KthLargestElementinaStreamK'></a>703.Kth Largest Element in a Stream数据流中的第K大元素

[图灵](https://www.bilibili.com/video/BV1g5411w7o8?spm_id_from=333.999.0.0)

###  4.327. <a name='BinarySearch'></a>704.Binary Search二分查找

[图灵](https://www.bilibili.com/video/BV1Dh411v7yT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qa4y157E4?spm_id_from=333.999.0.0)

###  4.328. <a name='DesignHashSet'></a>705 Design HashSet

[小明](https://www.bilibili.com/video/BV1hV411z73p?spm_id_from=333.999.0.0)

###  4.329. <a name='DesignHashMap'></a>706. Design HashMap设计哈希映射

[图灵](https://www.bilibili.com/video/BV1Ho4y1Q7cr?spm_id_from=333.999.0.0)

###  4.330. <a name='DesignLinkedList'></a>707. Design Linked List

[花花酱](https://www.bilibili.com/video/BV1yW411Z7dV?spm_id_from=333.999.0.0)

###  4.331. <a name='MinimumASCIIDeleteSumforTwoStrings'></a>712. Minimum ASCII Delete Sum for Two Strings

[花花酱](https://www.bilibili.com/video/BV17W411d7m2?spm_id_from=333.999.0.0)

###  4.332. <a name='SubarrayProductLessThanK'></a>713 Subarray Product Less Than K

[小明](https://www.bilibili.com/video/BV1T5411j7tC?spm_id_from=333.999.0.0)

###  4.333. <a name='-1'></a>714-买卖股票的最佳时机含手续费

[哈哈哈](https://www.bilibili.com/video/BV1WK4y1E7mP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1t54y187Qy?spm_id_from=333.999.0.0)

###  4.334. <a name='RangeModule'></a>715. Range Module

[花花酱](https://www.bilibili.com/video/BV1jt411379W?spm_id_from=333.999.0.0)

###  4.335. <a name='FindK-thSmallestPairDistance'></a>719. Find K-th Smallest Pair Distance

[花花酱](https://www.bilibili.com/video/BV1zb411u7iP?spm_id_from=333.999.0.0)

###  4.336. <a name='LongestWordinDictionary'></a>720. Longest Word in Dictionary

[花花酱](https://www.bilibili.com/video/BV1vW411r75D?spm_id_from=333.999.0.0)

###  4.337. <a name='FindPivotIndex'></a>724. Find Pivot Index

[花花酱](https://www.bilibili.com/video/BV1KW411S7nG?spm_id_from=333.999.0.0)

###  4.338. <a name='SplitLinkedListinParts'></a>725. Split Linked List in Parts

[花花酱](https://www.bilibili.com/video/BV1KW411S7ti?spm_id_from=333.999.0.0)

###  4.339. <a name='NumberofAtoms'></a>726. Number of Atoms

[花花酱](https://www.bilibili.com/video/BV11W411U7KT?spm_id_from=333.999.0.0)

###  4.340. <a name='CountDifferentPalindromicSubsequences'></a>730. Count Different Palindromic Subsequences

[花花酱](https://www.bilibili.com/video/BV12W41167vQ?spm_id_from=333.999.0.0)

###  4.341. <a name='MyCalendarIII'></a>732. My Calendar III

[花花酱](https://www.bilibili.com/video/BV1fW411k75b?spm_id_from=333.999.0.0)

###  4.342. <a name='FloodFill'></a>733. 图像渲染 Flood Fill

[花花酱](https://www.bilibili.com/video/BV1yW41167S4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fp4y1v7Pn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1p7vH?spm_id_from=333.999.0.0)

###  4.343. <a name='AsteroidCollision'></a>735 Asteroid Collision

[小明](https://www.bilibili.com/video/BV1jT4y1F76n?spm_id_from=333.999.0.0)

###  4.344. <a name='SentenceSimilarityII'></a>737. Sentence Similarity II

[花花酱](https://www.bilibili.com/video/BV1qW41167iB?spm_id_from=333.999.0.0)

###  4.345. <a name='DailyTemperatures'></a>739-Daily Temperatures

[哈哈哈](https://www.bilibili.com/video/BV1Q7411L7w8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ov411z7rM?spm_id_from=333.999.0.0)

###  4.346. <a name='DeleteandEarn'></a>740. Delete and Earn

[24:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1xW41167b5?spm_id_from=333.999.0.0)

###  4.347. <a name='CherryPickup'></a>741. Cherry Pickup

[花花酱](https://www.bilibili.com/video/BV1tW41167jy?spm_id_from=333.999.0.0)

###  4.348. <a name='NetworkDelayTime'></a>743. Network Delay Time

[花花酱](https://www.bilibili.com/video/BV1UW411r7S8?spm_id_from=333.999.0.0)

###  4.349. <a name='PrefixandSuffixSearch'></a>745. Prefix and Suffix Search

[花花酱](https://www.bilibili.com/video/BV1TW411k7PY?spm_id_from=333.999.0.0)

###  4.350. <a name='MinCostClimbingStairs'></a>746. Min Cost Climbing Stairs

[7:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1VW411y7Dq?spm_id_from=333.999.0.0)

###  4.351. <a name='ShortestCompletingWord'></a>748. Shortest Completing Word

[花花酱](https://www.bilibili.com/video/BV15W411y7sJ?spm_id_from=333.999.0.0)

###  4.352. <a name='OpentheLock'></a>752. Open the Lock

[花花酱](https://www.bilibili.com/video/BV1NW411y74z?spm_id_from=333.999.0.0)

###  4.353. <a name='PartitionLabels'></a>763 Partition Labels

[小明](https://www.bilibili.com/video/BV1Ca4y177LW?spm_id_from=333.999.0.0)

###  4.354. <a name='CouplesHoldingHands'></a>765. 情侣牵手 Couples Holding Hands

[官方](https://www.bilibili.com/video/BV1pv411Y7wX?spm_id_from=333.999.0.0)

###  4.355. <a name='MaxChunksToMakeSorted'></a>769. Max Chunks To Make Sorted

[花花酱](https://www.bilibili.com/video/BV1LW411C7nD?spm_id_from=333.999.0.0)

###  4.356. <a name='JewelsandStones'></a>771 Jewels and Stones

[小明](https://www.bilibili.com/video/BV1RC4y1W7yH?spm_id_from=333.999.0.0)

###  4.357. <a name='SlidingPuzzle'></a>773. Sliding Puzzle

[花花酱](https://www.bilibili.com/video/BV1PW411o7g4?spm_id_from=333.999.0.0)

###  4.358. <a name='GlobalandLocalInversions'></a>775. Global and Local Inversions

[花花酱](https://www.bilibili.com/video/BV1JW411d75t?spm_id_from=333.999.0.0)

###  4.359. <a name='SwiminRisingWater'></a>778. Swim in Rising Water

[花花酱](https://www.bilibili.com/video/BV1ab411k7TH?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kv4y1f7to?spm_id_from=333.999.0.0)

###  4.360. <a name='LetterCasePermutation'></a>784. Letter Case Permutation

[花花酱](https://www.bilibili.com/video/BV1wW411o7WK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sv411a7Gx?spm_id_from=333.999.0.0)

###  4.361. <a name='-1'></a>785-判断二分图

[哈哈哈](https://www.bilibili.com/video/BV1KQ4y1N72Z?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11r4y1P7Wr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1254y1i7Ut?spm_id_from=333.999.0.0)

###  4.362. <a name='K-thSmallestPrimeFraction'></a>786. K-th Smallest Prime Fraction

[花花酱](https://www.bilibili.com/video/BV1AW411o7oi?spm_id_from=333.999.0.0)

###  4.363. <a name='CheapestFlightsWithinKStops'></a>787. Cheapest Flights Within K Stops

[花花酱](https://www.bilibili.com/video/BV13W411o7wc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DZ4y1H7oH?spm_id_from=333.999.0.0)

###  4.364. <a name='DominoandTrominoTiling'></a>790. Domino and Tromino Tiling

[花花酱](https://www.bilibili.com/video/BV13W411o7AW?spm_id_from=333.999.0.0)

###  4.365. <a name='NumberofMatchingSubsequences'></a>792. Number of Matching Subsequences

[花花酱](https://www.bilibili.com/video/BV13W411o7Af?spm_id_from=333.999.0.0)

###  4.366. <a name='AllPathsFromSourcetoTarget'></a>797 All Paths From Source to Target

[小明](https://www.bilibili.com/video/BV1qa4y1E7sg?spm_id_from=333.999.0.0)

###  4.367. <a name='ChampagneTower'></a>799 Champagne Tower

[小明](https://www.bilibili.com/video/BV1Da411A7u5?spm_id_from=333.999.0.0)

###  4.368. <a name='MinimumSwapsToMakeSequencesIncreasing'></a>801. Minimum Swaps To Make Sequences Increasing

[花花酱](https://www.bilibili.com/video/BV1FW411o7tL?spm_id_from=333.999.0.0) 

###  4.369. <a name='BricksFallingWhenHit'></a>803. Bricks Falling When Hit 

[花花酱](https://www.bilibili.com/video/BV13W411o7kA?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xv411W74B?spm_id_from=333.999.0.0)

###  4.370. <a name='UniqueMorseCodeWords'></a>804 Unique Morse Code Words

[小明](https://www.bilibili.com/video/BV1RD4y1Q7AM?spm_id_from=333.999.0.0)

###  4.371. <a name='LargestSumofAverages'></a>813. Largest Sum of Averages

[花花酱](https://www.bilibili.com/video/BV1XW411d7RB?spm_id_from=333.999.0.0)

###  4.372. <a name='BusRoutes'></a>815. Bus Routes

[花花酱](https://www.bilibili.com/video/BV1QW411d794?spm_id_from=333.999.0.0)

###  4.373. <a name='LinkedListComponents'></a>817. Linked List Components

[花花酱](https://www.bilibili.com/video/BV1cW411o7Eu?spm_id_from=333.999.0.0)

###  4.374. <a name='RaceCar'></a>818. Race Car (上)

[花花酱](https://www.bilibili.com/video/BV1cW411o7Tb?spm_id_from=333.999.0.0)

###  4.375. <a name='ShortestDistancetoaCharacter'></a>821 Shortest Distance to a Character

[小明](https://www.bilibili.com/video/BV1gy4y1Y784?spm_id_from=333.999.0.0)

###  4.376. <a name='BinaryTreesWithFactors'></a>823. Binary Trees With Factors

[花花酱](https://www.bilibili.com/video/BV1CW411d7RX?spm_id_from=333.999.0.0)

###  4.377. <a name='GoatLatin'></a>824 Goat Latin

[小明](https://www.bilibili.com/video/BV1Th411o782?spm_id_from=333.999.0.0)

###  4.378. <a name='MakingALargeIsland'></a>827. Making A Large Island

[花花酱](https://www.bilibili.com/video/BV1mW411d7rc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Cg4117727?spm_id_from=333.999.0.0)

###  4.379. <a name='FlippinganImage'></a>832 Flipping an Image

[小明](https://www.bilibili.com/video/BV1q54y1r7f3?spm_id_from=333.999.0.0)

###  4.380. <a name='ImageOverlap'></a>835 Image Overlap

[小明](https://www.bilibili.com/video/BV1NK4y1a7Yf?spm_id_from=333.999.0.0)

###  4.381. <a name='New21Game'></a>837. 新 21 点 New 21 Game

[官方](https://www.bilibili.com/video/BV1Sz4y197cA?spm_id_from=333.999.0.0)

###  4.382. <a name='KeysandRooms'></a>841 Keys and Rooms

[小明](https://www.bilibili.com/video/BV1Wb4y1Q7hE?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1HK411F7JQ?spm_id_from=333.999.0.0)

###  4.383. <a name='SplitArrayintoFibonacciSequence'></a>842. Split Array into Fibonacci Sequence

[花花酱](https://www.bilibili.com/video/BV1ZJ411H7t4?spm_id_from=333.999.0.0)

###  4.384. <a name='BackspaceStringCompare'></a>844 Backspace String Compare

[小明](https://www.bilibili.com/video/BV1aC4y1s7LK?spm_id_from=333.999.0.0)

###  4.385. <a name='LongestMountaininArray'></a>845 Longest Mountain in Array

[小明](https://www.bilibili.com/video/BV1zi4y1L7yV?spm_id_from=333.999.0.0)

###  4.386. <a name='ShortestPathVisitingAllNodes'></a>847 Shortest Path Visiting All Nodes

[花花酱](https://www.bilibili.com/video/BV1hW411d7MU?spm_id_from=333.999.0.0)

###  4.387. <a name='MaximizeDistancetoClosestPerson'></a>849 Maximize Distance to Closest Person

[小明](https://www.bilibili.com/video/BV1ZZ4y1G7iT?spm_id_from=333.999.0.0)

###  4.388. <a name='ScoreofParentheses'></a>856. Score of Parentheses

[花花酱](https://www.bilibili.com/video/BV1bW411d7gp?spm_id_from=333.999.0.0)

###  4.389. <a name='MirrorReflection'></a>858 Mirror Reflection

[小明](https://www.bilibili.com/video/BV1av411r7MW?spm_id_from=333.999.0.0)

###  4.390. <a name='BuddyStrings'></a>859 Buddy Strings

[小明](https://www.bilibili.com/video/BV1nz4y1o7Wo?spm_id_from=333.999.0.0)

###  4.391. <a name='AllNodesDistanceKinBinaryTree'></a>863. All Nodes Distance K in Binary Tree

[花花酱](https://www.bilibili.com/video/BV14W411d7mz?spm_id_from=333.999.0.0)

###  4.392. <a name='ShortestPathtoGetAllKeys'></a>864. Shortest Path to Get All Keys

[花花酱](https://www.bilibili.com/video/BV1LW411d7th?spm_id_from=333.999.0.0)

###  4.393. <a name='ReorderedPowerof2'></a>869 Reordered Power of 2

[小明](https://www.bilibili.com/video/BV1M64y1D78v?spm_id_from=333.999.0.0)

###  4.394. <a name='SmallestSubtreewithalltheDeepestNodes'></a>865. Smallest Subtree with all the Deepest Nodes

[花花酱](https://www.bilibili.com/video/BV14W411d7ZR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CV41187ZA?spm_id_from=333.999.0.0)

###  4.395. <a name='MinimumNumberofRefuelingStops'></a>871. Minimum Number of Refueling Stops

[花花酱](https://www.bilibili.com/video/BV1JW411d7VK?spm_id_from=333.999.0.0)

###  4.396. <a name='LengthofLongestFibonacciSubsequence'></a>873. Length of Longest Fibonacci Subsequence

[花花酱](https://www.bilibili.com/video/BV1jW411d79H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ab411i7wx?spm_id_from=333.999.0.0)

###  4.397. <a name='KokoEatingBananas'></a>875.Koko Eating Bananas科科吃香蕉

[图灵](https://www.bilibili.com/video/BV1iV411s7eU?spm_id_from=333.999.0.0)

###  4.398. <a name='MiddleoftheLinkedList'></a>876.Middle of the Linked List 链表的中间结点

[图灵](https://www.bilibili.com/video/BV1Kv411p7vf?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Pz41187WS?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK411T74X?spm_id_from=333.999.0.0)

###  4.399. <a name='StoneGame'></a>877 Stone Game

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Hr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xq4y1Q7uL?spm_id_from=333.999.0.0)

###  4.400. <a name='ProfitableSchemes'></a>879. Profitable Schemes

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Jt?spm_id_from=333.999.0.0)

###  4.401. <a name='DecodedStringatIndex'></a>880 Decoded String at Index

[小明](https://www.bilibili.com/video/BV1Tt4y1k7GJ?spm_id_from=333.999.0.0)

###  4.402. <a name='BoatstoSavePeople'></a>881 Boats to Save People

[小明](https://www.bilibili.com/video/BV1MT4y1K7yq?spm_id_from=333.999.0.0)

###  4.403. <a name='ReachableNodesInSubdividedGraph'></a>882. Reachable Nodes In Subdivided Graph

[花花酱](https://www.bilibili.com/video/BV11W411Z71N?spm_id_from=333.999.0.0)

###  4.404. <a name='PossibleBipartition'></a>886. Possible Bipartition

[花花酱](https://www.bilibili.com/video/BV1DW411Z7G6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FT4y1g77u?spm_id_from=333.999.0.0)

###  4.405. <a name='SuperEggDrop'></a>887. Super Egg Drop

[花花酱](https://www.bilibili.com/video/BV1Tv411i7cP?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ri4y1t78d?spm_id_from=333.999.0.0)

###  4.406. <a name='ConstructBinaryTreefromPreorderandPostorder'></a>889. Construct Binary Tree from Preorder and Postorder

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Qi?spm_id_from=333.999.0.0)

###  4.407. <a name='SumofSubsequenceWidths'></a>891. Sum of Subsequence Widths

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Yv?spm_id_from=333.999.0.0)

###  4.408. <a name='AllPossibleFullBinaryTrees'></a>894. All Possible Full Binary Trees

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Sb?spm_id_from=333.999.0.0)

###  4.409. <a name='MaximumFrequencyStack'></a>895. Maximum Frequency Stack

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Hp?spm_id_from=333.999.0.0)

###  4.410. <a name='BitwiseORsofSubarrays'></a>898. Bitwise ORs of Subarrays

[花花酱](https://www.bilibili.com/video/BV1kW411Z7HV?spm_id_from=333.999.0.0)

###  4.411. <a name='OnlineStockSpan'></a>901. Online Stock Span

[花花酱](https://www.bilibili.com/video/BV1kW411k77K?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Jg4y1B74H?spm_id_from=333.999.0.0)

###  4.412. <a name='NumbersAtMostNGivenDigitSet'></a>902 Numbers At Most N Given Digit Set

[小明](https://www.bilibili.com/video/BV19A411j7Wf?spm_id_from=333.999.0.0)

###  4.413. <a name='-1'></a>904-水果成篮

[哈哈哈](https://www.bilibili.com/video/BV19i4y1M7Xn?spm_id_from=333.999.0.0)

###  4.414. <a name='SortArrayByParity'></a>905 Sort Array By Parity

[小明](https://www.bilibili.com/video/BV1Xk4y117rK?spm_id_from=333.999.0.0)

###  4.415. <a name='SuperPalindromes'></a>906 Super Palindromes

[小明](https://www.bilibili.com/video/BV1LA41157Wf?spm_id_from=333.999.0.0)

###  4.416. <a name='SnakesandLadders'></a>909. Snakes and Ladders

[小梦想家](https://www.bilibili.com/video/BV1cy4y1W7u9?spm_id_from=333.999.0.0)

###  4.417. <a name='SmallestRangeII'></a>910 Smallest Range II

[小明](https://www.bilibili.com/video/BV1p5411H7mS?spm_id_from=333.999.0.0)

###  4.418. <a name='WordSubsetse'></a>916 Word Subsetse

[小明](https://www.bilibili.com/video/BV1vh411S7r3?spm_id_from=333.999.0.0)

###  4.419. <a name='MaximumSumCircularSub'></a>918 Maximum Sum Circular Sub

[小明](https://www.bilibili.com/video/BV1c5411s7jZ?spm_id_from=333.999.0.0)

###  4.420. <a name='SumWithMultiplicity'></a>923. 3Sum With Multiplicity 

[花花酱](https://www.bilibili.com/video/BV14t411o7QT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pv41187sq?spm_id_from=333.999.0.0)

###  4.421. <a name='FlipStringtoMonotoneIncreasing'></a>926. Flip String to Monotone Increasing

[花花酱](https://www.bilibili.com/video/BV1ft411R7qv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Vh411i7Wg?spm_id_from=333.999.0.0)

###  4.422. <a name='-1'></a>930-和相同的二元子数组(滑动窗口+前缀和)

[哈哈哈](https://www.bilibili.com/video/BV1iy4y1T7M3?spm_id_from=333.999.0.0)

###  4.423. <a name='NumberofRecentCalls'></a>933 Number of Recent Calls

[小明](https://www.bilibili.com/video/BV1gA41177jm?spm_id_from=333.999.0.0)

###  4.424. <a name='ShortestBridge'></a>934. Shortest Bridge

[花花酱](https://www.bilibili.com/video/BV19t411y7rL?spm_id_from=333.999.0.0)

###  4.425. <a name='StampingTheSequence'></a>936 Stamping The Sequence

[小明](https://www.bilibili.com/video/BV1d64y1D7fq?spm_id_from=333.999.0.0)

###  4.426. <a name='RangeSumofBST'></a>938 Range Sum of BST

[小明](https://www.bilibili.com/video/BV1WV411a7VR?spm_id_from=333.999.0.0)

###  4.427. <a name='ValidMountainArray'></a>941 Valid Mountain Array

[小明](https://www.bilibili.com/video/BV1n5411G7qs?spm_id_from=333.999.0.0)

###  4.428. <a name='FindtheShortestSuperstring'></a>943. Find the Shortest Superstring

[花花酱](https://www.bilibili.com/video/BV1yt411171k?spm_id_from=333.999.0.0)

###  4.429. <a name='Python-'></a>946-Python-栈的压入、弹出序列

[哈哈哈](https://www.bilibili.com/video/BV1JD4y1o7ZD?spm_id_from=333.999.0.0)

###  4.430. <a name='ValidateStackSequences'></a>946 Validate Stack Sequences

[小明](https://www.bilibili.com/video/BV1fz4y1y7rS?spm_id_from=333.999.0.0)

###  4.431. <a name='MostStonesRemovedwithSame'></a>947. 移除最多的同行或同列石头 Most Stones Removed with Same

[官方](https://www.bilibili.com/video/BV1Nr4y1K7Gj?spm_id_from=333.999.0.0)

###  4.432. <a name='BagofTokens'></a>948 Bag of Tokens

[小明](https://www.bilibili.com/video/BV1MK411P7K6?spm_id_from=333.999.0.0)

###  4.433. <a name='LargestTimeforGivenDigits'></a>949 Largest Time for Given Digits

[小明](https://www.bilibili.com/video/BV13v41117QS?spm_id_from=333.999.0.0)

###  4.434. <a name='LargestComponentSizebyCommo'></a>952 Largest Component Size by Commo

[小明](https://www.bilibili.com/video/BV1oK4y1h7Jt?spm_id_from=333.999.0.0)

###  4.435. <a name='VerifyinganAlienDictionary'></a>953 Verifying an Alien Dictionary

[小明](https://www.bilibili.com/video/BV1C64y1S7tT?spm_id_from=333.999.0.0)

###  4.436. <a name='ArrayofDoubledPairs'></a>954 Array of Doubled Pairs

[小明](https://www.bilibili.com/video/BV1Hq4y1S7xR?spm_id_from=333.999.0.0)

###  4.437. <a name='RegionsCutBySlashes'></a>959. 由斜杠划分区域 Regions Cut By Slashes

[官方](https://www.bilibili.com/video/BV1Ry4y117HD?spm_id_from=333.999.0.0)

###  4.438. <a name='LeastOperatorstoExpressNumber'></a>964. Least Operators to Express Number

[花花酱](https://www.bilibili.com/video/BV1Pt411k7qn?spm_id_from=333.999.0.0)

###  4.439. <a name='VowelSpellchecker'></a>966 Vowel Spellchecker

[小明](https://www.bilibili.com/video/BV1oK4y1T7kR?spm_id_from=333.999.0.0)

###  4.440. <a name='NumbersWithSameConsecutiveDifferences'></a>967. Numbers With Same Consecutive Differences

[花花酱](https://www.bilibili.com/video/BV1gt411B7oG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

###  4.441. <a name='BinaryTreeCameras'></a>968 Binary Tree Cameras

[小明](https://www.bilibili.com/video/BV1Q5411u72B?spm_id_from=333.999.0.0)

###  4.442. <a name='PancakeSorting'></a>969 Pancake Sorting

[小明](https://www.bilibili.com/video/BV1hk4y127yJ?spm_id_from=333.999.0.0)

###  4.443. <a name='FlipBinaryTreeToMatchPreorder'></a>971 Flip Binary Tree To Match Preorder

[小明](https://www.bilibili.com/video/BV1NB4y1P7qL?spm_id_from=333.999.0.0)

###  4.444. <a name='KClosestPointstoOrigin'></a>973 K Closest Points to Origin

[小明](https://www.bilibili.com/video/BV1Vf4y1278J?spm_id_from=333.999.0.0)

###  4.445. <a name='KSubarraySumsDivisiblebyK'></a>974. 和可被 K 整除的子数组 Subarray Sums Divisible by K 

[官方](https://www.bilibili.com/video/BV19z4y1X79a?spm_id_from=333.999.0.0)

###  4.446. <a name='OddEvenJump'></a>975. Odd Even Jump

[花花酱](https://www.bilibili.com/video/BV1pt411p7M4?spm_id_from=333.999.0.0)

###  4.447. <a name='MiddleoftheLinkedList-1'></a>976 Middle of the Linked List

[小明](https://www.bilibili.com/video/BV1N5411t7Xm?spm_id_from=333.999.0.0)

###  4.448. <a name='SquaresofaSortedArray'></a>977 Squares of a Sorted Array

[小明](https://www.bilibili.com/video/BV1EX4y1u7Mb?spm_id_from=333.999.0.0)

###  4.449. <a name='LongestTurbulentSubarray'></a>978. 最长湍流子数组 Longest Turbulent Subarray 

[官方](https://www.bilibili.com/video/BV1PV411i73Y?spm_id_from=333.999.0.0)

###  4.450. <a name='UniquePathsIII'></a>980. Unique Paths III 

[花花酱](https://www.bilibili.com/video/BV1yt41187Si?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oK4y1a7Qp?spm_id_from=333.999.0.0)

###  4.451. <a name='MinimumCostForTickets'></a>983 Minimum Cost For Tickets

[小明](https://www.bilibili.com/video/BV1Wz4y1f7hG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1WK4y1t7pP?spm_id_from=333.999.0.0)

###  4.452. <a name='IntervalListIntersections'></a>986 Interval List Intersections

[小明](https://www.bilibili.com/video/BV1wg4y1z7Xz?spm_id_from=333.999.0.0)

###  4.453. <a name='VerticalOrderTraversalofaBinary'></a>987 Vertical Order Traversal of a Binary

[小明](https://www.bilibili.com/video/BV1yZ4y1M7CL?spm_id_from=333.999.0.0)

###  4.454. <a name='SatisfiabilityofEqualityEquations'></a>990. 等式方程的可满足性 Satisfiability of Equality Equations 

[官方](https://www.bilibili.com/video/BV1gz411i7kD?spm_id_from=333.999.0.0)

###  4.455. <a name='K-1'></a>992-K 个不同整数的子数组

[哈哈哈](https://www.bilibili.com/video/BV1t44y1q7th?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xy4y1Y7GL?spm_id_from=333.999.0.0)

###  4.456. <a name='-1'></a>993. 二叉树的堂兄弟节点

[小明](https://www.bilibili.com/video/BV17t4y11725?spm_id_from=333.999.0.0)

###  4.457. <a name='-1'></a>994-腐烂的橘子

[哈哈哈](https://www.bilibili.com/video/BV1Yp4y1D7Kg?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1bB4y1A7tG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qk4y1m7fz?spm_id_from=333.999.0.0)

###  4.458. <a name='-1'></a>993, 994, 995, 996

[花花酱](https://www.bilibili.com/video/BV1bb41117PB?spm_id_from=333.999.0.0)

###  4.459. <a name='FindtheTownJudge'></a>997 Find the Town Judge

[小明](https://www.bilibili.com/video/BV1Ka4y1i7Qt?spm_id_from=333.999.0.0)

###  4.460. <a name='MinimumCosttoMergeStones'></a>1000. Minimum Cost to Merge Stones

[花花酱](https://www.bilibili.com/video/BV1db411v7DG?spm_id_from=333.999.0.0)

###  4.461. <a name='GridIllumination'></a>1001 Grid Illumination

[小明](https://www.bilibili.com/video/BV1NT4y1V7Vk?spm_id_from=333.999.0.0)

###  4.462. <a name='III-1'></a>1004-最大连续1的个数 III

[哈哈哈](https://www.bilibili.com/video/BV1Zg411L7Qu?spm_id_from=333.999.0.0)

###  4.463. <a name='MinimumDominoRotationsForEq'></a>1007 Minimum Domino Rotations For Eq

[小明](https://www.bilibili.com/video/BV1br4y1w7TM?spm_id_from=333.999.0.0)

###  4.464. <a name='ConstructBinarySearchTreefrom'></a>1008 Construct Binary Search Tree from

[小明](https://www.bilibili.com/video/BV1yk4y1R7oF?spm_id_from=333.999.0.0)

###  4.465. <a name='ComplementofBase10Integer'></a>1009 Complement of Base 10 Integer

[小明](https://www.bilibili.com/video/BV1oK4y187ZM?spm_id_from=333.999.0.0)

###  4.466. <a name='PairsofSongsWithTotalDurations'></a>1010 Pairs of Songs With Total Durations 

[小明](https://www.bilibili.com/video/BV1t64y1f7hc?spm_id_from=333.999.0.0)

###  4.467. <a name='PartitionArrayIntoThreePartsWithEqu'></a>1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ

[官方](https://www.bilibili.com/video/BV1ZK4y1t7Sf?spm_id_from=333.999.0.0)

###  4.468. <a name='SmallestIntegerDivisiblebyK'></a>1015 Smallest Integer Divisible by K

[小明](https://www.bilibili.com/video/BV1PZ4y1G7iU?spm_id_from=333.999.0.0)

###  4.469. <a name='NextGreaterNodeInLinkedList'></a>1019. Next Greater Node In Linked List

[花花酱](https://www.bilibili.com/video/BV12b411s77J?spm_id_from=333.999.0.0)

###  4.470. <a name='SumofRootToLeafBinaryNumbers'></a>1022 Sum of Root To Leaf Binary Numbers

[小明](https://www.bilibili.com/video/BV11A411E7AN?spm_id_from=333.999.0.0)

###  4.471. <a name='-1'></a>1025,1026,1027,1028

[花花酱](https://www.bilibili.com/video/BV1Nb411j7qr?spm_id_from=333.999.0.0)

###  4.472. <a name='VideoStitching'></a>1024. Video Stitching

[花花酱](https://www.bilibili.com/video/BV1kb411u7Qk?spm_id_from=333.999.0.0)

###  4.473. <a name='MaximumDifferenceBetweenNod'></a>1026 Maximum Difference Between Nod

[小明](https://www.bilibili.com/video/BV1fi4y157ZS?spm_id_from=333.999.0.0)

###  4.474. <a name='TwoCityScheduling'></a>1029 Two City Scheduling

[小明](https://www.bilibili.com/video/BV1t54y1Q7G8?spm_id_from=333.999.0.0)

###  4.475. <a name='StreamofCharacters'></a>1032 Stream of Characters

[小明](https://www.bilibili.com/video/BV15T4y1L7RG?spm_id_from=333.999.0.0)

###  4.476. <a name='UncrossedLines'></a>1035 Uncrossed Lines

[小明](https://www.bilibili.com/video/BV1si4y1s79e?spm_id_from=333.999.0.0)

###  4.477. <a name='RobotBoundedInCircle'></a>1041 Robot Bounded In Circle

[小明](https://www.bilibili.com/video/BV1dk4y1y7RH?spm_id_from=333.999.0.0)

###  4.478. <a name='PartitionArrayforMaximumSum'></a>1043. Partition Array for Maximum Sum

[花花酱](https://www.bilibili.com/video/BV154411J7so?spm_id_from=333.999.0.0)

###  4.479. <a name='LongestDuplicateSubstring'></a>1044 Longest Duplicate Substring

[小明](https://www.bilibili.com/video/BV1Kv411B7a3?spm_id_from=333.999.0.0)

###  4.480. <a name='LastStoneWeight'></a>1046 Last Stone Weight

[小明](https://www.bilibili.com/video/BV1w54y197Ln?spm_id_from=333.999.0.0)

###  4.481. <a name='LongestStringChain'></a>1048 Longest String Chain

[小明](https://www.bilibili.com/video/BV17K4y1G7et?spm_id_from=333.999.0.0)



###  4.482. <a name='ShortestWaytoFormString'></a>1055.Shortest Way to Form String 形成字符串的最短路径

[图灵](https://www.bilibili.com/video/BV1SZ4y1G7WX?spm_id_from=333.999.0.0)

###  4.483. <a name='-1'></a>1091-二进制矩阵中的最短路径

[哈哈哈](https://www.bilibili.com/video/BV17k4y1r7EP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ro4y197kU?spm_id_from=333.999.0.0)

###  4.484. <a name='CarPooling'></a>1094 Car Pooling

[小明](https://www.bilibili.com/video/BV1Xk4y1k7UX?spm_id_from=333.999.0.0)

###  4.485. <a name='FindinMountainArray'></a>1095. Find in Mountain Array

[花花酱](https://www.bilibili.com/video/BV1m5411V7x7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK4115778?spm_id_from=333.999.0.0)

###  4.486. <a name='FillingBookcaseShelves'></a>1105. Filling Bookcase Shelves

[花花酱](https://www.bilibili.com/video/BV1Mx411X7Ks?spm_id_from=333.999.0.0)

###  4.487. <a name='ParsingABooleanExpression'></a>1106. Parsing A Boolean Expression

[花花酱](https://www.bilibili.com/video/BV1Cx411X7aF?spm_id_from=333.999.0.0)

###  4.488. <a name='DeleteNodesAndReturnForest'></a>1110. Delete Nodes And Return Forest

[花花酱](https://www.bilibili.com/video/BV1u4411977H?spm_id_from=333.999.0.0)

###  4.489. <a name='MaximumNestingDepthofTwoValidParentheses'></a>1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses

[官方](https://www.bilibili.com/video/BV11a4y1v7Bb?spm_id_from=333.999.0.0)

###  4.490. <a name='threading'></a>1114 - 1115 - 1116 - 多线程 threading

[花花酱](https://www.bilibili.com/video/BV12t411P79a?spm_id_from=333.999.0.0)

###  4.491. <a name='LowestCommonAncestorofDeepestLeaves'></a>1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖

[小明](https://www.bilibili.com/video/BV16f4y1q7eA?spm_id_from=333.999.0.0)

###  4.492. <a name='LongestWell-PerformingInterval'></a>1124. Longest Well-Performing Interval

[花花酱](https://www.bilibili.com/video/BV1Et41157Jw?spm_id_from=333.999.0.0)

###  4.493. <a name='SmallestSufficientTeam'></a>1125. Smallest Sufficient Team

[花花酱](https://www.bilibili.com/video/BV14t411G7WL?spm_id_from=333.999.0.0)

###  4.494. <a name='NumberofEquivalentDominoPairs'></a>1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs

[官方](https://www.bilibili.com/video/BV1fV411q7ZY?spm_id_from=333.999.0.0)

###  4.495. <a name='ShortestPathwithAlternatingColors'></a>1129. Shortest Path with Alternating Colors

[花花酱](https://www.bilibili.com/video/BV1Et411J7Dh?spm_id_from=333.999.0.0)

###  4.496. <a name='N-thTribonacciNumber'></a>1137. N-th Tribonacci Number

[3:55 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

###  4.497. <a name='StoneGameII'></a>1140. Stone Game II

[花花酱](https://www.bilibili.com/video/BV1Gt411c7hM?spm_id_from=333.999.0.0)

###  4.498. <a name='LongestCommonSubsequence'></a>1143 Longest Common Subsequence

[小明](https://www.bilibili.com/video/BV19Z4y1W7Xi?spm_id_from=333.999.0.0)

###  4.499. <a name='BinaryTreeColoringGame'></a>1145. Binary Tree Coloring Game

[花花酱](https://www.bilibili.com/video/BV1ft411K7Gf?spm_id_from=333.999.0.0)

###  4.500. <a name='NumberofDiceRollsWithTargetSum'></a>1155. Number of Dice Rolls With Target Sum

[花花酱](https://www.bilibili.com/video/BV1t4411Q7JN?spm_id_from=333.999.0.0)

###  4.501. <a name='FindWordsThatCanBeFormedbyCharacters'></a>1160. 拼写单词 Find Words That Can Be Formed by Characters 

[官方](https://www.bilibili.com/video/BV1Lt4y1Q7Yx?spm_id_from=333.999.0.0)

###  4.502. <a name='DinnerPlateStacks'></a>1172. Dinner Plate Stacks

[花花酱](https://www.bilibili.com/video/BV1E4411z7xb?spm_id_from=333.999.0.0)

###  4.503. <a name='NumberofValidWordsforEachPuzzle'></a>1178. Number of Valid Words for Each Puzzle

[花花酱](https://www.bilibili.com/video/BV1x441117vz?spm_id_from=333.999.0.0)

###  4.504. <a name='MakeArrayStrictlyIncreasing'></a>1187. Make Array Strictly Increasing

[花花酱](https://www.bilibili.com/video/BV1sJ411N7jD?spm_id_from=333.999.0.0)

###  4.505. <a name='K-ConcatenationMaximumSum'></a>1191. K-Concatenation Maximum Sum

[花花酱](https://www.bilibili.com/video/BV1AJ411w756?spm_id_from=333.999.0.0)

###  4.506. <a name='UglyNumberIII'></a>1201. Ugly Number III

[花花酱](https://www.bilibili.com/video/BV1QJ411M7Jx?spm_id_from=333.999.0.0)

###  4.507. <a name='SmallestStringWithSwaps'></a>1202. Smallest String With Swaps

[花花酱](https://www.bilibili.com/video/BV1PJ411T7Wq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Yh41127VH?spm_id_from=333.999.0.0)

###  4.508. <a name='SortItemsbyGroupsRespectingDependencies'></a>1203. 项目管理 Sort Items by Groups Respecting Dependencies

[官方](https://www.bilibili.com/video/BV1iy4y1m7ye?spm_id_from=333.999.0.0)

###  4.509. <a name='DesignSkiplist'></a>1206. Design Skiplist 

[花花酱](https://www.bilibili.com/video/BV1kT4y1F7Nr?spm_id_from=333.999.0.0)

###  4.510. <a name='RemoveAllAdjacentDuplicatesin'></a>1209 Remove All Adjacent Duplicates in 

[小明](https://www.bilibili.com/video/BV1qA411L7z9?spm_id_from=333.999.0.0)

###  4.511. <a name='MinimumCosttoMoveChips'></a>1217 Minimum Cost to Move Chips

[小明](https://www.bilibili.com/video/BV1zt4y1e7fK?spm_id_from=333.999.0.0)

###  4.512. <a name='LongestArithmeticSubsequenceofGivenDifference'></a>1218. Longest Arithmetic Subsequence of Given Difference

[花花酱](https://www.bilibili.com/video/BV1tE411f73y?spm_id_from=333.999.0.0)

###  4.513. <a name='CountVowelsPermutation'></a>1220. Count Vowels Permutation

[花花酱](https://www.bilibili.com/video/BV1FJ411c7pT?spm_id_from=333.999.0.0)

###  4.514. <a name='DiceRollSimulation'></a>1223 Dice Roll Simulation

[花花酱](https://www.bilibili.com/video/BV17E411k7PR?spm_id_from=333.999.0.0)

###  4.515. <a name='TilingaRectanglewiththeFewestSquares'></a>1240 Tiling a Rectangle with the Fewest Squares

[花花酱](https://www.bilibili.com/video/BV1UE411t7Gb?spm_id_from=333.999.0.0)

###  4.516. <a name='-1'></a>1248-统计「优美子数组」

[哈哈哈](https://www.bilibili.com/video/BV1FU4y1H76T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wk4y1r7t7?spm_id_from=333.999.0.0)

###  4.517. <a name='MinimumRemovetoMakeValidPare'></a>1249 Minimum Remove to Make Valid Pare

[小明](https://www.bilibili.com/video/BV1wK4y1X7G7?spm_id_from=333.999.0.0)

###  4.518. <a name='-1'></a>1252 1253 1254 1255

[花花酱](https://www.bilibili.com/video/BV1kE411Y7rg?spm_id_from=333.999.0.0)

###  4.519. <a name='MinimumMovestoMoveaBoxtoTheirTarget'></a>1263. Minimum Moves to Move a Box to Their Target

[花花酱](https://www.bilibili.com/video/BV1AJ411Q7B6?spm_id_from=333.999.0.0)

###  4.520. <a name='-1'></a>1277-统计全为1的正方形子矩阵

[哈哈哈](https://www.bilibili.com/video/BV1nk4y1k7vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Kp4y1X7n4?spm_id_from=333.999.0.0)

###  4.521. <a name='PalindromePartitioningIII'></a>1278. Palindrome Partitioning III

[花花酱](https://www.bilibili.com/video/BV1HJ411q7nc?spm_id_from=333.999.0.0)

###  4.522. <a name='FindtheSmallestDivisorGivena'></a>1283 Find the Smallest Divisor Given a

[小明](https://www.bilibili.com/video/BV1Fv411r7Nw?spm_id_from=333.999.0.0)

###  4.523. <a name='MinimumNumberofFlipstoConvertBinaryMatrix'></a>1284. Minimum Number of Flips to Convert Binary Matrix

[花花酱](https://www.bilibili.com/video/BV1nJ411y7m1?spm_id_from=333.999.0.0)

###  4.524. <a name='ConvertBinaryNumberinaLinkedList'></a>1290. 二进制链表转整数 (Convert Binary Number in a Linked List

[洛阳](https://www.bilibili.com/video/BV1kc411h7Rs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nD4y1R7QH?spm_id_from=333.999.0.0)

###  4.525. <a name='SequentialDigits'></a>1291 Sequential Digits

[小明](https://www.bilibili.com/video/BV11v411C7so?spm_id_from=333.999.0.0)

###  4.526. <a name='ShortestPathinaGridwithObstaclesElimination'></a>1293. Shortest Path in a Grid with Obstacles Elimination

[花花酱](https://www.bilibili.com/video/BV1VJ411k72A?spm_id_from=333.999.0.0)

###  4.527. <a name='DivideArrayinSetsofKConsecutiveNumbers'></a>1296. Divide Array in Sets of K Consecutive Numbers

[花花酱](https://www.bilibili.com/video/BV1gJ411e7cS?spm_id_from=333.999.0.0)

###  4.528. <a name='NumberofPathswithMaxScore'></a>1301. Number of Paths with Max Score

[花花酱](https://www.bilibili.com/video/BV1pJ411a7ry?spm_id_from=333.999.0.0)

###  4.529. <a name='DeepestLeavesSum'></a>1302 Deepest Leaves Sum

[小明](https://www.bilibili.com/video/BV1Bb4y1D7Cp?spm_id_from=333.999.0.0)

###  4.530. <a name='AllElementsinTwoBinarySearch'></a>1305 All Elements in Two Binary Search

[小明](https://www.bilibili.com/video/BV1kK411N7az?spm_id_from=333.999.0.0)

###  4.531. <a name='JumpGameIII'></a>1306 Jump Game III

[小明](https://www.bilibili.com/video/BV13y4y1q7Gi?spm_id_from=333.999.0.0)

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0:
            return True

        n = len(arr)
        used = {start}
        q = collections.deque([start])

        while len(q) > 0:
            u = q.popleft()
            for v in [u + arr[u], u - arr[u]]:
                if 0 <= v < n and v not in used:
                    if arr[v] == 0:
                        return True
                    q.append(v)
                    used.add(v)
        
        return False

```

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(site, n):
            if flag[0]:
                return
            if arr[site] == 0:
                flag[0] = True
                return
            see[site] = True
            for next_site in (site+arr[site], site-arr[site]):
                if 0 <= next_site < n and see[next_site] == False:
                    dfs(next_site, n)
        n = len(arr)
        flag = [False]
        see = [False] * n
        dfs(start, n)
        return flag[0]
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()

        def dfs(index):
            if index in seen:
                return False

            seen.add(index)
            if index < 0 or index >= len(arr):
                return False

            if arr[index] == 0:
                return True

            return dfs(index + arr[index]) or dfs(index - arr[index])

        return dfs(start)
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()
        queue = [(start, 0)]

        while queue:
            index, step = queue.pop(0)

            if index in seen:
                continue

            seen.add(index)

            if index < 0 or index >= len(arr):
                continue

            if arr[index] == 0:
                return True

            queue.extend([(index + arr[index], step+1), (index - arr[index], step+1)])

        return False

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(index,d):
            if index<0 or index>=len(arr) or len(d)!=len(set(d)):return False
            if arr[index]==0:return True
            return dfs(index+arr[index],d+[index+arr[index]]) or  dfs(index-arr[index],d+[index-arr[index]])
        return dfs(start,[start])

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start]==0:return True
        q=collections.deque([start])
        visited={start}
        while q:
            node=q.popleft()
            for n in [node+arr[node],node-arr[node]]:
                if 0<=n<len(arr) and n not in visited:
                    if arr[n]==0:return True
                    q.append(n)
                    visited.add(n)
        return False

bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        q, v, n = [start], {start}, len(arr)
        while q:
            p = []
            for i in q:
                if not arr[i]:
                    return True
                for j in i - arr[i], i + arr[i]:
                    if 0 <= j < n and j not in v:
                        p.append(j)
                        v.add(j)
            q = p
        return False
dfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        n, v = len(arr), set()
        def f(i):
            if not arr[i]:
                return True
            elif i not in v:
                v.add(i)
                return 0 <= i - arr[i] < n and f(i - arr[i]) or 0 <= i + arr[i] < n and f(i + arr[i])
        return f(start)

python bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        l, mark, queue= len(arr), [1 for i in range(len(arr))], [start]
        while len(queue)!=0:
            n = len(queue)
            for i in range(n):
                tmp = queue.pop()
                if arr[tmp]==0:
                    return True
                mark[tmp] = 0
                for cur in tmp+arr[tmp], tmp-arr[tmp]:
                    if 0<=cur<l and mark[cur]:
                        queue.insert(0, cur)
        return False
```

###  4.532. <a name='XORQueriesofaSubarray'></a>1310. XOR Queries of a Subarray

[花花酱](https://www.bilibili.com/video/BV1oJ411L78Y?spm_id_from=333.999.0.0)

###  4.533. <a name='MinimumInsertionStepstoMakeaStringPalindrom'></a>1312. Minimum Insertion Steps to Make a String Palindrom

[花花酱](https://www.bilibili.com/video/BV1HJ411L7b2?spm_id_from=333.999.0.0)

###  4.534. <a name='MinimumDistancetoTypeaWordUsingTwoFinger'></a>1320. Minimum Distance to Type a Word Using Two Finger

[花花酱](https://www.bilibili.com/video/BV11J411n7fN?spm_id_from=333.999.0.0)

###  4.535. <a name='SorttheMatrixDiagonally'></a>1329 Sort the Matrix Diagonally

[小明](https://www.bilibili.com/video/BV1hU4y147b1?spm_id_from=333.999.0.0)

###  4.536. <a name='RemovePalindromicSubsequences'></a>1332 Remove Palindromic Subsequences

[小明](https://www.bilibili.com/video/BV1tK4y1D7aV?spm_id_from=333.999.0.0)

###  4.537. <a name='FindtheCityWithSmallestNumberofNeighbors'></a>1334. Find the City With Smallest Number of Neighbors

[花花酱](https://www.bilibili.com/video/BV1b7411z7Tb?spm_id_from=333.999.0.0)

###  4.538. <a name='MinimumDifficultyofaJobSchedule'></a>1335. Minimum Difficulty of a Job Schedule

[花花酱](https://www.bilibili.com/video/BV1K7411r7xj?spm_id_from=333.999.0.0)

###  4.539. <a name='TheKWeakestRowsinaMatrix'></a>1337 The K Weakest Rows in a Matrix

[小明](https://www.bilibili.com/video/BV1bX4y157ju?spm_id_from=333.999.0.0)

###  4.540. <a name='MaximumProductofSplitt'></a>1339 Maximum Product of Splitt

[小明](https://www.bilibili.com/video/BV1Ch411i7yS?spm_id_from=333.999.0.0)

###  4.541. <a name='JumpGameV'></a>1340. Jump Game V

[花花酱](https://www.bilibili.com/video/BV1h7411W7wS?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        pathdic = defaultdict(list)
        n = len(arr)
        if n<=1: return n
        indegrees = [0]*n
        for i in range(n):
            for j in range(i+1,n):
                if arr[j]<arr[i] and j-i<=d:
                    pathdic[i].append(j)
                    indegrees[j] += 1
                else:
                    break
            for j in range(i-1, -1, -1):
                if arr[j]<arr[i] and i-j<=d:
                    pathdic[i].append(j)
                    indegrees[j] += 1
                else:
                    break
        # 拓扑排序
        queue = Deque()
        for i,degree in enumerate(indegrees):
            if degree == 0:
                queue.append((i,1))
        ans = 1
        while queue:
            node, level = queue.popleft()
            for nx_node in pathdic[node]:
                ans = max(ans, level+1)
                indegrees[nx_node] -= 1
                if indegrees[nx_node] == 0:
                    queue.append((nx_node, level+1))
        return ans

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        D = {}
        l = len(arr)
        def P(n):
            if n in D:
                return D[n]
            t = 1
            for i in range(1, d + 1):
                if n + i >= l or arr[n] <= arr[n + i]:
                    break
                t = max(t, 1 + P(n + i))
            for i in range(1, d + 1):
                if n - i < 0 or arr[n] <= arr[n - i]:
                    break
                t = max(t, 1 + P(n - i))
            D[n] = t
            return t
        return max(P(i) for i in range(l))
```

```py
记忆化 DFS

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        n = len(arr)
        @lru_cache(None)
        def helper(i):
            res = 0
            for j in range(i + 1, i + d + 1):
                if j >= n or arr[j] >= arr[i]:
                    break
                res = max(res, helper(j))
            for j in range(i - 1, i - d - 1, -1):
                if j < 0 or arr[j] >= arr[i]:
                    break
                res = max(res, helper(j))
            return res + 1
        return max(helper(i) for i in range(n))
```

```py
排序之后对向两边进行拓展

#python3
class Solution:
	def maxJumps(self,arr,d):
		fans=1
		size=len(arr)
		has,dp=[[0]*size for _ in range(2)]
		for i in sorted(range(size),key=arr.__getitem__):
			tans=has[i]=1
			for j in range(i+1,min(size,i+d+1)):
				if not has[j] or arr[j]==arr[i]:
					break
				tans=max(tans,dp[j]+1)
			for j in range(i-1,max(-1,i-d-1),-1):
				if not has[j] or arr[j]==arr[i]:
					break
				tans=max(tans,dp[j]+1)
			dp[i]=tans
			fans=max(fans,tans)
		return fans

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        # 不能往比自己的高的跳
        # 能跳的区间内不能有比自己高的
        # dp[i]从 i开始的最大跳跃
        n = len(arr)
        height = [(jump,i) for i, jump in enumerate(arr)]
        height = sorted(height, key=lambda x: x[0])
        dp = [1 for _ in range(n)]
        #print(idx)
        #idx1 = map(lambda x: x[1], idx)
        for jump, i in height:
            cur = 1
            for j in range(i-1, max(-1, i - d) - 1, -1): # 向左跳
                if arr[j] >= jump: break
                cur = max(dp[j] + 1,cur)

            for j in range(i + 1, min(n, i + d + 1)):
                if arr[j] >= jump: break
                cur = max(dp[j] + 1, cur)
            dp[i] = cur
        return max(dp)

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        seen = dict()

        def dfs(pos):
            if pos in seen:
                return
            seen[pos] = 1

            i = pos - 1
            while i >= 0 and pos - i <= d and arr[pos] > arr[i]:
                dfs(i)
                seen[pos] = max(seen[pos], seen[i] + 1)
                i -= 1
            i = pos + 1
            while i < len(arr) and i - pos <= d and arr[pos] > arr[i]:
                dfs(i)
                seen[pos] = max(seen[pos], seen[i] + 1)
                i += 1

        for i in range(len(arr)):
            dfs(i)
        print(seen)
        return max(seen.values())

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/jump-game-v/solution/tiao-yue-you-xi-v-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  4.542. <a name='MaximumStudentsTakingExam'></a>1349. Maximum Students Taking Exam

[花花酱](https://www.bilibili.com/video/BV1w7411V7eC?spm_id_from=333.999.0.0)

###  4.543. <a name='MaximumNumberofEventsThatCanBeAttended'></a>1353. Maximum Number of Events That Can Be Attended 

[花花酱](https://www.bilibili.com/video/BV1C7411j7YJ?spm_id_from=333.999.0.0)

###  4.544. <a name='ConstructTargetArrayWithMultipleSums'></a>1354. Construct Target Array With Multiple Sums

[花花酱](https://www.bilibili.com/video/BV1g7411c793?spm_id_from=333.999.0.0)

###  4.545. <a name='MinimumCosttoMakeatLeastOneValidPath'></a>1368. Minimum Cost to Make at Least One Valid Path

[花花酱](https://www.bilibili.com/video/BV1oE411E74t?spm_id_from=333.999.0.0)

###  4.546. <a name='FindtheLongestSubstringContainingVowelsinEve'></a>1371. Find the Longest Substring Containing Vowels in Eve

[花花酱](https://www.bilibili.com/video/BV1CE411K7hb?spm_id_from=333.999.0.0)

###  4.547. <a name='MaximumSumBSTinBinaryTree'></a>1373. Maximum Sum BST in Binary Tree

[花花酱](https://www.bilibili.com/video/BV17E411u797?spm_id_from=333.999.0.0)

###  4.548. <a name='FrogPositionAfterTSeconds'></a>1377. Frog Position After T Seconds

[花花酱](https://www.bilibili.com/video/BV1mE411K7vc?spm_id_from=333.999.0.0)

###  4.549. <a name='FindCorrespondingNodeofBinaryTreeinaClone'></a>1379 Find Corresponding Node of Binary Tree in a Clone

[小明](https://www.bilibili.com/video/BV1A54y147HN?spm_id_from=333.999.0.0)

###  4.550. <a name='BalanceaBinarySearchTree'></a>1382. Balance a Binary Search Tree

[花花酱](https://www.bilibili.com/video/BV1y7411f7v2?spm_id_from=333.999.0.0)

###  4.551. <a name='CountNumberofTeams'></a>1395. Count Number of Teams

[花花酱](https://www.bilibili.com/video/BV1cc411h73E?spm_id_from=333.999.0.0)

###  4.552. <a name='DesignUndergroundSystem'></a>1396 Design Underground System

[小明](https://www.bilibili.com/video/BV1uA411N7q6?spm_id_from=333.999.0.0)

###  4.553. <a name='StoneGameIII'></a>1406. Stone Game III

[花花酱](https://www.bilibili.com/video/BV1zT4y1G7Tb?spm_id_from=333.999.0.0)

###  4.554. <a name='QueriesonaPermutationWithKey'></a>1409. Queries on a Permutation With Key

[花花酱](https://www.bilibili.com/video/BV1mz411b7Uw?spm_id_from=333.999.0.0)

###  4.555. <a name='RestoreTheArray'></a>1416. Restore The Array

[花花酱](https://www.bilibili.com/video/BV1gK4y1k7Rv?spm_id_from=333.999.0.0)

###  4.556. <a name='DiagonalTraverseII'></a>1424. Diagonal Traverse II

[花花酱](https://www.bilibili.com/video/BV1r5411x7Tm?spm_id_from=333.999.0.0)

###  4.557. <a name='ConstrainedSubsetSum'></a>1425. Constrained Subset Sum

[花花酱](https://www.bilibili.com/video/BV13t4y1m7fD?spm_id_from=333.999.0.0)

###  4.558. <a name='CountingElements'></a>1426  Counting Elements

[小明](https://www.bilibili.com/video/BV1Eg4y187vx?spm_id_from=333.999.0.0)

###  4.559. <a name='KidsWiththeGreatestNumberofCandie'></a>1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie

[官方](https://www.bilibili.com/video/BV1vD4y1D7yo?spm_id_from=333.999.0.0)

###  4.560. <a name='CheckIfAll1sAreatLeastLength'></a>1437 Check If All 1's Are at Least Length

[小明](https://www.bilibili.com/video/BV1Yo4y1R78P?spm_id_from=333.999.0.0)

###  4.561. <a name='LongestContinuousSubarrayWithAbsolute'></a>1438. Longest Continuous Subarray With Absolute

[花花酱](https://www.bilibili.com/video/BV1Cf4y1m7aN?spm_id_from=333.999.0.0)

###  4.562. <a name='BuildanArrayWithStackOperations'></a>1441 Build an Array With Stack Operations

[小明](https://www.bilibili.com/video/BV1Gg4y167ZD?spm_id_from=333.999.0.0)

###  4.563. <a name='CountTripletsThatCanFormTwoArraysofEqual'></a>1442. Count Triplets That Can Form Two Arrays of Equal

[花花酱](https://www.bilibili.com/video/BV17g4y1B7yo?spm_id_from=333.999.0.0)

###  4.564. <a name='MinimumTimetoCollectAllApplesinaTree'></a>1443. Minimum Time to Collect All Apples in a Tree

[花花酱](https://www.bilibili.com/video/BV1e541147oZ?spm_id_from=333.999.0.0)

###  4.565. <a name='NumberofWaysofCuttingaPizza'></a>1444. Number of Ways of Cutting a Pizza

[花花酱](https://www.bilibili.com/video/BV1CK411W7nR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gg4y1B7zS?spm_id_from=333.999.0.0)

###  4.566. <a name='ConsecutiveCharacters'></a>1446 Consecutive Characters

[小明](https://www.bilibili.com/video/BV1QA411j7Qt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pp4y1Q7Rh?spm_id_from=333.999.0.0)

###  4.567. <a name='CountGoodNodesinBinaryTree'></a>1448 Count Good Nodes in Binary Tree

[小明](https://www.bilibili.com/video/BV1Zg4y1q7kc?spm_id_from=333.999.0.0)

###  4.568. <a name='FormLargestIntegerWithDigitsThatAdd'></a>1449. Form Largest Integer With Digits That Add

[花花酱](https://www.bilibili.com/video/BV19Q4y1A7Rf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1j54y1D7vf?spm_id_from=333.999.0.0)

###  4.569. <a name='RearrangeWordsinaSentence'></a>1451 Rearrange Words in a Sentence

[小明](https://www.bilibili.com/video/BV1UA411t7Eg?spm_id_from=333.999.0.0)

###  4.570. <a name='MaximumNumberofDartsInsideofaCircularDartb'></a>1453 Maximum Number of Darts Inside of a Circular Dartb

[小明](https://www.bilibili.com/video/BV1Ut4y117jp?spm_id_from=333.999.0.0)

###  4.571. <a name='Pseudo-PalindromicPathsinaBin'></a>1457 Pseudo-Palindromic Paths in a Bin

[小明](https://www.bilibili.com/video/BV1t54y1t7KK?spm_id_from=333.999.0.0)

###  4.572. <a name='CheckIfaStringContainsAllBinar'></a>1461 Check If a String Contains All Binar

[小明](https://www.bilibili.com/video/BV13Z4y1w7K9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oU4y1p7Tr?spm_id_from=333.999.0.0)

###  4.573. <a name='CherryPickupII'></a>1463 Cherry Pickup II

[小明](https://www.bilibili.com/video/BV1AA411s7Tc?spm_id_from=333.999.0.0)

###  4.574. <a name='PaintHouseIII'></a>1473. Paint House III

[花花酱](https://www.bilibili.com/video/BV15K411p7nT?spm_id_from=333.999.0.0)

###  4.575. <a name='FinalPricesWithaSpecialDiscountinaSho'></a>1475. Final Prices With a Special Discount in a Sho

[花花酱](https://www.bilibili.com/video/BV1na4y1Y7VU?spm_id_from=333.999.0.0)

###  4.576. <a name='KthAncestorofaTreeNode'></a>1483. Kth Ancestor of a Tree Node

[花花酱](https://www.bilibili.com/video/BV1kt4y1X7fk?spm_id_from=333.999.0.0)

###  4.577. <a name='AvoidFloodinTheCity'></a>1488. Avoid Flood in The City

[花花酱](https://www.bilibili.com/video/BV1af4y1y7uW?spm_id_from=333.999.0.0)

##  5. <a name='FindCriticalandPseudo-CriticalEdgesin'></a>1489. Find Critical and Pseudo-Critical Edges in

[花花酱](https://www.bilibili.com/video/BV1cV41167oi?spm_id_from=333.999.0.0)

###  5.1. <a name='ThekthFactorofn'></a>1492 The kth Factor of n

[小明](https://www.bilibili.com/video/BV1ha4y1H7vz?spm_id_from=333.999.0.0)

###  5.2. <a name='LongestSubarrayof1sAfterDeletingOne'></a>1493. Longest Subarray of 1's After Deleting One

[花花酱](https://www.bilibili.com/video/BV1rC4y18751?spm_id_from=333.999.0.0)

###  5.3. <a name='MaxValueofEquation'></a>1499. Max Value of Equation

[花花酱](https://www.bilibili.com/video/BV1VK411H7zy?spm_id_from=333.999.0.0)

###  5.4. <a name='CanMakeArithmeticProgressionFromSequence'></a>1502 Can Make Arithmetic Progression From Sequence

[小明](https://www.bilibili.com/video/BV12T4y177vU?spm_id_from=333.999.0.0)

###  5.5. <a name='LastMomentBeforeAllAntsFallOutofaPlank'></a>1503 Last Moment Before All Ants Fall Out of a Plank

[小明](https://www.bilibili.com/video/BV1Fg4y1i7na?spm_id_from=333.999.0.0)

###  5.6. <a name='MinimumPossibleIntegerAfteratMostKAdjacent'></a>1505. Minimum Possible Integer After at Most K Adjacent

[花花酱](https://www.bilibili.com/video/BV1YD4y1S7BQ?spm_id_from=333.999.0.0)

###  5.7. <a name='RangeSumofSortedSubarraySums'></a>1508. Range Sum of Sorted Subarray Sums

[花花酱](https://www.bilibili.com/video/BV1fg4y1v7qe?spm_id_from=333.999.0.0)

###  5.8. <a name='StoneGameIV'></a>1510 Stone Game IV

[小明](https://www.bilibili.com/video/BV1pr4y1w7ao?spm_id_from=333.999.0.0)

###  5.9. <a name='PathwithMaximumProbability'></a>1514 Path with Maximum Probability

[小明](https://www.bilibili.com/video/BV1Ak4y1B7yR?spm_id_from=333.999.0.0)

###  5.10. <a name='BestPositionforaServiceCentre'></a>1515 Best Position for a Service Centre

[小明](https://www.bilibili.com/video/BV1UA411e7PC?spm_id_from=333.999.0.0)

###  5.11. <a name='MaximumNumberofNon-OverlappingSubstrings'></a>1520. Maximum Number of Non-Overlapping Substrings

[花花酱](https://www.bilibili.com/video/BV1yz4y1D7p3?spm_id_from=333.999.0.0)

###  5.12. <a name='NumberofGoodLeafNodesPairs'></a>1530. Number of Good Leaf Nodes Pairs

[花花酱](https://www.bilibili.com/video/BV1bv411q7SD?spm_id_from=333.999.0.0)

###  5.13. <a name='StringCompressionII'></a>1531. String Compression II

[花花酱](https://www.bilibili.com/video/BV1aK4y1v7B9?spm_id_from=333.999.0.0)

###  5.14. <a name='CountGoodTriplets'></a>1534 Count Good Triplets

[小明](https://www.bilibili.com/video/BV11k4y1m7rV?spm_id_from=333.999.0.0)

###  5.15. <a name='FindtheWinnerofanArrayGame'></a>1535 Find the Winner of an Array Game

[小明](https://www.bilibili.com/video/BV1Xp4y1i7ey?spm_id_from=333.999.0.0)

###  5.16. <a name='GettheMaximumScore'></a>1537. Get the Maximum Score

[小梦想家](https://www.bilibili.com/video/BV1KC4y1t7P8?spm_id_from=333.999.0.0)

###  5.17. <a name='KthMissingPositiveNumber'></a>1539. Kth Missing Positive Number

[小梦想家](https://www.bilibili.com/video/BV1SC4y147Eo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK4y1p7E3?spm_id_from=333.999.0.0)

###  5.18. <a name='FindLongestAwesomeSubstring'></a>1542. Find Longest Awesome Substring

[花花酱](https://www.bilibili.com/video/BV1ZD4y1U79Y?spm_id_from=333.999.0.0)

###  5.19. <a name='MaximumNumberofNon-OverlappingSubarraysWithSum'></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum

[小梦想家](https://www.bilibili.com/video/BV1LA411n7L8?spm_id_from=333.999.0.0)

###  5.20. <a name='ThreeConsecutiveOdds'></a>1550. Three Consecutive Odds

[小梦想家](https://www.bilibili.com/video/BV1aV411m7fy?spm_id_from=333.999.0.0)

###  5.21. <a name='MinimumOperationstoMakeArray'></a>1551 Minimum Operations to Make Array

[小明](https://www.bilibili.com/video/BV1u64y1S7fx?spm_id_from=333.999.0.0)

###  5.22. <a name='MinimumNumberofDaystoEatNOranges'></a>1553. Minimum Number of Days to Eat N Oranges

[花花酱](https://www.bilibili.com/video/BV1Qf4y197Zk?spm_id_from=333.999.0.0)

###  5.23. <a name='ThousandSeparator'></a>1556. Thousand Separator

[小梦想家](https://www.bilibili.com/video/BV1Ka4y177HV?spm_id_from=333.999.0.0)

###  5.24. <a name='MinimumNumbersofFunctionCallstoMakeTarget'></a>1558. Minimum Numbers of Function Calls to Make Target

[花花酱](https://www.bilibili.com/video/BV1xC4y1t7Q3?spm_id_from=333.999.0.0)

###  5.25. <a name='StoneGameV'></a>1563. Stone Game V 

[花花酱](https://www.bilibili.com/video/BV1B54y1U77f?spm_id_from=333.999.0.0)

###  5.26. <a name='NumberofWaystoReorderArraytoGetSa'></a>1569. Number of Ways to Reorder Array to Get Sa

[花花酱](https://www.bilibili.com/video/BV1pZ4y1T7TY?spm_id_from=333.999.0.0)

###  5.27. <a name='NumberofWaystoSplitaString'></a>1573. Number of Ways to Split a String

[花花酱](https://www.bilibili.com/video/BV1bi4y1u7c3?spm_id_from=333.999.0.0)

###  5.28. <a name='CheckIfStringIsTransformableWith'></a>1585. Check If String Is Transformable With

[花花酱](https://www.bilibili.com/video/BV1a54y1m75Y?spm_id_from=333.999.0.0)

###  5.29. <a name='SplitaStringIntotheMaxNumberofUniqueSubstri'></a>1593. Split a String Into the Max Number of Unique Substri

[花花酱](https://www.bilibili.com/video/BV14y4y1k77x?spm_id_from=333.999.0.0) 

###  5.30. <a name='MinimumCosttoConnectTwoGroupsofPoints'></a>1595. Minimum Cost to Connect Two Groups of Points

[花花酱](https://www.bilibili.com/video/BV1Xf4y1D7SW?spm_id_from=333.999.0.0)

###  5.31. <a name='NumberofSetsofKNon-OverlappingLine'></a>1621. Number of Sets of K Non-Overlapping Line

[花花酱](https://www.bilibili.com/video/BV1JV411y7eK?spm_id_from=333.999.0.0)

###  5.32. <a name='PathWithMinimumEffort'></a>1631. Path With Minimum Effort

[花花酱](https://www.bilibili.com/video/BV1tr4y1w725?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ft4y1z71X?spm_id_from=333.999.0.0)

###  5.33. <a name='RankTransformofaMatrix'></a>1632 Rank Transform of a Matrix

[小明](https://www.bilibili.com/video/BV1KX4y1F7UA?spm_id_from=333.999.0.0)

###  5.34. <a name='CheckArrayFormationThrough'></a>1640 Check Array Formation Through

[小明](https://www.bilibili.com/video/BV1uh411274P?spm_id_from=333.999.0.0)

###  5.35. <a name='CountSortedVowelStrings'></a>1641 Count Sorted Vowel Strings

[小明](https://www.bilibili.com/video/BV1jf4y1k7bJ?spm_id_from=333.999.0.0)

###  5.36. <a name='FurthestBuildingYouCanReach'></a>1642. Furthest Building You Can Reach

[花花酱](https://www.bilibili.com/video/BV1az4y1C7Pk?spm_id_from=333.999.0.0)

###  5.37. <a name='GetMaximuminGeneratedArray'></a>1646 Get Maximum in Generated Array

[小明](https://www.bilibili.com/video/BV1W54y1s7mg?spm_id_from=333.999.0.0)

###  5.38. <a name='SellDiminishing-ValuedColoredBalls'></a>1648. Sell Diminishing-Valued Colored Balls

[花花酱](https://www.bilibili.com/video/BV11z4y1C7PC?spm_id_from=333.999.0.0)

###  5.39. <a name='CreateSortedArraythroughInstru'></a>1649 Create Sorted Array through Instru

[小明](https://www.bilibili.com/video/BV1ua4y1H7KK?spm_id_from=333.999.0.0)

###  5.40. <a name='DistributeRepeatingIntegers'></a>1655. Distribute Repeating Integers

[花花酱](https://www.bilibili.com/video/BV1qt4y1a7Lm?spm_id_from=333.999.0.0)

###  5.41. <a name='DetermineifTwoStringsAreClose'></a>1657 Determine if Two Strings Are Close

[小明](https://www.bilibili.com/video/BV18z4y1S779?spm_id_from=333.999.0.0)

###  5.42. <a name='MinimumOperationstoReduceX'></a>1658 Minimum Operations to Reduce X

[小明](https://www.bilibili.com/video/BV18t4y1z7Hq?spm_id_from=333.999.0.0)

###  5.43. <a name='MaximizeGridHappiness'></a>1659. Maximize Grid Happiness

[花花酱](https://www.bilibili.com/video/BV1kf4y1v7Js?spm_id_from=333.999.0.0)

###  5.44. <a name='CheckIfTwoStringArraysareEqui'></a>1662 Check If Two String Arrays are Equi

[小明](https://www.bilibili.com/video/BV1LV411t7v4?spm_id_from=333.999.0.0)

###  5.45. <a name='SmallestStringWithAGivenNumer'></a>1663 Smallest String With A Given Numer

[小明](https://www.bilibili.com/video/BV1gv411e7Ly?spm_id_from=333.999.0.0)

###  5.46. <a name='FindtheMostCompetitiveSubseq'></a>1673 Find the Most Competitive Subseq

[小明](https://www.bilibili.com/video/BV1yK4y1H7ni?spm_id_from=333.999.0.0)

###  5.47. <a name='MinimumMovestoMakeArrayComplement'></a>1674. Minimum Moves to Make Array Complement

[花花酱](https://www.bilibili.com/video/BV1qz4y1k7Cm?spm_id_from=333.999.0.0)

###  5.48. <a name='MinimizeDeviationinArray'></a>1675. Minimize Deviation in Array

[花花酱](https://www.bilibili.com/video/BV15541157p6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16f4y167uf?spm_id_from=333.999.0.0)

###  5.49. <a name='MaxNumberofK-SumPairs'></a>1679 Max Number of K-Sum Pairs】

[小明](https://www.bilibili.com/video/BV16t4y1z7kY?spm_id_from=333.999.0.0)

###  5.50. <a name='ConcatenationofConsecutiveBina'></a>1680 Concatenation of Consecutive Bina

[小明](https://www.bilibili.com/video/BV1Py4y117o5?spm_id_from=333.999.0.0)

###  5.51. <a name='MinimumIncompatibility'></a>1681. Minimum Incompatibility

[花花酱](https://www.bilibili.com/video/BV16p4y1z79z?spm_id_from=333.999.0.0)

###  5.52. <a name='StoneGameVII'></a>1690. Stone Game VII

[花花酱](https://www.bilibili.com/video/BV1wf4y1e7xH?spm_id_from=333.999.0.0)

###  5.53. <a name='JumpGameVI'></a>1696. Jump Game VI

[花花酱](https://www.bilibili.com/video/BV1554y1t7Tz?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        
        
        # dp[i] = max(dp[j])+ nums[i] for j in range(i - k, i)
        
        dp = [0] * len(nums)
        dp[0] = nums[0]
        
        q = [0]
        for i in range(1, len(nums)):
            while q and i - q[0] > k:
                q.pop(0)
            dp[i] = dp[q[0]] + nums[i]
            while q and dp[q[-1]] <= dp[i]:
                q.pop(-1)
            q.append(i)     
        return dp[-1]
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        from queue import PriorityQueue
        ans, q = nums[0], PriorityQueue()
        q.put([-nums[0], 0])
        for i in range(1, len(nums)):
            while not q.empty():
                top = q.get()
                if i - top[-1] <= k:
                    q.put(top)
                    break
            ans = -top[0] + nums[i]
            q.put([-ans, i])
        return ans
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        #维护当前最大值  方法1：最大堆  方法2:单调递减队列（队首）
        n = len(nums)
        maxHeap = []
        heapq.heapify(maxHeap)
        heapq.heappush(maxHeap, (-nums[0], 0) )
        res = nums[0]

        for i in range(1, n):
            while maxHeap and i - maxHeap[0][1] > k:    #index的距离太大，以后i越来越大，top()就没用了
                heapq.heappop(maxHeap)
            res = -maxHeap[0][0] + nums[i]
            heapq.heappush(maxHeap, (-res, i) )         #dp的思想
        return res
```

###  5.54. <a name='DetermineifStringHalvesAreAlike'></a>1704 Determine if String Halves Are Alike

[小明](https://www.bilibili.com/video/BV1WA41157sf?spm_id_from=333.999.0.0)

###  5.55. <a name='MaximumXORWithanElementFromArray'></a>1707. Maximum XOR With an Element From Array

[花花酱](https://www.bilibili.com/video/BV13v411t742?spm_id_from=333.999.0.0)

###  5.56. <a name='MinimumOperationstoMakeaSubsequence'></a>1713. Minimum Operations to Make a Subsequence

[花花酱](https://www.bilibili.com/video/BV1Yy4y127DQ?spm_id_from=333.999.0.0)

###  5.57. <a name='SwappingNodesinaLinkedList'></a>1721 Swapping Nodes in a Linked List

[小明](https://www.bilibili.com/video/BV1Ji4y1P7Xc?spm_id_from=333.999.0.0)

###  5.58. <a name='LargestSubmatrixWithRearrangements'></a>1727. Largest Submatrix With Rearrangements

[花花酱](https://www.bilibili.com/video/BV1XT4y1N7gy?spm_id_from=333.999.0.0)

###  5.59. <a name='PalindromePartitioningIV'></a>1745. Palindrome Partitioning IV

[花花酱](https://www.bilibili.com/video/BV1yo4y1R75T?spm_id_from=333.999.0.0)

###  5.60. <a name='MinimumLimitofBallsinaBag'></a>1760. Minimum Limit of Balls in a Bag

[花花酱](https://www.bilibili.com/video/BV1bK4y1H7Ly?spm_id_from=333.999.0.0)

###  5.61. <a name='MaximumScorefromPerformingMultiplication'></a>1770. Maximum Score from Performing Multiplication

[花花酱](https://www.bilibili.com/video/BV1Li4y1T7j6?spm_id_from=333.999.0.0)

###  5.62. <a name='MaximizePalindromeLengthFromSubsequences'></a>1771. Maximize Palindrome Length From Subsequences

[花花酱](https://www.bilibili.com/video/BV1Cp4y1H7Xq?spm_id_from=333.999.0.0)

###  5.63. <a name='EqualSumArraysWithMinimumNumberofOperatio'></a>1775. Equal Sum Arrays With Minimum Number of Operatio

[花花酱](https://www.bilibili.com/video/BV1Di4y1T7nF?spm_id_from=333.999.0.0)

###  5.64. <a name='NumberofRestrictedPathsFromFirsttoLastNode'></a>1786. Number of Restricted Paths From First to Last Node

[花花酱](https://www.bilibili.com/video/BV1Df4y147TB?spm_id_from=333.999.0.0)

###  5.65. <a name='MaximumAveragePassRatio'></a>1792. Maximum Average Pass Ratio

[花花酱](https://www.bilibili.com/video/BV1qb4y197zc?spm_id_from=333.999.0.0)

###  5.66. <a name='MaximizeScoreAfterNOperations'></a>1799. Maximize Score After N Operations

[花花酱](https://www.bilibili.com/video/BV1Sf4y1x7Cy?spm_id_from=333.999.0.0)

###  5.67. <a name='MaximumNumberofGroupsGettingFreshDonuts'></a>1815. Maximum Number of Groups Getting Fresh Donuts

[花花酱](https://www.bilibili.com/video/BV1CU4y187tk?spm_id_from=333.999.0.0)

###  5.68. <a name='FrequencyoftheMostFrequentElement'></a>1838. Frequency of the Most Frequent Element

[花花酱](https://www.bilibili.com/video/BV1Ai4y1P7Yt?spm_id_from=333.999.0.0)

###  5.69. <a name='ClosestRoom'></a>1847. Closest Room

[花花酱](https://www.bilibili.com/video/BV1cy4y1x7sz?spm_id_from=333.999.0.0)

###  5.70. <a name='StoneGameVIII'></a>1872. Stone Game VIII

[花花酱](https://www.bilibili.com/video/BV1vb4y1z7wx?spm_id_from=333.999.0.0)

###  5.71. <a name='s'></a>s
