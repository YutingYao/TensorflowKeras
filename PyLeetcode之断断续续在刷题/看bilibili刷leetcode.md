<!-- vscode-markdown-toc -->
* 1. [题目](#)
	* 1.1. [100-Same Tree](#SameTree)
	* 1.2. [101-Symmetric tree](#Symmetrictree)
	* 1.3. [102-Binary Tree Level Order Traversal](#BinaryTreeLevelOrderTraversal)
	* 1.4. [103. Binary Tree Zigzag Level Order Traversal](#BinaryTreeZigzagLevelOrderTraversal)
	* 1.5. [104-Maximum Depth of Binary](#MaximumDepthofBinary)
	* 1.6. [105-从前序与中序遍历序列构](#-1)
	* 1.7. [106-从中序与后序遍历序列构造二叉树](#-1)
	* 1.8. [107-Binary Tree Level Order Traversal II](#BinaryTreeLevelOrderTraversalII)
	* 1.9. [108 Convert Sorted Array to Binary Search Tree](#ConvertSortedArraytoBinarySearchTree)
	* 1.10. [109题. 有序链表转换二叉搜索树](#-1)
	* 1.11. [110-Balanced Binary Tree](#BalancedBinaryTree)
	* 1.12. [111-Minimum Depth of Binary Tree](#MinimumDepthofBinaryTree)
	* 1.13. [112-Path Sum](#PathSum)
	* 1.14. [113. 二叉树中和为某一值的路径](#-1)
	* 1.15. [114题. 二叉树展开为链表](#-1)
	* 1.16. [115. Distinct Subsequences](#DistinctSubsequences)
	* 1.17. [116. Populating Next Right Pointers in Each Node](#PopulatingNextRightPointersinEachNode)
	* 1.18. [117 Populating Next Right Pointers in Ea](#PopulatingNextRightPointersinEa)
	* 1.19. [118-Pascal's Triangle](#PascalsTriangle)
	* 1.20. [119-Pascal's Triangle II](#PascalsTriangleII)
	* 1.21. [120 Triangle](#Triangle)
	* 1.22. [121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机](#BestTimetoBuyandSellStock121-)
	* 1.23. [122-买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II](#II122-BestTimetoBuyandSellStockII)
	* 1.24. [123-买卖股票的最佳时机 III](#III)
	* 1.25. [124. Binary Tree Maximum Path Sum](#BinaryTreeMaximumPathSum)
	* 1.26. [125-Valid Palindrome](#ValidPalindrome)
	* 1.27. [126. Word Ladder II](#WordLadderII)
	* 1.28. [127. Word Ladder](#WordLadder)
	* 1.29. [128. Longest Consecutive Sequence](#LongestConsecutiveSequence)
	* 1.30. [129 Sum Root to Leaf Numbers](#SumRoottoLeafNumbers)
	* 1.31. [130. Surrounded Regions 130-被围绕的区域](#SurroundedRegions130-)
	* 1.32. [131-分割回文串](#-1)
	* 1.33. [132. Palindrome Partitioning II](#PalindromePartitioningII)
	* 1.34. [133. Clone Graph](#CloneGraph)
	* 1.35. [134. Gas Station](#GasStation)
	* 1.36. [138 Copy List with Random Pointer](#CopyListwithRandomPointer)
	* 1.37. [136-Single Number](#SingleNumber)
	* 1.38. [137 Single Number II](#SingleNumberII)
	* 1.39. [139 Word Break](#WordBreak)
	* 1.40. [140 Word Break II](#WordBreakII)
	* 1.41. [141-Linked List Cycle](#LinkedListCycle)
	* 1.42. [142 Linked List Cycle II](#LinkedListCycleII)
	* 1.43. [143 Reorder List](#ReorderList)
	* 1.44. [144-Preorder with stack](#Preorderwithstack)
	* 1.45. [144-Binary Tree Preorder Traversal](#BinaryTreePreorderTraversal)
	* 1.46. [145-Postorder with stack](#Postorderwithstack)
	* 1.47. [145-Binary Tree Postorder Traversal](#BinaryTreePostorderTraversal)
	* 1.48. [146 LRU Cache](#LRUCache)
	* 1.49. [147 Insertion Sort List](#InsertionSortList)
	* 1.50. [148. Sort List](#SortList)
	* 1.51. [149. Max Points on a Line](#MaxPointsonaLine)
	* 1.52. [150. Evaluate Reverse Polish Notation](#EvaluateReversePolishNotation)
	* 1.53. [151. Reverse Words in a String](#ReverseWordsinaString)
	* 1.54. [152-乘积最大子数组](#-1)
	* 1.55. [153-寻找旋转排序数组中的最小值](#-1)
	* 1.56. [154 Find Minimum in Rotated Sorted Arr](#FindMinimuminRotatedSortedArr)
	* 1.57. [155-Min Stack](#MinStack)
	* 1.58. [160-Intersection of Two Linked Lists](#IntersectionofTwoLinkedLists)
	* 1.59. [162. Find Peak Element](#FindPeakElement)
	* 1.60. [165. Compare Version Numbers](#CompareVersionNumbers)
	* 1.61. [166. Fraction to Recurring Decimal](#FractiontoRecurringDecimal)
	* 1.62. [167-Two Sum II - Input array is sorted](#TwoSumII-Inputarrayissorted)
	* 1.63. [168-Excel Sheet Column Title](#ExcelSheetColumnTitle)
	* 1.64. [169. Majority Element](#MajorityElement)
	* 1.65. [171. Excel Sheet Column Number](#ExcelSheetColumnNumber)
	* 1.66. [172-Factorial Trailing Zeroes](#FactorialTrailingZeroes)
	* 1.67. [173 Binary Search Tree Iterator](#BinarySearchTreeIterator)
	* 1.68. [174 Dungeon Game](#DungeonGame)
	* 1.69. [179 Largest Number](#LargestNumber)
	* 1.70. [186. Reverse Words in a String II](#ReverseWordsinaStringII)
	* 1.71. [187 Repeated DNA Sequences](#RepeatedDNASequences)
	* 1.72. [188 Best Time to Buy and Sell Stock IV](#BestTimetoBuyandSellStockIV)
	* 1.73. [189. Rotate Array](#RotateArray)
	* 1.74. [190. Reverse Bits](#ReverseBits)
	* 1.75. [191 Number of 1 Bits](#Numberof1Bits)
	* 1.76. [198. House Robber 198-打家劫舍](#HouseRobber198-)
	* 1.77. [199 Binary Tree Right Side View](#BinaryTreeRightSideView)
	* 1.78. [200-岛屿数量](#-1)
	* 1.79. [201 Bitwise AND of Numbers Range](#BitwiseANDofNumbersRange)
	* 1.80. [202. 快乐数 Happy Number](#HappyNumber)
	* 1.81. [203. Remove Linked List Elements](#RemoveLinkedListElements)
	* 1.82. [204-Count Primes](#CountPrimes)
	* 1.83. [205. isomorphic strings](#isomorphicstrings)
	* 1.84. [206-Reverse Linked List](#ReverseLinkedList)
	* 1.85. [207-课程表](#-1)
	* 1.86. [208. Implement Trie (Prefix Tree)](#ImplementTriePrefixTree)
	* 1.87. [209-长度最小的子数组](#-1)
	* 1.88. [210. Course Schedule II 210-课程表II](#CourseScheduleII210-II)
	* 1.89. [211 Add and Search Word](#AddandSearchWord)
	* 1.90. [212. Word Search II](#WordSearchII)
	* 1.91. [213. House Robber II 213-打家劫舍II](#HouseRobberII213-II)
	* 1.92. [216. Combination Sum III 216-组合总和 III](#CombinationSumIII216-III)
	* 1.93. [217. Contains Duplicate](#ContainsDuplicate)
	* 1.94. [218. The Skyline Problem](#TheSkylineProblem)
	* 1.95. [219. Contains Duplicate II](#ContainsDuplicateII)
	* 1.96. [220 Contains Duplicate III](#ContainsDuplicateIII)
	* 1.97. [221-最大正方形](#-1)
	* 1.98. [222. Count Complete Tree Nodes](#CountCompleteTreeNodes)
	* 1.99. [223. Rectangle Area](#RectangleArea)
	* 1.100. [225-Implement Stack using Queues](#ImplementStackusingQueues)
	* 1.101. [226-翻转二叉树](#-1)
	* 1.102. [227 Basic Calculator II](#BasicCalculatorII)
	* 1.103. [228 Summary Ranges](#SummaryRanges)
	* 1.104. [229. Majority Element II](#MajorityElementII)
	* 1.105. [230 Kth Smallest Element in a B](#KthSmallestElementinaB)
	* 1.106. [231. Power of Two](#PowerofTwo)
	* 1.107. [232-Implement Queue using Stacks](#ImplementQueueusingStacks)
	* 1.108. [234. Palindrome Linked List](#PalindromeLinkedList)
	* 1.109. [235. Lowest Common Ancestor of a Binary Search Tree](#LowestCommonAncestorofaBinarySearchTree)
	* 1.110. [236-二叉树的最近公共祖先](#-1)
	* 1.111. [237. Delete Node in a Linked List](#DeleteNodeinaLinkedList)
	* 1.112. [238 Product of Array Except Self](#ProductofArrayExceptSelf)
	* 1.113. [239. Sliding Window Maximum](#SlidingWindowMaximum)
	* 1.114. [240. 二维数组的查找](#-1)
	* 1.115. [242. Valid Anagram](#ValidAnagram)
	* 1.116. [243. Shortest Word Distance](#ShortestWordDistance)
	* 1.117. [246. Strobogrammatic Number](#StrobogrammaticNumber)
	* 1.118. [257-二叉树的所有路径](#-1)
	* 1.119. [258. Add Digits](#AddDigits)
	* 1.120. [260-只出现一次的数字 III](#III-1)
	* 1.121. [263 Ugly Number](#UglyNumber)
	* 1.122. [264. Ugly Number II](#UglyNumberII)
	* 1.123. [268 Missing Number](#MissingNumber)
	* 1.124. [270. Closest Binary Search Tree Value](#ClosestBinarySearchTreeValue)
	* 1.125. [274 H-Index](#H-Index)
	* 1.126. [278. First Bad Version](#FirstBadVersion)
	* 1.127. [279 Perfect Squares](#PerfectSquares)
	* 1.128. [282. Expression Add Operators](#ExpressionAddOperators)
	* 1.129. [283. Move Zeros](#MoveZeros)
	* 1.130. [284 Peeking Iterator](#PeekingIterator)
	* 1.131. [287 Find the Duplicate Number](#FindtheDuplicateNumber)
	* 1.132. [289. Game of Life](#GameofLife)
	* 1.133. [290. Word Pattern](#WordPattern)
	* 1.134. [297. Serialize and Deserialize Binary Tree](#SerializeandDeserializeBinaryTree)
	* 1.135. [299. Bulls and Cows](#BullsandCows)
	* 1.136. [300 Longest Increasing Subsequence 最长上升子序列](#LongestIncreasingSubsequence)
	* 1.137. [301. Remove Invalid Parentheses](#RemoveInvalidParentheses)
	* 1.138. [303-区域和检索 - 数组不可变](#-1)
	* 1.139. [304. Range Sum Query 2D](#RangeSumQuery2D)
	* 1.140. [309. Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期](#BestTimetoBuyandSellStockwithCooldown309-)
	* 1.141. [310 Minimum Height Trees](#MinimumHeightTrees)
	* 1.142. [312 Burst Balloons](#BurstBalloons)
	* 1.143. [315. Count of Smaller Numbers After Self](#CountofSmallerNumbersAfterSelf)
	* 1.144. [316 Remove Duplicate Letters](#RemoveDuplicateLetters)
	* 1.145. [321. Create Maximum Number](#CreateMaximumNumber)
	* 1.146. [322. Coin Change](#CoinChange)
	* 1.147. [326. Power of Three](#PowerofThree)
	* 1.148. [328. 奇偶链表 (Odd Even Linked List)](#OddEvenLinkedList)
	* 1.149. [329. Longest Increasing Path in a Matrix](#LongestIncreasingPathinaMatrix)
	* 1.150. [332 Reconstruct Itinerary](#ReconstructItinerary)
	* 1.151. [334 Increasing Triplet Subseque](#IncreasingTripletSubseque)
	* 1.152. [337 House Robber III](#HouseRobberIII)
	* 1.153. [338 Counting Bits](#CountingBits)
	* 1.154. [342. Power of Four](#PowerofFour)
	* 1.155. [343-整数拆分](#-1)
	* 1.156. [344. Reverse String](#ReverseString)
	* 1.157. [345. Reverse Vowels of a String](#ReverseVowelsofaString)
	* 1.158. [346 Moving Average from Data Stream](#MovingAveragefromDataStream)
	* 1.159. [347. Top K Frequent Elements](#TopKFrequentElements)
	* 1.160. [349. Intersection of Two Arrays](#IntersectionofTwoArrays)
	* 1.161. [350. Intersection of Two Arrays II](#IntersectionofTwoArraysII)
	* 1.162. [355. 设计推特 Design Twitter](#DesignTwitter)
	* 1.163. [359 Logger Rate Limiter](#LoggerRateLimiter)
	* 1.164. [367. Valid Perfect Square](#ValidPerfectSquare)
	* 1.165. [368 Largest Divisible Subset](#LargestDivisibleSubset)
	* 1.166. [373. Find K Pairs with Smallest Sums查找和最小的k对数字](#FindKPairswithSmallestSumsk)
	* 1.167. [374. Guess Number Higher or Lower](#GuessNumberHigherorLower)
	* 1.168. [376-摆动序列](#-1)
	* 1.169. [377. Combination Sum IV](#CombinationSumIV)
	* 1.170. [378-有序矩阵中第K小的元素](#K)
	* 1.171. [380 Insert Delete GetRandom O(1)](#InsertDeleteGetRandomO1)
	* 1.172. [382 Linked List Random Node](#LinkedListRandomNode)
	* 1.173. [383 Ransom Note](#RansomNote)
	* 1.174. [387. First Unique Character in a String](#FirstUniqueCharacterinaString)
	* 1.175. [389. Find the Difference](#FindtheDifference)
	* 1.176. [391. Perfect Rectangle](#PerfectRectangle)
	* 1.177. [392. Is Subsequence](#IsSubsequence)
	* 1.178. [393. UTF-8 Validation](#UTF-8Validation)
	* 1.179. [394 Decode String](#DecodeString)
	* 1.180. [395 Longest Substring with At Least K](#LongestSubstringwithAtLeastK)
	* 1.181. [399. Evaluate Division](#EvaluateDivision)
	* 1.182. [402 Remove K Digits](#RemoveKDigits)
	* 1.183. [404. Sum of Left Leaves](#SumofLeftLeaves)
	* 1.184. [405-Convert a Number to Hexadecimal](#ConvertaNumbertoHexadecimal)
	* 1.185. [406. Queue Reconstruction by Height](#QueueReconstructionbyHeight)
	* 1.186. [408. Valid Word Abbreviation](#ValidWordAbbreviation)
	* 1.187. [409. Longest Palindrome](#LongestPalindrome)
	* 1.188. [410. Split Array Largest Sum](#SplitArrayLargestSum)
	* 1.189. [412. Fizz Buzz](#FizzBuzz)
	* 1.190. [413-等差数列划分](#-1)
	* 1.191. [414. Third Maximum Number](#ThirdMaximumNumber)
	* 1.192. [415-Add Strings](#AddStrings)
	* 1.193. [416. Partition Equal Subset Sum](#PartitionEqualSubsetSum)
	* 1.194. [417. Pacific Atlantic Water Flow](#PacificAtlanticWaterFlow)
	* 1.195. [419. Battleships in a Board](#BattleshipsinaBoard)
	* 1.196. [421 Maximum XOR of Two Numbers in an Array](#MaximumXORofTwoNumbersinanArray)
	* 1.197. [423 Reconstruct Original Digits from English](#ReconstructOriginalDigitsfromEnglish)
	* 1.198. [424. 替换后的最长重复字符 Longest Repeating Character Replacem](#LongestRepeatingCharacterReplacem)
	* 1.199. [429. N-ary Tree Level Order Traversal](#N-aryTreeLevelOrderTraversal)
	* 1.200. [430 Flatten a Multilevel Doubly Linked List](#FlattenaMultilevelDoublyLinkedList)
	* 1.201. [432. All O`one Data Structure](#AllOoneDataStructure)
	* 1.202. [435-Non-overlapping Intervals](#Non-overlappingIntervals)
	* 1.203. [436 Find Right Interval](#FindRightInterval)
	* 1.204. [437 Path Sum III](#PathSumIII)
	* 1.205. [438. Find All Anagrams in a String](#FindAllAnagramsinaString)
	* 1.206. [441 Arranging Coins](#ArrangingCoins)
	* 1.207. [442 Find All Duplicates in an Array](#FindAllDuplicatesinanArray)
	* 1.208. [443. String Compression](#StringCompression)
	* 1.209. [445-Add Two Numbers II](#AddTwoNumbersII)
	* 1.210. [447. Number of Boomerangs](#NumberofBoomerangs)
	* 1.211. [448. Find All Numbers Disappeared in an Array](#FindAllNumbersDisappearedinanArray)
	* 1.212. [449. Serialize and Deserialize BST](#SerializeandDeserializeBST)
	* 1.213. [450. Delete Node in a BST](#DeleteNodeinaBST)
	* 1.214. [451 Sort Characters By Frequency](#SortCharactersByFrequency)
	* 1.215. [454 4Sum II](#SumII)
	* 1.216. [452. Minimum Number of Arrows to Burst Balloons](#MinimumNumberofArrowstoBurstBalloons)
	* 1.217. [455-Assign Cookies](#AssignCookies)
	* 1.218. [456 132 Pattern](#Pattern)
	* 1.219. [458 Poor Pigs](#PoorPigs)
	* 1.220. [459 Repeated Substring Pattern](#RepeatedSubstringPattern)
	* 1.221. [460. LFU Cache / O(1)](#LFUCacheO1)
	* 1.222. [461 Hamming Distance](#HammingDistance)
	* 1.223. [463 Island Perimeter](#IslandPerimeter)
	* 1.224. [464. Can I Win](#CanIWin)
	* 1.225. [466. 统计重复个数 Count The Repetitions](#CountTheRepetitions)
	* 1.226. [468 Validate IP Address](#ValidateIPAddress)
	* 1.227. [470. Implement Rand10() Using Rand7()](#ImplementRand10UsingRand7)
	* 1.228. [475. Heaters](#Heaters)
	* 1.229. [476. Number Complement](#NumberComplement)
	* 1.230. [477. Total Hamming Distance](#TotalHammingDistance)
	* 1.231. [478 Generate Random Point in a Circle](#GenerateRandomPointinaCircle)
	* 1.232. [480. Sliding Window Median](#SlidingWindowMedian)
	* 1.233. [484 Find Permutation](#FindPermutation)
	* 1.234. [485. Max Consecutive Ones](#MaxConsecutiveOnes)
	* 1.235. [486. Predict the Winner](#PredicttheWinner)
	* 1.236. [490 The Maze](#TheMaze)
	* 1.237. [494. Target Sum](#TargetSum)
	* 1.238. [495 Teemo Attacking](#TeemoAttacking)
	* 1.239. [496. 下一个更大元素 I (Next Greater Element I)](#INextGreaterElementI)
	* 1.240. [497 Random Point in Non-overlapping](#RandomPointinNon-overlapping)
	* 1.241. [500. Keyboard Row](#KeyboardRow)
	* 1.242. [503-Next Greater Element II](#NextGreaterElementII)
	* 1.243. [504-Base 7](#Base7)
	* 1.244. [509. Fibonacci Number](#FibonacciNumber)
	* 1.245. [516. Longest Palindromic Subsequence](#LongestPalindromicSubsequence)
	* 1.246. [518 Coin Change 2](#CoinChange2)
	* 1.247. [520. Detect Capital](#DetectCapital)
	* 1.248. [525. Contiguous Array](#ContiguousArray)
	* 1.249. [526 Beautiful Arrangement](#BeautifulArrangement)
	* 1.250. [528 Random Pick with Weight](#RandomPickwithWeight)
	* 1.251. [530. Minimum Absolute Difference in BST](#MinimumAbsoluteDifferenceinBST)
	* 1.252. [532 K-diff Pairs in an Array](#K-diffPairsinanArray)
	* 1.253. [535. Encode and Decode TinyURL](#EncodeandDecodeTinyURL)
	* 1.254. [537 Complex Number Multiplicatin](#ComplexNumberMultiplicatin)
	* 1.255. [538 Convert BST to Greater Tree](#ConvertBSTtoGreaterTree)
	* 1.256. [540. Single Element in a Sorted Array 540-有序数组中的单一元素](#SingleElementinaSortedArray540-)
	* 1.257. [542. 01 矩阵 01 Matrix](#Matrix)
	* 1.258. [543 Diameter of Binary Tree](#DiameterofBinaryTree)
	* 1.259. [546 Remove Boxes](#RemoveBoxes)
	* 1.260. [547-朋友圈](#-1)
	* 1.261. [554 Brick Wall](#BrickWall)
	* 1.262. [556 Next Greater Element III](#NextGreaterElementIII)
	* 1.263. [560. Subarray Sum Equals K 和为K的子数组](#SubarraySumEqualsKK)
	* 1.264. [563 Binary Tree Tilt](#BinaryTreeTilt)
	* 1.265. [567. Permutation in String 567-字符串的排列](#PermutationinString567-)
	* 1.266. [572-另一个树的子树](#-1)
	* 1.267. [575 Distribute Candies](#DistributeCandies)
	* 1.268. [576. Out of Boundary Paths](#OutofBoundaryPaths)
	* 1.269. [581 Shortest Unsorted Continuous Suba](#ShortestUnsortedContinuousSuba)
	* 1.270. [589 N-ary Tree Preorder Traversal](#N-aryTreePreorderTraversal)
	* 1.271. [593 Valid Square](#ValidSquare)
	* 1.272. [594 Longest Harmonious Subsequence](#LongestHarmoniousSubsequence)
	* 1.273. [605 Can Place Flowers](#CanPlaceFlowers)
	* 1.274. [621. Task Scheduler](#TaskScheduler)
	* 1.275. [622 Design Circular Queue](#DesignCircularQueue)
	* 1.276. [623 Add One Row to Tree](#AddOneRowtoTree)
	* 1.277. [633-Sum of Square Numbers](#SumofSquareNumbers)
	* 1.278. [636. Exclusive Time of Functions](#ExclusiveTimeofFunctions)
	* 1.279. [637 Average of Levels in Binary Tree](#AverageofLevelsinBinaryTree)
	* 1.280. [639. Decode Ways II](#DecodeWaysII)
	* 1.281. [643. Maximum Average Subarray I](#MaximumAverageSubarrayI)
	* 1.282. [645-错误的集合](#-1)
	* 1.283. [646-最长数对链](#-1)
	* 1.284. [647 Palindromic Substrings](#PalindromicSubstrings)
	* 1.285. [650-只有两个键的键盘](#-1)
	* 1.286. [652. Find Duplicate Subtrees](#FindDuplicateSubtrees)
	* 1.287. [653. Two Sum IV](#TwoSumIV)
	* 1.288. [662. Maximum Width of Binary Tree](#MaximumWidthofBinaryTree)
	* 1.289. [667 Beautiful Arrangement II](#BeautifulArrangementII)
	* 1.290. [668. Kth Smallest Number in Multiplication Table](#KthSmallestNumberinMultiplicationTable)
	* 1.291. [669 Trim a Binary Search Tree](#TrimaBinarySearchTree)
	* 1.292. [673 Number of Longest Increasing Subse](#NumberofLongestIncreasingSubse)
	* 1.293. [678 Valid Parenthesis String](#ValidParenthesisString)
	* 1.294. [680-Valid Palindrome II](#ValidPalindromeII)
	* 1.295. [683. K Empty Slots](#KEmptySlots)
	* 1.296. [684. Redundant Connection 684-冗余连接](#RedundantConnection684-)
	* 1.297. [685. Redundant Connection II](#RedundantConnectionII)
	* 1.298. [687. Longest Univalue Path](#LongestUnivaluePath)
	* 1.299. [688. Knight Probability in Chessboard](#KnightProbabilityinChessboard)
	* 1.300. [690. Employee Importance](#EmployeeImportance)
	* 1.301. [692. Top K Frequent Words](#TopKFrequentWords)
	* 1.302. [695-岛屿的最大面积](#-1)
	* 1.303. [696 Count Binary Substrings](#CountBinarySubstrings)
	* 1.304. [699. Falling Squares](#FallingSquares)
	* 1.305. [700 Search in a Binary Search Tree](#SearchinaBinarySearchTree)
	* 1.306. [701 Insert into a Binary Search Tree](#InsertintoaBinarySearchTree)
	* 1.307. [703.Kth Largest Element in a Stream数据流中的第K大元素](#KthLargestElementinaStreamK)
	* 1.308. [704.Binary Search二分查找](#BinarySearch)
	* 1.309. [705 Design HashSet](#DesignHashSet)
	* 1.310. [706. Design HashMap设计哈希映射](#DesignHashMap)
	* 1.311. [707. Design Linked List](#DesignLinkedList)
	* 1.312. [712. Minimum ASCII Delete Sum for Two Strings](#MinimumASCIIDeleteSumforTwoStrings)
	* 1.313. [713 Subarray Product Less Than K](#SubarrayProductLessThanK)
	* 1.314. [714-买卖股票的最佳时机含手续费](#-1)
	* 1.315. [715. Range Module](#RangeModule)
	* 1.316. [719. Find K-th Smallest Pair Distance](#FindK-thSmallestPairDistance)
	* 1.317. [720. Longest Word in Dictionary](#LongestWordinDictionary)
	* 1.318. [724. Find Pivot Index](#FindPivotIndex)
	* 1.319. [725. Split Linked List in Parts](#SplitLinkedListinParts)
	* 1.320. [726. Number of Atoms](#NumberofAtoms)
	* 1.321. [730. Count Different Palindromic Subsequences](#CountDifferentPalindromicSubsequences)
	* 1.322. [732. My Calendar III](#MyCalendarIII)
	* 1.323. [733. 图像渲染 Flood Fill](#FloodFill)
	* 1.324. [735 Asteroid Collision](#AsteroidCollision)
	* 1.325. [737. Sentence Similarity II](#SentenceSimilarityII)
	* 1.326. [739-Daily Temperatures](#DailyTemperatures)
	* 1.327. [740. Delete and Earn](#DeleteandEarn)
	* 1.328. [741. Cherry Pickup](#CherryPickup)
	* 1.329. [743. Network Delay Time](#NetworkDelayTime)
	* 1.330. [745. Prefix and Suffix Search](#PrefixandSuffixSearch)
	* 1.331. [746. Min Cost Climbing Stairs](#MinCostClimbingStairs)
	* 1.332. [748. Shortest Completing Word](#ShortestCompletingWord)
	* 1.333. [752. Open the Lock](#OpentheLock)
	* 1.334. [763 Partition Labels](#PartitionLabels)
	* 1.335. [765. 情侣牵手 Couples Holding Hands](#CouplesHoldingHands)
	* 1.336. [769. Max Chunks To Make Sorted](#MaxChunksToMakeSorted)
	* 1.337. [771 Jewels and Stones](#JewelsandStones)
	* 1.338. [773. Sliding Puzzle](#SlidingPuzzle)
	* 1.339. [775. Global and Local Inversions](#GlobalandLocalInversions)
	* 1.340. [778. Swim in Rising Water](#SwiminRisingWater)
	* 1.341. [784. Letter Case Permutation](#LetterCasePermutation)
	* 1.342. [785-判断二分图](#-1)
	* 1.343. [786. K-th Smallest Prime Fraction](#K-thSmallestPrimeFraction)
	* 1.344. [787. Cheapest Flights Within K Stops](#CheapestFlightsWithinKStops)
	* 1.345. [790. Domino and Tromino Tiling](#DominoandTrominoTiling)
	* 1.346. [792. Number of Matching Subsequences](#NumberofMatchingSubsequences)
	* 1.347. [797 All Paths From Source to Target](#AllPathsFromSourcetoTarget)
	* 1.348. [799 Champagne Tower](#ChampagneTower)
	* 1.349. [801. Minimum Swaps To Make Sequences Increasing](#MinimumSwapsToMakeSequencesIncreasing)
	* 1.350. [803. Bricks Falling When Hit](#BricksFallingWhenHit)
	* 1.351. [804 Unique Morse Code Words](#UniqueMorseCodeWords)
	* 1.352. [813. Largest Sum of Averages](#LargestSumofAverages)
	* 1.353. [815. Bus Routes](#BusRoutes)
	* 1.354. [817. Linked List Components](#LinkedListComponents)
	* 1.355. [818. Race Car (上)](#RaceCar)
	* 1.356. [821 Shortest Distance to a Character](#ShortestDistancetoaCharacter)
	* 1.357. [823. Binary Trees With Factors](#BinaryTreesWithFactors)
	* 1.358. [824 Goat Latin](#GoatLatin)
	* 1.359. [827. Making A Large Island](#MakingALargeIsland)
	* 1.360. [832 Flipping an Image](#FlippinganImage)
	* 1.361. [835 Image Overlap](#ImageOverlap)
	* 1.362. [837. 新 21 点 New 21 Game](#New21Game)
	* 1.363. [841 Keys and Rooms](#KeysandRooms)
	* 1.364. [842. Split Array into Fibonacci Sequence](#SplitArrayintoFibonacciSequence)
	* 1.365. [844 Backspace String Compare](#BackspaceStringCompare)
	* 1.366. [845 Longest Mountain in Array](#LongestMountaininArray)
	* 1.367. [847 Shortest Path Visiting All Nodes](#ShortestPathVisitingAllNodes)
	* 1.368. [849 Maximize Distance to Closest Person](#MaximizeDistancetoClosestPerson)
	* 1.369. [856. Score of Parentheses](#ScoreofParentheses)
	* 1.370. [858 Mirror Reflection](#MirrorReflection)
	* 1.371. [859 Buddy Strings](#BuddyStrings)
	* 1.372. [863. All Nodes Distance K in Binary Tree](#AllNodesDistanceKinBinaryTree)
	* 1.373. [864. Shortest Path to Get All Keys](#ShortestPathtoGetAllKeys)
	* 1.374. [869 Reordered Power of 2](#ReorderedPowerof2)
	* 1.375. [865. Smallest Subtree with all the Deepest Nodes](#SmallestSubtreewithalltheDeepestNodes)
	* 1.376. [871. Minimum Number of Refueling Stops](#MinimumNumberofRefuelingStops)
	* 1.377. [873. Length of Longest Fibonacci Subsequence](#LengthofLongestFibonacciSubsequence)
	* 1.378. [875.Koko Eating Bananas科科吃香蕉](#KokoEatingBananas)
	* 1.379. [876.Middle of the Linked List 链表的中间结点](#MiddleoftheLinkedList)
	* 1.380. [877 Stone Game](#StoneGame)
	* 1.381. [879. Profitable Schemes](#ProfitableSchemes)
	* 1.382. [880 Decoded String at Index](#DecodedStringatIndex)
	* 1.383. [881 Boats to Save People](#BoatstoSavePeople)
	* 1.384. [882. Reachable Nodes In Subdivided Graph](#ReachableNodesInSubdividedGraph)
	* 1.385. [886. Possible Bipartition](#PossibleBipartition)
	* 1.386. [887. Super Egg Drop](#SuperEggDrop)
	* 1.387. [889. Construct Binary Tree from Preorder and Postorder](#ConstructBinaryTreefromPreorderandPostorder)
	* 1.388. [891. Sum of Subsequence Widths](#SumofSubsequenceWidths)
	* 1.389. [894. All Possible Full Binary Trees](#AllPossibleFullBinaryTrees)
	* 1.390. [895. Maximum Frequency Stack](#MaximumFrequencyStack)
	* 1.391. [898. Bitwise ORs of Subarrays](#BitwiseORsofSubarrays)
	* 1.392. [901. Online Stock Span](#OnlineStockSpan)
	* 1.393. [902 Numbers At Most N Given Digit Set](#NumbersAtMostNGivenDigitSet)
	* 1.394. [904-水果成篮](#-1)
	* 1.395. [905 Sort Array By Parity](#SortArrayByParity)
	* 1.396. [906 Super Palindromes](#SuperPalindromes)
	* 1.397. [909. Snakes and Ladders](#SnakesandLadders)
	* 1.398. [910 Smallest Range II](#SmallestRangeII)
	* 1.399. [916 Word Subsetse](#WordSubsetse)
	* 1.400. [918 Maximum Sum Circular Sub](#MaximumSumCircularSub)
	* 1.401. [923. 3Sum With Multiplicity](#SumWithMultiplicity)
	* 1.402. [926. Flip String to Monotone Increasing](#FlipStringtoMonotoneIncreasing)
	* 1.403. [930-和相同的二元子数组(滑动窗口+前缀和)](#-1)
	* 1.404. [933 Number of Recent Calls](#NumberofRecentCalls)
	* 1.405. [934. Shortest Bridge](#ShortestBridge)
	* 1.406. [936 Stamping The Sequence](#StampingTheSequence)
	* 1.407. [938 Range Sum of BST](#RangeSumofBST)
	* 1.408. [941 Valid Mountain Array](#ValidMountainArray)
	* 1.409. [943. Find the Shortest Superstring](#FindtheShortestSuperstring)
	* 1.410. [946-Python-栈的压入、弹出序列](#Python-)
	* 1.411. [946 Validate Stack Sequences](#ValidateStackSequences)
	* 1.412. [947. 移除最多的同行或同列石头 Most Stones Removed with Same](#MostStonesRemovedwithSame)
	* 1.413. [948 Bag of Tokens](#BagofTokens)
	* 1.414. [949 Largest Time for Given Digits](#LargestTimeforGivenDigits)
	* 1.415. [952 Largest Component Size by Commo](#LargestComponentSizebyCommo)
	* 1.416. [953 Verifying an Alien Dictionary](#VerifyinganAlienDictionary)
	* 1.417. [954 Array of Doubled Pairs](#ArrayofDoubledPairs)
	* 1.418. [959. 由斜杠划分区域 Regions Cut By Slashes](#RegionsCutBySlashes)
	* 1.419. [964. Least Operators to Express Number](#LeastOperatorstoExpressNumber)
	* 1.420. [966 Vowel Spellchecker](#VowelSpellchecker)
	* 1.421. [967. Numbers With Same Consecutive Differences](#NumbersWithSameConsecutiveDifferences)
	* 1.422. [968 Binary Tree Cameras](#BinaryTreeCameras)
	* 1.423. [969 Pancake Sorting](#PancakeSorting)
	* 1.424. [971 Flip Binary Tree To Match Preorder](#FlipBinaryTreeToMatchPreorder)
	* 1.425. [973 K Closest Points to Origin](#KClosestPointstoOrigin)
	* 1.426. [974. 和可被 K 整除的子数组 Subarray Sums Divisible by K](#KSubarraySumsDivisiblebyK)
	* 1.427. [975. Odd Even Jump](#OddEvenJump)
	* 1.428. [976 Middle of the Linked List](#MiddleoftheLinkedList-1)
	* 1.429. [977 Squares of a Sorted Array](#SquaresofaSortedArray)
	* 1.430. [978. 最长湍流子数组 Longest Turbulent Subarray](#LongestTurbulentSubarray)
	* 1.431. [980. Unique Paths III](#UniquePathsIII)
	* 1.432. [983 Minimum Cost For Tickets](#MinimumCostForTickets)
	* 1.433. [986 Interval List Intersections](#IntervalListIntersections)
	* 1.434. [987 Vertical Order Traversal of a Binary](#VerticalOrderTraversalofaBinary)
	* 1.435. [990. 等式方程的可满足性 Satisfiability of Equality Equations](#SatisfiabilityofEqualityEquations)
	* 1.436. [992-K 个不同整数的子数组](#K-1)
	* 1.437. [993. 二叉树的堂兄弟节点](#-1)
	* 1.438. [994-腐烂的橘子](#-1)
	* 1.439. [993, 994, 995, 996](#-1)
	* 1.440. [997 Find the Town Judge](#FindtheTownJudge)
	* 1.441. [1000. Minimum Cost to Merge Stones](#MinimumCosttoMergeStones)
	* 1.442. [1001 Grid Illumination](#GridIllumination)
	* 1.443. [1004-最大连续1的个数 III](#III-1)
	* 1.444. [1007 Minimum Domino Rotations For Eq](#MinimumDominoRotationsForEq)
	* 1.445. [1008 Construct Binary Search Tree from](#ConstructBinarySearchTreefrom)
	* 1.446. [1009 Complement of Base 10 Integer](#ComplementofBase10Integer)
	* 1.447. [1010 Pairs of Songs With Total Durations](#PairsofSongsWithTotalDurations)
	* 1.448. [1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ](#PartitionArrayIntoThreePartsWithEqu)
	* 1.449. [1015 Smallest Integer Divisible by K](#SmallestIntegerDivisiblebyK)
	* 1.450. [1019. Next Greater Node In Linked List](#NextGreaterNodeInLinkedList)
	* 1.451. [1022 Sum of Root To Leaf Binary Numbers](#SumofRootToLeafBinaryNumbers)
	* 1.452. [1025,1026,1027,1028](#-1)
	* 1.453. [1024. Video Stitching](#VideoStitching)
	* 1.454. [1026 Maximum Difference Between Nod](#MaximumDifferenceBetweenNod)
	* 1.455. [1029 Two City Scheduling](#TwoCityScheduling)
	* 1.456. [1032 Stream of Characters](#StreamofCharacters)
	* 1.457. [1035 Uncrossed Lines](#UncrossedLines)
	* 1.458. [1041 Robot Bounded In Circle](#RobotBoundedInCircle)
	* 1.459. [1043. Partition Array for Maximum Sum](#PartitionArrayforMaximumSum)
	* 1.460. [1044 Longest Duplicate Substring](#LongestDuplicateSubstring)
	* 1.461. [1046 Last Stone Weight](#LastStoneWeight)
	* 1.462. [1048 Longest String Chain](#LongestStringChain)
	* 1.463. [1055.Shortest Way to Form String 形成字符串的最短路径](#ShortestWaytoFormString)
	* 1.464. [1091-二进制矩阵中的最短路径](#-1)
	* 1.465. [1094 Car Pooling](#CarPooling)
	* 1.466. [1095. Find in Mountain Array](#FindinMountainArray)
	* 1.467. [1105. Filling Bookcase Shelves](#FillingBookcaseShelves)
	* 1.468. [1106. Parsing A Boolean Expression](#ParsingABooleanExpression)
	* 1.469. [1110. Delete Nodes And Return Forest](#DeleteNodesAndReturnForest)
	* 1.470. [1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses](#MaximumNestingDepthofTwoValidParentheses)
	* 1.471. [1114 - 1115 - 1116 - 多线程 threading](#threading)
	* 1.472. [1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖](#LowestCommonAncestorofDeepestLeaves)
	* 1.473. [1124. Longest Well-Performing Interval](#LongestWell-PerformingInterval)
	* 1.474. [1125. Smallest Sufficient Team](#SmallestSufficientTeam)
	* 1.475. [1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs](#NumberofEquivalentDominoPairs)
	* 1.476. [1129. Shortest Path with Alternating Colors](#ShortestPathwithAlternatingColors)
	* 1.477. [1137. N-th Tribonacci Number](#N-thTribonacciNumber)
	* 1.478. [1140. Stone Game II](#StoneGameII)
	* 1.479. [1143 Longest Common Subsequence](#LongestCommonSubsequence)
	* 1.480. [1145. Binary Tree Coloring Game](#BinaryTreeColoringGame)
	* 1.481. [1155. Number of Dice Rolls With Target Sum](#NumberofDiceRollsWithTargetSum)
	* 1.482. [1160. 拼写单词 Find Words That Can Be Formed by Characters](#FindWordsThatCanBeFormedbyCharacters)
	* 1.483. [1172. Dinner Plate Stacks](#DinnerPlateStacks)
	* 1.484. [1178. Number of Valid Words for Each Puzzle](#NumberofValidWordsforEachPuzzle)
	* 1.485. [1187. Make Array Strictly Increasing](#MakeArrayStrictlyIncreasing)
	* 1.486. [1191. K-Concatenation Maximum Sum](#K-ConcatenationMaximumSum)
	* 1.487. [1201. Ugly Number III](#UglyNumberIII)
	* 1.488. [1202. Smallest String With Swaps](#SmallestStringWithSwaps)
	* 1.489. [1203. 项目管理 Sort Items by Groups Respecting Dependencies](#SortItemsbyGroupsRespectingDependencies)
	* 1.490. [1206. Design Skiplist](#DesignSkiplist)
	* 1.491. [1209 Remove All Adjacent Duplicates in](#RemoveAllAdjacentDuplicatesin)
	* 1.492. [1217 Minimum Cost to Move Chips](#MinimumCosttoMoveChips)
	* 1.493. [1218. Longest Arithmetic Subsequence of Given Difference](#LongestArithmeticSubsequenceofGivenDifference)
	* 1.494. [1220. Count Vowels Permutation](#CountVowelsPermutation)
	* 1.495. [1223 Dice Roll Simulation](#DiceRollSimulation)
	* 1.496. [1240 Tiling a Rectangle with the Fewest Squares](#TilingaRectanglewiththeFewestSquares)
	* 1.497. [1248-统计「优美子数组」](#-1)
	* 1.498. [1249 Minimum Remove to Make Valid Pare](#MinimumRemovetoMakeValidPare)
	* 1.499. [1252 1253 1254 1255](#-1)
	* 1.500. [1263. Minimum Moves to Move a Box to Their Target](#MinimumMovestoMoveaBoxtoTheirTarget)
	* 1.501. [1277-统计全为1的正方形子矩阵](#-1)
	* 1.502. [1278. Palindrome Partitioning III](#PalindromePartitioningIII)
	* 1.503. [1283 Find the Smallest Divisor Given a](#FindtheSmallestDivisorGivena)
	* 1.504. [1284. Minimum Number of Flips to Convert Binary Matrix](#MinimumNumberofFlipstoConvertBinaryMatrix)
	* 1.505. [1290. 二进制链表转整数 (Convert Binary Number in a Linked List](#ConvertBinaryNumberinaLinkedList)
	* 1.506. [1291 Sequential Digits](#SequentialDigits)
	* 1.507. [1293. Shortest Path in a Grid with Obstacles Elimination](#ShortestPathinaGridwithObstaclesElimination)
	* 1.508. [1296. Divide Array in Sets of K Consecutive Numbers](#DivideArrayinSetsofKConsecutiveNumbers)
	* 1.509. [1301. Number of Paths with Max Score](#NumberofPathswithMaxScore)
	* 1.510. [1302 Deepest Leaves Sum](#DeepestLeavesSum)
	* 1.511. [1305 All Elements in Two Binary Search](#AllElementsinTwoBinarySearch)
	* 1.512. [1306 Jump Game III](#JumpGameIII)
	* 1.513. [1310. XOR Queries of a Subarray](#XORQueriesofaSubarray)
	* 1.514. [1312. Minimum Insertion Steps to Make a String Palindrom](#MinimumInsertionStepstoMakeaStringPalindrom)
	* 1.515. [1320. Minimum Distance to Type a Word Using Two Finger](#MinimumDistancetoTypeaWordUsingTwoFinger)
	* 1.516. [1329 Sort the Matrix Diagonally](#SorttheMatrixDiagonally)
	* 1.517. [1332 Remove Palindromic Subsequences](#RemovePalindromicSubsequences)
	* 1.518. [1334. Find the City With Smallest Number of Neighbors](#FindtheCityWithSmallestNumberofNeighbors)
	* 1.519. [1335. Minimum Difficulty of a Job Schedule](#MinimumDifficultyofaJobSchedule)
	* 1.520. [1337 The K Weakest Rows in a Matrix](#TheKWeakestRowsinaMatrix)
	* 1.521. [1339 Maximum Product of Splitt](#MaximumProductofSplitt)
	* 1.522. [1340. Jump Game V](#JumpGameV)
	* 1.523. [1349. Maximum Students Taking Exam](#MaximumStudentsTakingExam)
	* 1.524. [1353. Maximum Number of Events That Can Be Attended](#MaximumNumberofEventsThatCanBeAttended)
	* 1.525. [1354. Construct Target Array With Multiple Sums](#ConstructTargetArrayWithMultipleSums)
	* 1.526. [1368. Minimum Cost to Make at Least One Valid Path](#MinimumCosttoMakeatLeastOneValidPath)
	* 1.527. [1371. Find the Longest Substring Containing Vowels in Eve](#FindtheLongestSubstringContainingVowelsinEve)
	* 1.528. [1373. Maximum Sum BST in Binary Tree](#MaximumSumBSTinBinaryTree)
	* 1.529. [1377. Frog Position After T Seconds](#FrogPositionAfterTSeconds)
	* 1.530. [1379 Find Corresponding Node of Binary Tree in a Clone](#FindCorrespondingNodeofBinaryTreeinaClone)
	* 1.531. [1382. Balance a Binary Search Tree](#BalanceaBinarySearchTree)
	* 1.532. [1395. Count Number of Teams](#CountNumberofTeams)
	* 1.533. [1396 Design Underground System](#DesignUndergroundSystem)
	* 1.534. [1406. Stone Game III](#StoneGameIII)
	* 1.535. [1409. Queries on a Permutation With Key](#QueriesonaPermutationWithKey)
	* 1.536. [1416. Restore The Array](#RestoreTheArray)
	* 1.537. [1424. Diagonal Traverse II](#DiagonalTraverseII)
	* 1.538. [1425. Constrained Subset Sum](#ConstrainedSubsetSum)
	* 1.539. [1426  Counting Elements](#CountingElements)
	* 1.540. [1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie](#KidsWiththeGreatestNumberofCandie)
	* 1.541. [1437 Check If All 1's Are at Least Length](#CheckIfAll1sAreatLeastLength)
	* 1.542. [1438. Longest Continuous Subarray With Absolute](#LongestContinuousSubarrayWithAbsolute)
	* 1.543. [1441 Build an Array With Stack Operations](#BuildanArrayWithStackOperations)
	* 1.544. [1442. Count Triplets That Can Form Two Arrays of Equal](#CountTripletsThatCanFormTwoArraysofEqual)
	* 1.545. [1443. Minimum Time to Collect All Apples in a Tree](#MinimumTimetoCollectAllApplesinaTree)
	* 1.546. [1444. Number of Ways of Cutting a Pizza](#NumberofWaysofCuttingaPizza)
	* 1.547. [1446 Consecutive Characters](#ConsecutiveCharacters)
	* 1.548. [1448 Count Good Nodes in Binary Tree](#CountGoodNodesinBinaryTree)
	* 1.549. [1449. Form Largest Integer With Digits That Add](#FormLargestIntegerWithDigitsThatAdd)
	* 1.550. [1451 Rearrange Words in a Sentence](#RearrangeWordsinaSentence)
	* 1.551. [1453 Maximum Number of Darts Inside of a Circular Dartb](#MaximumNumberofDartsInsideofaCircularDartb)
	* 1.552. [1457 Pseudo-Palindromic Paths in a Bin](#Pseudo-PalindromicPathsinaBin)
	* 1.553. [1461 Check If a String Contains All Binar](#CheckIfaStringContainsAllBinar)
	* 1.554. [1463 Cherry Pickup II](#CherryPickupII)
	* 1.555. [1473. Paint House III](#PaintHouseIII)
	* 1.556. [1475. Final Prices With a Special Discount in a Sho](#FinalPricesWithaSpecialDiscountinaSho)
	* 1.557. [1483. Kth Ancestor of a Tree Node](#KthAncestorofaTreeNode)
	* 1.558. [1488. Avoid Flood in The City](#AvoidFloodinTheCity)
	* 1.559. [1489. Find Critical and Pseudo-Critical Edges in](#FindCriticalandPseudo-CriticalEdgesin)
	* 1.560. [1492 The kth Factor of n](#ThekthFactorofn)
	* 1.561. [1493. Longest Subarray of 1's After Deleting One](#LongestSubarrayof1sAfterDeletingOne)
	* 1.562. [1499. Max Value of Equation](#MaxValueofEquation)
	* 1.563. [1502 Can Make Arithmetic Progression From Sequence](#CanMakeArithmeticProgressionFromSequence)
	* 1.564. [1503 Last Moment Before All Ants Fall Out of a Plank](#LastMomentBeforeAllAntsFallOutofaPlank)
	* 1.565. [1505. Minimum Possible Integer After at Most K Adjacent](#MinimumPossibleIntegerAfteratMostKAdjacent)
	* 1.566. [1508. Range Sum of Sorted Subarray Sums](#RangeSumofSortedSubarraySums)
	* 1.567. [1510 Stone Game IV](#StoneGameIV)
	* 1.568. [1514 Path with Maximum Probability](#PathwithMaximumProbability)
	* 1.569. [1515 Best Position for a Service Centre](#BestPositionforaServiceCentre)
	* 1.570. [1520. Maximum Number of Non-Overlapping Substrings](#MaximumNumberofNon-OverlappingSubstrings)
	* 1.571. [1530. Number of Good Leaf Nodes Pairs](#NumberofGoodLeafNodesPairs)
	* 1.572. [1531. String Compression II](#StringCompressionII)
	* 1.573. [1534 Count Good Triplets](#CountGoodTriplets)
	* 1.574. [1535 Find the Winner of an Array Game](#FindtheWinnerofanArrayGame)
	* 1.575. [1537. Get the Maximum Score](#GettheMaximumScore)
	* 1.576. [1539. Kth Missing Positive Number](#KthMissingPositiveNumber)
	* 1.577. [1542. Find Longest Awesome Substring](#FindLongestAwesomeSubstring)
	* 1.578. [1546. Maximum Number of Non-Overlapping Subarrays With Sum](#MaximumNumberofNon-OverlappingSubarraysWithSum)
	* 1.579. [1550. Three Consecutive Odds](#ThreeConsecutiveOdds)
	* 1.580. [1551 Minimum Operations to Make Array](#MinimumOperationstoMakeArray)
	* 1.581. [1553. Minimum Number of Days to Eat N Oranges](#MinimumNumberofDaystoEatNOranges)
	* 1.582. [1556. Thousand Separator](#ThousandSeparator)
	* 1.583. [1558. Minimum Numbers of Function Calls to Make Target](#MinimumNumbersofFunctionCallstoMakeTarget)
	* 1.584. [1563. Stone Game V](#StoneGameV)
	* 1.585. [1569. Number of Ways to Reorder Array to Get Sa](#NumberofWaystoReorderArraytoGetSa)
	* 1.586. [1573. Number of Ways to Split a String](#NumberofWaystoSplitaString)
	* 1.587. [1585. Check If String Is Transformable With](#CheckIfStringIsTransformableWith)
	* 1.588. [1593. Split a String Into the Max Number of Unique Substri](#SplitaStringIntotheMaxNumberofUniqueSubstri)
	* 1.589. [1595. Minimum Cost to Connect Two Groups of Points](#MinimumCosttoConnectTwoGroupsofPoints)
	* 1.590. [1621. Number of Sets of K Non-Overlapping Line](#NumberofSetsofKNon-OverlappingLine)
	* 1.591. [1631. Path With Minimum Effort](#PathWithMinimumEffort)
	* 1.592. [1632 Rank Transform of a Matrix](#RankTransformofaMatrix)
	* 1.593. [1640 Check Array Formation Through](#CheckArrayFormationThrough)
	* 1.594. [1641 Count Sorted Vowel Strings](#CountSortedVowelStrings)
	* 1.595. [1642. Furthest Building You Can Reach](#FurthestBuildingYouCanReach)
	* 1.596. [1646 Get Maximum in Generated Array](#GetMaximuminGeneratedArray)
	* 1.597. [1648. Sell Diminishing-Valued Colored Balls](#SellDiminishing-ValuedColoredBalls)
	* 1.598. [1649 Create Sorted Array through Instru](#CreateSortedArraythroughInstru)
	* 1.599. [1655. Distribute Repeating Integers](#DistributeRepeatingIntegers)
	* 1.600. [1657 Determine if Two Strings Are Close](#DetermineifTwoStringsAreClose)
	* 1.601. [1658 Minimum Operations to Reduce X](#MinimumOperationstoReduceX)
	* 1.602. [1659. Maximize Grid Happiness](#MaximizeGridHappiness)
	* 1.603. [1662 Check If Two String Arrays are Equi](#CheckIfTwoStringArraysareEqui)
	* 1.604. [1663 Smallest String With A Given Numer](#SmallestStringWithAGivenNumer)
	* 1.605. [1673 Find the Most Competitive Subseq](#FindtheMostCompetitiveSubseq)
	* 1.606. [1674. Minimum Moves to Make Array Complement](#MinimumMovestoMakeArrayComplement)
	* 1.607. [1675. Minimize Deviation in Array](#MinimizeDeviationinArray)
	* 1.608. [1679 Max Number of K-Sum Pairs】](#MaxNumberofK-SumPairs)
	* 1.609. [1680 Concatenation of Consecutive Bina](#ConcatenationofConsecutiveBina)
	* 1.610. [1681. Minimum Incompatibility](#MinimumIncompatibility)
	* 1.611. [1690. Stone Game VII](#StoneGameVII)
	* 1.612. [1696. Jump Game VI](#JumpGameVI)
	* 1.613. [1704 Determine if String Halves Are Alike](#DetermineifStringHalvesAreAlike)
	* 1.614. [1707. Maximum XOR With an Element From Array](#MaximumXORWithanElementFromArray)
	* 1.615. [1713. Minimum Operations to Make a Subsequence](#MinimumOperationstoMakeaSubsequence)
	* 1.616. [1721 Swapping Nodes in a Linked List](#SwappingNodesinaLinkedList)
	* 1.617. [1727. Largest Submatrix With Rearrangements](#LargestSubmatrixWithRearrangements)
	* 1.618. [1745. Palindrome Partitioning IV](#PalindromePartitioningIV)
	* 1.619. [1760. Minimum Limit of Balls in a Bag](#MinimumLimitofBallsinaBag)
	* 1.620. [1770. Maximum Score from Performing Multiplication](#MaximumScorefromPerformingMultiplication)
	* 1.621. [1771. Maximize Palindrome Length From Subsequences](#MaximizePalindromeLengthFromSubsequences)
	* 1.622. [1775. Equal Sum Arrays With Minimum Number of Operatio](#EqualSumArraysWithMinimumNumberofOperatio)
	* 1.623. [1786. Number of Restricted Paths From First to Last Node](#NumberofRestrictedPathsFromFirsttoLastNode)
	* 1.624. [1792. Maximum Average Pass Ratio](#MaximumAveragePassRatio)
	* 1.625. [1799. Maximize Score After N Operations](#MaximizeScoreAfterNOperations)
	* 1.626. [1815. Maximum Number of Groups Getting Fresh Donuts](#MaximumNumberofGroupsGettingFreshDonuts)
	* 1.627. [1838. Frequency of the Most Frequent Element](#FrequencyoftheMostFrequentElement)
	* 1.628. [1847. Closest Room](#ClosestRoom)
	* 1.629. [1872. Stone Game VIII](#StoneGameVIII)
	* 1.630. [s](#s)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name=''></a>题目

###  1.1. <a name='SameTree'></a>100-Same Tree 

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7ti?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vf4y1R7Ue?spm_id_from=333.999.0.0)

> python:

```py
self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

```py
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        return str(p)==str(q)
```



> scala

```scala
object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        if (p == null && q == null) {
        true
        } else if (p == null || q == null) {
        false
        } else if (p.value == q.value) {
        isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        } else {
        false
        }
    }
}


object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
     if (p!=null && q!=null) {
       p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
     } else {
       p == q
     }
   }
}

object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        (p,q) match {
          case (p,q) if (p!=null && q!=null) => p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
          case (p,q) => p==q
        }
    }
  }
```

###  1.2. <a name='Symmetrictree'></a>101-Symmetric tree

[哈哈哈](https://www.bilibili.com/video/BV1VJ41197KD?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xv41167z8?spm_id_from=333.999.0.0)

> Python 迭代：其实就是层序遍历，然后检查每一层是不是回文数组

```py
class Solution(object):
    def isSymmetric(self, root):
        layer = [root]
        
        while(layer):
            nextLayer = []
            vals = []
            for node in layer:
                if not node # 有一种情况是[None]
                    vals.append(None)
                    continue
                nextLayer.append(node.left)
                nextLayer.append(node.right)
                
                vals.append(node.val)
                
            if vals != vals[::-1]:
                return False
            layer = nextLayer
            
        return True
```

> Python 递归：

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def twoSym(node1, node2):
            if node1 and node2 and node1.val == node2.val: 
                return twoSym(node1.left, node2.right) and twoSym(node1.right, node2.left)
            elif not node1 and not node2:
                return True
            else:
                return False
        return twoSym(root.left, root.right)
```

> scala:

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def symmetric(nodeA: TreeNode, nodeB: TreeNode): Boolean = {
        if(nodeA == null && nodeB == null){
            true
        }else if(nodeA !=null && nodeB != null){
            if(nodeA.value != nodeB.value){
                false
            }else{
                symmetric(nodeA.left, nodeB.right) && symmetric(nodeA.right, nodeB.left)
            }
        }else{
            false
        }
    }
    
    def isSymmetric(root: TreeNode): Boolean = {
        if(root == null){
            true
        } else{
            symmetric(root.left, root.right)
        }
    }
}

```

###  1.3. <a name='BinaryTreeLevelOrderTraversal'></a>102-Binary Tree Level Order Traversal

[哈哈哈](https://www.bilibili.com/video/BV1W54y197Lc?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14T4y1u7Wk?spm_id_from=333.999.0.0)

> python queue

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)): # 当前层的个数!!!
                node=queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res


from collections import deque
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []

        queue = deque([root]) 
        res = []
        
        while queue: 
            level = [] 
            for _ in range(len(queue)): 
                node = queue.popleft() 
                level.append(node.val) 
                if node.left:
                    queue.append(node.left) 
                if node.right:
                    queue.append(node.right) 
            res.append(level) 
        return res
```


> python 递归


```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []

        def bfs(node, level):
            if node: 
                if len(res) < level + 1:
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level+1)
                bfs(node.right, level+1)

        bfs(root, 0)
        return res

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        dic = collections.defaultdict(list)

        def bfs(node, level):
            if node:
                dic[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0) 
        return [*dic.values()]
```

> scala queue

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val buffer =  scala.collection.mutable.Queue[TreeNode]()
        val res =  scala.collection.mutable.ListBuffer[List[Int]]()

        if(root == null) return List[List[Int]]()
        buffer.enqueue(root)
	
        while(buffer.nonEmpty) {
          val cur = scala.collection.mutable.ListBuffer[Int]()
          for ( _ <- 0 until buffer.size) {
            val node = buffer.dequeue
            cur.append(node.value)
            if(node.left != null) buffer.enqueue(node.left)
            if(node.right != null) buffer.enqueue(node.right)
        }
        res += cur.toList
        }
        res.toList
    }
}
```

> scala 递归

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val oderMap = scala.collection.mutable.Map[Int, List[Int]]()
        bfs(root, 1, oderMap)
        oderMap.values.toList
    }
    def bfs(node: TreeNode, level: Int, map: scala.collection.mutable.Map[Int, List[Int]]): Unit = {
        if (node != null) {
            val l = map.get(level)
                .map(_ :+ node.value)
                .getOrElse(List(node.value))

            map(level) = l
            bfs(node.left, level + 1, map)
            bfs(node.right, level + 1, map)
        }
    }
}
```

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        bfs(if(root == null) List() else List(root), List())
    }

    // @annotation.tailrec
    // @annotation.tailrec 告诉编译器，下面这个函数是递归的，在栈桢的管理上，希望编译器能所有优化。
    def bfs(queue: List[TreeNode], ans: List[List[Int]]): List[List[Int]] = {
        if(queue.isEmpty) ans
        else{
        bfs(queue.flatMap(n => List(n.left, n.right)).filter(_ != null), ans :+ queue.map(n => n.value))
        }
    }
}
```

###  1.4. <a name='BinaryTreeZigzagLevelOrderTraversal'></a>103. Binary Tree Zigzag Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1NE411M7Fm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15h411Z7h5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GA411W7NY?spm_id_from=333.999.0.0)

> python 队列

```py
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: 
            return []

        queue = [root]
        res = []
        indexflag = 1 
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        queue = [root]
        res = []
        indexflag = 1 
        while queue and queue[0]: # 或者
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

# python 双端duque
from collections import deque
class Solution:
    def zigzagLevelOrder(self, root):
        queue = deque([root])
        res = []
        flag = True # flag
        while queue and queue[0]:
            level = []
            for _ in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            if flag: # flag
                res.append(level)
            else:
                res.append(level[::-1])  # [::-1]反转
            flag = bool(1-flag) # flag
        return res
```

递归

```py
class Solution:
    def zigzagLevelOrder(self, root):
        res = []
        def bfs(node, level):
            if node:
                if level >= len(res):
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0)
        for i in range(1, len(res), 2): # flag，各两个逆序
            res[i] = res[i][::-1]
        return res
```

###  1.5. <a name='MaximumDepthofBinary'></a>104-Maximum Depth of Binary

[哈哈哈](https://www.bilibili.com/video/BV1AJ411Q7xG?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1u54y1D7Nx?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tK41137GM?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

```scala
object Solution1 {
    def maxDepth(root: TreeNode): Int = {
        if (root == null) return 0
        math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}

object Solution {
    def maxDepth(root: TreeNode): Int = root match {
        case null => 0
        case x: TreeNode => Math.max((1 + maxDepth(x.left)), (1 + maxDepth(x.right)))
    }
}

object Solution2 {
    def maxDepth(root: TreeNode): Int = {
        if(root == null) return 0
        var depth = 0
        val queue = scala.collection.mutable.Queue[TreeNode]()
        queue.enqueue(root)

        while(queue.nonEmpty) {
            depth += 1
            for(_ <- 0 until queue.size){
                val node = queue.dequeue
                if(node.left != null) queue.enqueue(node.left)
                if(node.right != null) queue.enqueue(node.right)
            }
        }   
        depth
    }
}
```

###  1.6. <a name='-1'></a>105-从前序与中序遍历序列构

[哈哈哈](https://www.bilibili.com/video/BV1uv411B73D?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1x54y1d7e8?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1ry4y1U7ZR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14A411q7Nv?spm_id_from=333.999.0.0)

> PYTHON 递归

```py
class Solution:
    def buildTree(self, preorder, inorder):
        if inorder:
            root = TreeNode(preorder.pop(0))
            i = inorder.index(root.val)
            root.left = self.buildTree(preorder, inorder[: i])
            root.right = self.buildTree(preorder, inorder[i + 1:])
            return root

class Solution:
    def buildTree(self, preorder, inorder):
        if preorder: # 也可以
        if inorder:
          root = TreeNode(preorder.pop(0))
          i = inorder.index(root.val)
          root.left = self.buildTree(preorder[:i], inorder[:i])
          root.right = self.buildTree(preorder[i:], inorder[i+1:])
          return root

```

###  1.7. <a name='-1'></a>106-从中序与后序遍历序列构造二叉树

[哈哈哈](https://www.bilibili.com/video/BV1r5411W7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jh411Z7y8?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if inorder:
            root = TreeNode(postorder.pop())
            i = inorder.index(root.val)
            root.left = self.buildTree(inorder[:i], postorder[:i])
            root.right = self.buildTree(inorder[i+1:], postorder[i:])
            return root
```

###  1.8. <a name='BinaryTreeLevelOrderTraversalII'></a>107-Binary Tree Level Order Traversal II

[哈哈哈](https://www.bilibili.com/video/BV1eJ411z7d6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1yK411n76R?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qA411i7P4?spm_id_from=333.999.0.0)


```py
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res[::-1]
```

###  1.9. <a name='ConvertSortedArraytoBinarySearchTree'></a>108 Convert Sorted Array to Binary Search Tree 

[花花酱](https://www.bilibili.com/video/BV1F7411H7tH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1JJ411q74U?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wa411c7tS?spm_id_from=333.999.0.0)

> python

```py
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if nums:
            mid = len(nums) // 2
            root = TreeNode(nums[mid])
            root.left = self.sortedArrayToBST(nums[:mid])
            root.right = self.sortedArrayToBST(nums[mid+1:])
            return root
```

scala 中没有这种形式的写法 nums[:mid]，nums[mid+1:]

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def formTree(nums: Array[Int], begin: Int, end: Int): TreeNode = {
        var mid = begin + Math.ceil((end - begin)/2).toInt
        TreeNode(
            nums(mid), 
            if(mid <= begin) null else formTree(nums, begin, mid-1), 
            if(mid >= end) null else formTree(nums, mid+1, end)
        )
    }
    
    def sortedArrayToBST(nums: Array[Int]): TreeNode = {
        if(nums.isEmpty){
            null
        }else{
            formTree(nums, 0, nums.size - 1)
        }
    }
}

```

###  1.10. <a name='-1'></a>109题. 有序链表转换二叉搜索树

https://www.bilibili.com/video/BV19a4y157U8?spm_id_from=333.999.0.0

https://www.bilibili.com/video/BV1ff4y197dS?spm_id_from=333.999.0.0

当递归的是一个链表`头`时，需要切断

```py
class Solution:
    def sortedListToBST(self, head) -> TreeNode:
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)

        fast = head
        slow = head
        pre =  head

        while fast and fast.next:
            pre = slow # pre切断
            slow = slow.next
            fast = fast.next.next
        mid = TreeNode(slow.val)
        # print(head.val,node.val,last.val)
        mid.right = self.sortedListToBST(slow.next) # 从mid+1到tail
        pre.next = None # pre切断
        mid.left = self.sortedListToBST(head) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        return mid
```

https://www.bilibili.com/video/BV19K411T73P?p=2&spm_id_from=pageDriver

当递归的是一个链表`头尾`时，不需要切断

```py
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getMedian(head: ListNode, tail: ListNode) -> ListNode:
            fast = slow = head
            while fast != tail and fast.next != tail:
                fast = fast.next.next
                slow = slow.next
            return slow
        
        def buildTree(left: ListNode, right: ListNode) -> TreeNode:
            if left == right:
                return None
            mid = getMedian(left, right)
            root = TreeNode(mid.val)
            root.left = buildTree(left, mid) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
            root.right = buildTree(mid.next, right) # 从mid+1到tail
            return root
        
        return buildTree(head, None)
```

###  1.11. <a name='BalancedBinaryTree'></a>110-Balanced Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1NJ411v7b1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Lb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sV411b7hR?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            return max(height(root.left), height(root.right)) + 1

        if not root:
            return True
        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)
        # 注意：左右两个子树也必须balanced


其实就是二叉树先序遍历和后序遍历的区别，每种遍历方式都有它的用武之地。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        ans = True
        
        def postorder(root):
            nonlocal ans
            if not root or not ans:
                return 0
            leftH = postorder(root.left)
            rightH = postorder(root.right)
            if abs(leftH-rightH) > 1:
                ans = False
            return max(leftH, rightH) + 1
        
        postorder(root)
        return ans

必须用

nonlocal + ans

如下返回错误结果 postorder(root,bol)

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        bol = True
        
        def postorder(root,bol):
            if not root or not bol:
                return 0
            leftH = postorder(root.left,bol)
            rightH = postorder(root.right,bol)
            if abs(leftH-rightH) > 1:
                bol = False
            return max(leftH, rightH) + 1
        
        postorder(root,bol)
        return bol
```

###  1.12. <a name='MinimumDepthofBinaryTree'></a>111-Minimum Depth of Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1E7411k7KY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1XZ4y1G7xM?spm_id_from=333.999.0.0)

递归

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root:
            if root.left and root.right:
                return 1+min(self.minDepth(root.left),self.minDepth(root.right))
            elif root.left:
                return 1+self.minDepth(root.left) #较高一层的值
            elif root.right:
                return 1+self.minDepth(root.right) #较高一层的值
            else:
                return 1
        else:
            return 0
```

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        # 如果 没有 root
        if not root:
            return 0
        # 如果 只有 root
        elif not root.left and not root.right:
            return 1
        else:
        # 如果 root 有 子树
            minDepth = float('inf')
            if root.left:
                minDepth = min(self.minDepth(root.left), minDepth) 
            if root.right:
                minDepth = min(self.minDepth(root.right), minDepth) 
            return minDepth + 1
```

队列

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        que = collections.deque([(root, 1)]) # 注意这个写法：[(root, 1)] 的括号
        while que:
            node, depth = que.popleft()
            if not node.left and not node.right:
                return depth
            if node.left: 
                que.append((node.left, depth + 1)) # 注意这个写法：(node.left, depth + 1) 的括号
            if node.right:
                que.append((node.right, depth + 1))
        
        return 0
```

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        bfs(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def bfs(queue: List[TreeNode], res: Int): Int = {
        if(queue.isEmpty) res
        // node has no child 
        else if(queue.exists(t => t.left == null && t.right == null)) res + 1
        else bfs(queue.flatMap(t => List(t.left, t.right)).filter(_ != null), res + 1)
    }
}

object Solution1 {
    def minDepth(root: TreeNode): Int = {
        if (root == null) return 0
        val left = minDepth(root.left) 
        val right = minDepth(root.right) 

        if (left == 0 || right == 0) left + right + 1 else math.min(left, right) + 1
        
    }
}

object Solution1_2 {
    def minDepth(root: TreeNode): Int = {
        if(root == null) 0
        else if(root.left == null) minDepth(root.right) + 1
        else if(root.right == null) minDepth(root.left) + 1
        else minDepth(root.right) + 1 min minDepth(root.left) + 1
    
    }
}
```

队列

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        if(root == null) return 0
        val que = scala.collection.mutable.Queue[TreeNode]()
        var depth = 0
        var flag = true
        que.enqueue(root)
        
        while(que.nonEmpty && flag){
            depth += 1
            for(_ <- 0 until que.size; if flag){
                val node = que.dequeue
                if(node.left == null && node.right == null) flag = false
                else {
                    if(node.left != null) que.enqueue(node.left)
                    if(node.right != null) que.enqueue(node.right)
                } 
            } 
        }
        depth
        
    }
} 
```

###  1.13. <a name='PathSum'></a>112-Path Sum

[哈哈哈](https://www.bilibili.com/video/BV1T7411r7Yr?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1pb411e7r7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1uK411T7kX?spm_id_from=333.999.0.0)

递归

```py
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if root is None:
            return False
        if root.val==targetSum:
            return True
        return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
```

```py
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que = collections.deque([(root, root.val)])
        while que:
            node, tmp = que.popleft()
            if not node.left and not node.right:
                if tmp == sum:
                    return True
                continue
            if node.left:
                que.append((node.left,node.left.val + tmp))
            if node.right:
                que.append((node.right,node.right.val + tmp))
        return False
```

###  1.14. <a name='-1'></a>113. 二叉树中和为某一值的路径

[哈哈哈](https://www.bilibili.com/video/BV1P54y1i73U?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1k54y177fu?spm_id_from=333.999.0.0)

```py
# 注意比较这两个写法
# 路径记忆，计算效率好像更😕
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        path = []
        
        def dfs(node, tsum):
            if not node:
                return
            
            path.append(node.val)
            tsum -= node.val # 对于每一个node，当前node的sum = 总和sum - root的值
            
            if not node.left and not node.right and tsum == 0: # 结束条件
                res.append(path[:])
            dfs(node.left, tsum)
            dfs(node.right, tsum)
            
            path.pop()
        
        dfs(root, targetSum)
        return res
```

```py
# 注意比较这两个写法
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        
        def dfs(node, path, tsum):
            
            if not node:
                return 
            
            tsum -= node.val # 对于每一个node，当前node的sum = 总和sum - root的值
            
            if not node.left and not node.right and tsum == 0: # 结束条件
                res.append(path + [node.val]) # 可以不需要深拷贝
                
            dfs(node.left, path + [node.val], tsum)
            dfs(node.right, path + [node.val], tsum)
        
        dfs(root, [], targetSum)
        return res

class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res=[]

        def dfs(node,path,tsum):

            if node is None:
                return

            if node.val == tsum and node.left is None and node.right is None:
                res.append(path[:] + [node.val])  # 需要深拷贝

            dfs(node.left,path + [node.val], tsum-node.val)
            dfs(node.right,path + [node.val], tsum-node.val)
            
        dfs(root,[],targetSum)
        return res
```

###  1.15. <a name='-1'></a>114题. 二叉树展开为链表

https://www.bilibili.com/video/BV1T7411A7S8?from=search&seid=15731266160913668837&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6tma3pncods0.png" width="80%">

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5csg54lu3lw0.png" width="50%">

递归

```py
class Solution(object):
    def flatten(self, root):
        if not root:
            return
        #把子树备份一下
        tmpleft = root.left
        tmpright = root.right
        root.left = None #记得把左子树置空
        #先把左右子树捋直
        self.flatten(tmpleft)
        self.flatten(tmpright)
        if tmpleft:
            root.right = tmpleft #把捋直的左子树放到右边
            while tmpleft.right: #找到现在右子树的最后一个node
                tmpleft = tmpleft.right 
            tmpleft.right = tmpright #左子树接上右子树
```

stack: 先看144题

```py
class Solution:
    def flatten(self, root: TreeNode) -> None:
        if not root:
            return
        
        stack = [root]
        pre = None # 穿针引线
        
        while stack:
            cur = stack.pop()
            if pre:
                pre.left = None # 穿针引线
                pre.right = cur # 穿针引线
            left, right = cur.left, cur.right
            if right:
                stack.append(right)
            if left:
                stack.append(left)
            pre = cur # 穿针引线

        return root

class Solution:
    def flatten(self, root: TreeNode) -> None:
        preorderList = list()
        stack = list()
        node = root

        while node or stack:
            while node:
                preorderList.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        
        n = len(preorderList)
        for i in range(1, n):
            prev, curr = preorderList[i - 1], preorderList[i] # 穿针引线
            prev.left = None # 穿针引线
            prev.right = curr # 穿针引线
```


###  1.16. <a name='DistinctSubsequences'></a>115. Distinct Subsequences

[花花酱](https://www.bilibili.com/video/BV1EW411d7PC?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV185411G7F6?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        for i in range(sN+1):
            for j in range(tN+1):
                if j == 0:  
                    dp[i][j] = 1
                elif i == 0:  
                    dp[i][j] = 0
                elif s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
Python3:

class SolutionDP2:
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(s), len(t)
        if n1 < n2:
            return 0

        dp = [0 for _ in range(n2 + 1)]
        dp[0] = 1

        for i in range(1, n1 + 1):
            prev = dp[:] # 深拷贝一下
            end = i if i < n2 else n2 # 剪枝，保证s的长度大于等于t, 因为对于任意i，i > n1, dp[i] = 0, 没必要跟新状态。 
            for j in range(1, end + 1):
                if s[i - 1] == t[j - 1]:
                    dp[j] = prev[j - 1] + prev[j]
                else:
                    dp[j] = prev[j]
        return dp[-1]
```

###  1.17. <a name='PopulatingNextRightPointersinEachNode'></a>116. Populating Next Right Pointers in Each Node

[花花酱](https://www.bilibili.com/video/BV1b4411R7G4?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1zQ4y1M75t?spm_id_from=333.999.0.0)

```py
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        
        que = [root]
        while que:
            n = len(que)
            pre = Node(0) # 指针
            for _ in range(n):
                node = que.pop(0)
                if pre:
                    pre.next = node
                pre = node

                if node.left:
                    que.append(node.left)
                if node.right:
                    que.append(node.right)
        
        return root

class Solution:
    # 层次遍历
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        que = deque([root])
        while que:
            n = len(que)
            for i in range(n):        # 每一层n固定
                cur = que.popleft()
                if i < n - 1:         # 只要不是最后一个，就连上
                    cur.next = que[0] # 只要不是最后一个，就连上
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            
        return root
```

```py
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if root:
            l,r=root.left,root.right
            while l:
                l.next=r
                l,r=l.right,r.left
            self.connect(root.left)
            self.connect(root.right)
        return root
```

###  1.18. <a name='PopulatingNextRightPointersinEa'></a>117 Populating Next Right Pointers in Ea (可跳过)

[小明](https://www.bilibili.com/video/BV1np4y1r7fQ?spm_id_from=333.999.0.0)

看不懂，懵逼了

```py
# 看不懂，懵逼了

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        dummy = Node()
        dummy.next = root
        while dummy.next:
            curp = dummy.next
            dummy.next = None
            pre = dummy
            while curp:
                for cur in [curp.left, curp.right]:
                    if cur:
                        pre.next = cur
                        pre = cur
                curp = curp.next
        return root

# python 非递归方法，常数空间，从顶到下，逐层连接
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        first = root # left_most表示当前层的最左边节点
        while first: # 每次循环连接当前层的下一层
            dummy = pre = Node(0) # head表示下一层的虚拟头部
            cur = first
            while cur : # 遍历当前层，将下一层连接
                if cur.left :
                    pre.next = cur.left
                    pre = pre.next
                if cur.right :
                    pre.next = cur.right
                    pre = pre.next
                cur = cur.next
            first = dummy.next
        return root
```


###  1.19. <a name='PascalsTriangle'></a>118-Pascal's Triangle

[哈哈哈](https://www.bilibili.com/video/BV1T741167KS?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7tJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1D54y147NY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generate(self, numRows):
        res = []
        for i in range(numRows):
            curlevel = [1]*(i+1)
            if i >= 2:
                for n in range(1,i):
                    curlevel[n] = pre[n-1]+pre[n]
                    # 头尾为1，中间的第j个为上一层的第j-1个和j个的和
            res += [curlevel]
            pre = curlevel
        return res
        
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for i in range(numRows):
            level = []
            for j in range(0, i + 1):
                if j == 0 or j == i:
                    level.append(1)
                else:
                    level.append(res[i - 1][j] + res[i - 1][j - 1])
            res.append(level)
        return res
```

```py
库函数重拳出击！
它本质上评估为n! /(k! *(n-k)! )它也被称为二项式系数
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        return [[comb(i, j) for j in range(i + 1)] for i in range(numRows)]
```

```scala
object Solution {
    def generate(numRows: Int): List[List[Int]] = {
        var output = List.empty[List[Int]]
        var curr = 1
        if(numRows == 0){
            output
        }else{
            while(curr <= numRows){
                curr match{
                    case 1 => output = List(List(1))
                    case _ => {
                        val prev = output(curr-2)
                        val begin = 0
                        val end = curr - 1
                        val row = 
                        (0 to curr-1)
                        .map(i => if(i == begin || i == end) 1 else prev(i)+prev(i-1))
                        .toList
                        
                        output = output :+ row
                    }
                }
                curr += 1
            }
        }
        output
    }
}

```

###  1.20. <a name='PascalsTriangleII'></a>119-Pascal's Triangle II

[哈哈哈](https://www.bilibili.com/video/BV187411B7Hj?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7hA?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ni4y1g7Lv?spm_id_from=333.999.0.0)

```py
class Solution3:
    def generate(self, rowIndex):
        for i in range(rowIndex + 1):
            # 用 1 先填充每行所有元素
            curlevel = [1] * (i + 1)
            # 由上一行循环生成当前行元素（除两端）
            for j in range(1, i):
                curlevel[j] = pre[j - 1] + pre[j]
            pre = curlevel
        return curlevel

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        res = [1]
        for i in range(rowIndex):
            res.append(0)
            j = i + 1
            while j > 0:
                res[j] = res[j] + res[j - 1]
                j -= 1
        return res
```

###  1.21. <a name='Triangle'></a>120 Triangle

[小明](https://www.bilibili.com/video/BV1m54y1L7Af?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        i = len(triangle) - 2
        while i >= 0:
            subi = i
            while subi >= 0:
                triangle[i][subi] += min(triangle[i+1][subi],triangle[i+1][subi+1])
                subi -= 1
            i -= 1
        return triangle[0][0]
```

```scala
object Solution {
    def minimumTotal(triangle: List[List[Int]]): Int = {
        val depth = triangle.size
        val dp = triangle.last.toArray
        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices) {
            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) 
        }
        dp(0)
    }
}
```

###  1.22. <a name='BestTimetoBuyandSellStock121-'></a>121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机

[花花酱](https://www.bilibili.com/video/BV1oW411C7UB?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1cZ4y1K7HP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1D7411s7A1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7by?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16z4y1Z7jD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1hA411t76C?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        minprice = 1e9
        for price in prices:
            maxprofit = max(maxprofit,price - minprice)
            minprice = min(minprice,price)
        return maxprofit
```

```scala
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices.foldLeft((Int.MaxValue, 0)){
            case ((minPriceSoFar, maxProfit), price) => (minPriceSoFar min price, maxProfit max (price - minPriceSoFar))
        }._2
    }
}
```

###  1.23. <a name='II122-BestTimetoBuyandSellStockII'></a>122-买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II

[哈哈哈](https://www.bilibili.com/video/BV12K411A7rL?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d7411x78d?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7iq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Fk4y1R7ve?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y1L7LG?spm_id_from=333.999.0.0)

```py
我的写法：

贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度O(n)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
                # preprice = 1e9 是错误的，比如[1,2,3,4,5] 会返回2，应该返回4
                preprice = price
            else:
                preprice = price
        return maxprofit

# 简化为
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
            preprice = price
        return maxprofit
```

```py

其他写法：

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i] > 0])



class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                ans += prices[i] - prices[i-1]
        return ans
```

```scala
/**
* my first commitment
* greedy alg
* time complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices.length > 1){
            prices.sliding(2).collect{ case arr: Array[Int] if arr(1) > arr(0)=> arr}
    .foldLeft(0){(sum, arr) => 
      sum + arr(1) - arr(0)}
        } else {
            0
        }
    }
}

/**
* greedy alg: one line pass
*/

object Solution1-2 {
  def maxProfit(prices: Array[Int]): Int = {
    if(prices.length > 1) prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum else 0
  }
}

//Alternate solution
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices
            .foldLeft(0,Int.MaxValue)((t, current) => (t._1 + 0.max(current-t._2), current))
            ._1
    }
}
 
  object Solution {
    def maxProfit(prices: Array[Int]): Int = {
      if (prices.isEmpty) return 0
      else (0 until prices.length-1).foldLeft(0)(
        (profit,i) =>{
          if (prices(i)<prices(i+1)) profit+prices(i+1)-prices(i) else profit
        }
      )
    }
  }

```

###  1.24. <a name='III'></a>123-买卖股票的最佳时机 III

[哈哈哈](https://www.bilibili.com/video/BV1Xp4y1k7aD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rk4y117z8?spm_id_from=333.999.0.0)

```py
# 我的写法：
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        profit1 = profit2 = 0
        buy1 = buy2 = prices[0]
        for i in range(1,n):
            # 实际上，是从卖出那天开始算，也就是第二天
            buy1 = min(buy1,prices[i])
            profit1 = max(profit1,prices[i]-buy1)
            buy2 = min(buy2,prices[i]-profit1)  # buy2[i]-profit1[i-1] 相当于一个虚拟的买入价格
            profit2 = max(profit2,prices[i]-buy2)
        return profit2

## 未进行空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = [0] * n
        sell1 = [0] * n
        buy2 = [0] * n
        sell2 = [0] * n
        buy1[0] = buy2[0] = -prices[0]
        sell1[0] = sell2[0] = 0
        for i in range(1, n):
            buy1[i]  = max(buy1[i-1], -prices[i]) 
            sell1[i] = max(sell1[i-1], buy1[i-1] + prices[i])
            buy2[i]  = max(buy2[i-1], sell1[i-1] - prices[i])
            sell2[i] = max(sell2[i-1], buy2[i-1] + prices[i])
        return sell2[-1]
```

```scala
object Solution3{
    def maxProfit(prices: Array[Int]): Int = {
        val r = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case (acc, px) =>
                val (buy1, sell1, buy2, sell2) = acc
                val newBuy1 = buy1 max - px
                val newSell1 =  sell1 max (buy1 + px)
                val newBuy2 = buy2 max (sell1 - px)
                val newSell2 = sell2 max (buy2 + px)
                (newBuy1, newSell1, newBuy2, newSell2)
        }
        r._2 max r._4
    }
}

object Solution3-1 {
    def maxProfit(prices: Array[Int]): Int = {
        val (buy1, sell1, buy2, sell2) = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case ((buy1, sell1, buy2, sell2), cost) =>
                (
                    buy1 max -cost,
                    sell1 max (buy1 + cost),
                    buy2 max (sell1 - cost),
                    sell2 max (buy2 + cost)
                )
        }
        sell1 max.sell2
    }
}
```

###  1.25. <a name='BinaryTreeMaximumPathSum'></a>124. Binary Tree Maximum Path Sum

[花花酱](https://www.bilibili.com/video/BV1ct411r7qw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CT4y1g7bR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qT4y1J71C?spm_id_from=333.999.0.0)

```py
我的思考：
        # 有两种情况：
        # node.val 往上回收, 构成递归
        return max(left,right) + node.val
        # node.val 不往上回收, 左中右
        res = max(left+right + node.val, res)

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = -1e9
        # left = right = 0
        def dfs(node) -> int:
            nonlocal res # 也可以写成 self.res
            if not node:
                return 0
            # if node.left:
            left = max(dfs(node.left), 0)     # 正负性：left 为负，就不回收
            # if node.right:
            right = max(dfs(node.right), 0)   # 正负性：right 为负，就不回收
            # 有两种情况：node.val 不往上回收, 左中右
            res = max(left + right + node.val, res)
            # 有两种情况：node.val 往上回收, 构成递归
            return max(left,right) + node.val # 正负性：node.val必须回收
        dfs(root)
        return res
```

```scala
object Solution1 {
    def maxPathSum(root: TreeNode): Int = {
        dfs(root)._1
    }

    def dfs(node: TreeNode): (Int, Int) = {
      if (node == null) return (Int.MinValue, 0)
      
      val (leftSoFar, leftEndingHere) = dfs(node.left)
      val (rightSoFar, rightEndingHere) = dfs(node.right)

      val maxSoFar = leftSoFar max rightSoFar max (node.value + leftEndingHere + rightEndingHere)

      val maxEndingHere = 0 max (node.value + (leftEndingHere max rightEndingHere))
      (maxSoFar, maxEndingHere)
    }
}
```

###  1.26. <a name='ValidPalindrome'></a>125-Valid Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1d7411n7cF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7ML?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17h411Z7ey?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

isalnum() 方法检测字符串是否由字母和数字组成。

isalpha() 方法检测字符串是否只由字母组成。

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) - 1
        while left < right:
            # 易错点：if not s[left].isalnum(): 是不对的，因为存在连续多个“非数字的情况”
            while left < right and not s[left].isalnum(): 
                left += 1
            while left < right and not s[right].isalnum(): 
                right -= 1
            if s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else:
                return False
        return True
```

python牛逼的一行代码：

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        sgood = "".join(ch.lower() for ch in s if ch.isalnum())
        return sgood == sgood[::-1]

class Solution:
    def isPalindrome(self, s):
        s = ''.join(filter(str.isalnum,s)).lower()
        return s==s[::-1]

练习一下正则

import re
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s=re.sub('[^a-zA-Z0-9]','',s)
        s=s.lower()
        return s==s[::-1]
```


```scala

/**
* two pointer comparison
* memo
*  1. alphanumeric = letters + numerals
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def isPalindrome(s: String): Boolean = {
      val newString = s.filter(_.isLetterOrDigit).toLowerCase
      isPalindrome(newString, 0, newString.length - 1)
    }
    @annotation.tailrec
    def isPalindrome(s: String, left: Int, right: Int): Boolean = {
      if (left > right) return true
      if (s(left) == s(right)) isPalindrome(s, left + 1, right - 1)
      else false
    }
}
```


###  1.27. <a name='WordLadderII'></a>126. (bfs好难暂时放弃) Word Ladder II

[花花酱](https://www.bilibili.com/video/BV1yt411Y7gH?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV16K4y1j7hX?spm_id_from=333.999.0.0)

```py
# dfs
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList:
            return []

        allpath = []
        visited = {beginWord}

        def findWords(target,words):
            res = []
            for word in words:
                n = len(target)
                for i in range(n):
                    if target[i] == word[i]: 
                        n -= 1
                if n == 1: 
                    res.append(word)
            return res


        def dfs(path,middlelist):
            nonlocal allpath
            if not middlelist:
                return
            if endWord in middlelist:
                path.append(endWord)
                allpath.append(path)
                return 
            for item in middlelist:
              if item not in path:
                dfs(path+[item],findWords(item,wordList))
        dfs([beginWord],findWords(beginWord,wordList))
        return allpath
    
if __name__ == "__main__":
  s = Solution()
  res = s.findLadders("hit","cog",["hot","dot","dog","lot","log","cog"])
  print('res:',res)

# res: [['hit', 'hot', 'dot', 'dog', 'cog'], 
# ['hit', 'hot', 'dot', 'lot', 'log', 'cog'], 
# ['hit', 'hot', 'lot', 'dot', 'dog', 'cog'], 
# ['hit', 'hot', 'lot', 'log', 'cog']]
```

```py
import collections
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList:
            return []
        lookup = collections.defaultdict(list)
        L = len(beginWord)
        for word in wordList:
            for i in range(L):
                lookup[word[:i] + '*' + word[i+1:]].append(word)
        
        res = []
        que = [(beginWord, 1, [[beginWord]])] # 终点，长度，path
        visited = {beginWord:[[beginWord]]}
        mindepth = len(wordList) + 1  # 剪枝
        print(visited)
        while que:
            cur, depth, paths = que.pop(0)
            if depth > mindepth: continue  # 剪枝           
            for i in range(L):
                dummyword = cur[:i] + '*' + cur[i+1:]
                for word in lookup[dummyword]:
                    if word == endWord:
                        for path in paths:
                            mindepth = depth  # 剪枝
                            res.append(path + [endWord])
                    elif word not in visited:
                        newPaths = [path+[word] for path in paths]
                        visited[cur] = newPaths
                        que.append((word, depth+1, newPaths))

        return res
    
if __name__ == "__main__":
  s = Solution()
  res = s.findLadders("hit","cog",["hot","dot","dog","lot","log","cog"])
  print('res:',res)
```

```py
把单词到通配串的路径生成，再把通配串到单词的路径生成，
然后再单向宽搜，写双向就更复杂了，单向速度也马马虎虎吧，148ms。 py

import collections
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList) :
        lookup = collections.defaultdict(list)
        for word in wordList + [beginWord]:
            w = [*word]
            for i, c in enumerate(word):
                w[i] = '.'
                dummyword = ''.join(w)
                lookup[dummyword].append(word)
                lookup[word].append(dummyword)
                w[i] = c
        if endWord in lookup:
            que, visited = {beginWord: [[beginWord]]}, {beginWord}
            while que:
                # que是达到的点与路径的映射
                if endWord in que:
                    return [*que[endWord]]
                tmp = collections.defaultdict(set)
                
                for i in que:
                    for dummyword in lookup[i]:
                        for w in lookup[dummyword]:
                            if w not in visited:
                                tmp[w].update((*path, w) for path in que[i]) #看不懂更新path路径😂
                que = tmp
                visited.update(que.keys())
        return []
```

###  1.28. <a name='WordLadder'></a>127. Word Ladder

[花花酱](https://www.bilibili.com/video/BV1yt411Y7Me?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1BK4y157k1?spm_id_from=333.999.0.0)

```py
(压根没想到用虚拟节点的方法，用了最蠢的遍历a-z的方法。没想到竟然能通过= =)

附上我的低效python代码，仅供参考。

from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList):
        lookup = set(wordList)
        visited = set(['beginWord'])
        queue = deque([(beginWord, 1)])
        while queue:
            pop, depth = queue.popleft()
            if pop == endWord:
                return depth
            for i in range(len(pop)):
                for j in range(97, 123):
                    char26word = pop[:i] + chr(j) + pop[i+1:]
                    if char26word not in visited and char26word in lookup:
                        queue.append((char26word, depth + 1))
                        visited.add(char26word)
        return 0
```

```py
还有个更巧妙的想法，将 word 的某一位改为 '*' 作为 word 的 key。

例如 hit 的 key 为 '*it'、'h*t'、'hi*'。

在 wordList 中找到 key 相同的单词，即是能转换的单词。

于是提前将 wordList 的单词按 key 存在哈希表中，就可以进一步减少搜索范围到 len(word)。

from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        lookup = defaultdict(list)
        genKey = lambda w: [w[:i] + '*' + w[i+1:] for i in range(len(w))]
        for word in wordList:
            for dummyword in genKey(word):
                lookup[dummyword].append(word)
        queue, visited = deque([(beginWord, 1)]), {beginWord}
        while queue:
            word, depth = queue.popleft()
            for dummyword in genKey(word):
                for nextword in lookup[dummyword]:
                    if nextword not in visited:
                        if nextword == endWord:
                            return depth+1
                        visited.add(nextword)
                        queue.append([nextword, depth+1])
        return 0
```

###  1.29. <a name='LongestConsecutiveSequence'></a>128. Longest Consecutive Sequence

[花花酱](https://www.bilibili.com/video/BV14t411Y7cg?spm_id_from=333.999.0.0)

###  1.30. <a name='SumRoottoLeafNumbers'></a>129 Sum Root to Leaf Numbers

[小明](https://www.bilibili.com/video/BV1VK411H7o5?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        sums = 0
        def dfs(node,cur):
            nonlocal sums
            if not node:
                return
            else:
                cur = cur*10 + node.val
                if not node.left and not node.right: # 易错点：不要忽视了这种情况
                    sums += cur
                    return
                else:
                    dfs(node.right,cur)
                    dfs(node.left,cur)
        dfs(root,0)
        return sums # 在根节点处cur为0，而不是sums


其他写法：

class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        ans = 0
        
        def dfs(root, acc):
            nonlocal ans
            if not root.left and not root.right:
                ans += acc * 10 + root.val
                return
            if root.left:
                dfs(root.left, acc*10+root.val)
            if root.right:
                dfs(root.right, acc*10+root.val)
        dfs(root, 0)
        return ans

```

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return 0

        sums = 0
        que = collections.deque([(root,root.val)])
        
        while que:
            node, num = que.popleft()
            left, right = node.left, node.right
            if not left and not right:
                sums += num
            else:
                if left:
                    que.append((left, num * 10 + left.val))
                if right:
                    que.append((right, num * 10 + right.val))
        return sums
```

###  1.31. <a name='SurroundedRegions130-'></a>130. Surrounded Regions 130-被围绕的区域

[花花酱](https://www.bilibili.com/video/BV1dE411f7U4?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV18y4y1j7JH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411k7TH?spm_id_from=333.999.0.0)


```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m = len(board)
        n = len(board[0])
        que = collections.deque()

        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1: # 易错点：m 和 n 不要写反了
                    if board[i][j] == 'O':
                        que.append((i,j))

        while que:
            x,y = que.popleft()
            board[x][y] = 'A'
            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                # 易错点：x+dx 和 x 不要写反了
                if 0 <= x+dx < m-1 and 0 <= y+dy < n-1 and board[x+dx][y+dy] == 'O': # 易错点：'O'不要写成0
                    board[x+dx][y+dy] = 'A'
                    que.append((x+dx,y+dy))

        for i in range(m):
            for j in range(n):
                # 易错点：== 和 = 不要写反了
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == 'A':
                    board[i][j] = 'O'

        return board
```

另一种写法

```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        n, m = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < n or not 0 <= y < m or board[x][y] != 'O':
                return
            
            board[x][y] = "A"
            dfs(x + 1, y)
            dfs(x - 1, y)
            dfs(x, y + 1)
            dfs(x, y - 1)
        
        for i in range(n):
            dfs(i, 0)
            dfs(i, m - 1)
        
        for i in range(m - 1):
            dfs(0, i)
            dfs(n - 1, i)
        
        for i in range(n):
            for j in range(m):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"
```



###  1.32. <a name='-1'></a>131-分割回文串

[哈哈哈](https://www.bilibili.com/video/BV1dK411p7eU?spm_id_from=333.999.0.0)

```py
# 递归解法
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtrack(startIndex):
            if startIndex == len(s):
                res.append(path[:])
                return
            
            for end in range(startIndex, len(s)):
                seg = s[startIndex:end+1]
                if seg == seg[::-1]:
                    path.append(seg)
                    backtrack(end+1)
                    path.pop()
            
        path = []
        res = []
        backtrack(0)
        return res

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)

        res = []
        path = []

        @cache
        def isPalindrome(i: int, j: int) -> int:
            if i >= j:
                return 1
            return isPalindrome(i + 1, j - 1) if s[i] == s[j] else -1

        def backtrack(startIndex: int):
            if startIndex == n:
                res.append(path[:])
                return
            
            for end in range(startIndex, n):
                if isPalindrome(startIndex, end) == 1:
                    path.append(s[startIndex:end+1])
                    backtrack(end + 1)
                    path.pop()

        backtrack(0)
        isPalindrome.cache_clear()
        return res

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # ------------------------ 背一背 ------------------------
        n = len(s)
        isPalinDP = [[True] * n for _ in range(n)]
        
        for start in range(n - 1, -1, -1): # start 指向 倒数第二位, start 向前扫描
            for end in range(start + 1, n): # end 指向 倒数第一位, end 向后扫描
                isPalinDP[start][end] = (s[start] == s[end]) and isPalinDP[start + 1][end - 1] 
        # ------------------------ 背一背 ------------------------

        res = []
        path = []

        def backtrack(startIndex: int):
            if startIndex == n:
                res.append(path[:])
                return
            
            for end in range(startIndex, n):
                if isPalinDP[startIndex][end]:
                    path.append(s[startIndex:end+1])
                    backtrack(end + 1)
                    path.pop()

        backtrack(0)
        return res



class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtrack(start):
            if start == len(s):
                ans.append(tmp[:])
                return
            
            for end in range(start+1, len(s)+1):
                seg = s[start:end]
                if seg == seg[::-1]:
                    tmp.append(seg)
                    backtrack(end)
                    tmp.pop()
            
        tmp = []
        ans = []
        backtrack(0)
        return ans


```

```py

python3 用回溯递归的方法去试探每一种可能性 对于一个字符串s，

有len(s)种方法把它分成左右两个部分（分割方法看代码），

假如左侧的不是回文，则舍弃这次尝试；

假如左侧的是回文串，则把右侧的进行递归的分割，并返回右侧的分割的所有情况

class Solution:
    @cache
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        res = []
        if n == 0:
            res.append([])

        for i in range(1, n+1):
            if s[:i] != s[:i][::-1]:
                continue
            left = [s[:i]]
            rights = self.partition(s[i:])
            for right in rights:
                res.append(left+right)
        return res


class Solution(object):
    def partition(self, s):

        n = len(s)
        res = []

        
        if n == 0:
            return [[]]
        if n == 1:
            return [[s]]


        for i in range(1, n+1):
            if s[:i] != s[:i][::-1]:
                continue
            left = [s[:i]]
            rights = self.partition(s[i:])
            for right in rights:
                res.append(left+right)
        return res


不需要预处理，没有递归，然后代码简洁的动态规划

我真牛逼

class Solution:
    def partition(self, s: str):
        
        n = len(s)
        res = [[s[0]]]
        
# 下一个位置的分割结果 = 前一个位置所有分割结果 + 当前位置的字母s[i]得到的结果 
        for char in s[1:]:
            for path in res[:]: # 一定要写成res[:],而不是res
                
# + 判断前一个位置每个分割结果中最后一个回文串和当前字母s[i]是否组成回文串得到的结果 --> 也就是偶数个回文
                if len(path[-1]) == 1 and path[-1] == char:
                    res.append(path[:-1] + [char + char])
                    
# + 判断前一个位置每个分割结果中最后两个回文串和当前字母s[i]是否组成回文串得到的结果 --> 也就是奇数个回文
                if len(path) > 1 and len(path[-2]) == 1 and path[-2] == char:
                    res.append(path[:-2] + [char + path[-1] + char])
                    
                path.append(char)
        return res
```

###  1.33. <a name='PalindromePartitioningII'></a>132. Palindrome Partitioning II

[花花酱](https://www.bilibili.com/video/BV1NJ411v7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1944y1C71s?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5d4nophqby00.webp" width="70%">

```py
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        isPalinDP = [[True] * n for _ in range(n)]
        
        for start in range(n - 1, -1, -1): # start 指向 倒数第二位, start 向前扫描
            for end in range(start + 1, n): # end 指向 倒数第一位, end 向后扫描
                isPalinDP[start][end] = (s[start] == s[end]) and isPalinDP[start + 1][end - 1] 

        cutDP = [float("inf")] * n
        for endcut in range(n):
            # 如果前一小段是回文
            if isPalinDP[0][endcut]:
                cutDP[endcut] = 0
            # 如果前一小段不是回文，则从start开始继续拆分
            else:
                for startcut in range(endcut):
                    if isPalinDP[startcut + 1][endcut]:
                        cutDP[endcut] = min(cutDP[endcut], cutDP[startcut] + 1) # 动态转移，将 cutDP[start] + 1处的转移过来
        
        return cutDP[n - 1]
```

```py
看不懂
class Solution:
    def minCut(self, s: str) -> int:
        def dfs(startI):
            if startI >= len(s):
                return -1
            elif startI == len(s)-1: 
                dp[startI] = 0
                return 0
            
            if dp[startI] < 1e9: 
                return dp[startI]

            for i in range(startI,len(s)):
                # 如果某个子序列回文
                if s[startI:i+1]==s[startI:i+1][::-1] :
                    dp[startI] = min(dfs(i+1),dp[startI])
            dp[startI] += 1
            return dp[startI]
        
        dp = [1e9]*len(s)
        return dfs(0)

```

###  1.34. <a name='CloneGraph'></a>133. Clone Graph

[小梦想家](https://www.bilibili.com/video/BV1wA411T7SM?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV18i4y1c7FE?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12K411A7Zb?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1hzav19bp1wg.png" width="70%">

https://www.bilibili.com/video/BV1Cy4y127Di?from=search&seid=15236791324980694232&spm_id_from=333.337.0.0

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6d4fzq5ov200.png)


```py
class Solution(object):

    def __init__(self):
        self.visited = {}

    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        # 递归结束条件：
        # 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回
        if node in self.visited:
            return self.visited[node]
        # 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表
        cloneNode = Node(node.val, [])
        # 哈希表存储
        self.visited[node] = cloneNode
        # 遍历该节点的邻居并更新克隆节点的邻居列表
        if node.neighbors:
            cloneNode.neighbors = [self.cloneGraph(n) for n in node.neighbors] # 递归在这里，neighbors里面是😁
        return cloneNode
```

```py
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        def dfs(nod): # dfs的本质在于赋值
            VisitDic[nod] = Node(nod.val)
            # 对node的neighbors,如果在目录里面，返回这些邻居的值nod.val,否则dfs
            VisitDic[nod].neighbors = [dfs(n) if n not in VisitDic else VisitDic[n] for n in nod.neighbors] # 递归在这里，neighbors里面是😁
            return VisitDic[nod]
        VisitDic = {}
        return dfs(node) if node else None

# bfs模板加一个dict记录即可！

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        visited = {}
        def dfs(nod,visited):
            if not nod:
                return None # dfs 返回的是neighbors
            elif nod in visited:
                # 易错点：return nod
                return visited[nod]
            else:
                visited[nod] = Node(nod.val)
                for neigh in nod.neighbors:
                    visited[nod].neighbors.append(dfs(neigh,visited))
            return visited[nod]
        return dfs(node,visited) # 易错点：一定要返回
```

```py
类似的三种写法：

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        nodecp = Node(node.val)
        visited = {node:nodecp}
        stack = [node]
        while stack:
            tmp = stack.pop() #
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) # 😁 注意，append是字典内的neigh，也就是 Node(node.val)
        return nodecp

类似的三种写法：


class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        visited = {}
        visited[node] = Node(node.val)
        stack = [node]
        while stack:
            tmp = stack.pop() 
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) 
        return visited[node]

类似的三种写法：

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        visited = {}
        stack = [node]
        while stack:
            tmp = stack.pop() 
            if tmp not in visited: # 这行必须要有
                visited[tmp] = Node(tmp.val)
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) 
        return visited[node]
```


###  1.35. <a name='GasStation'></a>134. Gas Station

[小梦想家](https://www.bilibili.com/video/BV1BC4y1472f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1754y1176F?spm_id_from=333.999.0.0)

```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        start = 0
        curSum = 0
        totalSum = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            if curSum < 0:
                curSum = 0
                start = i + 1
        if totalSum < 0: return -1
        return start
```

###  1.36. <a name='CopyListwithRandomPointer'></a>138 Copy List with Random Pointer

[小明](https://www.bilibili.com/video/BV1BN411R7a8?spm_id_from=333.999.0.0)

###  1.37. <a name='SingleNumber'></a>136-Single Number

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7bf?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Sp4y1D7M3?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7PU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pa4y1t7tr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```py
class Solution:
    def singleNumber(self, nums):
        a = 0
        for num in nums:
            a = a ^ num
        return a

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)
```

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.reduce(_^_)
    }
}
```

###  1.38. <a name='SingleNumberII'></a>137 Single Number II

[小明](https://www.bilibili.com/video/BV1Hv411B7rd?spm_id_from=333.999.0.0)

###  1.39. <a name='WordBreak'></a>139 Word Break

[小明](https://www.bilibili.com/video/BV1p54y1k7vf?spm_id_from=333.999.0.0)

```py
# python 动态规划

# 从 i = 0 开始分析：i = 0， 遍历 j in range(1, n+1)， 

# 即遍历所有以 s[0]开头的组合，把第一个单词可能的情况全部找出来。

# 此时相当于把打头的单词可能的情况全部找出来了。

# 然后基于第一个单词一个单词一个单词地接上去。

class Solution(object):
    def wordBreak(self, s, wordDict):

        dp = [True]
        for end in range(1, len(s)+1):
            dp += [any(dp[start] and s[start:end] in wordDict for start in range(end))]
        return dp[-1]

class Solution:
    def wordBreak(self, s, wordDict):
        n = len(s) 
        dp = [True] + [False]*n

        for end in range(1, n + 1):
            for start in range(end):
                if dp[start] and s[start: end] in wordDict:
                    dp[end] = True # 说明s[: i] 在wordDict中
                    break # 优化部分：剩下的切分点j不用再寻找了，也可以不写，像下方一样
        return dp[-1]

```

###  1.40. <a name='WordBreakII'></a>140 Word Break II

[小明](https://www.bilibili.com/video/BV1ht4y1X7DJ?spm_id_from=333.999.0.0)

```py
# 直接回溯过了，这是样例出问题了还是标错难度了。。。
class Solution(object):
    def wordBreak(self, s, wordDict):
        res = []
        
        # 也是左右🐧切
        def backtrack(s, path):
            # nonlocal res
            if len(s) == 0:
                res.append(path[1:])
                return

            n = len(s)
            for i in range(n):
                if s[:i+1] in cash:
                    backtrack(s[i+1:], path+" "+s[:i+1])
                    
        backtrack(s, "")
        return res

class Solution:
    def wordBreak(self, s, wordDict):
        # @lru_cache(None)
        def backtrack(index: int):
            if index == len(s):
                return [[]]
            res = []
            for i in range(index + 1, len(s) + 1):
                left = s[index:i]
                if left in wordSet:
                    rightBreaks = backtrack(i)
                    for right in rightBreaks:
                        res.append(right[:] + [left])
            return res
        
        wordSet = set(wordDict)
        breakList = backtrack(0)
        return [" ".join(words[::-1]) for words in breakList]

class Solution(object):
    def wordBreak(self, s, wordDict):
        memo = {len(s): ['']}
        def sentences(i):
            if i not in memo:
                memo[i] = [s[i:j] + (tail and ' ' + tail)
                           for j in range(i+1, len(s)+1)
                           if s[i:j] in wordDict
                           for tail in sentences(j)]
            return memo[i]
        return sentences(0)
```

###  1.41. <a name='LinkedListCycle'></a>141-Linked List Cycle

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7ta?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411H7XP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1KX4y157vh?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1PA411b7gq?spm_id_from=333.999.0.0)

```py
方法一：集合 如果发现节点已在集合内则说明存在环

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            visited.add(head)
            head = head.next
            if head in visited:
                return True
        return False

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            if head in visited:
                return True
            visited.add(head)
            head = head.next
        return False

感觉初始时把快慢指针都指向 head 反而更简洁：

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
        
```


```scala
object Solution1 {
    def hasCycle(head: ListNode): Boolean = {
        
        var cur = head
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        
        var res: Boolean = false
        while (cur != null && res != true) {

            if(visited.contains(cur))  
                res = true
            else {
                visited += cur
                cur = cur.next
            }
        }
        res
    }
}


object Solution3 {
    def hasCycle(head: ListNode): Boolean = {
        var fast = head
        var slow = head
        
        
        var result = false
        while (fast != null && fast.next != null && result != true) {
            fast = fast.next.next
            slow = slow.next
        
            if(fast == slow) result = true
        }
        result
    }
}

object Solution {
    def hasCycle(head: ListNode): Boolean = {
        
        if(head == null){
            false
        }else{
        
        var slow = head
        var fast = head.next
        var output = true
        
        import scala.util.control.Breaks._
        breakable{
            while(slow != fast){
                if(fast == null || fast.next == null){
                    output=false
                    break
                }
                slow = slow.next
                fast = fast.next.next
            }
        }
        output
    }
    }
}

/**
* two pointer - tail recursive
*/
object Solution {
    def hasCycle(head: ListNode): Boolean = {
        if(head != null && head.next != null) 
            _hasCycle(head.next.next, head.next)
        else false
    }
    
    @annotation.tailrec
    def _hasCycle(fast: ListNode, slow: ListNode): Boolean = {
        if(fast == null || fast.next == null || slow == null) return false
        else if(fast == slow) return true
        else _hasCycle(fast.next.next, slow.next)
    }
}
//Alternate solution: Slow & Fast pointer
```

###  1.42. <a name='LinkedListCycleII'></a>142 Linked List Cycle II

[小明](https://www.bilibili.com/video/BV1W5411L7AF?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV15e41147EY?spm_id_from=333.999.0.0)

```py
我这个都在一个循环中，简洁点

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow, res = head, head, head
        flag = False

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if flag: res = res.next

            if slow == fast: flag = True
            if flag and slow == res: return res
        return None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            # 如果相遇
            if slow == fast:
                p = head
                q = slow
                while p!=q:
                    p = p.next
                    q = q.next
                #你也可以return q
                return p

        return None
```

```py
在for循环与while循环中的else语句块

旨在循环正常遍历了所有内容或由于循环条件不成立而结束循环时执行，

如果for循环与while循环因为break退出，则不执行else语句块中的内容。

continue对else没影响。 

这样在while循环之后使用else代码块，就可以达到代码中使用flag的效果

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head:
            return None
        fast, slow = head,  head
        while slow.next and fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return None
        
        slow = head
        while slow != fast:
             slow = slow.next
             fast = fast.next
        return slow

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        # 首先初始化快指针和慢指针，确保快指针走的路的长度是慢指针长度的2倍
        if head and head.next:
            fast = head.next.next
            slow = head.next
        else:
            return None  # 说明无环

        # 进行循环，首先让快指针和慢指针第一次相遇
        while fast:
            if fast != slow:

                # 快指针走两步
                if fast.next:
                    fast = fast.next.next
                else:
                    return None  # 说明无环

                # 慢指针走一步
                slow = slow.next
            else:
                detection = head
                while detection != slow:  # 此时由于slow和fast是一样的，用哪个都行
                    slow = slow.next
                    detection = detection.next

                return detection

```

```scala
object Solution {
    def detectCycle(head: ListNode): ListNode = {
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        var cur = head
        
        var result: ListNode = null

        while (cur != null && result == null) {
            // println(result)
            if(visited.contains(cur))  
                result = cur
            else {
                visited += cur
                cur = cur.next
            }
        }
        result
        
    }
}

```

###  1.43. <a name='ReorderList'></a>143 Reorder List

[小明](https://www.bilibili.com/video/BV1Jf4y1Q7y7?spm_id_from=333.999.0.0)

###  1.44. <a name='Preorderwithstack'></a>144-Preorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1HT4y1G74i?spm_id_from=333.999.0.0)

###  1.45. <a name='BinaryTreePreorderTraversal'></a>144-Binary Tree Preorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7NZ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Ch411Q74P?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1RD4y1D7C7?spm_id_from=333.999.0.0)


```py
Python递归

class Solution(object):
    def preorderTraversal(self, root):
        if not root:
            return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
```

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def dfs(node):
            if not node:
                return
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        res = []
        dfs(root)
        return res
```

stack

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        ans = []
        if not root:
            return ans
        stack = [root]
        while stack:
            node = stack.pop()
            ans.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return ans
```


###  1.46. <a name='Postorderwithstack'></a>145-Postorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1Ti4y187jL?spm_id_from=333.999.0.0)

###  1.47. <a name='BinaryTreePostorderTraversal'></a>145-Binary Tree Postorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7ub?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1uv411h7Gc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1xZ4y1H7uS?spm_id_from=333.999.0.0)

```py
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def postorder(root: TreeNode):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = []
        postorder(root)
        return res

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        from collections import deque
        res, que = [], deque()
        que.append(root) if root else None
        while que:
            tmp = que.pop()
            res.append(tmp.val)
            que.append(tmp.left) if tmp.left else None
            que.append(tmp.right) if tmp.right else None
        return res[::-1]

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return list()
        
        res = list()
        stack = list()
        prev = None

        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if not root.right or root.right == prev:
                res.append(root.val)
                prev = root
                root = None
            else:
                stack.append(root)
                root = root.right
        
        return res

```

###  1.48. <a name='LRUCache'></a>146 LRU Cache 

[花花酱](https://www.bilibili.com/video/BV19b411c7ue?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7c6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1t7zj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ZQ4y1A74H?spm_id_from=333.999.0.0)

```py

from clecode import decorator_default
import collections

class LRUCache(collections.OrderedDict):

    def __init__(self, capacity: int):
        super().__init__()
        self.capacity = capacity


    def get(self, key: int) -> int:
        if key not in self:
            return -1
        self.move_to_end(key)
        return self[key]

    def put(self, key: int, value: int) -> None:
        if key in self:
            self.move_to_end(key)
        self[key] = value
        if len(self) > self.capacity:
            self.popitem(last=False)


if __name__ == "__main__":  
    import doctest  
    
    doctest.testmod()
```


```py
import collections
class LRUCache:
    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.capacity = capacity
        self.cache = collections.OrderedDict()

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key in self.cache:
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
            
        return -1

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if key in self.cache:
            self.cache.pop(key)
        else:
            if len(self.cache) == self.capacity:
                self.cache.popitem(last=False)
                
        self.cache[key] = value

```

```scala

/**
* chosen solution
* build-in linkedHashMap
* time complexity: O(1)
*/
class LRUCache0(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
    cache.get(key) match {
        case Some(v) => 
            cache.remove(key)
            cache.put(key, v)
            v
        case None => -1
    }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}



/**
* build-in linkedHashMap
*/
class LRUCache3(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
  /**
   *cache.get(key).map{
   *   value =>
   *     cache.remove(key)
   *     cache.update(key, value)
   *     value
   * }.getOrElse(-1)
   */
   cache.get(key) match {
            case Some(v) => 
                cache.remove(key)
                cache.put(key, v)
                v
            case None => -1
        }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}

```

```scala
import scala.collection.mutable._

  class LRUCache(_capacity: Int) {

    val hm = HashMap[Int, Int]()
    val lb = ListBuffer.empty[Int]
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key)
      } else {
        -1
      }

    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key) = value
      } else {
        if (hm.size == c) {
          val lk = lb.head
          hm.remove(lk)
          lb.remove(0)
        }
        hm(key) = value
        lb += key
      }
    }
  }


// test case
//  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
//  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]

//  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]
  class LRUCache3(_capacity: Int) {
    val hm = HashMap[Int, Node]()
    val dl = new DoublyLinkedList()
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v
      } else { // not found
        -1
      }
    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v = value
      } else {
        if (hm.size == c) {
          val old = dl.tail
          if (old!=null) {
            dl.erase(old)
            hm.remove(old.v.k)
          }
        }
        val node = Node(KV(key,value),null,null)
        hm(key) = node
        dl.push_front(node)
      }
    }
  }
```

```scala
  class Test extends BaseExtension {
    def init {
      val lru = new LRUCache(2)
      lru.put(1,1)
      lru.put(2,2)
      println(lru.get(1) == 1)
    }

    val name = "146 LRU chache"
  }

//  ["LRUCache","put","put","get","put","get","put","get","get","get"]
//  [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
  class Test2 extends BaseExtension {
    def init {
      val lru = new LRUCache2(2)
      lru.put(2,1)
      lru.put(1,1)
      lru.put(2,3)
      lru.put(4,1)
      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }

  //  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
  //  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]
  //  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]

  class Test3 extends BaseExtension {
    def init {
      val lru = new LRUCache3(10)
      lru.put(10,13)
      lru.put(3,17)
      lru.put(6,11)
      lru.put(10,5)
      lru.put(9,10)

      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }
```

###  1.49. <a name='InsertionSortList'></a>147 Insertion Sort List

[小明](https://www.bilibili.com/video/BV1F54y1k7oU?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Ti4y187pN?spm_id_from=333.999.0.0)

```py
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        dummy = ListNode(0)
        dummy.next = head
        tmp = head
        cur = head.next

        while cur:
            if tmp.val <= cur.val:
                tmp = tmp.next
            else:
                pre = dummy
                while pre.next.val <= cur.val:
                    pre = pre.next
                tmp.next = cur.next
                cur.next = pre.next
                pre.next = cur
            cur = tmp.next
        
        return dummy.next

class Solution(object):
    def insertionSortList(self, head):
        if head == None or head.next == None:
            return head

        dummy = ListNode(0)
        dummy.next = head

        tmp = head 
        cur = head.next

        while cur:
            pre = dummy
            while pre.next.val <= cur.val and pre != tmp:
                pre = pre.next
            if pre != tmp:
                tmp.next = cur.next
                cur.next = pre.next
                pre.next = cur
            tmp = cur
            cur = cur.next

        return dummy.next


# 菜鸡版 python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        cur = head.next
        dummy.next.next = None
        while cur:
            pre = dummy
            while pre.next and cur.val > pre.next.val:
                pre = pre.next
            tmp = cur.next
            cur.next = pre.next
            pre.next = cur
            cur = tmp
        return dummy.next
```

###  1.50. <a name='SortList'></a>148. Sort List

[花花酱](https://www.bilibili.com/video/BV1jW411d7z7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK411A7Gm?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        sortlist = []
        while(head is not None):
            aft = head.next
            head.next = None
            sortlist.append(head)
            head = aft
        sortlist = sorted(sortlist, key=lambda x: x.val)
        n = len(sortlist)
        if n == 0:
            return None
        dummy.next = sortlist[0]
        for i in range(n-1):
            sortlist[i].next = sortlist[i+1]
        
        return dummy.next
```

```py
# py3 归并排序，递归实现。空间复杂度主要在递归栈深度：O( log(n) )，整个递归过程有点像后序遍历

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        mid=self.findmid(head)
        left=head # 指定左右
        right=mid.next # 指定左右
        mid.next=None # 断开链接
        l=self.sortList(left)
        r=self.sortList(right)
        return self.merge(l,r)

    def findmid(self,head):
        slow=head
        fast=head
        while fast.next and fast.next.next:
            slow=slow.next
            fast=fast.next.next
        return slow

    def merge(self,l,r):
        dummy=ListNode(None)
        cur=dummy
        while l and r:
            if l.val<=r.val:
                cur.next=l
                l=l.next # 下一个
            else:
                cur.next=r
                r=r.next # 下一个
            cur=cur.next # 下一个
        cur.next=l or r
        return dummy.next

        # 基本用法：
        # v = p1 or p2

        # 它完成的效果等同于：
        # if p1:
        #     v = p1
        # else:
        #     v = p2
```

###  1.51. <a name='MaxPointsonaLine'></a>149. Max Points on a Line

[花花酱](https://www.bilibili.com/video/BV1zb411u7WW?spm_id_from=333.999.0.0)

###  1.52. <a name='EvaluateReversePolishNotation'></a>150. Evaluate Reverse Polish Notation

[花花酱](https://www.bilibili.com/video/BV14f4y127K8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16B4y1P7Nx?spm_id_from=333.999.0.0)

```py
class Solution:
    def evalRPN(self, tokens):
        f1 = lambda a,b:a+b
        f2 = lambda a,b:a-b
        f3 = lambda a,b:a*b
        f4 = lambda a,b:int(a/b)
        maps = {'+':f1,'-':f2,'*':f3,'/':f4}
        stack = []
        for i in tokens:
            if i in maps:
                a = stack.pop()
                b = stack.pop()
                stack.append(maps[i](b,a))
            else:
                i = int(i)
                stack.append(i)
        return stack[-1]

class Solution:
    def evalRPN(self, tokens):
        stack = []
        for item in tokens:
            if item not in {"+", "-", "*", "/"}:
                stack.append(item)
            else:
                first_num, second_num = stack.pop(), stack.pop()
                stack.append(
                    int(eval(f'{second_num} {item} {first_num}'))   # 第一个出来的在运算符后面
                )
        return int(stack.pop()) # 如果一开始只有一个数，那么会是字符串形式的

class Solution:
    def evalRPN(self, tokens):
        """
        解题思路:数字入栈，算数符号出栈两个数字栈并计算，计算结果入栈
        """
        stack = []
        
        for item in tokens:

            if item not in ['+', '-', '*', '/']:
                stack.append(int(item))
            else:
                a = stack.pop()
                b = stack.pop()
                if item == '+': stack.append(a + b)
                elif item == '-': stack.append(b - a)
                elif item == '*': stack.append(a * b)
                elif item == '/': stack.append(int(b / float(a)))   # 注意如何取整
        return stack[0]
```

###  1.53. <a name='ReverseWordsinaString'></a>151. Reverse Words in a String

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7g4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rT4y1g7AJ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ei4y1V7yA?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        left, right = 0, len(s) - 1
        # 去掉字符串开头的空白字符
        while left <= right and s[left] == ' ':
            left += 1
        
        # 去掉字符串末尾的空白字符
        while left <= right and s[right] == ' ':
            right -= 1
            
        que, word = collections.deque(), []
        # 将单词 push 到队列的头部
        while left <= right:
            if s[left] == ' ' and word:
                que.appendleft(''.join(word))
                word = []
            elif s[left] != ' ':
                word.append(s[left])
            left += 1
        que.appendleft(''.join(word))
        
        return ' '.join(que)
```

```py
一种没有用split 和reverse的方法[^1]

分三步:

先翻转整个数组
再翻转单个单词
清除多余空格
class Solution:
    def reverseWords(self, s: str) -> str:
        s = list(s)
        n = len(s)
        #print(s)
        
        # 翻转数组
        def reverse(s, i, j):
            while i < j:
                s[i], s[j] = s[j], s[i]
                i += 1
                j -= 1

        # 翻转单个单词
        def word_reverse(s):
            # 用双指针找到一个单词
            i = 0
            j = 0
            while i < n:
                # 找到一个单词首字母
                while i < n and s[i] == " ":
                    i += 1
                j = i
                # 找到一个单词末位置
                while j < n and s[j] != " ":
                    j += 1
                reverse(s, i, j - 1)
                i = j

        # 清除多余空格
        def clean_space(s):
            i = 0
            j = 0
            while j < n:
                # 找到一个单词
                while j < n and s[j] == " ":
                    j += 1
                # 单词朝前移
                while j < n and s[j] != " ":
                    s[i] = s[j]
                    i += 1
                    j += 1
                # 移动下一个单词
                while j < n and s[j] == " ":
                    j += 1
                if j < n:
                    s[i] = " "
                    i += 1
            return "".join(s[:i])

        reverse(s, 0, n - 1)
        #print(s)
        word_reverse(s)
        #print(s)
        return clean_space(s)
```



###  1.54. <a name='-1'></a>152-乘积最大子数组

[哈哈哈](https://www.bilibili.com/video/BV12a4y1i76G?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iK411K7yG?spm_id_from=333.999.0.0)

```py
# 动态规划：遍历时，每次分别存储 前i个中连续数组 [最大的乘积和] 和 [最小乘积和]

# 之所有存 [最小乘积和]，是因为 [最小乘积和] 如果是负数有可能遇到负数，

# 相乘后结果更大 Python

class Solution(object):
    def maxProduct(self, nums):
        n = len(nums)
        maxdp = [ nums[0] for i in range(n)]
        mindp = [ nums[0] for i in range(n)]

        for i in range(1,n):
        	maxdp[i] = max(mindp[i-1]*nums[i], maxdp[i-1]*nums[i],nums[i])
        	mindp[i] = min(maxdp[i-1]*nums[i], mindp[i-1]*nums[i],nums[i])

        return max(maxdp)

class Solution:
    def maxProduct(self,nums):
        dp_max, dp_min = nums[0],nums[0] 
        maxp = nums[0]
        for i in range(1,len(nums)):
            dp_max = max(nums[i], dp_max*nums[i], dp_min*nums[i]) 
            dp_min = min(nums[i], dp_max*nums[i], dp_min*nums[i])
            maxp = max(maxp, dp_max)
        return maxp


class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        max_num = []
        min_num = []

        max_num.append(nums[0])
        min_num.append(nums[0])

        res = nums[0]

        for i in range(1,len(nums)):
            max_num.append(max(nums[i], nums[i]*max_num[i-1], nums[i]*min_num[i-1]))
            min_num.append(min(nums[i], nums[i]*max_num[i-1], nums[i]*min_num[i-1]))
            res = max(res, max_num[i])
        return res
# 优化空间
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        maxF, minF, ans = nums[0], nums[0], nums[0]
        length = len(nums)
        for i in range(1, length):
            mx, mn = maxF, minF # 只用两个变量来维护i−1时刻的状态,优化空间
            maxF = max(mx * nums[i], nums[i], mn * nums[i])
            minF = min(mn * nums[i], nums[i], mx * nums[i])
            ans = max(maxF, ans)
        
        return ans


class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        dp_min = [1] * n
        dp_max = [1] * n
        dp_min[0] = nums[0]
        dp_max[0] = nums[0]
        res = dp_max[0]
        for i in range(1, n):
            dp_min[i] = min(dp_min[i-1]*nums[i], dp_max[i-1]*nums[i], nums[i])
            dp_max[i] = max(dp_min[i-1]*nums[i], dp_max[i-1]*nums[i], nums[i])
            res = max(res, dp_max[i])
        return res


class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums: return 
        res = nums[0]
        pre_max = nums[0]
        pre_min = nums[0]
        for num in nums[1:]:
            cur_max = max(pre_max * num, pre_min * num, num)
            cur_min = min(pre_max * num, pre_min * num, num)
            res = max(res, cur_max)
            pre_max = cur_max
            pre_min = cur_min
        return res
```

```scala

object Solution2-1 {
    def maxProduct(nums: Array[Int]): Int = {
        
        val (_, _, ans) = (1 until nums.length).foldLeft((nums.head, nums.head, nums.head)){
            case ((min, max, ans), idx) => 
                val a = nums(idx) * min 
                val b = nums(idx) * max
                val newMin = a min b min nums(idx)
                val newMax = a max b max nums(idx)
                (newMin, newMax, ans max newMax)
        }
        ans
    }
}


object Solution0 {
  def maxProduct(nums: Array[Int]): Int = {
    val dp = Array.ofDim[Int](nums.length, 2) // record each position n's max product( from 0 to n)
    var result = nums(0)
    dp(0)(0) = nums(0)
    dp(0)(1) = nums(0)

    /* 0 for min, 1 for max */
    for (i <- 1 until nums.length) {
      val a = dp(i - 1)(0) * nums(i)
      val b = dp(i - 1)(1) * nums(i)
      dp(i)(0) = nums(i) min a min b // record min
      dp(i)(1) = nums(i) max a max b // record max
      result = result max dp(i)(1)
    }
    result
  }
}


/**
* optimize above one
* don't copy subArray during transmit parameters
* time complexity： O(N^2)
*/
object Solution {
  def maxProduct(nums: Array[Int]): Int = {
    (1 to nums.length).map(n =>  _maxProduct(nums(n - 1), n, nums)).max
  }
  def _maxProduct(curr: Int, idx: Int, nums: Array[Int]): Int = {
      if(idx >= nums.length) return curr   
      curr max  _maxProduct( curr * nums(idx), idx + 1, nums)
  }

}




object Solution {
    def maxProduct(nums: Array[Int]): Int = {
        if (nums == null || nums.size == 0) {
            return 0;
        }
        val list: List[Int] = nums.toList
        val head: Int = list.head
        val tail: List[Int] = list.tail
        _MaxProduct(tail, head, head, head)
    }
    
    def _MaxProduct(nums: List[Int], min: Int, max: Int, result: Int): Int = nums match {
        case Nil => result
        case x :: xs => {
            val cur_min = math.min(x, math.min(x * max, x * min))
            val cur_max = math.max(x, math.max(x * max, x * min))
            _MaxProduct(xs, cur_min, cur_max, math.max(cur_max, result))
        }
    }
}
```

###  1.55. <a name='-1'></a>153-寻找旋转排序数组中的最小值

[哈哈哈](https://www.bilibili.com/video/BV1bT4y1w7yK?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1yK411L7rp?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMin(self, nums):
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == nums[right]:    # 此时 left 和 right 相等，直接返回
                return nums[right]
            elif nums[mid] < nums[right]:   # 比右界小，nums[mid] 可能是最小值，不能去掉
                right = mid
            else:                           # 比右界大，nums[mid] 肯定不会是最小值     
                left = mid + 1

        return 1000000    # 这里写什么都无所谓，正常情况下不会走到这里的

# 二分法

class Solution:
    def findMin(self, nums):
        l,r= 0,len(nums) -1
        while l < r:
            if nums[l] < nums[r]:
                return nums[l]
            mid = (l + r) // 2
            if nums[mid] >= nums[r]:
                l = mid +1
            else:  
                r = mid
        return nums[l]
```

```scala

/**
* my first commitment binary search
*/
object Solution1 {
    def findMin(nums: Array[Int]): Int = {
        search(nums, 0, nums.length - 1)
    }
  
    def search(nums: Array[Int], left: Int, right: Int): Int = {
      if (left > right) return nums(left)
      val mid = left + (right - left) / 2
      val leftAns = if (nums(mid) >= nums(left)){ // left part in order
        nums(left)
      } else {
        search(nums, left, mid - 1)
      }
      
      val rightAns = if (nums(mid) <= nums(right)) { // right part in order
        nums(mid)
      } else {
        search(nums, mid + 1, right)
      }
      
      leftAns min rightAns
    }
}
```

###  1.56. <a name='FindMinimuminRotatedSortedArr'></a>154 Find Minimum in Rotated Sorted Arr

[小明](https://www.bilibili.com/video/BV1ik4y1B7de?spm_id_from=333.999.0.0)

###  1.57. <a name='MinStack'></a>155-Min Stack

[哈哈哈](https://www.bilibili.com/video/BV1H74118748?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1r77W?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ja4y1Y7vY?spm_id_from=333.999.0.0)

```py
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = [math.inf]

    def push(self, x: int) -> None:
        self.stack.append(x)
        self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

面试的时候被问到不能用额外空间，就去网上搜了下不用额外空间的做法。思路是栈里保存差值。

class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min_value = -1

    def push(self, x: int) -> None:
        if not self.stack:
            self.stack.append(0)
            self.min_value = x
        else:
            diff = x-self.min_value
            self.stack.append(diff)
            self.min_value = self.min_value if diff > 0 else x

    def pop(self) -> None:
        if self.stack:
            diff = self.stack.pop()
            if diff < 0:
                top = self.min_value
                self.min_value = top - diff
            else:
                top = self.min_value + diff
            return top

    def top(self) -> int:
        return self.min_value if self.stack[-1] < 0 else self.stack[-1] + self.min_value

    def getMin(self) -> int:
        return self.min_value if self.stack else -1

class MinStack:

    def __init__(self):
        # 另外用一个stack，栈顶表示原栈里所有值的最小值
        self.min_stack = []
        self.stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.min_stack == []:
            self.min_stack.append(val)
            return
        if self.min_stack[-1] >= val:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack[-1] == self.min_stack[-1]:
            self.min_stack.pop()
        return self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]


    def getMin(self) -> int:
        return self.min_stack[-1]        
```


```scala
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var min = Int.MaxValue

    def push(x: Int) {
        stack = stack :+ x
        if(x < min){
            min = x
        }
    }

    def pop() {
        stack = stack.init
        min = Int.MaxValue
        stack.map(x => {
            if(x < min) min = x
        })
    }

    def top(): Int = {
        stack.last
    }

    def getMin(): Int = {
        min
    }

}

//替代解决方案：更快
//这里我们将元素添加到列表中而不是附加
//请注意，由于List实际上是一个LinkedList，因此处理列表的“头部”要容易得多
//还有另一个列表来维护列表的最小元素
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var mins = List.empty[Int]

    def push(x: Int) {
        //如果我们将第二个条件设为 x < mins.head，则此行失败
        //with NoSuchElementException: 空列表的头部
        //为什么？？？
        if(mins.isEmpty || mins.head >= x) mins = x +: mins
        stack = x +: stack
    }

    def pop() {
        if(mins.head == stack.head) mins = mins.tail
        stack = stack.tail
    }

    def top(): Int = {
        stack.head
    }

    def getMin(): Int = {
        mins.head
    }

}

```

###  1.58. <a name='IntersectionofTwoLinkedLists'></a>160-Intersection of Two Linked Lists

[哈哈哈](https://www.bilibili.com/video/BV1n741187X6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411H7uq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K4y1J7wx?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1np4y1y789?spm_id_from=333.999.0.0)

```py
## 1. 哈希表

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        listA = set()
        while headA:
            listA.add(headA)
            headA = headA.next
        while headB:
            if headB in listA:
                return headB
            headB = headB.next
        return None

# > 时间复杂度 $O(M+N)$, 空间复杂度 $O(M)$

## 2. 双指针

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        pa,pb = headA, headB
        while pa != pb:
            pa = pa.next if pa else headB
            pb = pb.next if pb else headA
        return pa

# > 时间复杂度 $O(M+N)$, 空间复杂度 $O(1)$
```

```py

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        lengthA,lengthB = 0,0
        curA,curB = headA,headB
        while(curA!=None): #求链表A的长度
            curA = curA.next
            lengthA +=1
        
        while(curB!=None): #求链表B的长度
            curB = curB.next
            lengthB +=1
        
        curA, curB = headA, headB

        if lengthB>lengthA: #让curA为最长链表的头，lenA为其长度
            lengthA, lengthB = lengthB, lengthA
            curA, curB = curB, curA

        gap = lengthA - lengthB #求长度差
        while(gap!=0): 
            curA = curA.next #让curA和curB在同一起点上
            gap -= 1
        
        while(curA!=None):
            if curA == curB:
                return curA
            else:
                curA = curA.next
                curB = curB.next
        return None
```



```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {
        var ha = headA
        var hb = headB
        
        while(ha != hb){
            if(ha == null){
                ha = headB
            }else{
                ha = ha.next
            }
            
            if(hb == null){
                hb = headA
            }else{
                hb = hb.next
            }
        }
        
        ha
    }
}

```

###  1.59. <a name='FindPeakElement'></a>162. Find Peak Element

[小梦想家](https://www.bilibili.com/video/BV1Rb411n7dT?spm_id_from=333.999.0.0)

```py
# 努力接受了一下。就是想象一下峰顶在中间，那么左右两侧都是有序的，可根据mid和mid+1的值判断当前是在哪一侧，然后最后定位到峰值

class Solution:
    def findPeakElement(self, nums):
        l = 0 
        r = len(nums) - 1 

        while l <= r:
            mid = (l + r) >> 1 
            
            if mid == len(nums) - 1:
                r = mid - 1 
            else:
                if nums[mid] > nums[mid+1]:
                    r = mid - 1 
                else:
                    l = mid + 1 
        return l

# 要求时间复杂度 O(log N)，考虑二分查找。

# nums[mid] > max(nums[mid-1], nums[mid+1])	mid 即为所求
# nums[mid] < nums[mid+1]			        [mid+1, n-1] 范围内必然有一个峰值
# nums[mid] < nums[mid-1]				[0, mid-1] 范围内必然有一个峰值
class Solution(object):
    def findPeakElement(self, nums):
        n = len(nums)
        i, j = 0, n - 1
        while i <= j:
            mid = i + (j - i) // 2
            if (mid == 0 or nums[mid] > nums[mid-1]) and (mid == n-1 or nums[mid] > nums[mid+1]):
                return mid
            if nums[mid] < nums[mid+1]:
                i = mid + 1
            else:
                j = mid - 1

class Solution(object):
    def findPeakElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        l, r = 0, len(nums) - 1
        while l <= r:
        	if l == r : return l
        	mid = l + ((r - l) >> 2)
        	if nums[mid] < nums[mid+1]:
        		l = mid + 1
        	else:
        		r = mid

            
# 方法一：寻找最大值
class Solution:
    def findPeakElement(self, nums):
        idx = 0
        for i in range(1, len(nums)):
            if nums[i] > nums[idx]:
                idx = i
        return idx
```

###  1.60. <a name='CompareVersionNumbers'></a>165. Compare Version Numbers

[小梦想家](https://www.bilibili.com/video/BV19K4y1C7L3?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pk4y117dF?spm_id_from=333.999.0.0)

```py
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        for v1, v2 in zip_longest(version1.split('.'), version2.split('.'), fillvalue=0):
            x, y = int(v1), int(v2)
            if x != y:
                return 1 if x > y else -1
        return 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/compare-version-numbers/solution/bi-jiao-ban-ben-hao-by-leetcode-solution-k6wi/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        n, m = len(version1), len(version2)
        i, j = 0, 0
        while i < n or j < m:
            x = 0
            while i < n and version1[i] != '.':
                x = x * 10 + ord(version1[i]) - ord('0')
                i += 1
            i += 1  # 跳过点号
            y = 0
            while j < m and version2[j] != '.':
                y = y * 10 + ord(version2[j]) - ord('0')
                j += 1
            j += 1  # 跳过点号
            if x != y:
                return 1 if x > y else -1
        return 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/compare-version-numbers/solution/bi-jiao-ban-ben-hao-by-leetcode-solution-k6wi/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = version1.split(".")
        v2 = version2.split(".")

        while v1 or v2:
            x = int(v1.pop(0)) if v1 else 0
            y = int(v2.pop(0)) if v2 else 0

            if x>y:
                return 1
            elif x<y:
                return -1
        return 0
python 精简版

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        a = list(map(int,version1.split('.')))
        b = list(map(int,version2.split('.')))
        if len(a) > len(b):
            b += [0] * (len(a) - len(b))
        else:
            a += [0] * (len(b) - len(a))
        a = int(''.join(map(str,a)))
        b = int(''.join(map(str,b)))
        if a > b:
            return 1
        elif a < b:
            return -1
        else:
            return 0
简洁版

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        for x, y in zip_longest(version1.split('.'), version2.split('.'), fillvalue='0'):
            a, b = int(x), int(y)
            if a != b: return 1 if a > b else -1
        return 0 
```

###  1.61. <a name='FractiontoRecurringDecimal'></a>166. Fraction to Recurring Decimal

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7PE?spm_id_from=333.999.0.0)

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # ----------情况一：没有余数----------
        if numerator % denominator == 0:
            return str(numerator // denominator)
        # ----------情况一：没有余数----------


        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        s = []

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if (numerator < 0) != (denominator < 0):
            s.append('-')
        # ----------------得到负数----------------
        # ----------------得到负数----------------


        # 整数部分
        numerator = abs(numerator)
        denominator = abs(denominator)
        integerPart = numerator // denominator
        s.append(str(integerPart))
        s.append('.')

        # 小数部分
        indexMap = {}
        remainder = numerator % denominator
        while remainder and remainder not in indexMap:
            indexMap[remainder] = len(s) 

            # 这里需要一个计数器，s的长度递增，所以用len(s)
            # 解法二中：
            # i = 0
            # i += 1
            # 也是可以的。
            # len(s) 可以直接指向 insertIndex-插入位置

            print("余数remainder: ",indexMap.keys())
            remainder *= 10
            s.append(str(remainder // denominator))
            remainder %= denominator
        if remainder:  # 有循环节
            insertIndex = indexMap[remainder]
            s.insert(insertIndex, '(') #左侧插入
            s.append(')')

        return ''.join(s)
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
```

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        dic = {}
        res = []

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if numerator*denominator<0:
            sign = "-"
        else:
            sign = ""
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator = abs(numerator)
        denominator = abs(denominator)
        intPart,res = divmod(numerator, denominator)


        # ----------情况一：没有余数----------
        if res==0:
            return sign + str(intPart)
        # ----------情况一：没有余数----------
        
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        res.append(str(intPart))
        res.append(".")

        dic[res]= len(res) # 是 2
        while res!=0:
            intPart,res = divmod(10*res,denominator)
            res.append(str(intPart))
            # 如果余数出现在字典中，加上（）并返回
            if res in dic:
                res.insert(dic[res],"(") #左侧插入
                res.append(")")     #右侧插入
                return sign + "".join(res)
            # 继续记录余数和(索引位置
            
            dic[res] = len(res) # i+=1
        # 如果余数为0
        return sign + "".join(res) 
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # 处理整数部分
        ans = ""

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if numerator * denominator < 0:
            ans += "-"
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart, res = divmod(numerator, denominator)
        # ans += f"{q}"
        ans += str(intPart)


        # ----------情况一：没有余数----------
        if 0 == res:
            return ans
        # ----------情况一：没有余数----------

        
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        ans += '.'
        # 小数部分：除法发现循环节
        index = len(ans)  # 小数点后一个位置
        numerator = res * 10  # 被除数增加十倍
        dic = {numerator: index}
        while True:
            intPart, res = divmod(numerator, denominator)
            ans += str(intPart)
            if res == 0:
                break
            numerator = res * 10
            if numerator in dic:  # 发现循环节
                return ans[:dic[numerator]] + f"({ans[dic[numerator]:]})" # 直接加括号（）
            dic[numerator] = index + 1  # 新被除数位置
            index += 1
        return ans
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        sign = "" if numerator * denominator >= 0 else "-"
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart = numerator // denominator

        # ----------情况一：没有余数----------
        if numerator % denominator == 0: return sign + str(intPart)
        # ----------情况一：没有余数----------

        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        res, dic, index = numerator % denominator, {}, 3
        ans = [sign, str(intPart), "."]
        while res:
            if res not in dic:
                dic[res] = index
            else:
                ans.insert(dic[res], "(")
                ans.append(")")
                break
            res *= 10
            ans.append(str(res // denominator))
            res %= denominator
            index += 1
        return "".join(ans)
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
```

###  1.62. <a name='TwoSumII-Inputarrayissorted'></a>167-Two Sum II - Input array is sorted

[哈哈哈](https://www.bilibili.com/video/BV167411h7ou?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7id?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1VZ4y1M7eu?spm_id_from=333.999.0.0)

```py
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        n = len(numbers)
        for i in range(n):
            low, high = i + 1, n - 1
            while low <= high:
                mid = (low + high) // 2
                if numbers[mid] == target - numbers[i]:
                    return [i + 1, mid + 1]
                elif numbers[mid] > target - numbers[i]:
                    high = mid - 1
                else:
                    low = mid + 1
        
        return [-1, -1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        low, high = 0, len(numbers) - 1
        while low < high:
            total = numbers[low] + numbers[high]
            if total == target:
                return [low + 1, high + 1]
            elif total < target:
                low += 1
            else:
                high -= 1

        return [-1, -1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python 3 有点二分法的味道

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left = 0
        right = len(numbers)-1      
        while left < right:
            if numbers[left] + numbers[right] == target:                
                return [left+1, right+1]
            elif numbers[left] + numbers[right] < target:
                left = left + 1
            else:
                right = right - 1

python3 双指针，二分，hash表记录差值 class Solution: def twoSum(self, numbers: List[int], target: int) -> List[int]: n = len(numbers)

    # 双指针
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r =0, n-1 
        while l <= r:
            if numbers[l] + numbers[r] == target:
                return [l+1, r+1]
            elif numbers[l] + numbers[r] < target:
                l +=1
            else:
                r -=1
    # 二分
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        for i in range(n-1):
            l, r =i+1, n-1
            while l <= r:
                mid = (l+r) // 2
                if numbers[mid] == target - numbers[i]:
                    return [i+1, mid+1]
                elif numbers[mid] > target - numbers[i]:
                    r = mid - 1
                else:
                    l = mid + 1
    # hasn表，利用hash表记录所有的差值
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        hash_ = dict()
        for index, num in enumerate(numbers):
            if num in hash_:
                return [hash_[num]+1, index+1]
            hash_[target - num] = index
```

###  1.63. <a name='ExcelSheetColumnTitle'></a>168-Excel Sheet Column Title

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7FY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H777?spm_id_from=333.999.0.0)

```py
class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        ans = list()
        while columnNumber > 0:
            a0 = (columnNumber - 1) % 26 + 1
            ans.append(chr(a0 - 1 + ord("A")))
            columnNumber = (columnNumber - a0) // 26
        return "".join(ans[::-1])

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/excel-sheet-column-title/solution/excelbiao-lie-ming-cheng-by-leetcode-sol-hgj4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        ans = list()
        while columnNumber > 0:
            columnNumber -= 1
            ans.append(chr(columnNumber % 26 + ord("A")))
            columnNumber //= 26
        return "".join(ans[::-1])

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/excel-sheet-column-title/solution/excelbiao-lie-ming-cheng-by-leetcode-sol-hgj4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

麻了，简单题都不能重拳出击了

class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        res = ""

        while columnNumber-1 >= 0:
            columnNumber -= 1
            res += chr(columnNumber % 26 + ord('A'))
            columnNumber //= 26
        return res[::-1]
```

```py
## A的ascii码为65

class Solution:
    def convertToTitle(self, n: int) -> str:
        s = ''
        while(n):
            n -= 1
            s = chr(n%26+65) + s
            n = n//26
        return s

用换进制的方法做了好久，突然发现这个题是没有A0的，又想了好久才知道在哪里减一。。

class Solution(object):
    def convertToTitle(self, columnNumber):
        res = ''
        while columnNumber:
            columnNumber -= 1
            res = chr(columnNumber % 26 + 65) + res
            columnNumber = columnNumber // 26 
        return res

class Solution(object):
    def convertToTitle(self, columnNumber):
        """
        :type columnNumber: int
        :rtype: str
        """
        words = 'ZABCDEFGHIJKLMNOPQRSTUVWXY'
        dic = {}
        for i in range(26):
            dic[i] = words[i]
        res = ''
        while columnNumber :
            columnNumber,mod = divmod(columnNumber,26)
            res = dic[mod] + res
            if not mod:
                columnNumber -= 1
        return res
```

###  1.64. <a name='MajorityElement'></a>169. Majority Element

[花花酱](https://www.bilibili.com/video/BV1hb411c7bF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7pW?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ff4y1U7Vn?spm_id_from=333.999.0.0)

```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[len(nums) // 2]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        majority_count = len(nums) // 2
        while True:
            candidate = random.choice(nums)
            if sum(1 for elem in nums if elem == candidate) > majority_count:
                return candidate

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = None

        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)

        return candidate

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python3 因为一定有众数，且众数个数大于n/2，所以直接排序输出n/2位置的数即可。[力扣]

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[int(len(nums)/2)]
         整除//不好用吗，为什么用int


藏在管子里的蛇，身体长于管子的一半的话，砍中间就肯定能砍到

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        return sorted(nums)[len(nums) // 2]
```

```scala

/**
* chosen solution
*
* Boyer-Moore Voting Algorithm
* time complexity N(N)
* space complexity O(1)
*/
object Solution {
    def majorityElement(nums: Array[Int]): Int = {
      var counter = 1
      var candidate = nums(0)
      for (idx <- 1 until nums.length) {
        val value = nums(idx)
        if(candidate == value)
          counter += 1
        else {
          if(counter == 1)
            candidate = value
          else
            counter -= 1
        }
      }
      candidate
    }
}


/**
* Boyer-Moore Voting Algorithm
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1 {
  def majorityElement(nums: Array[Int]): Int = {
    var num = nums(0)
    var counter = 0
    nums.foreach { n =>
      if (num == n) {
        counter += 1
      } else {
        counter -= 1
        if (counter == 0) {
          num = n
          counter += 1
        }
      }
    }
    num
  }
}

/**
* immutable during iteration
*/
object Solution1-2 {
    def majorityElement(nums: Array[Int]): Int = {
       val (ans, accumulate) = (1 until nums.length).foldLeft((nums.head, 1)) {
            case ((cur, acc), idx) =>
                val incoming = nums(idx)
                if(incoming == cur) (cur, acc + 1)
                else {
                    if(acc == 1) (incoming, 1)
                    else (cur, acc - 1)
                }
        }
        ans
    }
}

/**
* HashMap
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution2 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.groupBy(identity).mapValues(_.length).maxBy(_._2)._1  
    }
}


/**
* sorting array and pick middle element
* time complexity O(NlogN)
*/

object Solution3 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.sorted(Ordering.Int)(nums.length / 2)
    }
}


```

```scala
object Solution {
    def majorityElement(nums: Array[Int]): Int = {
        var map = scala.collection.mutable.Map.empty[Int, Int]
        for(elem <- nums){
            map.get(elem) match{
                case Some(count) => map += (elem -> (count+1))
                case None => map += (elem -> 1)
            }
        }
        
        map.toList.filter(_._2 > (nums.size / 2)).head._1
    }
}

//Alternate solution O(n) but NO EXTRA SPACE
object Solution {
    def majorityElement(nums: Array[Int]): Int = {     
        var current = nums.head
        var count = 0
        nums.foreach(num => {
            if(count == 0) { 
                current = num
                count = 0
            }
            if(num == current) count+=1;
            else count-=1;
        })
        
        current
    }
}

```

###  1.65. <a name='ExcelSheetColumnNumber'></a>171. Excel Sheet Column Number

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7nT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1h541187Sv?spm_id_from=333.999.0.0)

```py
class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        number, multiple = 0, 1
        for i in range(len(columnTitle) - 1, -1, -1):
            k = ord(columnTitle[i]) - ord("A") + 1
            number += k * multiple
            multiple *= 26
        return number

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/excel-sheet-column-number/solution/excelbiao-lie-xu-hao-by-leetcode-solutio-r29l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        num = 0
        for t in columnTitle:
            num *= 26 
            num += ord(t) - ord('A') + 1
        return num

python 从左到右遍历

class Solution:
def titleToNumber(self, columnTitle: str) -> int:
        res = 0
        for c in columnTitle:
            res *= 26
            res += ord(c) - ord('A') + 1 
        return res
```

```py
class Solution(object):
    def titleToNumber(self, s):
        #26进制转10进制
        ans = 0
        for x in s:
            ans *= 26
            ans += ord(x)-ord('A')+1
        return ans
        请问一下-ord('A')+1 该怎么理解呢,说明A表示1，而不是0。ord('A') = 65 这里直接减去64就好了

我太菜了

class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        map = {'A':1, 'B':2, 'C':3, 'D':4,'E':5, 'F':6, 'G':7, 'H':8,
        'I':9, 'J':10, 'K':11, 'L':12,'M':13, 'N':14, 'O':15, 'P':16,
        'Q':17, 'R':18, 'S':19, 'T':20,'U':21, 'V':22, 'W':23, 'X':24,'Y':25, 'Z':26}
        i = len(columnTitle) - 1
        p = 0
        res = 0
        while i > -1:
            res += (map[columnTitle[i]]) * pow(26, p)
            p += 1
            i -= 1
        return res
```

```scala
object Solution {
    def titleToNumber(s: String): Int = {
        var size = s.size
        var i = 0
        var sheetNumber = 0
        while(i < size){
            var sum = (s.charAt(i) - 'A' + 1) * Math.pow(26, (size - i-1)).toInt
            
            sheetNumber += sum
            i += 1
        }
        sheetNumber
    }
}


//Alternate solution
object Solution {
    def titleToNumber(s: String): Int = 
        s.foldLeft(0)((acc, ch) => acc * 26 + (ch - 'A' + 1))
}

```

###  1.66. <a name='FactorialTrailingZeroes'></a>172-Factorial Trailing Zeroes

[哈哈哈](https://www.bilibili.com/video/BV1hE411n7TM?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7tS?spm_id_from=333.999.0.0)

```py
def trailingZeroes(self, n: int) -> int:
        
    # Calculate n!
    n_factorial = 1
    for i in range(2, n + 1):
        n_factorial *= i
    
    # Count how many 0's are on the end.
    zero_count = 0
    while n_factorial % 10 == 0:
        zero_count += 1
        n_factorial //= 10
        
    return zero_count

作者：LeetCode
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/jie-cheng-hou-de-ling-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def trailingZeroes(self, n: int) -> int:
        
    zero_count = 0
    for i in range(5, n + 1, 5):
        current = i
        while current % 5 == 0:
            zero_count += 1
            current //= 5

    return zero_count

作者：LeetCode
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/jie-cheng-hou-de-ling-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def trailingZeroes(self, n: int) -> int:
        
    zero_count = 0
    for i in range(5, n + 1, 5):
        power_of_5 = 5
        while i % power_of_5 == 0:
            zero_count += 1
            power_of_5 *= 5

    return zero_count

作者：LeetCode
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/jie-cheng-hou-de-ling-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def trailingZeroes(self, n: int) -> int:
    zero_count = 0
    current_multiple = 5
    while n >= current_multiple:
        zero_count += n // current_multiple
        current_multiple *= 5
    return zero_count

作者：LeetCode
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/jie-cheng-hou-de-ling-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def trailingZeroes(self, n: int) -> int:
    zero_count = 0
    while n > 0:
        n //= 5
        zero_count += n
    return zero_count

作者：LeetCode
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/jie-cheng-hou-de-ling-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n >= 5:
            ans = ans + n//5
            n=n//5
        return ans
```

```scala
object Solution {
    def trailingZeroes(n: Int): Int = {
        var count5 = 0
        var count2 = 0
        
        var temp = n
        while(temp>=5){
            count5 += temp/5
            temp = temp/5
        }
        
        temp = n
        while(temp>=2){
            count2 += temp/2
            temp = temp/2
        }
        
        if(count5 < count2) count5 else count2
    }
}

```

###  1.67. <a name='BinarySearchTreeIterator'></a>173 Binary Search Tree Iterator

[小明](https://www.bilibili.com/video/BV1qK41137h1?spm_id_from=333.999.0.0)

```py
# 在数据上设计迭代器的话，是「一定」不能修改原始的数据的。

# ------

# 借楼贴个 Morris 遍历。O(1) 空间复杂度，均摊 O(1) 时间复杂度。

class BSTIterator:
    def __init__(self, root: TreeNode):
        self.curr = root

    def next(self) -> int:
        while self.curr.left:
            left = self.curr.left
            while left.right and left.right != self.curr:
                left = left.right
            # left child has been visited
            if left.right:
                left.right = None
                break
            # left child has not been visited
            else:
                left.right = self.curr
                self.curr = self.curr.left
        # visit current node and go right
        ans = self.curr.val
        self.curr = self.curr.right
        return ans

    def hasNext(self) -> bool:
        return True if self.curr else False

# 这并不是一种好办法。如果在数据上设计迭代器的话，
# 是「一定」不能修改原始的数据的。
# 请教下为什么不能修改原始数据？
# 是因为某些情况下会造成迭代器失效吗？
# 有些迭代器设计时也允许这种情况，比如STL中的某些容器。Thanks!
# 是「迭代器在迭代的过程中不能修改原始的数据结构」，
# 不是「不能通过迭代器本身修改原始的数据」。
# 想一想 const iterator 就知道是怎么回事了

# Python 72ms 击败100%，关键是构建一个最小值存储栈，实现O(h)空间复杂度。

class BSTIterator(object):

    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self):
        """
        @return the next smallest number
        :rtype: int
        """
        temp = self.stack.pop()
        res = temp.val
        temp = temp.right
        while temp:
            self.stack.append(temp)
            temp = temp.left
        return res

    def hasNext(self):
        """
        @return whether we have a next smallest number
        :rtype: bool
        """
        return self.stack != []

# 在next中回溯的，这个用的是非递归，栈的方法来遍历的
# 在next中 ，把pop 的节点看做root， 将其右节点压入栈。自下往上
# 每一次调用next都是在return 之余去看一下当前节点的右子节点，
# 如果有右子节点，那么树的深度会比当前遍历深度大，
# 也就是说，next在右子节点代表的子树中，
# 那就按照正常遍历左子树的思路去遍历该子树即可，就跟init一样；
# 如果没有右子树，那么当前子树达到最大深度，next就得往上一层找，
# 就是说继续从stack中pop，因为stack中存的是每一层的左子树，
# pop到上一层再看看有没有右子树，如果有，还是一样的道理，去遍历该右子树的左子树。
# 总的来说stack总能pop出树的最小值，也就是当前状态下的左子树的最深左节点。

class BSTIterator(object):
    def __init__(self, root):

        #二叉搜索树中序遍历是递增数组
        self.res = []

        def inorder(root):
            if root == None:
                return
            inorder(root.left)
            self.res.append(root.val)
            inorder(root.right)
        inorder(root)
        self.index = 0


    def next(self):
        """
        :rtype: int
        """
        self.index += 1
        return self.res[self.index-1]

    def hasNext(self):
        """
        :rtype: bool
        """
        if self.index < len(self.res):
            return True
        else:
            return False
# 这样似乎空间复杂度大于题目要求的O(h)了吧
# 是的 不能用递归 应该用迭代

# 还是用栈空间吧

class BSTIterator:
    def __init__(self, root: TreeNode):
        self.data = []
        self.enqueue(root)
        
    def enqueue(self, root):
        while root:
            self.data.append(root)
            root = root.left

    def next(self) -> int:
        res = self.data.pop()
        self.enqueue(res.right)
        return res.val

    def hasNext(self) -> bool:
        return bool(self.data)

# 同样没有听题目要求，一开始就取巧，用InOrder，这样得到BSF有序排列，然后使用
class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.root = root
        self.lst = []
        self.inOrder(root)
        self.lst.reverse()

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.lst != []

    def next(self):
        """
        :rtype: int
        """
        return self.lst.pop()
    
    def inOrder(self, root):
        if root == None:
            return
        self.inOrder(root.left)
        self.lst.append(root.val)
        self.inOrder(root.right)

# 谷歌了一下，得到如何满足题目要求的hint，从root开始，
# 往左走，把左孩子压入stack，直到左边为空。

# 然后开始取node，如果node有右孩子，
# 则同样要把node的右孩子的所有左孩子全部append入stack，画了一个图，可行。
class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.root = root
        self.stack = []
        self.pushAllLeft(root)
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.stack != []
        

    def next(self):
        """
        :rtype: int
        """
        if self.hasNext():
            cur = self.stack.pop()
            if cur.right:
                self.pushAllLeft(cur.right)
            return cur.val
            
    def pushAllLeft(self, node):
        """
        :type node: TreeNode
        """
        cur = node
        while cur:
            self.stack.append(cur)
            cur = cur.left
```

###  1.68. <a name='DungeonGame'></a>174 Dungeon Game

[小明](https://www.bilibili.com/video/BV1TK411W7T1?spm_id_from=333.999.0.0)

###  1.69. <a name='LargestNumber'></a>179 Largest Number

[小明](https://www.bilibili.com/video/BV1mV411m7aN?spm_id_from=333.999.0.0)

```py
from functools import cmp_to_key

# 比较函数
def compare(a, b):
    print("compare:")
    return int(b + a) - int(a + b)
    

class Solution(object):
    def largestNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: str
        """
        nums = sorted([str(x) for x in nums], key=cmp_to_key(compare))
        return str(int(''.join(nums)))
```

```py
class Solution:
    def largestNumber(self, nums):
        # 第一步：定义比较函数，把最大的放左边
        # 第二步：排序
        # 第三步：返回结果
        def compare(x, y): return int(y+x) - int(x+y)
        nums = sorted(map(str, nums), key=cmp_to_key(compare))
        return "0" if nums[0]=="0" else "".join(nums)
```

```py
# 一个[0,0]让我不讲武德——str->int->str

class Solution:
    def largestNumber(self, nums):
        # res = []
        # for i in nums:
        #     res.append(str(i))

        # res.sort(reverse=True)
        # print(res)
        # return ''.join(res)

        # 大小的比较不是常规的字符串比较
        # 正常来说'30' > '3' 但是'303' < '330'
        # 需要自己定义排序规则

        res = []
        for i in nums:
            res.append(str(i))

        def cmp(a,b):
            return 1 if (a+b) < (b+a) else -1
        
        import functools
        res.sort(key=functools.cmp_to_key(cmp))
        
        # print(res)
        return str(int(''.join(res)))
```

```py
class Solution:
    def largestNumber(self, nums):
        nums=sorted([str(x) for x in nums],reverse=True)
        for i in range(len(nums)-1):
            for j in range(i,len(nums)):
                if str(nums[i])+str(nums[j])<str(nums[j])+str(nums[i]):
                    nums[i],nums[j]=nums[j],nums[i]
        return str(int(''.join(nums)))
```

###  1.70. <a name='ReverseWordsinaStringII'></a>186. Reverse Words in a String II 

[哈哈哈](https://www.bilibili.com/video/BV1GV411Z7fo?spm_id_from=333.999.0.0)

###  1.71. <a name='RepeatedDNASequences'></a>187 Repeated DNA Sequences

[小明](https://www.bilibili.com/video/BV1mp4y1r7v5?spm_id_from=333.999.0.0)

###  1.72. <a name='BestTimetoBuyandSellStockIV'></a>188 Best Time to Buy and Sell Stock IV

[小明](https://www.bilibili.com/video/BV1f54y1k7cX?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0

        n = len(prices)
        k = min(k, n // 2)
        buy = [[0] * (k + 1) for _ in range(n)]
        sell = [[0] * (k + 1) for _ in range(n)]

        buy[0][0], sell[0][0] = -prices[0], 0
        for i in range(1, k + 1):
            buy[0][i] = sell[0][i] = float("-inf")

        for i in range(1, n):
            buy[i][0] = max(buy[i - 1][0], sell[i - 1][0] - prices[i])
            for j in range(1, k + 1):
                buy[i][j] = max(buy[i - 1][j], sell[i - 1][j] - prices[i])
                sell[i][j] = max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);  

        return max(sell[n - 1])

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iv-by-8xtkp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0

        n = len(prices)
        k = min(k, n // 2)
        buy = [0] * (k + 1)
        sell = [0] * (k + 1)

        buy[0], sell[0] = -prices[0], 0
        for i in range(1, k + 1):
            buy[i] = sell[i] = float("-inf")

        for i in range(1, n):
            buy[0] = max(buy[0], sell[0] - prices[i])
            for j in range(1, k + 1):
                buy[j] = max(buy[j], sell[j] - prices[i])
                sell[j] = max(sell[j], buy[j - 1] + prices[i]); 

        return max(sell)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-iv-by-8xtkp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
## 未进行空间优化
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0


        n = len(prices)
        k = min(k, n // 2)  # k最大为总天数的一半
        have = [[0] * (k + 1) for _ in range(n)]
        no = [[0] * (k + 1) for _ in range(n)]


        have[0][0], no[0][0] = -prices[0], 0
        for i in range(1, k + 1): # 不合法状态
            have[0][i] = no[0][i] = float("-inf")


        for i in range(1, n): # j=0时, no[i][0]不合法
            have[i][0] = max(have[i - 1][0], no[i - 1][0] - prices[i])
            for j in range(1, k + 1):
                have[i][j] = max(have[i - 1][j], no[i - 1][j] - prices[i])
                no[i][j] = max(no[i - 1][j], have[i - 1][j - 1] + prices[i]);  


        return max(no[n - 1])

## 进行空间优化
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0


        n = len(prices)
        k = min(k, n // 2)  # k最大为总天数的一半
        have = [0] * (k + 1)
        no = [0] * (k + 1)


        have[0], no[0] = -prices[0], 0
        for i in range(1, k + 1): # 不合法状态
            have[i] = no[i] = float("-inf")


        for i in range(1, n): # j=0时, no[0]不合法
            have[0] = max(have[0], no[0] - prices[i])
            for j in range(k, 0, -1): # 优化空间, k倒序
                have[j] = max(have[j], no[j] - prices[i])
                no[j] = max(no[j], have[j - 1] + prices[i]); 


        return max(no)


标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。

首先初始化三维数组，填充第1天操作j次的没买或买了的情况的初始值，没买就是0，第一天就买入即-prices[0]。这里定义卖出操作时交易次数加1

然后是状态转移方程，下面描述的i, j都大于0

「第i天交易次数0不持有股票」的情况只能来自「第i-1天交易次数0不持有股票」；

「第i天交易j次不持有股票」的状态可以来自「第i-1天交易j次不持有股票」或者「第i-1天交易j-1次持有股票」(即今天卖出股票，然后交易次数+1)；

「第i天交易j次持有股票」的状态可以来自「第i-1天交易j次持有股票」或者「第i-1天交易j次不持有股票」(即今天买入股票，因为是买入操作所以交易次数不变)

最后对于这题LeetCode的测试样例里有超大k值的情况，退化成122题不限次数的操作，可以用贪心解决或者直接替换k值为数组长度的一半

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices or not k:
            return 0
        n = len(prices)
        
        # 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数
        if k > n//2:
            return self.greedy(prices)
        
        dp, res = [[[0]*2 for _ in range(k+1)] for _ in range(n)], []
        # dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票
        # 设定在卖出时加1次交易次数
        for i in range(k+1):
            dp[0][i][0], dp[0][i][1] = 0, - prices[0]
        for i in range(1, n):
            for j in range(k+1):
                if not j:
                    dp[i][j][0] = dp[i-1][j][0]
                else:
                    dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j-1][1] + prices[i])
                dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0] - prices[i])
        # 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解
        for m in range(k+1):
            res.append(dp[n-1][m][0])
        return max(res)
    
    # 处理k过大导致超时的问题，用贪心解决
    def greedy(self, prices):
        res = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                res += prices[i] - prices[i-1]
        return res


Python： 版本一

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0
        dp = [[0] * (2*k+1) for _ in range(len(prices))]
        for j in range(1, 2*k, 2):
            dp[0][j] = -prices[0]
        for i in range(1, len(prices)):
            for j in range(0, 2*k-1, 2):
                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i])
                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i])
        return dp[-1][2*k]
版本二

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) == 0: return 0
        dp = [0] * (2*k + 1)
        for i in range(1,2*k,2):
            dp[i] = -prices[0]
        for i in range(1,len(prices)):
            for j in range(1,2*k + 1):
                if j % 2:
                    dp[j] = max(dp[j],dp[j-1]-prices[i])
                else:
                    dp[j] = max(dp[j],dp[j-1]+prices[i])
        return dp[2*k]
```




```scala
/**
* chosen solution
* dynamic programming
* memo 
*    1: using an 3-dim array to record previous state
*     dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's restrictions
*  space complexity: O(K),  worst case: O(N)N
*/ 
object Solution0 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
/**
* my first commitment
* dynamic programming
* memo 
*    1: using an 3-dim array to record all previous state
*         dp[state index][k times transaction][buy or sell]
*     dp definition: dp[i][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's constraint
*/
object Solution1 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum
    val profits = Array.ofDim[Int](prices.length, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val ii = (i + prices.length - 1) % prices.length
      profits(i)(j)(1) = profits(ii)(j)(1)  max ( profits(ii)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(i)(j)(0) = profits(ii)(j)(0)  max ( profits(ii)(j - 1)(1) - prices(i)) // buy
      else
        profits(i)(j)(0) = profits(ii)(j)(0)  max  - prices(i) // buy
    }

    profits(prices.length - 1).map(_.max).max
  }
}

/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/

object Solution1-2 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum


    val profits = Array.ofDim[Int](2, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val currentI = (i + 1) % 2
      val preciousI = i % 2
      profits(currentI)(j)(1) = profits(preciousI)(j)(1)  max ( profits(preciousI)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max ( profits(preciousI)(j - 1)(1) - prices(i)) // buy
      else
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max  - prices(i) // buy
    }
    profits(prices.length % 2).map(_.max).max // prices.length % 2: decide the newest status index
  }

  private def debugProfits(profits: Array[Array[Array[Int]]]): Unit = {
        profits.zipWithIndex.foreach{
          case (p, i) =>
            println(s"status: $i")
            p.zipWithIndex.foreach{
            case (pp, j) =>
                println(s"transaction $j: hold: ${pp(0)}, sell: ${pp(1)}")
          }
            println(" ")
        }
  }
}
/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/
object Solution1-3 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
```

###  1.73. <a name='RotateArray'></a>189. Rotate Array 

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Yy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N541177Bk?spm_id_from=333.999.0.0)

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        r = k % len(nums)
        if r:
            nums[:] = nums[::-1]
            nums[:r] = nums[:r][::-1]
            nums[r:] = nums[r:][::-1]

class Solution:
    def rotate( nums, k):
        n = len(nums)
        k = k % n
        for _ in range(k):
            nums.insert(0,nums.pop())
class Solution:
    def rotate(self, A: List[int], k: int) -> None:
        def reverse(i, j):
            while i < j:
                A[i], A[j] = A[j], A[i]
                i += 1
                j -= 1
        n = len(A)
        k %= n
        reverse(0, n - 1)
        reverse(0, k - 1)
        reverse(k, n - 1)
```


```py
一行98.44%时间,数组切片必须等于切片，左边方括号和冒号都是要的
不写切片相当于nums修改的地址重新指向右边的临时地址，写切片相当于按着切片下标修改值，前者在线上判定里无法AC，线上判定只判定原地地址的情况，不写切片的nums只在函数内有效。
切片不能满足O(1)的空间要求

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        nums[: ] = nums[-k % len(nums): ] + nums[: -k % len(nums)]
改成空间o(1)的方法了，速度还快了，99.53%。

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        nums[: ] = (nums[i] for i in range(-(k % len(nums)), len(nums) - k % len(nums)))
```

###  1.74. <a name='ReverseBits'></a>190. Reverse Bits

[花花酱](https://www.bilibili.com/video/BV1NJ411k7VP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qv411i7Wg?spm_id_from=333.999.0.0)

```py
从n的右侧开始，逐个检查是否是1（利用一个s）

ans逐渐<<1，如果当前n&s==s，则说明此位为1，ans+=1

最后ans就是n的二进制位的颠倒了

执行用时：28 ms, 在所有 Python3 提交中击败了92.53%的用户
内存消耗：14.9 MB, 在所有 Python3 提交中击败了21.75%的用户

class Solution:
    def reverseBits(self, n: int) -> int:
        ans = 0
        s = 1
        for _ in range(31):
            if n&s == s:   #说明此位为1，那么ans中也+1
                ans += 1
            ans = ans<<1  #最先加入的，到最后就是最前面的数字
            s = s<<1  #1,10,100,1000...
        if n & s == s:   #最后处理一次
            ans += 1
        return ans

    每次只对最低位进行操作，理论上效率高于对 31 的循环

class Solution:
    def reverseBits(self, n: int) -> int:
        b = n & ((1 << 32) - 1)
        base = 1 << 31
        ans = 0
        while b:
            ans |=  base // (b & (-b))
            b &= b-1
        return ans    
```

```py
class Solution:
    def reverseBits(self, n):
        return int(bin(n)[2:].zfill(32)[::-1],2)
```

```scala
object Solution {
    // you need treat n as an unsigned value
    def reverseBits(x: Int): Int = {
        var binaryString = x.toBinaryString.toList
        
        var additional = (1 to (32 - binaryString.length)).map(_ => '0').toList
        
        binaryString = additional ++ binaryString
        
        val reversed = reverseBinary(binaryString, "")
        
        Integer.parseUnsignedInt(reversed.mkString, 2)
    }
    
    def reverseBinary(x: List[Char], str: String): String = x match{
        case Nil => str
        case x::xs => reverseBinary(xs, x + str)
    }
}

```

###  1.75. <a name='Numberof1Bits'></a>191 Number of 1 Bits

[小明](https://www.bilibili.com/video/BV1i5411J7SA?spm_id_from=333.999.0.0)

```py
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = sum(1 for i in range(32) if n & (1 << i)) 
        return ret

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode-solution-jnwf/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = 0
        while n:
            n &= n - 1
            ret += 1
        return ret

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode-solution-jnwf/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

最近每日一题是来给我培养信心的？

class Solution:
    def hammingWeight(self, n: int) -> int:
        ones = 0
        while n > 0:
            ones += 1
            n &= n - 1
        return ones
```

```py
从1开始，每次<<一位，与n做与运算，如果不为0，则该位为1

执行用时：36 ms, 在所有 Python3 提交中击败了40.82%的用户
内存消耗：14.7 MB, 在所有 Python3 提交中击败了91.95%的用户
class Solution:
    def hammingWeight(self, n: int) -> int:
        a, ans = 0, 0
        while a <= 32:
            if (1<<a)&n != 0:
                ans += 1
            a += 1
        return ans
         
class Solution:
    def hammingWeight(self, n: int) -> int:
        return ('{:0b}'.format(n).count('1'))

class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')
 python 输入的是10进制的 直接转str不行 可以试试 bin(n) 将10进制 转成 二进制然后 count

```

```scala
/**
* chosen solution
* bit operation - recursive version
* time complexity: O(1)
*/
object Solution0{
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        _hammingWeight(n, 0)
    }
    
    @annotation.tailrec
    def _hammingWeight(n: Int, counter: Int): Int = {
        if(n  == 0) counter
        else _hammingWeight(n & (n - 1), counter + 1 )
    }
}

/**
* my first commitment
* time complexity: fixed size: 32 bits, so O(1)
*/
object Solution0 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {

        var mask = 1
        var counter = 0
        for (_ <- 0 to 32) {

            if ((n & mask) != 0) {
                counter += 1
            }
            mask  = mask << 1
        }
        counter
    }
}


/**
* bit operation - iterative version
* memo
*    1. using bit operation :  x = x & (x -1)  to set the last non zero pos to zero
*
*/
object Solution1 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {

        var nn = n
        var counter = 0
        while(nn != 0) {
            counter += 1
            nn = nn & (nn -1)
        }
        
        counter
    }
}

/**
* bit operation - recursive version
*/
object Solution1-2 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        _hammingWeight(n, 0)
    }
    
    @annotation.tailrec
    def _hammingWeight(n: Int, counter: Int): Int = {
        if(n  == 0) counter
        else _hammingWeight(n & (n - 1), counter + 1 )
    }
}

```

```scala
object Solution {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        n.toBinaryString.toCharArray.filter(_ == '1').length
    }
}

//Alternate bit-wise shift and count 1
def hammingWeight(n: Int): Int = {
        var count = 0
        var num   = n

        while (num != 0) {
            if ((num & 1) > 0) { count = count + 1 }
            num = num >>> 1
        }
    count
}

//Alternate (need to understand whats happening here) AND of num, num-1
// num & num-1 returns the last SET bit
def hammingWeight(n: Int): Int = {
        println(n)
        var sum = 0
        var num = n         
        while (num != 0) {
            sum += 1
            num &= (num-1)                
        }
        sum
    }

```

###  1.76. <a name='HouseRobber198-'></a>198. House Robber 198-打家劫舍

[12:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1tW411676f?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1u64y1M7PA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7hu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gZ4y1N75c?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV18g4y1i7f9?spm_id_from=333.999.0.0)

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0

        size = len(nums)
        if size == 1:
            return nums[0]
        
        dp = [0] * size
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, size):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        
        return dp[size - 1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0

        size = len(nums)
        if size == 1:
            return nums[0]
        
        first, second = nums[0], max(nums[0], nums[1])
        for i in range(2, size):
            first, second = second, max(first + nums[i], second)
        
        return second

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

使劲盯着题解看，滚动数组，受到启发，写了这个，优化了5次。

class Solution:
    def rob(self, nums: List[int]) -> int:
        y = yesterday = 0
        t = today = 0
        for j in nums:
            y, t = t, max(y + j, t)
        return t
其实就是，在dp 数组前面，加上了两天，这两天，运气不好，啥都没有搞到。为了把所有边界的情况，也压到这些代码中， 而不必单独写语句，压缩函数的行数。

dp[i] 这个定义，一定要搞清楚，代表，截至第i天，能够偷盗的最大收获，这一天可能没偷，但昨天干了一个大活。 [33,9999,1] ,最后一天，啥也不干。但最后一天的dp[i]=9999 ,虽然前一天也是9999
状态转移方程，dp[i]=max(dp[i-1],dp[i-2]+nums[i]
而后发现dp[i] ,只与dp[i-2],dp[i-1]有关了
空间压缩，也就是原来要用一个列表存储dp ，现在只用两个变量，不过这两个变量要时刻刷新。
我一开始，也不会空间压缩，慢慢来。

动态规划。当前位置的最大金额，等于前一个位置的金额，或者前前位置金额加上当前位置金额。dp[i]=max(dp[i-1], dp[i-2]+nums[i])

class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], (dp[i-2]+nums[i]))
        return dp[len(nums)-1]

Python：

class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        return dp[-1]
```

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        sums = [0, 0]
        ret = 0
        for i in range(n):
            t = i % 2;
            sums[t] += nums[i]
            if sums[t] <= sums[1 - t]:
                ret += sums[1 - t]
                sums[0] = sums[1] = 0
        ret += max(sums[0], sums[1])
        return ret

动态规划，典型例题：

class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        last = 0 
        now = 0
        for i in nums: 
            #这是一个动态规划问题
            last, now = now, max(last + i, now)
        return now
但是我确实实现的不是很复杂，就是一个交替赋值比对的过程。 可以探讨。

class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        last = 0 
        now = 0
        for i in nums: 
            #其实就是一个奇数和偶数位元素求和，哪个更大么？
            last, now = now, max(last + i, now)
        return now
```


```scala
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else if(nums.length == 1){
            nums(0)
        }else if(nums.length == 2){
            Math.max(nums(0), nums(1))
        }else{
            Math.max(
                nums(0) + rob(nums.drop(2)),
                nums(1) + rob(nums.drop(3))
            )
        }
    }
}

//The above solution worked for small input arrays
//but had MEMORY LIMIT EXCEEDED for large input

//While using DP: we try to store values of repetitive calculations
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var dp = Array.fill(nums.length+1)(0)
            
            dp(0) = 0
            dp(1) = nums(0)
            (1 to nums.length-1).map(i => {
                dp(i+1) = Math.max(dp(i), dp(i-1) + nums(i))
            })
            
            dp(nums.length)
        }
    }
}

//Another way to do the same
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.isEmpty){
            0
        }else{
            var rob = nums(0)
            var no_rob = 0
            var prev = rob
            for(i <- 1 until nums.length){
                prev = rob
                rob = no_rob + nums(i)
                no_rob = Math.max(prev, no_rob)
                
            }
            Math.max(no_rob, rob)
        }
    }
}

```

###  1.77. <a name='BinaryTreeRightSideView'></a>199 Binary Tree Right Side View

[小明](https://www.bilibili.com/video/BV1854y1W7CB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xK4y1b7Wh?spm_id_from=333.999.0.0)

```py
# py，36ms，99.37%前根序遍历，按层存进字典，
# 能保证每层最后一个遍历的到的元素一定是最右边的元素，
# 输出时字典默认遍历序等于定义序

class Solution:
    def rightSideView(self, root: TreeNode):
        d = {}
        def f(r, i):
            if r:
                d[i] = r.val
                f(r.left, i + 1)
                f(r.right, i + 1)
        f(root, 0)
        return [*d.values()]
class Solution:
    def rightSideView(self, root: TreeNode):
        d, f = {}, lambda r, i: r and (d.__setitem__(i, r.val) or f(r.left, i + 1) or f(r.right, i + 1))
        return f(root, 0) or [*d.values()]

#  bfs 层序遍历，每次保留最后一个值

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root: return []
        ans = []
        stack = deque([root])
        while stack:
            for _ in range(len(stack)):
                node = stack.popleft()
                if node.left: stack.append(node.left)
                if node.right: stack.append(node.right)
            ans.append(node.val)
        return ans

# 基础方法，层次遍历：

class Solution:
    def rightSideView(self, root: TreeNode):
        ans, d = [], root and [root]
        while d:
            ans.append(d[-1].val)
            d = [r for t in d for r in (t.left, t.right) if r]
        return ans
# 老层序遍历了

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode):
        if not root:
            return []
        res = []
        node = [root]
        while node:
            node2 = []
            for n in node:
                if n.left:
                    node2.append(n.left)
                if n.right:
                    node2.append(n.right)
            res.append(node[-1].val)
            node = node2
        return res

# 后序遍历：

class Solution:
    def rightSideView(self, root: TreeNode):
        d = []
        def f(r, i):
            if r:
                i == len(d) and d.append(r.val)
                f(r.right, i + 1)
                f(r.left, i + 1)
        f(root, 0)
        return d
```

###  1.78. <a name='-1'></a>200-岛屿数量

[哈哈哈](https://www.bilibili.com/video/BV15K411p72j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Cg4y1i7dZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1KK4y1U7Ds?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1E64y1T7Nk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Np4y1977S?spm_id_from=333.999.0.0)


<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3v3ayrrcjf60.png" width="50%">

```py

# dfs
from pprint import pprint
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # 行列
        ans = 0
        # 就像是把岛屿一个个蚕食
        def dfs(i, j): 
            if 0 <= i < m and 0 <= j < n and grid[i][j] == '1':   # 补充边界条件，防止溢出
                grid[i][j] = '0' # dfs置为0
                dfs(i + 1, j)  # 遍历4个领域
                dfs(i - 1, j)  # 遍历4个领域
                dfs(i, j - 1)  # 遍历4个领域
                dfs(i, j + 1)  # 遍历4个领域

        for i in range(m): # 行列
            for j in range(n): # 行列
                if grid[i][j] == '1': # 如果grid[i][j]为1，则dfs
                    pprint(grid)
                    ans += 1
                    dfs(i, j)
        return ans

# 看了别人的代码，写的真美 ╮(╯_╰)╭ 啊

# ```python
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        def dfs(gird, used, row, col, x, y):
            if gird[x][y] == '0' or used[x][y]:
                return 
            used[x][y] = True

            if x!= 0:
                dfs(grid, used, row,col, x-1,y)
            if x!= row -1 :
                dfs(grid, used, row,col, x+1, y)
            if y!= 0:
                dfs(grid, used, row,col, x, y-1)
            if y!= col - 1:
                dfs(grid, used, row,col, x, y+1)


        row = len(grid) # 行列
        col = len(grid[0]) if row else 0 # 行列

        used = [[0 for i in range(col)] for i in range(row)]

        count = 0
        for i in range(row): # 行列
            for j in range(col): # 行列
                if grid[i][j] == '1' and not used[i][j]: # 如果grid[i][j]为1，则dfs
                    dfs(grid,used,row,col,i,j)
                    count += 1
        return count

class Solution:
    def dfs(self, grid, r, c):
        grid[r][c] = 0
        nr, nc = len(grid), len(grid[0]) # 行列
        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                self.dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid) # 行列
        if nr == 0:
            return 0
        nc = len(grid[0]) # 行列

        num_islands = 0
        for r in range(nr): # 行列
            for c in range(nc): # 行列
                if grid[r][c] == "1": # 如果grid[i][j]为1，则dfs
                    num_islands += 1
                    self.dfs(grid, r, c)
        
        return num_islands
```

```py
# 厉害的解法：Sink and count the islands.
# ```python
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        def sink(i, j):
            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1':
                grid[i][j] = '0'
                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))
                return 1
            return 0
        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[0])))

```

```scala
/**
* chosen solution
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/

object Solution0 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}


/**
* my first commit
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/
object Solution1 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}

/**
* Union & Find 
* memo
*    1. without modify original grid's elements
* time complexity: O(N * M) both N M is the dimension of grid 
*     both union and find operation's amortized time complexity in UnionFind class are very very close to 1 but not 1
*/

/**
* weighted quick-union with path compression
* all operation's amortized time complexity are very very close to 1
*/
class UnionFind(grid: Array[Array[Char]]) {
  private val n = grid.length
  private val m = grid(0).length
  private val roots = Array.tabulate(n * m){i => i}
  private val rank = Array.fill[Int](n * m)(1)
  var counter = (for(i <- 0 until n; j <- 0 until m ; if grid(i)(j) == '1' ) yield(i, j)).size

  def findRoot(coord: (Int, Int)): Int = {
    var idx = coord._2 + coord._1 * m
    var root = idx

    while(root != roots(root)) {
      root = roots(root)
    }
    /** path compression */
    while(idx != roots(idx)) {
      val tmp = roots(idx)
      roots(idx) = root
      idx = tmp
    }
    root
  }

  def isConnected(coordA: (Int, Int), coordB: (Int, Int)): Boolean = {
    findRoot(coordA) == findRoot(coordB)
  }
  def union(coordA: (Int, Int), coordB: (Int, Int)): Unit = {
    val findA  = findRoot(coordA)
    val findB = findRoot(coordB)
    if(findA == findB) return

    if(rank(findA) > rank(findB)) {
      roots(findB) = findA
    }else if(rank(findA) < rank(findB)) {
      roots(findA) = findB
    }else {
      roots(findA) = findB
      rank(findB) += 1
    }
    counter -= 1
  }

}

object Solution2 {
  private val endLabel = '0'
  def numIslands(grid: Array[Array[Char]]): Int = {
    val unionFind = new UnionFind(grid)
    for(i <- grid.indices; j <- grid(0).indices)
      union((i, j), unionFind, grid)
    unionFind.counter

  }

  def union(coord: (Int, Int), unionFind: UnionFind, grid: Array[Array[Char]]): Unit = {
    val (row, col) = coord
    if(grid(row)(col) == endLabel) return

    neighbors(coord, (grid.length, grid(0).length)).foreach {
      case (nr, nc) if grid(nr)(nc) != endLabel  =>
        unionFind.union(coord, (nr, nc))
      case _ =>
    }
  }

  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{ case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

```scala
package com.zhourui.leetcode


// 思路 
package lc0200_numberofisland {
  object Solution {
    def numIslands(grid: Array[Array[Char]]): Int = {
      if(grid.isEmpty || grid(0).isEmpty){
        return 0
      }
      val m = grid.size
      val n = grid(0).size;

      //val dp:Array[Array[Int]];//vector<vector<int>> dp(m,std::vector<int>(n));
      //val dp = Array.ofDim[Int](m,n)
      val dp = Array.fill(m,n)(0)

      var count=0;
      for (i<-0 until m) {
        for (j<-0 until n) {
          if (dp(i)(j)==0) {
            if (bfs(grid,dp,(i,j)))
              count +=1;
          }
        }
      }
      count;
    }

    def bfs(grid:Array[Array[Char]], dp:Array[Array[Int]],pos:(Int,Int)):Boolean = {
      val m = grid.length
      val n = grid(0).length
      if (pos._1>=m || pos._2>=n || pos._1<0 || pos._2<0) {
        return false
      }
      if (dp(pos._1)(pos._2) == 1) {
        false
      } else if (dp(pos._1)(pos._2) == 0 && grid(pos._1)(pos._2) == '1') {
        dp(pos._1)(pos._2) = 1
        // right
        bfs(grid, dp, (pos._1, pos._2 + 1))
        // down
        bfs(grid, dp, (pos._1 + 1, pos._2))
        // up
        bfs(grid, dp, (pos._1 - 1, pos._2))
        // left
        bfs(grid, dp, (pos._1, pos._2 - 1))
        true;
      } else {
        false
      }
    }
  }
}

```

###  1.79. <a name='BitwiseANDofNumbersRange'></a>201 Bitwise AND of Numbers Range

[小明](https://www.bilibili.com/video/BV1dT4y1g75m?spm_id_from=333.999.0.0)

```py
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        shift = 0   
        # 找到公共前缀
        while m < n:
            m = m >> 1
            n = n >> 1
            shift += 1
        return m << shift

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while m < n:
            # 抹去最右边的 1
            n = n & (n - 1)
        return n

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

只要找到规律，那么暴力法依然给力，核心思想是：如果m与n在二进制下的位数不一样，那么必须得0，然后只算m,n在二进制位数一样的情况下，来个暴力解法，就可以通过，而且速度不慢额，代码如下：

class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        if len(bin(m))<len(bin(n)):
            return 0
        else:
            temp=m
            for each in range(m+1,n+1,1):
                temp&=each
            return temp
当两个数位数不同时，中间一定会有一个1000...0 这样的进位数，这个数与比他小的数&操作都是0       
```

```py
因为 只要有一个0，那么无论有多少个 1都是 0

比如：从 5到 7

5:0 1 0 1
6:0 1 1 0
7:0 1 1 1
-----------
  0 1 0 0
所以，代码如下：

class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        i = 0
        while m != n:
            m >>= 1
            n >>= 1
            i += 1
        return m << i
```

```scala
package com.zhourui.leetcode

//看题感觉需要对所有的[m,n]范围内的数字进行遍历一遍吧。。其实不需要的。
//
//我们知道，数组的数字是连续的，那么m,n范围内的二进制表示的末尾相同位置一定会出现不同的0,1.我们只要找出m,n的做左边起的最长相同的二进制头部即可呀。
//
//如[5, 7]里共有三个数字，分别写出它们的二进制为：
//
//101　　110　　111
//
//相与后的结果为100，仔细观察我们可以得出，最后的数是该数字范围内所有的数的左边共同的部分（即m,n左边的共同部分），如果上面那个例子不太明显，我们再来看一个范围[26, 30]，它们的二进制如下：
//
//11010　　11011　　11100　　11101　　11110
//
//也是前两位是11，后面3位在不同数字中一定会出现0和1、相与即为0了。
//————————————————
//版权声明：本文为CSDN博主「负雪明烛」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
//原文链接：https://blog.csdn.net/fuxuemingzhu/article/details/79495633

class lc201_bitwiseand {
  object Solution {
    def rangeBitwiseAnd(m: Int, n: Int): Int = {
      var count = 0
      var m1 = m
      var n1 = n
      while (m1!=n1) {
        m1 >>= 1
        n1 >>=1
        count+=1
      }
      m1<<count
    }
  }
}

```

###  1.80. <a name='HappyNumber'></a>202. 快乐数 Happy Number

[官方](https://www.bilibili.com/video/BV1Ca4y1v7Qr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CA41187LQ?spm_id_from=333.999.0.0)

```py
def isHappy(self, n: int) -> bool:

    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)

    return n == 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def isHappy(self, n: int) -> bool:  
    def get_next(number):
        total_sum = 0
        while number > 0:
            number, digit = divmod(number, 10)
            total_sum += digit ** 2
        return total_sum

    slow_runner = n
    fast_runner = get_next(n)
    while fast_runner != 1 and slow_runner != fast_runner:
        slow_runner = get_next(slow_runner)
        fast_runner = get_next(get_next(fast_runner))
    return fast_runner == 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def isHappy(self, n: int) -> bool:

    cycle_members = {4, 16, 37, 58, 89, 145, 42, 20}

    def get_next(number):
        total_sum = 0
        while number > 0:
            number, digit = divmod(number, 10)
            total_sum += digit ** 2
        return total_sum

    while n != 1 and n not in cycle_members:
        n = get_next(n)

    return n == 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
Python：

class Solution:
    def isHappy(self, n: int) -> bool:
        def calculate_happy(num):
            sum_ = 0
            
            # 从个位开始依次取，平方求和
            while num:
                sum_ += (num % 10) ** 2
                num = num // 10
            return sum_

        # 记录中间结果
        record = set()

        while True:
            n = calculate_happy(n)
            if n == 1:
                return True
            
            # 如果中间结果重复出现，说明陷入死循环了，该数不是快乐数
            if n in record:
                return False
            else:
                record.add(n)

如果他不是快乐数，那么他肯定在某些数存在不停循环的过程，所以只要判断出没出现这种数就行 执行用时： 48 ms , 在所有 Python3 提交中击败了 17.45% 的用户 内存消耗： 14.9 MB , 在所有 Python3 提交中击败了 74.54% 的用户

class Solution:
    def isHappy(self, n: int) -> bool:
        res = []
        while 1:
            n = sum([ int(i)**2 for i in str(n)])
            if n == 1:
                return True
            else:
                if n not in res:
                    res.append(n)
                else:
                    return False
```

```scala
object Solution {
    
    def getDigitSquaresSum(num: Int) = {
        num.toString.map(_.asDigit).map(x => x*x).foldLeft(0)(_ + _)
    }
    
    def isHappy(n: Int): Boolean = {
        var num = n
        var set = scala.collection.mutable.HashSet.empty[Int]
        var flag = true
        while(flag){
            if(num == 1){
                flag = false
            }else if(set.contains(num)){
                flag = false
            }else{
                set.add(num)
                num = getDigitSquaresSum(num)
            }
        }
        
        num == 1
    }
}

```

```scala
package com.zhourui.leetcode

package lc0202_happynumber {
  object Solution {
    def isHappy(n: Int): Boolean = {
      def next(x:Int): Int ={
        x.toString().map(e=> (e-'0')*(e-'0')).sum
      }

      def solve(x:Int, m:Set[Int]): Boolean = x match {
        case 1 => return true
        case x if m.contains(x) =>return false
        case x =>solve(next(x), m+x)
      }
      solve(n, Set[Int]())
    }
  }
}

```

###  1.81. <a name='RemoveLinkedListElements'></a>203. Remove Linked List Elements

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7bf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Yi4y137WA?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Sz411b7zw?spm_id_from=333.999.0.0)

```py
首先处理特殊情况

然后开始双指针，一前一后，一起走

当后面的节点值等于val时，前面指针不动，后面指针继续走，直到节点的值!=val

此时把前面指针的next指向后面节点，即把中间这些值为val的节点删除了

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        if head == None:  #处理[]
            return head
        while head != None and head.val == val:  #处理[7,7,7,7,1]
            head = head.next
        if head == None:  #处理[7,7,7,7]
            return head

        h1, h2 = head, head.next
        while h2 != None:
            if h2.val == val:
                while h2 != None and h2.val == val:
                    h2 = h2.next
                h1.next = h2
            else:
                h1 = h1.next
                h2 = h2.next
        return head
```

```py
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        temp=head #操作对象是同一块内存 id(temp)=id(head)
        while temp:
            if temp.next and temp.next.val == val:
                temp.next = temp.next.next
            else:
                temp = temp.next
        if head and head.val == val: #头节点等于val的情况单独拿出来
            return head.next
        else:
            return head

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy_head = ListNode(next=head) #添加一个虚拟节点
        cur = dummy_head
        while(cur.next!=None):
            if(cur.next.val == val):
                cur.next = cur.next.next #删除cur.next节点
            else:
                cur = cur.next
        return dummy_head.next

简单每日我重拳出击，贡献一个（约等于）双100%的python实现

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        tempHead = ListNode(1)
        tempHead.next = head
        pre = tempHead
        while head:
            if head.val == val:
                pre.next = head.next
            else:
                pre = head
            head = head.next   
        return tempHead.next
```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//Remove all elements from a linked list of integers that have value val.
//
//Example:
//
//Input:  1->2->6->3->4->5->6, val = 6
//Output: 1->2->3->4->5

package lc203_remove_linkedlist_element {
  /**
   * Definition for singly-linked list.
   * class ListNode(var _x: Int = 0) {
   *   var next: ListNode = null
   *   var x: Int = _x
   * }
   */
  object Solution {
    def removeElements(head: ListNode, `val`: Int): ListNode = {
      val dummy = ListNode(0)
      dummy.next = head
      var prev = dummy
      var cur = head
      while (cur!=null) {
        if (cur.x != `val`) {
          prev.next = cur
          prev = cur
        } else {
          prev.next = null
        }
        cur = cur.next
      }
      dummy.next
    }
  }
}

```

###  1.82. <a name='CountPrimes'></a>204-Count Primes

[哈哈哈](https://www.bilibili.com/video/BV167411w7Sf?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7cV?spm_id_from=333.999.0.0)

```py
# 翻了排名靠前的代码，花了半天才看懂，自己添了备注，下次恐怕还是想不到，只能说，大佬真的牛

class Solution:
    def countPrimes(self, n) -> int:
        # 循环完成后，字典S中，每个key记录1到key中的素数的个数，V记录S的key值
        # 此方法和线性筛思想相同，每个S[key]中的合数都会被它的最小素数因子筛掉

        n -= 1
        if n < 2:  return 0

        r = int(n ** 0.5)
        V = [n//d for d in range(1, r + 1)]
        V += list(range(V[-1] - 1, 0, -1))
        S = {v: v - 1 for v in V}
        # 此时，可以认为S[v]中有数(2,3,4,...,v-1,v)，所以个数为v-1
        # S[v]中每个数乘d可以得到1到n中含因子d的所有合数
        # S[1]=0,S[2]=1,S[3]=2已经是最终结果
        # 在下面的每次循环中，逐步去掉S[v]中大于p且以p为因子，但不含比p小的因子的数
        # 即去掉S[v]中最小素数因子为p的合数

        for p in range(2, r + 1):
            # 小于n的所有合数的最小素数因子不可能大于r，所以只需要遍历2到r
            if S[p] == S[p - 1]:
                # p是合数，否则p是素数，S[p]至少比S[p-1]多出一个p来
                # 反过来，p是合数时，遍历到p时，已经遍历过p内的所有素数，S[p]中的所有合数必定已经筛掉，S[p] == S[p - 1]
                # 此时，S[key]中以p为因子的数，已经作为以p的最小素数因子为因子的数被筛掉，所以可以直接跳过
                continue
            # p是素数
            p2 = p * p
            sp_1 = S[p - 1] # 1到p-1中的所有素数的个数
            for v in V:
                if v < p2:
                    # v < p2 时，若为合数，素数因子小于p，已经遍历过了
                    break
                S[v] -= S[v//p] - sp_1
                # 在做此计算前，S[v]和S[v//p]中，去掉了最小素数因子在1到p-1之间的合数
                # 所以S[v//p]中，去掉小于p的素数(S[p-1])，剩余数乘p即为S[v]中以p为最小素数因子的合数
        return S[n]


# 埃氏筛代码重点理解一下j从i*i开始吧，

# 因为计算i*i之前就计算了i*2，i*3...,i*(i-1)。 

# 这题应该算个中等的，没思路无法下手啊。 

# 要讲武德，不要用简单题偷袭我。耗子尾汁......
import math
from math import sqrt
class Solution(object):
    def countPrimes(self, n):
        """
        :type n
        :rtype
        """
        isprime = [1]*n
        for i in range(2,int(sqrt(n))+1):
            if isprime[i]:
                for j in range(i*i,n,i):
                    isprime[j] = 0
        count = 0
        for i in range(2,n):
            if isprime[i]:count += 1
        return count

# 这题搜到一个非常牛逼的算法,叫做厄拉多塞筛法. 

# 比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,

# 然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,

# 然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,

# 再把5所有的倍数划去.以此类推.

# 代码的实现上用了非常好的技巧:
class Solution:
    def countPrimes(self, n) -> int:
        if n < 3:
            return 0     
        else:
            # 首先生成了一个全部为1的列表
            output = [1] * n
            # 因为0和1不是质数,所以列表的前两个位置赋值为0
            output[0],output[1] = 0,0
             # 此时从index = 2开始遍历,output[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引
             # 全部赋值为0. 此时output[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推.
            for i in range(2,int(n**0.5)+1): 
                if output[i] == 1:
                    output[i*i:n:i] = [0] * len(output[i*i:n:i])
         # 最后output中的数字1表明该位置上的索引数为质数,然后求和即可.
        return sum(output)
# 在上面遍历索引的时候用到了一个非常好的技巧. 

# 即i是从(2,int(n**0.5)+1)而非(2,n).这个技巧是可以验证的,

# 比如说求9以内的质数个数,那么只要划掉sqrt(9)以内的质数倍数,

# 剩下的即全为质数. 所以在划去倍数的时候也是从i*i开始划掉,而不是i+i.

# 这个解法真是太赞了!又学到了很多~~~ 和大家分享一下
class Solution(object):
    def countPrimes(self, n):
        """
        :type n
        :rtype
        """
        isPrime = [1 for i in range(n)]

        i = 2
        while i * i < n:
        	if isPrime[i]:
        		j = i * i 
        		while j < n :
        			isPrime[j] = 0
        			j += i
        	i += 1

        return sum(isPrime[2:])
```

```scala
object Solution {
    def countPrimes(n: Int): Int = {
        
        //Sieve of Eratosthenes
        
        var primeArray = Array.fill(n)(false)
        (2 until n).map(i => primeArray(i) = true)
        
        //We need to check for all numbers i, where i < sqrt(n)
        //To avoid doing sqrt operation again & again (since its expensive)
        //We can do i*i < n
        
        var i =2
        while(i*i < n){
            if(primeArray(i)){
                var j = i*i
                while(j < n){
                    primeArray(j) = false
                    j += i //because we are only checking multiple of i for each i in iteration
                }
            }
            i+=1
        }
        
        primeArray.filter(x => x).length
    }
}

```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def reverseList(head: ListNode): ListNode = {
        if(head == null || head.next == null){
            head
        } else{
            var p = reverseList(head.next)
            head.next.next = head
            head.next = null
            p
        }
    }
}

```

###  1.83. <a name='isomorphicstrings'></a>205. isomorphic strings

[小梦想家](https://www.bilibili.com/video/BV1ab411H7ZS?spm_id_from=333.999.0.0)

```py
满足题目要求的同构字符串即两个字符串的字符之间是双射或者说一一对应的关系，假设s字符串对应的集合是S，t字符串对应的集合是T，则双射关系要求：

S的元素个数、T的元素个数、S与T之间的映射个数三者都相等，则只需要一行代码即可：

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) == len(set(zip(s,t)))

从评论区@StrayCamel 搬运更 Pythonic 的写法：

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) == len(set(zip(s, t)))
原回答：

补充一个python3

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) and len(set(s)) == len(set(zip(s, t)))
```

```py
例如字符串 adsds 和 opfpf

a 和 o 是映射关系 d 和 p 是映射关系 s 和 f 是映射关系 那么

adsds.index('a') ==  opfpf.index('o')
 adsds.index('d') ==  opfpf.index('p')
 adsds.index('s') ==  opfpf.index('f')
这三个是不是恒成立

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        n = len(s)
        for i in range(n):
            if s.index(s[i]) != t.index(t[i]):  # 两个字符在各自字符串中第一次出现的位置相同，表示可以重构
                return False
        else:
            return True
和No209 单词规律同理，采用两个dict，互相指向，构成双射。发现了冲突，也就是一个字母可能对应了两个不同的字母，就说明两个字符串不是同构了。

class Solution(object):
    def isIsomorphic(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        if len(s) != len(t):
            return False
        sTot = dict()
        tTos = dict()
        for k,v in zip(s,t):
            if (k in sTot and sTot[k] != v) or (v in tTos and tTos[v] != k) :
                return False
            sTot[k] = v
            tTos[v] = k        
        return True


class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(t) != len(s):
            return False
        s2t = {}
        t2s = {}
        for i in range(len(s)):
            s_c, t_c = s[i], t[i]
            if s_c not in s2t:
                s2t[s_c] = t_c
            if t_c not in t2s:
                t2s[t_c] = s_c
            if s2t[s_c] != t_c or t2s[t_c] != s_c:
                return False
        return True

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        hashmap1 = {}
        hashmap2 = {}
        for c1, c2 in zip(s, t):
            # 这个get默认值用的好，满足了还没有完成配对字符出现的None值的情况
            if hashmap1.get(c1, c2) != c2 or hashmap2.get(c2, c1) != c1:
                return False
            hashmap1[c1] = c2
            hashmap2[c2] = c1
        return True 


class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s)!=len(t):return False

        d=dict()
        for x in range(len(s)):
            if s[x] not in d and t[x] not in d.values():
                d[s[x]]=t[x]
            elif s[x] in d and d[s[x]]==t[x]:
                pass
            else:return False
        return True
```

```scala
package com.zhourui.leetcode

import scala.collection.mutable._

package lc205_lsomorphic {
  object Solution {
    def isIsomorphic(s: String, t: String): Boolean = {
      val m:HashMap[Char,Char] = HashMap[Char,Char]()
      val n:HashMap[Char,Char] = HashMap[Char,Char]()

      s.indices.foreach(
        idx=>idx match {
          case idx if m.contains(s(idx)) && m(s(idx))!=t(idx) => return false
          case idx if n.contains(t(idx)) && n(t(idx))!=s(idx) => return false
          case idx =>{
            m(s(idx))=t(idx)
            n(t(idx))=s(idx)
          }
        }
      )
      true
    }
  }
}

/*
unordered_map<char,char> m;
unordered_map<char,char> n;

for (int i=0;i<s.length();i++) {
    if (m.count(s[i])) {
        if (m[s[i]]!=t[i]) return false;
    } else if (n.count(t[i])) {
        if (n[t[i]]!=s[i]) return false;
    } else {
        m[s[i]]=t[i];
        n[t[i]]=s[i];
    }
}
return true;

 */
```

###  1.84. <a name='ReverseLinkedList'></a>206-Reverse Linked List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7zr?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV16Q4y1M767?spm_id_from=333.999.0.0)

```py
递归解法， 先写出 while循环的迭代解法，再推导到 迭代写法。好像容易理解一些

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        """ 还有一种方法，不需要使用首元结点 
            1 -> 2 -> 3 -> 4    可以依次逆序每个指针
            1 <- 2 <- 3 <- 4    4变为了新的表头
            和头插法一样， 需要注意改变节点指针的时候，不能影响到 遍历下一个元素
        """
        # 1. 首先需要一个指针p顺序遍历节点， 还需要pre 和 cur 指针用于反转
        pre = None
        p = cur = head
        while p:
            # 1. 更新cur为当前节点
            cur = p
            # 2. p指针后移
            p = p.next
            # 3. 做反转
            cur.next = pre
            # 4. 更新pre为当前节点
            pre = cur

        # 5. 重新定义 head指向链表末尾
        head = cur
        return head


# 还可以 以递归的形式解决问题
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        """ 
            迭代解法中，每一步都是 重新指向next指针， 可以分治法，使用递归求解。找到最小子问题及终止条件
            需要调用递归栈， 空间效率要低很多。
        """
        # 1. 首先需要一个指针p顺序遍历节点， 还需要pre 和 cur 指针用于反转
        def reverse(pre, cur):
            # 当cur为None了， 说明pre指向最后的节点，返回作为新的头结点
            if not cur: 
                return pre
            next = cur.next
            cur.next = pre
            return reverse(cur, next)
        

        head = reverse(None, head)
        return head


class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        
        def reverse(pre,cur):
            if not cur:
                return pre
                
            tmp = cur.next
            cur.next = pre

            return reverse(cur,tmp)
        
        return reverse(None,head)
```


```py
前置条件：迭代指针：p = head、结果指针：res = none

以1->2->3->4->5为例：

过程：

res:None

第一层循环

res:1->2->3->4->5 res = p

res:1->None res.next = res

p:2->3->4->5 p = p.next

第二层循环

res:2->3->4->5 res = p

res:2->1->None res.next = res

p:3->4->5 p = p.next

第三层循环

res:3->4->5 res = p

res:3->2->1->None res.next = res

p:4->5 p = p.next

第四层循环

res:4->5 res = p

res:4->3->2->1->None res.next = res

p:5 p = p.next

第五层循环

res:5 res = p

res:5->4->3->2->1->None res.next = res

p:None p = p.next

end...
class Solution:
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        p, rev = head, None
        while p:
            rev, rev.next, p = p, rev, p.next
        return rev
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
/**
* chosen solution - iterative version
* time complexity: O(n)
* space complexity: O(1) 
*/
object Solution0 {
    def reverseList(head: ListNode): ListNode = {        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        prev
    }
}

 /**
 * iterative version
 * time complexity: O(n)
 * space complexity: O(1)
 */
object Solution1 {
    def reverseList(head: ListNode): ListNode = {
        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        // printNode(curr)
        prev
    }
    
    def printNode(node: ListNode) {
        var n = node
        while(n != null) {
            print(s"${n.x} ")
            n = n.next
        }
    }
}


/** recursive version */

object Solution2 {
    def reverseList(head: ListNode): ListNode = {
        
        val curr:ListNode = null
        
        _reverseList(curr, head)
        
    }
    
    @annotation.tailrec
    def _reverseList(curr: ListNode, next: ListNode): ListNode = {
        if(next == null) {
            curr
        }else{
            val tmpNode = next.next
            next.next = curr
            _reverseList(next, tmpNode)
        }
    }
}

object Solution2-1 {
    def reverseList(head: ListNode): ListNode = {
        if(head == null) head
        else _reverseList(head)
        
    }
    
    def _reverseList(node: ListNode): ListNode = {
        if (node == null || node.next == null) {
            node
        }else {
            val newHead = _reverseList(node.next)
              // reversedHead 是返回原本的尾巴，若一開始輸入是 1 -> 2 -> 3 -> 4 -> 5  -> null , 那 reversedHead 就是 5
            // 每次 iteration 返回都是同一個 reversedHead 也就是 5
            node.next.next = node
            node.next = null
             // 每次迭代 改變的就是送進每個 function 的 listnode 的 next 與 next.next 指向
            newHead
        }
        
        
    }
}
/**
stdout:
    5 4 
    5 4 3 
    5 4 3 2 
    5 4 3 2 1 
*/

/**
The recursive version is slightly trickier and the key is to work backwards.
Assume that the rest of the list had already been reversed, now how do I reverse the front part?
Let's assume the list is: n1 → … → nk-1 → nk → nk+1 → … → nm → Ø

Assume from node nk+1 to nm had been reversed and you are at node nk.

n1 → … → nk-1 → nk → nk+1 ← … ← nm

We want nk+1’s next node to point to nk.

So,
nk.next.next = nk;

Be very careful that n1's next must point to Ø.
If you forget about this, your linked list has a cycle in it.
This bug could be caught if you test your code with a linked list of size
*/
```

###  1.85. <a name='-1'></a>207-课程表

[花花酱](https://www.bilibili.com/video/BV1Ut411a74a?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV19k4y1r76s?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jz411B7UJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xp4y1Y7FJ?spm_id_from=333.999.0.0)

```py
class Solution(object):

    # 这里使用逆邻接表

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return True
        # 深度优先遍历，判断结点是否访问过
        # 这里要设置 3 个状态
        # 0 就对应 False ，表示结点没有访问过
        # 1 就对应 True ，表示结点已经访问过，在深度优先遍历结束以后才置为 1
        # 2 表示当前正在遍历的结点，如果在深度优先遍历的过程中，
        # 有遇到状态为 2 的结点，就表示这个图中存在环
        visited = [0 for _ in range(numCourses)]
        print("visited:", visited)

        # 逆邻接表，存的是每个结点的前驱结点的集合
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 在前，0 在后
        inverse_adj = [set() for _ in range(numCourses)]
        print("inverse_adj:",inverse_adj)
        for second, first in prerequisites:
            print("[first]:",first)
            print("[second]:",second)
            inverse_adj[second].add(first)
            print("inverse_adj表示在学习第[",second,"]节课前，要先学习:",inverse_adj[second])

        for i in range(numCourses):
            # 在遍历的过程中，如果发现有环，则dfs返回true，就退出
            if self.__dfs(i, inverse_adj, visited,1): # visited 初始化为 0
                return False
        return True

    def __dfs(self, vertex, inverse_adj, visited,depth):
        """
        注意：这个递归方法的返回值是返回是否有环
        :param vertex: 结点的索引
        :param inverse_adj: 逆邻接表，记录的是当前结点的前驱结点的集合
        :param visited: 记录了结点是否被访问过，2 表示当前正在 DFS 这个结点
        :return: 是否有环
        """
        # 结束条件：
        # 2 表示这个结点正在访问
        # 2 表示当前正在遍历的结点，如果在深度优先遍历的过程中，
            # -------------🎨很重要🎨-------------
        if visited[vertex] == 2:
            # 表示遇到环
            # 有遇到状态为 2 的结点，就表示这个图中存在环
            return True
            # -------------🎨很重要🎨-------------
        if visited[vertex] == 1: # 1 表示结点已经访问过，在深度优先遍历结束以后才置为 1
            return False

        print("第1步vertex:",vertex,"visited:", visited," depth:",depth)
        visited[vertex] = 2
        print("第2步vertex:",vertex,"visited:", visited," depth:",depth)
        for precursor in inverse_adj[vertex]: # 是个set()
            # 如果有环，就返回 True 表示有环
            # -------------🎨很重要🎨-------------
            if self.__dfs(precursor, inverse_adj, visited,depth+1):
                return True 
            # -------------🎨很重要🎨-------------
        print("第3步vertex:",vertex,"visited:", visited," depth:",depth)

        # 1 表示访问结束
        visited[vertex] = 1
        print("第4步vertex:",vertex,"visited:", visited," depth:",depth)
        return False

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        visited = [0] * numCourses
        result = list()
        valid = True

        for info in prerequisites:
            edges[info[1]].append(info[0])
        
        def dfs(u: int):
            nonlocal valid
            visited[u] = 1
            for v in edges[u]:
                if visited[v] == 0:
                    dfs(v)
                    if not valid:
                        return
                elif visited[v] == 1:
                    valid = False
                    return
            visited[u] = 2
            result.append(u)
        
        for i in range(numCourses):
            if valid and not visited[i]:
                dfs(i)
        
        return valid

class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        def dfs(i, colors, prerequisites):
        	colors[i] = 'G'
        	#print i, colors
        	for front, tail in prerequisites:
        		if tail == i:
        			if colors[front] == 'G':
        				return False
        			elif colors[front] == 'B':
        				continue
        			elif dfs(front, colors, prerequisites) == False:
        				return False
        	colors[i] = 'B'
        	return True

        colors = ['W' for i in range(numCourses)]
        for i in range(numCourses):
        	if colors[i] == 'W':
        		if dfs(i, colors, prerequisites) == False:
        			return False
        return True
```

```py
# python
from collections import defaultdict 
class Solution:
    def canFinish(self, numCourses, prerequisites):
        inde = defaultdict(lambda:0)  # keep track of indegree of a course
        g = defaultdict(list)          # digraph of courses 
        for t,f in prerequisites:
            g[f].append(t)
            inde[t]+=1
        inde0 = []                   # inde0 holds courses whose indegree is 0
        for i in range(numCourses):
            if inde[i]==0:
                inde0.append(i)      # initialize inde0
        for i in inde0:
            for j in g[i]:
                inde[j]-=1
                if inde[j]==0:
                    inde0.append(j)
        return len(inde0)==numCourses

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        indeg = [0] * numCourses

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])
        visited = 0

        while q:
            visited += 1
            u = q.popleft()
            for v in edges[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)

        return visited == numCourses

class Solution(object):

    # 思想：该方法的每一步总是输出当前无前趋（即入度为零）的顶点

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return True
        # 入度数组，一开始全部为 0
        in_degrees = [0 for _ in range(numCourses)]
        # 邻接表
        adj = [set() for _ in range(numCourses)]

        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # [0,1] 表示 1 在先，0 在后
        # 注意：邻接表存放的是后继 successor 结点的集合
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)
        counter = 0
        while queue:
            top = queue.pop(0)
            counter += 1

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)

        return counter == numCourses
```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

// new and apply
// Use the new keyword when you want to refer to a class's own constructor:
// 解法是 每个node(node)，1.它依赖的node个数(parent) 2.统计依赖它的node个数(son)，
// 一个node没有依赖其它节点，放入zeroInDegree
// 对zeroIndegree的node遍历，对每个依赖它的node都可以直接除去依赖

package lc207_course_schedule {

  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum == numCourses
    }
  }

  class Test extends BaseExtension {
    def init {
      val input = Array(Array(0,1),Array(1,2))
      println(Solution.canFinish(3,input) == true)
      //println(lru.get(1) == 1)
    }

    val name = "207 course schedule"
  }
}

```

###  1.86. <a name='ImplementTriePrefixTree'></a>208. Implement Trie (Prefix Tree)

[花花酱](https://www.bilibili.com/video/BV1Ut411a74P?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zz4y1R7j8?spm_id_from=333.999.0.0)

```py
from collections import  defaultdict
class TrieNode:
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.isWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.children[c]
        r.isWord = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r.children:
                return False
            r = r.children[c]
        return r.isWord

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r.children:
                return False
            r = r.children[c]
        return True
# 简单版：直接用字典

# char(key)->dict(value)

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.setdefault(c, {})
        r['#'] = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r: return False
            r = r[c]
        return r.get("#", False)

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r: return False
            r = r[c]
        return True
# 改成树了，不用类，哈希树实现 时间超过 98.94

class Trie:

    def __init__(self):
        self.root = {}


    def insert(self, word: str) -> None:
        cur_node = self.root
        for char in word:
            if not cur_node.get(char):
                cur_node[char] = {}
            cur_node = cur_node[char]
        cur_node['end'] = True


    def search(self, word: str) -> bool:
        cur_node = self.root
        for char in word:
            try:
                cur_node = cur_node[char]
            except:
                return False
        if cur_node.get('end'):
            return True
        else:
            return False


    def startsWith(self, prefix: str) -> bool:
        cur_node = self.root
        for char in prefix:
            try:
                cur_node = cur_node[char]
            except:
                return False
        return True
# Python, 写的时候忘了要写树
# 两个集合，一个存word，一个存前缀
# 插入word时倒序往prefixs集合中添加前缀，如果已经存在了，就说明后续都不用继续添加了
# 时间、空间 分别打败77%，91%
class Trie:

    def __init__(self):
        self.words = set()
        self.prefixs = set()

    def insert(self, word: str) -> None:
        try:
            self.words.add(word)
            for end_index in range(len(word)+1, 0, -1):
                prefix = word[:end_index]
                self.prefixs.add(prefix)
        except:
            return

    def search(self, word: str) -> bool:
        if word in self.words:
            return True
        else:
            return False


    def startsWith(self, prefix: str) -> bool:
        if prefix in self.prefixs:
            return True
        else:
            return False
```

```scala
/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

/**
* chosen solution
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie0() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}



/**
* my first commitment
*/
case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
}

class Trie1() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach { c =>

      val cIdx = c.asDigit - 'a'.asDigit
      if (node.childNode(cIdx) == null) {
        node.childNode(cIdx) = Node()
      }
      node = node(cIdx)
    }
    node.isWord = true

  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    val node = searchUtil(word)

    node != null && node.isWord

  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix) != null
  }


   private def searchUtil(s: String): Node = {
    var node = root
    var continue = true
    for {
      c <- s
      if continue
    } {
      val cIdx = c.asDigit - 'a'.asDigit
      if (node(cIdx) == null) {
        continue = false
      } 
      node = node(cIdx)
    }
    node
  }
}


/**
*  more elegant
*  Node with apply and update
*/

case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
  
  def update(idx: Int, node: Node): Unit = {
    childNode(idx) = node
  }

  def update(c: Char, node: Node): Unit = {
    this.update(c.asDigit - 'a'.asDigit, node)
  }
}
class Trie1-2() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach {
      case c if node(c) == null => 
        node(c) = Node()
        node = node(c)

      case c => node = node(c)
    }
    node.isWord = true
      
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }


  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach {
      case c if node(c) != null => node = node(c)
      case _ => return None
    }
    Some(node)
  }
  def traversal(): Unit = {
    val result = scala.collection.mutable.ListBuffer[String]()

    def _traversal(prefix: String, node: Node): Unit = {
      if (node.isWord) {
        result += prefix
      }
      node.childNode.zipWithIndex.foreach {
        case (n, idx) if n != null => _traversal(prefix + ('a' + idx).toChar, n)
        case _ =>
      }

    }

    _traversal("", root)
    result.foreach(s => println(s.mkString("")))

  }

}

/**
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie2() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}
```

###  1.87. <a name='-1'></a>209-长度最小的子数组

[哈哈哈](https://www.bilibili.com/video/BV1JZ4y1N7Rt?spm_id_from=333.999.0.0)

###  1.88. <a name='CourseScheduleII210-II'></a>210. Course Schedule II 210-课程表II

[花花酱](https://www.bilibili.com/video/BV1gW411y7Kb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ja4y147on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qt4y1X7oC?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kK411W7rL?spm_id_from=333.999.0.0)

```py
# 思路2：构建逆邻接表，实现深度优先遍历。思路其实也很简单，其实就是检测这个有向图中有没有环，只要存在环，课程就不能完成。

# 注意：这个深度优先遍历得通过逆邻接表实现，当访问一个结点的时候，应该递归访问它的前驱结点，直至前驱结点没有前驱结点为止。

# Python 代码：

class Solution(object):

    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return [i for i in range(numCourses)]

        # 逆邻接表
        inverse_adj = [set() for _ in range(numCourses)]
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 -> 0，这里要注意：不要弄反了
        for second, first in prerequisites:
            inverse_adj[second].add(first)

        visited = [0 for _ in range(numCourses)]
        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列

        res = []
        for i in range(numCourses):
            if self.__dfs(i,inverse_adj, visited, res,1):
                return []
        return res

    def __dfs(self, vertex, inverse_adj, visited, res,depth):
        """
        注意：这个递归方法的返回值是返回是否有环
        :param vertex: 结点的索引
        :param inverse_adj: 逆邻接表，记录的是当前结点的前驱结点的集合
        :param visited: 记录了结点是否被访问过，2 表示当前正在 DFS 这个结点
        :return: 是否有环
        """
        # 2 表示这个结点正在访问
        if visited[vertex] == 2:
            # DFS 的时候如果遇到一样的结点，就表示图中有环，课程任务便不能完成
            return True
        if visited[vertex] == 1:
            return False
        # 表示正在访问这个结点
        visited[vertex] = 2
        # 递归访问前驱结点
        for precursor in inverse_adj[vertex]:
            # 如果没有环，就返回 False，
            # 执行以后，逆拓扑序列就存在 res 中
            print(vertex,"的precursor:",precursor,"depth:",depth)
            if self.__dfs(precursor, inverse_adj, visited, res,depth+1):
                
                return True

        # 能走到这里，说明所有的前驱结点都访问完了，所以可以输出了
        # 并且将这个结点状态置为 1
        visited[vertex] = 1
        print("第4步vertex:",vertex,"visited:", visited," depth:",depth)
        # 先把 vertex 这个结点的所有前驱结点都输出之后，再输出自己
        res.append(vertex)
        print("visited置为1后,res才能append:",res,"depth:",depth)
        # 最后不要忘记返回 False 表示无环
        return False
```

```py
# 思路1：拓扑排序。构建的邻接表就是我们通常认识的邻接表，每一个结点存放的是后继结点的集合。

# 该方法的每一步总是输出当前无前趋（即入度为零）的顶点。

# 为避免每次选入度为 0 的顶点时扫描整个存储空间，可设置一个队列暂存所有入度为 0 的顶点。

# 具体做法如下：

# 1、在开始排序前，扫描对应的存储空间，将入度为 0 的顶点均入队列。

# 2、只要队列非空，就从队首取出入度为 0 的顶点，将这个顶点输出到结果集中，并且将这个顶点的所有邻接点的入度减 1，

# 在减 1 以后，发现这个邻接点的入度为 0 ，就继续入队。

# 最后检查结果集中的顶点个数是否和课程数相同即可。

# Python 代码：

class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return [i for i in range(numCourses)]
        # 入度数组，一开始全部为 0
        in_degrees = [0 for _ in range(numCourses)]
        # 邻接表
        adj = [set() for _ in range(numCourses)]
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 -> 0，这里要注意：不要弄反了
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)

        while queue:
            top = queue.pop(0)
            res.append(top)

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)
        if len(res) != numCourses:
            return []
        return res

# bfs 借助队列实现拓扑排序
from collections import deque
class Solution:
    def findOrder(self, numCourses, prerequisites):
        # 建图，以邻接表存储
        def buildGraph(numCourses, prerequisites):
            graph = []  # 邻接表
            indeg = [0] * numCourses  # 入度表

            for i in range(numCourses):  # 直接[[]]*numCourses建表有问题
                graph.append([])
            for side in prerequisites:
                a, b = side[1], side[0]  # 依赖关系b依赖a，就是a->b
                graph[a].append(b)
                indeg[b] += 1

            return graph, indeg

        graph, indeg = buildGraph(numCourses, prerequisites)
        res = []
        # print(graph)
        # print(indeg)
        
        # 将所有入度为 0 的节点放入队列中
        queue = deque()
        for i in range(numCourses):
            if indeg[i] == 0:
                queue.append(i)

        while queue:
            # 队首节点出队，放入答案中
            node = queue.popleft()
            res.append(node)
            # 将该节点相邻节点入度-1
            for neighbor in graph[node]:
                indeg[neighbor] -= 1
                # 相邻节点入度为 0 则入队
                if indeg[neighbor] == 0:
                    queue.append(neighbor)

        if len(res) != numCourses:  # 如果拓扑排序没排完，则说明有环，返回空
            return []
        return res

class Solution:
    def findOrder(self, numCourses, prerequisites):
        # 存储有向图
        edges = collections.defaultdict(list)
        # 存储每个节点的入度
        indeg = [0] * numCourses
        # 存储答案
        result = list()

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        # 将所有入度为 0 的节点放入队列中
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])

        while q:
            # 从队首取出一个节点
            u = q.popleft()
            # 放入答案中
            result.append(u)
            for v in edges[u]:
                indeg[v] -= 1
                # 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
                if indeg[v] == 0:
                    q.append(v)

        if len(result) != numCourses:
            result = list()
        return result

# 写了个python 3 ，广度优先的，加了每一句的注释，仅供参考

class Solution:
    def findOrder(self, numCourses, prerequisites):
        p = prerequisites
        # 所有课程没有先后顺序，这里我读题一开始没理解
        if p == []:
            return [i for i in range(numCourses)]

        from collections import defaultdict, deque
        go = defaultdict(list)
        # come=defaultdict(list) 逆向邻接表，本例不需要
        # 记录每个节点的入度
        rudu = defaultdict(int)
        # 记录所有prerequisites 出现的课程
        total = set()
        # 这个集合中存着所有需要前导课的课程号
        you = set()

        for i in p:

            a, base = i
            # 由基础课base 能够到达的a
            go[base].append(a)
            # come[a].append(base)  本例不需要
            # 进入并去重
            total.add(a)
            total.add(base)

            rudu[a] += 1
            # 只要有入度就是有前导课
            you.add(a)

        # 所有必须学习的课
        first = set([j for j in range(numCourses)])
        # 找到那些与其他课程无关的课，先学习了。ff 是集合
        ff = first - total
        ans = [g for g in ff]

        # 构建了邻接表，入度字典，下面开始拓扑排序
        #====================================
        # 找到入度为0 的课程，他们是其他课程的前导课，c 是一个集合
        c = total - you
        # 前导课加入deque
        q = deque(c)
        while q:

            # 入度为0，拿出来
            x = q.popleft()
            ans.append(x)
            # 遍历所有以x 为前导课的课
            xlist = go[x]
            for j in xlist:

                # 入度减去一
                rudu[j] -= 1
                # 发现入度==0 ，进入队列
                if rudu[j] == 0:
                    q.append(j)

        return ans if len(ans) == numCourses else []
       
class Solution:
    def findOrder(self, numCourses, prerequisites):
        ##创建入度的列表，索引对应节点编号，若索引不能对应节点编号，需要创建字典
        indegree = [0]*numCourses
        for i in range(len(prerequisites)):
            indegree[prerequisites[i][0]] += 1
        queue = [] ##存放入度为0的节点
        for i in range(numCourses):
            if indegree[i] == 0:
                queue.append(i)
        ret = [] ##按顺序存放节点
        while len(queue) != 0:
            cur = queue.pop(0) ##出队入度为0的节点
            ret.append(cur)
            for edge in prerequisites:
                if edge[1] == cur:
                    indegree[edge[0]] -= 1 ##更新节点的入度
                    if indegree[edge[0]] == 0:
                        queue.append(edge[0]) ##将入度为0的节点入队
        return ret if len(ret) == numCourses else [] #若结果列表个数不等于课程数，表示存在环
```

```py
# 拓扑排序khan算法的py/go/rs三语言实现

class Solution:
    def findOrder(self, numCourses, prerequisites):
        t = [0] * numCourses
        d = [[] for _ in range(numCourses)]
        for i, j in prerequisites:
            t[i] += 1
            d[j].append(i)
        ans = [i for i, j in enumerate(t) if not j]
        for i in ans:
            for j in d[i]:
                t[j] -= 1
                not t[j] and ans.append(j)
        return len(ans) == numCourses and ans or []
```

```scala
package com.zhourui.leetcode

import scala.collection.mutable.ArrayBuffer
// 与lc207类似，不过要给出顺序

class lc210_courseschedule2 {
  object Solution {
    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      val ans = ArrayBuffer[Int]()
      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        ans += cur
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum match {
        case canFinshNum if canFinshNum == numCourses => ans.toArray
        case _ => Array()
      }
    }
  }
}

```

###  1.89. <a name='AddandSearchWord'></a>211 Add and Search Word

[小明](https://www.bilibili.com/video/BV1x5411a77S?spm_id_from=333.999.0.0)

###  1.90. <a name='WordSearchII'></a>212. Word Search II

[花花酱](https://www.bilibili.com/video/BV184411d7i9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1G7NQ?spm_id_from=333.999.0.0)

```py
from collections import defaultdict


class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""

    def insert(self, word):
        cur = self
        for c in word:
            cur = cur.children[c]
        cur.is_word = True
        cur.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)

        def dfs(now, i1, j1):
            if board[i1][j1] not in now.children:
                return

            ch = board[i1][j1]

            now = now.children[ch]
            if now.word != "":
                ans.add(now.word)

            board[i1][j1] = "#"
            for i2, j2 in [(i1 + 1, j1), (i1 - 1, j1), (i1, j1 + 1), (i1, j1 - 1)]:
                if 0 <= i2 < m and 0 <= j2 < n:
                    dfs(now, i2, j2)
            board[i1][j1] = ch

        ans = set()
        m, n = len(board), len(board[0])

        for i in range(m):
            for j in range(n):
                dfs(trie, i, j)

        return list(ans)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/word-search-ii/solution/dan-ci-sou-suo-ii-by-leetcode-solution-7494/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

from collections import defaultdict


class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""

    def insert(self, word):
        cur = self
        for c in word:
            cur = cur.children[c]
        cur.is_word = True
        cur.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)
		
        def dfs(now, i1, j1):
            if board[i1][j1] not in now.children:
                return

            ch = board[i1][j1]

            nxt = now.children[ch]
            if nxt.word != "":
                ans.append(nxt.word)
                nxt.word = ""

            if nxt.children:
                board[i1][j1] = "#"
                for i2, j2 in [(i1 + 1, j1), (i1 - 1, j1), (i1, j1 + 1), (i1, j1 - 1)]:
                    if 0 <= i2 < m and 0 <= j2 < n:
                        dfs(nxt, i2, j2)
                board[i1][j1] = ch

            if not nxt.children:
                now.children.pop(ch)

        ans = []
        m, n = len(board), len(board[0])

        for i in range(m):
            for j in range(n):
                dfs(trie, i, j)

        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/word-search-ii/solution/dan-ci-sou-suo-ii-by-leetcode-solution-7494/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py

如果把方向换成[[0,1], [1,0], [0,-1], [-1,0]]过不了：

[["a","b","e"],["b","c","d"]]
["abcdeb"]
先检索abc（b用[0,1]）会记录这个结果不符合，再检索abc（b用[1,0]）会直接判断不行, lru_cache没法处理visited的差异


class Solution:
    def findWords(self, board: [[str]], words: [str]) -> [str]:
        m, n = len(board), len(board[0])
        res = set()
        @lru_cache(None)
        def dfs(x, y, ans, mark=set()):
            mark.add((x, y))
          
            if ans in words:
                res.add(ans)
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                if 0 <= x + dx < m and 0 <= y + dy < n and (x + dx, y + dy) not in mark:
                    dfs(x + dx, y + dy, ans + board[x + dx][y + dy])
            mark.remove((x, y))
        for i in range(m):
            for j in range(n):
                dfs(i, j, board[i][j])
        return list(res)
```

```scala

/**
* chosen solution
* tries + dfs + pruning
* memo
*   1. put all words into tries which is implemented by hashmap
*   2. DFS way searching all char in board composing a word and searching whether the word exists in tries
*   3. in dfs, we directly input the node from tries instead of tries itself 
*   4. pruning an edge after matching a word and its children couldn't represent a word
*/
import scala.collection.mutable
case class Node(next: mutable.Map[Char, Node] = mutable.Map.empty, var isWord: Boolean = false){
  def apply(char: Char): Option[Node] = next.get(char)
  def update(char: Char, node: Node): Unit = next(char) = node
}

class Tries(){
  val root = Node()
  def insert(word: String): Unit = {
    var node = root
    word.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined
  def search(word: String): Boolean =  searchUtil(word).exists(_.isWord)

  def searchUtil(s: String): Option[Node] = {
    var node = root
    s.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }
}


object Solution0 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
* tries + dfs + pruning
* memo
*   1. a seenBoard to record which position was visited 
* time complexity: 
* 
*/

object Solution1-1 {
  val result = scala.collection.mutable.Set[String]()

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for{
      row <- board.indices
      col <- board(0).indices
    }{
      _dfs(board, Array.ofDim[Boolean](board.length, board(0).length), tries, "", (row, col))
    }

    result.toList
  }

  private def _dfs(board: Array[Array[Char]], seenBoard:Array[Array[Boolean]], tries: Trie, currentPrefix: String, currentIdx: (Int, Int)) {
    val (row, col) = currentIdx
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    if(tries.startsWith(newPrefix)){
      seenBoard(row)(col) = true
      getNextPosition(currentIdx, seenBoard).foreach{idx =>
        _dfs(board, seenBoard.map(_.clone()), tries, newPrefix, idx)
      }
    }
  }

  private def getNextPosition(currentIdx: (Int, Int), seenBoard: Array[Array[Boolean]]): Array[(Int, Int)] = {

    def check(row: Int, col: Int): Boolean = {
      if(row >= seenBoard.length || row < 0 || col >= seenBoard(0).length || col < 0 || seenBoard(row)(col))  false
      else true
    }
    val (row, col) = currentIdx
    val result = scala.collection.mutable.ArrayBuffer[(Int, Int)]()

    for{
      i <- -1 to 1
      j <- -1 to 1
    }{
      if((math.abs(i) + math.abs(j) == 1) && check(row + i, col + j)) result.append((row + i, col + j))
    }
    result.toArray
  }
}

/**
* simplify : without seen matrix
*/

object Solution1-2 {

  val result = scala.collection.mutable.Set[String]()
  private val inBounds = (shape: (Int, Int)) => (coord: (Int, Int)) => coord._1 < shape._1 && coord._1 >= 0 && coord._2 < shape._2 && coord._2 >= 0
  private val getNeighbors = (coord: (Int, Int), filter: ((Int, Int)) => Boolean) => {
    List(
      (coord._1 + 1, coord._2),
      (coord._1, coord._2 + 1),
      (coord._1 - 1, coord._2),
      (coord._1, coord._2 - 1)
    ).filter(filter)
  }

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for {
      row <- board.indices
      col <- board(0).indices
    } {
      _dfs(board, tries, "", (row, col))
    }
    result.toList
  }

  private def _dfs(board: Array[Array[Char]], tries: Trie, currentPrefix: String, coord: (Int, Int)) {

    val (row, col) = coord
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    val c = board(row)(col)
    board(row)(col) = '#'
    if (tries.startsWith(newPrefix)) {

      getNeighbors(coord, inBounds((board.length, board.head.length))(_))
        .foreach {
          case (nr, nc) if board(nr)(nc) != '#' =>
            _dfs(board, tries, newPrefix, (nr, nc))
          case _ =>
        }
    }
    board(row)(col) = c
  }
}


object Solution1-3 {
  private val visitedLabel = '#'
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Trie()
    words.foreach(tries.insert)
    dfs(tries, board)
  }


  def dfs(tries: Trie, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int) ,prePrefix: String, board: Array[Array[Char]], ret: scala.collection.mutable.HashSet[String]): Unit = {
      val currentChar =  board(coord._1)(coord._2)
      val newPrefix = prePrefix + currentChar
      if(tries.search(newPrefix)) ret += newPrefix
      /* pruning */
      if(tries.startsWith(newPrefix)){
        board(coord._1)(coord._2) = visitedLabel
        getAvailableCoords(coord, (board.length, board(0).length)).foreach {
          case (r, c) if board(r)(c) != visitedLabel => _dfs((r, c), newPrefix, board, ret)
          case _ =>
        }
        board(coord._1)(coord._2) = currentChar
      }
    }

    val coords = for(i <- board.indices; j <- board(0).indices) yield (i, j)
    val ret = scala.collection.mutable.HashSet[String]()
    coords.foreach(coord => _dfs(coord, "", board, ret))
    ret.toList

  }

  private val getAvailableCoords = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row, col + 1),
      (row - 1, col),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 &&  0 <= c && c < shape._2}
  }
}


/** helper class **/
case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {
  def apply(c: Char): Node = this.apply(c.asDigit - 'a'.asDigit)
  def apply(idx: Int): Node =  childNode(idx)
  def update(idx: Int, node: Node): Unit = childNode(idx) = node
  def update(c: Char, node: Node): Unit = this.update(c.asDigit - 'a'.asDigit, node)
}


class Trie() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach {
      case c if node(c) == null =>
        node(c) = Node()
        node = node(c)

      case c => node = node(c)
    }
    node.isWord = true

  }
  def insert(words: Array[String]): Unit = {
    words.foreach(insert)
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }


  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach {
      case c if node(c) != null => node = node(c)
      case _ => return None
    }
    Some(node)
  }
  def traversal(): Unit = {
    val result = scala.collection.mutable.ListBuffer[String]()

    def _traversal(prefix: String, node: Node): Unit = {
      if(node.isWord) {
        result += prefix
      }
      node.childNode.zipWithIndex.foreach{
        case (n, idx) if n != null => _traversal(prefix + ('a' + idx).toChar, n)
        case _ =>
      }

    }
    _traversal("", root)
    result.foreach(s => println(s.mkString("")))

  }
}


/**
* implement prefix tries by hashmap
* memo
*   1. in dfs, we directly input the node from tries instead of tries itself 
*   2. pruning an edge after matching a word and its children couldn't represent a word
*   3. this solution is faster than solution1
*/

import scala.collection.mutable
case class Node(next: mutable.Map[Char, Node] = mutable.Map.empty, var isWord: Boolean = false){
  def apply(char: Char): Option[Node] = next.get(char)
  def update(char: Char, node: Node): Unit = next(char) = node
}

class Tries(){
  val root = Node()
  def insert(word: String): Unit = {
    var node = root
    word.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined
  def search(word: String): Boolean =  searchUtil(word).exists(_.isWord)

  def searchUtil(s: String): Option[Node] = {
    var node = root
    s.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }
}


object Solution2 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


```

###  1.91. <a name='HouseRobberII213-II'></a>213. House Robber II 213-打家劫舍II

[18:13 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ea4y147oh?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1GD4y1d7DS?spm_id_from=333.999.0.0)

```py
# 核心原则就是：第一个和最后一个不能同时抢。 
# 所以：要么不抢第一个，要么不抢最后一个。 
# 注意，不抢第一个的时候，最后一个可抢可不抢；
# 另一种情况同理 取两种情况中的最大值

class Solution(object):
    def rob(self, nums):
        n = len(nums)
        if n == 0:
          return 0
        if n <= 2:
          return max(nums)
        # 不抢第一个
        dp1 = [0] * n
        dp1[0] = 0
        dp1[1] = nums[1]
        for i in range(2, n):
          dp1[i] = max(dp1[i-1],nums[i] + dp1[i-2])

        # 不抢最后一个
        dp2 = [0] * n
        dp2[0] = nums[0]
        dp2[1] = max(nums[0],nums[1])
        for i in range(2, n-1):
          dp2[i] = max(dp2[i-1],nums[i] + dp2[i-2])
        return max(dp1[n-1],dp2[n-2])

class Solution(object):
    def rob(self, nums):
        n = len(nums)
        if n == 0:
          return 0
        if n <= 2:
          return max(nums)
        # 不抢第一个
        dp1 = [0] * n
        dp1[0] = 0
        dp1[1] = nums[1]
        for i in range(2, n):
          dp1[i] = max(dp1[i-1],nums[i] + dp1[i-2])

        # 不抢最后一个
        dp2 = [0] * n
        dp2[0] = nums[0]
        dp2[1] = max(nums[0],nums[1])
        for i in range(2, n-1):
          dp2[i] = max(dp2[i-1],nums[i] + dp2[i-2])
        return max(dp1[n-1],dp2[n-2])

class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if n == 0 : return 0
        if n == 1 : return nums[0]
        if n == 2 : return max(nums[0],nums[1])
        
        dp = [[0 for i in range(n)] for j in range(n)]

        for i in range(n):
            for j in range(i,n):
                if j == i:
                    dp[i][j] = nums[j]
                elif j == i + 1:
                    dp[i][j] = max(nums[i],nums[i+1])
                else:
                    dp[i][j] = max(dp[i][j-2] + nums[j], dp[i][j-1])

        # print dp 
        # rob without n-1, or rob with  n-1
        val = max(dp[0][n-2], dp[1][n-3] + nums[n-1])

        return val
```

```py
class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def Rob(nums,start,end):
            #前1个，前2个
            dp_1=0
            dp_2=0
            for i in range(start,end+1):
                dp_i = max(dp_1,dp_2+nums[i])
                dp_2 = dp_1
                dp_1 = dp_i
            return dp_i

        n = len(nums)
        if n == 1:
            return nums[0]
        return max(Rob(nums,0,n-2),Rob(nums,1,n-1))


class Solution:
    def rob(self, nums):
        def robRange(start: int, end: int) -> int:
            first = nums[start]
            second = max(nums[start], nums[start + 1])
            for i in range(start + 2, end + 1):
                first, second = second, max(first + nums[i], second)
            return second
        
        length = len(nums)
        if length == 1:
            return nums[0]
        elif length == 2:
            return max(nums[0], nums[1])
        else:
            return max(robRange(0, length - 2), robRange(1, length - 1))
```

###  1.92. <a name='CombinationSumIII216-III'></a>216. Combination Sum III 216-组合总和 III

[花花酱](https://www.bilibili.com/video/BV14b411u7q8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1SC4y1a7Vy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gz4y1Z7CV?spm_id_from=333.999.0.0)

```py
# 枚举剪枝，dfs()!

class Solution(object):
    def combinationSum3(self, k, n):

        def dfs(startIndex, sum, path):
            if sum==0 and len(path)==k: listList.append(path)
            if sum<=0: return
            
            for j in range(startIndex, 10):
                dfs(j, sum-j, path+[j])
        
        listList = []
        dfs(1, n, [])
        return listList

# 简单回溯

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        listList = []

        def dfs(startIndex, sum, path):
            if sum < 0:
                return

            if len(path) == k and sum == 0:
                listList.append(path[:])
                return

            for i in range(startIndex, 10):
                path.append(i)
                dfs(i+1, sum - i, path)
                path.pop()
                    
        dfs(1, n, [])

        return listList

class Solution(object):
    def combinationSum3(self, k, n):
        """
        :type k
        :type n
        :rtype: List[List[int]]
        """
        if not k or not n:
            return []
        
        res = []         
        def dfs(k, n, tmp, start):
            if n == 0 and k == 0:
                res.append(tmp[:])
                return
            if k <= 0 or n <= 0:
                return
            
            for i in range(start, 10):
                tmp.append(i)
                dfs(k - 1, n - i, tmp, i + 1)
                tmp.pop()
                    
        dfs(k, n, [], 1)       
        return res

from typing import List
class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        self.res = []
        cur = []
        def dfs(begin, k, n, cur):
            if k == 0 and n == 0:
                self.res.append(cur[:])
                return 
            elif n <= 0 or k == 0:
                return 
            for i in range(begin, 10):
                cur.append(i)
                dfs(i+1, k-1, n-i, cur)
                cur.pop()
        dfs(1, k, n, cur)
        return self.res

# 闭包用的挺好，如果内层函数不止一处用到的话，不建议写成内层函数，我是这么认为的。
# 感觉大佬们写的代码都好长啊。

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        def trackback(one2nine:int,sum:int):
            nonlocal path
            if k==len(path):
                if sum==0:
                    listList.append(path[:])
                return
            
            if one2nine<10 and sum>0:
                #添加当前元素到组合序列
                path.append(one2nine)
                trackback(one2nine+1,sum-one2nine)
                path.pop()
                trackback(one2nine+1,sum)
        path,listList=list(),list()
        trackback(1,n)
        return listList
# 回溯的king

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        listList = []
        def backtrack(path, startIndex):
            if len(path) == k and sum(path) == n:
                listList.append(path)
                return
            for j in range(startIndex, 10):
                backtrack(path=path+[j], startIndex=j+1)
        backtrack([], 1)
        return listList

# 补一个python解法，击败98%，主要表现为剪枝

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        if n < 6: return []
        res = []
        def backtrack(num, path, k, n):
            if k == 0 and n == 0:
                res.append(path[:])
            if n < 0 or k < 0:
                return 
            for cn in range(num, 10):
                if cn > n:
                    break
                path.append(cn)
                backtrack(cn+1, path, k-1, n-cn)
                path.pop()
            return 

        backtrack(1, [], k, n)
        return res

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []  #存放结果集
        path = []  #符合条件的结果
        def findallPath(n,k,sum,startIndex):
            if sum > n: return  #剪枝操作
            if sum == n and len(path) == k:  #如果path.size() == k 但sum != n 直接返回
                return res.append(path[:])
            for i in range(startIndex,9-(k-len(path))+2):  #剪枝操作
                path.append(i)
                sum += i 
                findallPath(n,k,sum,i+1)  #注意i+1调整startIndex
                sum -= i  #回溯
                path.pop()  #回溯
        
        findallPath(n,k,0,1)
        return res

# 接近双百的逆向思维，先一次性总结512种所有的情况，之后筛选k和n符合的情况就行了，对于情况有限的直接枚举肯定最快

class Solution(object):
    def combinationSum3(self, k, n):
        def zuhe(n):
            if n==1:
                return [[1],[]]
            else:
                temp=zuhe(n-1)
                return [x+[n] for x in temp]+temp
        temp=zuhe(9)
        c=[]
        for x in temp:
            if len(x)==k and sum(x)==n:
                c+=[x]
        return c
```

###  1.93. <a name='ContainsDuplicate'></a>217. Contains Duplicate

[小梦想家](https://www.bilibili.com/video/BV1ab411H7Zw?spm_id_from=333.999.0.0)

```py
简单题。。。我觉得我又行了

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(nums) != len(set(nums))

人生苦短，我用Python

class Solution:
    def containsDuplicate(self, nums):
        return len(nums) - len(set(nums)) > 0

我竟然自己想出来了这种反人类的玩意儿 python：

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) < len(nums)
谁还不会一行呢

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return not (len(nums)==len(set(nums)))
```


```py
用哈希表存放元素，遍历nums

（1）如果数字不在哈希表中，说明该数字第一次出现，哈希表加入该数字

（2）如果数字存在哈希表中，说明该数字第二次出现，直接返回False

如果遍历完了，说明所有数字都只出现一次，那么返回True

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        numSet = set()
        for i in nums:
            if i in numSet:
                return True
            else:
                numSet.add(i)
        return False
```

```scala
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        var hashSet = scala.collection.mutable.HashSet.empty[Int]
        import scala.util.control.Breaks._
        var flag = false
        breakable{
            for(num <- nums){
                if(hashSet.contains(num)){
                        flag = true
                        break
                    }else{
                    hashSet.add(num)
                }
                }
            }
        flag
        }
    }
    
  
//Alternate (SCALA) solution
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        return nums.distinctBy(_.self).length != nums.length
    }
}

```

###  1.94. <a name='TheSkylineProblem'></a>218. The Skyline Problem

[花花酱](https://www.bilibili.com/video/BV1hb411c7Q4?spm_id_from=333.999.0.0)

###  1.95. <a name='ContainsDuplicateII'></a>219. Contains Duplicate II

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ga?spm_id_from=333.999.0.0)

###  1.96. <a name='ContainsDuplicateIII'></a>220 Contains Duplicate III

[小明](https://www.bilibili.com/video/BV19h41197iw?spm_id_from=333.999.0.0)

###  1.97. <a name='-1'></a>221-最大正方形

[哈哈哈](https://www.bilibili.com/video/BV1XT4y137Gq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16K411575r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1mA411q7Sw?spm_id_from=333.999.0.0)

```py
# 暴力卷积法

import numpy as np
from scipy.signal import convolve2d
class Solution:
    def maximalSquare(self, matrix):
        if not matrix: return 0
        matrix=np.array(matrix,int)
        for i in range(1,min(matrix.shape)+1):
            if convolve2d(matrix,np.ones((i,i),int),'valid').max()<i**2:
                return (i-1)**2
        return i**2
```

```py
class Solution:
    def maximalSquare(self, matrix):
        m,n=len(matrix),len(matrix[0])
        dp=[[0]*(n+1) for _ in range(m+1)]
        ret=0
        for i in range(1,m+1):
            for j in range(1,n+1):
                if matrix[i-1][j-1]=="1":
                    dp[i][j]=1+min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])
                    ret=max(ret,dp[i][j])
        return ret**2

# 回想了一下上次的思考，对于这个矩阵中需要构成square(len>1)，

# 右下角的坐标为(x, y) ，那么(x - 1, y - 1)一定需要是一个square，

# 并且该点的左边全为1，上边也为1，按照这个进行理解变长的增加。

class Solution:
    def maximalSquare(self, matrix):
        m, n = len(matrix), len(matrix[0])
        # initialze a (m, n) array
        dp = [[0] * n for _ in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1
                    res = max(dp[i][j], res)
        return res * res

# 用原数组存算出来的值，空间复杂度是不是就降到O(1)了

class Solution:
    def maximalSquare(self, matrix):
        maxEdge = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                if i and j:
                    if matrix[i][j]=="1":
                        matrix[i][j]=min(int(matrix[i-1][j-1]),int(matrix[i][j-1]),int(matrix[i-1][j]))+1
                    else:
                        matrix[i][j]=0
                maxEdge = max(maxEdge,int(matrix[i][j]))
        return maxEdge**2       
# 浑元形意太极门的人过来，集合了

class Solution:
    def maximalSquare(self, matrix):
        dp = [[0]*(len(matrix[0])+1) for _ in range(len(matrix)+1)]
        res = 0
        for i in range(1,len(matrix)+1):
            for j in range(1,len(matrix[0])+1):
                if matrix[i-1][j-1] == '1':
                    dp[i][j] = 1 + min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])
                    res = max(res,dp[i][j])
        return res ** 2

class Solution:
    def maximalSquare(self, matrix):
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return 0
        
        maxSide = 0
        rows, columns = len(matrix), len(matrix[0])
        dp = [[0] * columns for _ in range(rows)]
        for i in range(rows):
            for j in range(columns):
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    maxSide = max(maxSide, dp[i][j])
        
        maxSquare = maxSide * maxSide
        return maxSquare
```

###  1.98. <a name='CountCompleteTreeNodes'></a>222. Count Complete Tree Nodes

[花花酱](https://www.bilibili.com/video/BV1n44y1E73D?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qz411i7bh?spm_id_from=333.999.0.0)

```py
# 完全二叉树的性质{根节点的左右子树至少有一个是满二叉树}， 
# 首先从根节点开始计算左右子树的高度，如果相等则为满二叉树，直接返回 
# 否则递归计算左右子树 
# Note：乍一看时间复杂度为O(N*logN)，
# 但是根据完全二叉树的性质,其子树中至少有一个满二叉树，
# 所以只会有一个递归会正真的执行下去 
# 查找深度的时间复杂度为logN,递归的深度为O(logN)，
# 所以总的时间复杂度为O(logN * logN)

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        left = right = 0
        tmp1 = tmp2 =  root

        # 求出树的深度
        while tmp1:
            left += 1
            tmp1 = tmp1.left
        while tmp2:
            right += 1
            tmp2 = tmp2.right

        # 利用树的深度
        if left == right:
            return 2 ** left - 1
        else:
            return 1 + self.countNodes(root.left) + self.countNodes(root.right)  #根据完全二叉树的性质，这两地递归真正执行的只有一个
# 超时，跟一般的树一样，递归的来数nodes数
class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
        	return 0
        if root.left == None and root.right == None:
        	return 1
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
# 相对来说，递归法利用公式更容易理解：
# 既然说了是 complete binary tree，那么必然有特性可用，
# complete binary tree的特性是除了最后一层，之前的就是perfect tree.


# 所以寻找左子树的最左边的高度和右子树的最右边的node高度，
# 如果相同就是perfect tree，高度2^h - 1， 否则递归的来看左子树和右子树

class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
        	return 0
        
        p, q = root,root

        leftHeight = 0
        rightHeight = 0

        while p:
        	p = p.left
        	leftHeight += 1

        while q:
        	q = q.right
        	rightHeight += 1

        if leftHeight == rightHeight:
        	return (int)(math.pow(2,leftHeight) - 1)
        else:
        	return 1 + self.countNodes(root.left) + self.countNodes(root.right)

class Solution(object):
    def countNodes(self, root):
        if not root:
            return 0
        lh, rh = self.__getHeight(root.left), self.__getHeight(root.right)
        if lh == rh:  # 左右子树高度相同，说明左子树必满 则节点数=左子树节点 + root节点(=1) + 递归找右子树
            return (pow(2, lh) - 1) + 1 + self.countNodes(root.right)
        else:  # 左子树比右子树高，说明右子树必满 同理
            return (pow(2, rh) - 1) + 1 + self.countNodes(root.left)

    def __getHeight(self, root):
        ret = 0
        while root:
            ret += 1
            root = root.left
        return ret

# 非递归解法
import math
class Solution(object):
    # 本题核心就在于ret = 前h-1层的节点数(用公式求) + 最后一层节点数
    # 而最后一层的节点数 = 左侧节点数(依然用公式求) + 右侧节点数(就=1)
    def countNodes(self, root):
        if not root:
            return 0
        h = self.depth(root)
        cur, ret = root, 0
        while cur:
            # 左右子树高度相同，说明左子树肯定满，右子树可能满也可能不满
            if self.depth(cur.left) == self.depth(cur.right):
                # 这个是针对最后一个节点,画图就明白了
                if self.depth(cur.left) == 0:
                    ret += 1
                    break
                # 此时左子树肯定是满树，那么加上左子树(最后一层)的所有节点
                ret += int(math.pow(2, self.depth(cur.left) - 1))
                cur = cur.right
            else:
                cur = cur.left
        # 退出while说明最后一层的节点已经统计完，现在再根据公式加上前面h-1层的节点数
        ret += int(math.pow(2, h - 1)) - 1
        return ret

    def depth(self, root):
        level = 0
        while root:
            level += 1
            root = root.left
        return level

# 我随便写了写，还准备修改，没想到一提交啪就通过了，很快啊！

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        depth=0
        def get_depth(root):
            nonlocal depth
            depth+=1
            if root.left:
                get_depth(root.left)
            else:
                return
        get_depth(root)
        ans=2**(depth-1)-1
        def dfs(root,temp):
            nonlocal ans
            temp.append(root)
            if root.left:
                dfs(root.left,temp)
            if root.right:
                dfs(root.right,temp)
            if not root.left and not root.right:
                if len(temp)==depth:
                    ans+=1
            temp.pop()
        dfs(root,[])
        return ans
```

###  1.99. <a name='RectangleArea'></a>223. Rectangle Area

[小梦想家](https://www.bilibili.com/video/BV1Ck4y1z7Hp?spm_id_from=333.999.0.0)

```py
class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        def overlap_length(a1, a2, b1, b2) -> int:
            return max(min(a2, b2) - max(a1, b1), 0)

        overlap_area = overlap_length(ax1, ax2, bx1, bx2) * overlap_length(ay1, ay2, by1, by2)

        area_a = (ax2 - ax1) * (ay2 - ay1)

        area_b = (bx2 - bx1) * (by2 - by1)

        return area_a + area_b - overlap_area
```

```py
class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        
        xx1 = max(ax1,bx1)
        yy1 = min(ay2,by2)
        xx2 = min(ax2,bx2)
        yy2 = max(ay1,by1)
        
        w = max(0,xx2- xx1)
        h = max(0,yy1 - yy2)

        area1 = (ax2- ax1) * (ay2- ay1)
        area2 = (bx2- bx1) * (by2- by1)
        return area1 + area2 -w * h

class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        area1 = (ax2 - ax1) * (ay2 - ay1)
        area2 = (bx2 - bx1) * (by2 - by1)
        overlapWidth = min(ax2, bx2) - max(ax1, bx1)
        overlapHeight = min(ay2, by2) - max(ay1, by1)
        overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0)
        return area1 + area2 - overlapArea
```

### 224

https://www.bilibili.com/video/BV1Nb4y1z7hG?from=search&seid=1882841343164929357&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.71qtf391s5w0.png" width="40%">

```py
# 就挺简单~？

class Solution:
    def calculate(self, s: str) -> int:
        st = []
        i = n = 0
        x = 1
        s= '('+ s +')'
        while i < len(s):
            if '0'<= s[i] <='9':
                cur = int(s[i])
                while '0'<= s[i+1] <='9':
                    i += 1
                    cur = cur * 10 + int(s[i])
                n += x * cur
            elif s[i] == '(':
                st.append([n, x])
                n, x = 0, 1
            elif s[i] == '+' or s[i] == '-':
                x = 1 if s[i] == '+' else -1
            elif s[i] == ')':
                pre = st.pop()
                n = pre[0] + pre[1] * n
            i += 1
            # print(x ,n, st)
        return n

class Solution:
    def calculate(self, s: str) -> int:
        stack = [1]
        sign = 1
        i = 0
        res = 0
        while i < len(s):
            if s[i].isdigit():
                n = 0
                while i<len(s) and s[i].isdigit():
                    n = 10*n + int(s[i])
                    i += 1
                res += sign*n
            else:
                if s[i]=='+':   sign=stack[-1]
                elif s[i]=='-': sign=-stack[-1]
                elif s[i]=='(': stack.append(sign)
                elif s[i]==')': stack.pop()
                i += 1
        return res
```

###  1.100. <a name='ImplementStackusingQueues'></a>225-Implement Stack using Queues

[哈哈哈](https://www.bilibili.com/video/BV1p741177pK?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ep4y1Y77j?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */


/**
* chosen solution
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack0() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}




 /**
 * my first commit
 * two queue version
 * time complexity: 
 *   push: O(1)
 *   pop: O(2n - 1)  n is the element in queue1
 *   top: O(2n - 1)
 */
class MyStack1() {

    /** Initialize your data structure here. */
    var queue1 = scala.collection.mutable.Queue[Int]()
    var queue2 = scala.collection.mutable.Queue[Int]()

    /** Push element x onto stack. */
    def push(x: Int) {
        queue1.enqueue(x)
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
       }
    
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        ret
        
    }

    /** Get the top element. */
    def top(): Int = {
        while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
        }
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        queue1.enqueue(ret)
        ret
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty && queue2.isEmpty
    }

}

/**
* two queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack2() {

   import scala.collection.mutable.Queue
    /** Initialize your data structure here. */
    var queue1 = Queue.empty[Int] 


    /** Push element x onto stack. */
    def push(x: Int) {
        val queue2 = Queue(x)
        queue2.enqueueAll(queue1.dequeueAll(_ => true))
        queue1 = queue2
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
        if(queue1.isEmpty) -1 else queue1.dequeue
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }
}

/**
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack3() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}

/**
* memo:
*   1. push entire old queue into a new queue without expanding all elements 
* time complexity:  
*     all operation are O(1) after being amortized
*   
* start  Queue()
* push1  Queue(1, Queue())
* push2  Queue(2, Queue(1, Queue()))
* push3  Queue(3, Queue(2, Queue(1, Queue())))
* push4  Queue(4, Queue(3, Queue(2, Queue(1, Queue()))))
* pop    Queue(3, Queue(2, Queue(1, Queue())))
* pop    Queue(2, Queue(1, Queue()))
*/

class MyStack4() {
  import scala.collection.mutable
  /** Initialize your data structure here. */
  var queue: mutable.Queue[Any] = mutable.Queue.empty[Any]

  /** Push element x onto stack. */
  def push(x: Int) {
    val queue2: mutable.Queue[Any] = mutable.Queue(x)
    queue2.enqueue(queue)
    queue = queue2

  }
  /** Removes the element on top of the stack and returns that element. */
  def pop(): Int = {

    if(queue.isEmpty) -1 else {
      val ret = queue.dequeue.asInstanceOf[Int]
      queue = queue.dequeue.asInstanceOf[mutable.Queue[Any]]
      ret
    }
  }
  /** Get the top element. */
  def top(): Int = {
    if(queue.isEmpty) -1 else queue.head.asInstanceOf[Int]
  }

  /** Returns whether the stack is empty. */
  def empty(): Boolean = {
    queue.size != 2
  }
}
```

###  1.101. <a name='-1'></a>226-翻转二叉树

[哈哈哈](https://www.bilibili.com/video/BV1Sh411R7B2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73E?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FK411p7Co?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.102. <a name='BasicCalculatorII'></a>227 Basic Calculator II

[小明](https://www.bilibili.com/video/BV1Qy4y167Ax?spm_id_from=333.999.0.0)

https://www.bilibili.com/video/BV1t4411c7m6?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

https://www.bilibili.com/video/BV1v54y1a74b?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

```py
class Solution:
    def calculate(self, s: str) -> int:
        n = len(s)
        stack = []
        preSign = '+'
        num = 0
        for i in range(n):
            if s[i] != ' ' and s[i].isdigit():
                num = num * 10 + ord(s[i]) - ord('0')
            if i == n - 1 or s[i] in '+-*/':
                if preSign == '+':
                    stack.append(num)
                elif preSign == '-':
                    stack.append(-num)
                elif preSign == '*':
                    stack.append(stack.pop() * num)
                else:
                    stack.append(int(stack.pop() / num))
                preSign = s[i]
                num = 0
        return sum(stack)

class Solution:
    def calculate(self, s: str) -> int:
        stack = []
        num, sign = 0, "+"
        for i, c in enumerate(s):
            if c.isdigit():
                num = 10*num + int(c)
            if c in "+-*/" or i==len(s)-1:
                if sign=="+":
                    stack.append(num)
                elif sign=="-":
                    stack.append(-num)
                elif sign=="*":
                    stack.append(stack.pop()*num)
                elif sign=="/":
                    stack.append(int(stack.pop()/float(num)))
                num, sign = 0, c
        return sum(stack)

# python里 -3/2==-2
# -3//2=-2，就是个坑
import operator
class Solution(object):
    def calculate(self, s):
        a = []
        opmp = {
            "+": lambda e: a.append(e),
            "-": lambda e: a.append(-e),
            "*": lambda e: a.append(e * a.pop()),
            "/": lambda e: a.append(int((a.pop()/e)))
            # "/": lambda e: a.append(int(operator.truediv(a.pop(), e)))
        }
        op = "+"
        num = 0
        for c in s+"+":
            if c.isdigit():
                num = num * 10 + int(c)
            elif c != " ":
                opmp[op](num)
                op = c
                num = 0
        return sum(a)
```

```py
# 本题不含括号和符号位，所以将 '/' 替换为 '//' 就可以直接调用 eval 了。
class Solution(object):
    def calculate(self, s):
        return eval(s.replace('/', '//'))
```

###  1.103. <a name='SummaryRanges'></a>228 Summary Ranges

[小明](https://www.bilibili.com/video/BV1Et4y1i7YZ?spm_id_from=333.999.0.0)

###  1.104. <a name='MajorityElementII'></a>229. Majority Element II 

[哈哈哈](https://www.bilibili.com/video/BV12z411B7rS?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nK411P7qR?spm_id_from=333.999.0.0)

```py
# 哈希统计
class Solution:
    def majorityElement(self, nums):
        cnt = {}
        ans = []

        for v in nums:
            if v in cnt:
                cnt[v] += 1
            else:
                cnt[v] = 1
        for item in cnt.keys():
            if cnt[item] > len(nums)//3:
                ans.append(item)

        return ans

# 去重优化

class Solution:
    def majorityElement(self, nums):
        
        # 思路:排序后遍历,进位而判断
        nums = sorted(nums)
        rim_num = int(len(nums)/3)
        # 构建去重排序列表
        numL = sorted({}.fromkeys(nums).keys())
        List = []
        nown=numL[0]
        
        # 遍历去重列表,复用sorted(nums)
        for num in numL:
            if num>nown:
                if nums.index(num)-nums.index(nown)>rim_num:
                    List.append(nown)
                nown = num
        
        # 判断最后一个整数
        if len(nums)-nums.index(numL[-1])>rim_num:
            List.append(numL[-1])
        return List

class Solution:
    def majorityElement(self, nums):
        cnt = defaultdict(int)
        ans = []
        for i in nums:
            cnt[i] += 1
            if cnt[i] > len(nums) // 3:
                ans.append(i)
        return list(set(ans))

class Solution:
    def majorityElement(self, nums):
        
        # 思路:排序后遍历,进位而判断
        nums = sorted(nums)
        rim_num = int(len(nums)/3)
        List = []
        nown=nums[0]

        # 遍历排序后列表
        for num in nums:
            if num>nown:
                if nums.index(num)-nums.index(nown)>rim_num:
                    List.append(nown)
                nown = num
        
        # 判断最后一个整数
        if len(nums)-nums.index(nums[-1])>rim_num:
            List.append(nums[-1])
        return List
```

###  1.105. <a name='KthSmallestElementinaB'></a>230 Kth Smallest Element in a B

[小明](https://www.bilibili.com/video/BV1ha4y1i7dZ?spm_id_from=333.999.0.0)

```py
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        stack = []
        while root or stack: # stack一般都有
            while root: # 找到最深的节点，root在最深处的时候就为none
                stack.append(root)
                root = root.left
            print(stack)
            root = stack.pop() # stack弹出最深处的节点
            print(root)
            k -= 1
            if k == 0:
                return root.val
            root = root.right #去右孩子看看
            print(root)
```

```py
# 用yield来波骚操作

class Solution:
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        def gen(r):
            if r is not None:
                yield from gen(r.left)
                yield r.val
                yield from gen(r.right)
        
        it = gen(root)
        for _ in range(k):
            ans = next(it)
        return ans

# 收藏一波，博主大大威武
# 提醒一下后面的人，'yield from '操作是从python3.3才开始有的，悲伤
# 这个确实有点骚啊，第一次在力扣上看到用yield解题，眼前一亮！
# yield真是迭代优化利器

# 如果当前节点的左子树个数为k-1，当前节点为k最小的节点，
# 找到直接递归返回 如果当前节点的左子树个数小于k-1，
# 往当前节点右子树寻找，寻找个数为(k-左子树个数-1）数量的节点

class Solution:
    def helper(self, root, k):
        if not root: return 0
        left = self.helper(root.left, k)
        if left == -1: return -1
        if left == k-1:
            self.ret = root.val
            return -1
        right = self.helper(root.right, k-left-1)
        if right == -1: return -1

        return left+right+1



    def kthSmallest(self, root: TreeNode, k: int) -> int:
        if not root: return 0
        self.ret = 0
        self.helper(root, k)
        return self.ret

# 跟昨天做的一道题类似，一上来就走取巧之路。
class Solution:
    def kthSmallest(self, root, k: int) -> int:
        queue = deque([])

        def helper(root):
            print(queue)
            
            if root is None: return
            helper(root.left)
            queue.append(root.val)
            helper(root.right)
            return
        helper(root)
        
        return queue[k - 1]
# InOrder排序，输出，当然也完全可以用昨天的binary tree iterator,入stack,出stack,直到输出第k位


class Solution(object):
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        self.root = root
        self.lst = []
        self.inOrder(root)
        return self.lst[k-1]

    def inOrder(self, root):
        if root == None:
            return
        self.inOrder(root.left)
        self.lst.append(root.val)
        self.inOrder(root.right)

# 6得飞起！~ 来化简下助涨楼主骚气
class Solution:
    def kthSmallest(self, root, k):
        from itertools import chain, islice
        def gen(x): yield from chain(gen(x.left), [x.val], gen(x.right)) if x else ()
        return next(islice(gen(root), k - 1, k))
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

object Solution {
    def kthSmallest(root: TreeNode, k: Int): Int = {

      val stack = collection.mutable.Stack[TreeNode]()
      var node = root
      var counter = 0
      var ans = 0
      while ((counter <= k) && (node != null || stack.nonEmpty)) {
        while(node != null) {
          stack push node
          node = node.left
        }
        node = stack.pop
        
        counter += 1
        if (counter == 1 || counter <= k) {
          ans = node.value
        }
        
        node = node.right
        
      }
      ans
    }
}
/**
* my first commit
* inorder iterative template
* time complexity: O(H + K) => H is tree height, H + K = element in stack
*/

object Solution1 {
    def kthSmallest(root: TreeNode, k: Int): Int = {
        
        val stack = collection.mutable.Stack[TreeNode]()
        var node = root
        var counter = 0
        
        
        while(node != null || stack.nonEmpty) {
            while(node != null) {
                stack push node
                node = node.left
            }
            node = stack.pop
            counter += 1
            if(counter == k) return node.value
            else node = node.right
            
        }
        -1
    }
}

/**
* inorder traversal - recursive version
* time complexity: O(H + k)
*/

object Solution2-1 {
    import scala.collection.mutable
    def kthSmallest(root: TreeNode, k: Int): Int = {
        val ret = _kthSmallest(root, k, mutable.ListBuffer.empty)

        ret(k - 1)
    }
    
    def _kthSmallest(node: TreeNode, k:Int, l: mutable.ListBuffer[Int]): mutable.ListBuffer[Int]  = {
       if(node == null) l
       else {
           _kthSmallest(node.left, k, l)
           l += node.value
           if(l.size >= k) l  // shortcut
           else  _kthSmallest(node.right, k, l)  
       }
    }
}


/**
* a brilliant solution - inorder recursive traversal 
* memo:
*   1. using Either, right records numbers of visited node, left record the value when the condition is meet
* time complexity:
*      O(H + K) H is the height of the tree calculated by log(N) approximately
*/
object Solution2-2 {
  def go (node: TreeNode, k: Int) : Either[Int, Int] = {
     val r =for {
      numElementsLeft <- if (node.left == null) Right (0) else go(node.left, k)
      numElementsRight <- if (numElementsLeft + 1 == k) Left(node.value)
      else
        if (node.right == null) Right(0) else go(node.right, k - (numElementsLeft + 1))

    } yield numElementsLeft + numElementsRight + 1
      println(r)
      r

  }

  def kthSmallest(root: TreeNode, k: Int): Int = {
    go(root, k).left.get
  }
}

```

```scala

object Solution {
    var x = 0
    var result = 0
    
    //Using inorder and maintaining count
    
    def findk(root: TreeNode, k: Int): Unit = {
        if(root == null){
            ()
        }
        else if(root.left == null && root.right == null){
            x = x+1
            if(x == k) result = root.value
        }else if(root.left == null){
            x = x+1
            if(x == k) result = root.value
            findk(root.right, k)
        }else if(root.right == null){
            findk(root.left, k)
            x = x+1
            if(x == k) result = root.value
        }else{
            findk(root.left, k)
            x = x+1
            if(x == k) result = root.value
            findk(root.right, k)
        }
    }
    
    def kthSmallest(root: TreeNode, k: Int): Int = {
        x=0
        result=0
        findk(root, k)
        result
    }
}

```

###  1.106. <a name='PowerofTwo'></a>231. Power of Two

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rV411r7AL?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
* time complexity  O(1)
*/
object Solution {
    def isPowerOfTwo(n: Int): Boolean = {
        n > 0 && (n & (n - 1) ) == 0
    }
}
```

###  1.107. <a name='ImplementQueueusingStacks'></a>232-Implement Queue using Stacks

[哈哈哈](https://www.bilibili.com/video/BV1p741177pp?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Gf4y147Vj?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
* using two stack to implement
* one for push, the other for pop
* time complexity amortized O(1) per operation
* space complexity
*/

class MyQueue() {

  /** Initialize your data structure here. */
  private val inputStack = scala.collection.mutable.ArrayStack[Int]()
  private val outputStack = scala.collection.mutable.ArrayStack[Int]()


  /** Push element x to the back of queue. */
  def push(x: Int) {
    inputStack.push(x)

  }

  /** Removes the element from in front of queue and returns that element. */
  def pop(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.pop()

  }

  /** Get the front element. */
  def peek(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.head
  }

  /** Returns whether the queue is empty. */
  def empty(): Boolean = {
    outputStack.isEmpty && inputStack.isEmpty
  }

}

```

###  1.108. <a name='PalindromeLinkedList'></a>234. Palindrome Linked List

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ML?spm_id_from=333.999.0.0)

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
 
 /**
 * my first commitment
 *  using two pointer, one run 2 times faster than the other
 */
object Solution1 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null){
            true
        }else {
            var slowPre: ListNode = null
            var slow = head
            var fast = head

            while (fast != null && fast.next != null) {
                fast = fast.next.next

                val slowNext = slow.next
                slow.next = slowPre
                slowPre = slow
                slow = slowNext

            }

            fast match {
                case null => checkPalindrome(slowPre, slow)
                case _ => checkPalindrome(slowPre, slow.next)  // odd case
            }
            /**
                1 2 2 1 null
                s f
                    s   f  

                1 2 3 2 1 null
                s f   
                    s   f
            */
        }
       
                
    }
    def checkPalindrome(left: ListNode, right: ListNode): Boolean = {
        (left, right) match {
            case (null, null) => true
            case (l, r) if l != null && r != null && l.x == r.x => checkPalindrome(left.next, right.next)
            case _ => false   
        }
        
    }
    

    def printNode(node: ListNode) {
        var n = node
        
        while(n != null) {
            print(s"${n.x}\t")
            n = n.next
        }
    }
}


/**
* very brilliant solution
*/
object Solution2 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null) {
            return true
        }
        var p = head
        var result = true
        def go(node: ListNode): Unit = {
            if (node.next != null) {
                go(node.next)
            }
            if (p.x != node.x) {
                result = false
            }
            p = p.next
        }
        go(head)
        result
    }
}
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def isPalindrome(head: ListNode): Boolean = {
        var flag = true
        var rev = head
        var h = head
        def reverse(n: ListNode): Unit = {
            if(n == null){
                ()
            }else{
                reverse(n.next)
                val cond = n.x == h.x
                flag = flag && cond
                h = h.next
            }
        }
       
        reverse(rev)
        flag
    }
}

```

###  1.109. <a name='LowestCommonAncestorofaBinarySearchTree'></a>235. Lowest Common Ancestor of a Binary Search Tree

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7VY?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
* DFS 
* 
* exploit binary search three property:  right > parent value > left
* time complexity : O(N)
* space complexity: O(N)
*/
object Solution1 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }
  
  @annotation.tailrec
  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    (p, q) match {
      case (pp, qq) if p.value > node.value && q.value > node.value  && node != null => _lowestCommonAncestor(node.right, pp, qq)
      case (pp, qq) if p.value < node.value && q.value < node.value && node != null => _lowestCommonAncestor(node.left, pp, qq)
      case _ => node
    }
  }
}


/**
* iterative version
*/
object Solution1-2 {
    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
      if(root == null) return root
      var node = root
      
      var condition = true
      while(condition && node != null){
        if(q.value > node.value && p.value > node.value)
          node = node.right
        else if (node.value > q.value && node.value > p.value)
          node = node.left
        else 
          condition = false
      }
      node
    }
}
```

###  1.110. <a name='-1'></a>236-二叉树的最近公共祖先

[哈哈哈](https://www.bilibili.com/video/BV1ov411172r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411p7dr?spm_id_from=333.999.0.0)

```py
# 提供一个python3题解：

# 思路 ：这是我看过解释最清楚的youtube题解 需要听懂印度口音英语，但讲得非常好

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return 
        if root == p or root == q:
            return root 
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        if left and right:
            return root 
        elif left and not right:
            return left 
        elif right and not left:
            return right 

# Python 超越99%执行速度的解法：而且也简短

class Solution:
    def lowestCommonAncestor(self, root, p, q) -> 'TreeNode':

        if root in (None,p,q):
            return root 

        L = self.lowestCommonAncestor(root.left,p,q)
        R = self.lowestCommonAncestor(root.right,p,q)

        return R if None==L else L if None==R else root

# 左子树或自己含p 就返回p，右子树或自己含q就返回q，左右子树返回一p一q则返回自己，
# 如果某子树返回了答案（另一子树必然返回None），
# 则返回答案，剩下就是两个子树都返回空，则返回空。 
# 经过逻辑化简：

# 先分析自己，自己是p,q,None中的一者，自然返回自己。
# 然后分析左右子树的返回值，如果其中一个是None，则返回另一个，
# 作为传递，无论是传递最终的答案，还是传递p和q。
# 如果左右子树返回p和q，当然返回root。 Python中的None即C/C++/Java 中的Null/null

# //递归
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q: return root  
        # //找到了节点p或者q，或者遇到空节点
        left = self.lowestCommonAncestor(root.left,p,q)  
        # //左
        right = self.lowestCommonAncestor(root.right,p,q)  
        # //右
        if left and right: return root  
        # //中: left和right不为空，root就是最近公共节点
        elif left and not right: return left  
        # //目标节点是通过left返回的
        elif not left and right: return right  
        # //目标节点是通过right返回的
        else: return None  
        # //没找到
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
*  chosen solution
*  DFS with recursive
*  time complexity O(N), N is the number of node in the tree
*  space complexity O(N)
*/
object Solution0 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }

  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    if (node == null || node == p || node == q) return node
    /**
    *  1. if p and q are node 's child, return p q 's LCA 
    *  2.  if p and q are not node's child return null
    *  3. if p and q, only one of then ar node's child return that node (p or q)
    */
    val left = _lowestCommonAncestor(node.left, p, q)
    val right = _lowestCommonAncestor(node.right, p, q)

    (left, right) match {
      case (null, _) => right  // p and q are both not in left
      case (_, null) => left  // p and q are both not in right
      case (l, r) =>  node // only lowest common ancestor could return both non null node
      // p and q, one of then in left and the other one in right
    }
  }
}
```

###  1.111. <a name='DeleteNodeinaLinkedList'></a>237. Delete Node in a Linked List

[小梦想家](https://www.bilibili.com/video/BV1rv411h7Lv?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1ap4y1C7JP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vt4y1y7eM?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getNext(node: ListNode): ListNode = {
        val nextNode = node.next
        if(nextNode == null)
            null
        else{
            node.x = nextNode.x
            node.next = getNext(nextNode)
            node
        }
    }
    
    def deleteNode(node: ListNode): Unit = {
        getNext(node)
    }
}

//The above solution can be simplified to:
object Solution {
    
    def deleteNode(node: ListNode): Unit = {
        node.x = node.next.x
        node.next = node.next.next //These 2 lines are effectively the same as doing the above recursion in scala
    }
}

```

###  1.112. <a name='ProductofArrayExceptSelf'></a>238 Product of Array Except Self

[小明](https://www.bilibili.com/video/BV1oT4y1G78Y?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16z4y197oQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def productExceptSelf(self, nums):
        n = len(nums)
        # 动态规划,开辟两类空间,分别存储索引i左边(右边)所有数的乘积,
        # 所以,output[i]即为i左边所有数的乘积*i右边所有数的乘积.
        # 为了满足O(1)空间复杂度要求(输出数组不被视作额外空间),
        # 首先,一类空间的dp数据(i右边所有数的乘积)用输出数组存储,
        # 二类空间的dp数据(i左边所有数的乘积)用两个变量存储,
        # 因为这两个变量会一直变化, 所以应该实时更新输出数组.
        dp_right = [1 for i in range(n)]
        pre_left = 1
        for i in range(n - 2, -1, -1):
            dp_right[i] = dp_right[i + 1] * nums[i + 1]
        for i in range(1, n):
            cur_left = pre_left * nums[i - 1]
            dp_right[i] = cur_left * dp_right[i]
            pre_left = cur_left
        return dp_right

# python 思想：前缀积，前缀积和前缀和差不多

class Solution:
    def productExceptSelf(self, nums):
        nums_len = len(nums)
        res = [1]*nums_len
        right = 1
        for i in range(1, nums_len):
            res[i] = res[i-1] * nums[i-1]
        for i in range(nums_len-1, -1, -1):
            res[i] = res[i]*right
            right = right * nums[i]
        # print(res)
        return res

# 用一个数组来存储每一个数的左边的数的乘积，那么 ans[i] = ans[i-1]*nums[i]， 
# 第一个数左边没有数，认为ans[0] = 1。
# 再用一个数 R 来存储右边的数的乘积，
# 从后往前循环，ans乘以R就是左右数缀的乘积，同时更新R。

class Solution:
    def productExceptSelf(self, nums):
        n = len(nums)
        ans = [0]*n
        
        ans[0] = 1
        for i in range(1, n):
            ans[i] = ans[i-1]*nums[i-1]

        R = 1
        for i in reversed(range(n)):
            ans[i] = ans[i] * R
            R *= nums[i]

        return ans

class Solution:
    def productExceptSelf(self, nums):
        n=len(nums)
        left=[1]*n
        right=[1]*n
        res=[]
        for i in range(1,n):
            left[i]=left[i-1]*nums[i-1]
        for i in range(n-2,-1,-1):
            right[i]=right[i+1]*nums[i+1]
        for i in range(n):
            res.append(left[i]*right[i])
        return res 

# 方法一：左右乘积列表

class Solution:
    def productExceptSelf(self, nums):
        length = len(nums)
        
        # L 和 R 分别表示左右两侧的乘积列表
        L, R, answer = [0]*length, [0]*length, [0]*length
        
        # L[i] 为索引 i 左侧所有元素的乘积
        # 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1
        L[0] = 1
        for i in range(1, length):
            L[i] = nums[i - 1] * L[i - 1]
        
        # R[i] 为索引 i 右侧所有元素的乘积
        # 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1
        R[length - 1] = 1
        for i in reversed(range(length - 1)):
            R[i] = nums[i + 1] * R[i + 1]

        # 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
        for i in range(length):
            answer[i] = L[i] * R[i]
        
        return answer

# 方法二：空间复杂度 O(1)O(1) 的方法
# 思路
# 尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。
# 由于输出数组不算在空间复杂度内，那么我们可以将 L 或 R 数组用输出数组来计算。
# 先把输出数组当作 L 数组来计算，然后再动态构造 R 数组得到结果。
# 让我们来看看基于这个思想的算法。


class Solution:
    def productExceptSelf(self, nums):
        length = len(nums)
        answer = [0]*length
        
        # answer[i] 表示索引 i 左侧所有元素的乘积
        # 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1
        answer[0] = 1
        for i in range(1, length):
            answer[i] = nums[i - 1] * answer[i - 1]
        
        # R 为右侧所有元素的乘积
        # 刚开始右边没有元素，所以 R = 1
        R = 1;
        for i in reversed(range(length)):
            # 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
            answer[i] = answer[i] * R
            # R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
            R *= nums[i]
        
        return answer
```

```scala
object Solution {

    //pre-compute prefix & suffix products in O(N) time and then multiply them
    def productExceptSelf(nums: Array[Int]): Array[Int] = {
        var prefix = Array.fill(nums.length)(1)
        var suffix = Array.fill(nums.length)(1)
        
        (1 until prefix.length).map(i => {
            prefix(i) = prefix(i-1)*nums(i-1)
        })
        
        (suffix.length-2 to 0 by -1).map(i => {
            suffix(i) = suffix(i+1)*nums(i+1)
        })
        
        (0 until nums.length).map(i => {
            nums(i) = prefix(i) * suffix(i)
        })
        nums
    }
}

```

###  1.113. <a name='SlidingWindowMaximum'></a>239. Sliding Window Maximum

[花花酱](https://www.bilibili.com/video/BV1WW411C763?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Bf4y1v758?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala

/**
* chosen solution 
* using  array deque (double side queue)  which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution0 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
        //you should always delete elements from right side
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* using max heap, may not AC
* pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)} : keep element's time complexity is O(K)
* time complexity: O(N log K)
*/

object Solution1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        var pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
        val rest = scala.collection.mutable.ArrayBuffer[Int]()
        
        nums.zipWithIndex.foreach{case (v: Int, idx: Int) => {
     
            pq += ((v, idx))
            
            /* keep the elements that is only larger than newest v and the nearest k */
            pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)}       

            if (idx + 1 >= k) {
                rest += pq.head._1
            }
          
        }}        
        rest.toArray
    }
}


/**
* may not AC
* fold left version, it is worst than for loop version
*/
object Solution1-2 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
  val (_, rest, _) = nums.zipWithIndex.foldLeft((pq, Array.empty[Int], k)){
    (B, v_id) =>
      val (_pq, rest: Array[Int], _k) = B
      var newPq = _pq
      newPq += v_id
      if(v_id._2 + 1 >= k) {
        newPq = newPq.filter{case (_v:Int, _idx: Int) => (_v >= v_id._1) && (_idx > v_id._2 - k) }
          
         (newPq, rest :+ newPq.head._1, _k)
      }else {
         (newPq, rest, _k)
      }
     
  }
  rest
        
    }
}


/**
* using scala vector, due to scala vector is immutable, any operation about add update remove is generate a new vector
* so it's not a proper substitute for deque
*/

object Solution2 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    var windows = Vector.empty[Int]
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.head <= index - k)
        windows = windows.drop(1)

      while (windows.nonEmpty && nums(windows.last) <= value){
        windows = windows.dropRight(1)
      }
      windows = windows :+ index
      if (index + 1 >= k) {
        ret += nums(windows.head)
      }
    }
    ret.toArray
  }
}

/**
* using java array deque (double side queue) version which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution3 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    import java.util
    val windows = new util.ArrayDeque[Int]  // record nums index
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.peekFirst() <= index - k) {
        // remove out of date element
        windows.removeFirst()
      }

      while (!windows.isEmpty && nums(windows.peekLast()) <= value) {
        // drop the element if  it is smaller than upcoming element
        windows.removeLast()
      }
      windows.add(index)
      if (index + 1 >= k) {
        ret += nums(windows.peekFirst())
      }
    }
    ret.toArray
  }
}

/**
* use scala build-in arrayDeque
*/
object Solution3-1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* brute force, not AC
*/
object Solution4 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        nums.sliding(k).map(_.max).toArray
    }
}
```

###  1.114. <a name='-1'></a>240. 二维数组的查找

[哈哈哈](https://www.bilibili.com/video/BV1dz411i7jC?spm_id_from=333.999.0.0)

```py
import bisect
class Solution:
    def searchMatrix(self, matrix, target):
        for row in matrix:
            idx = bisect.bisect_left(row, target)
            if idx < len(row) and row[idx] == target:
                return True
        return False
```

```py
class Solution(object):
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix:
            return False
        row = len(matrix)
        col = len(matrix[0]) if row else 0 
        m, n = 0, col - 1
        while m < row and n >= 0:
            if matrix[m][n] < target:
                m += 1
            elif matrix[m][n] > target:
                n -= 1
            else:
                return True
        return False

class Solution:
    def searchMatrix(self, matrix, target):
        for row in matrix:
            for element in row:
                if element == target:
                    return True
        return False

# 从右上角开始找，若目标小了就左移，目标大了就下移

class Solution:
    def searchMatrix(self, matrix, target):
        i,j=0,len(matrix[0])-1
        while i<len(matrix) and j>=0:
            if matrix[i][j]==target: return True
            if target<matrix[i][j]: j-=1
            elif target>matrix[i][j]: i+=1
        return False


class Solution:
    def searchMatrix(self, matrix, target):
        m,n=len(matrix),len(matrix[0])
        for i in range(m):
            for j in range(n):
                if matrix[i][j]<target:
                    continue
                elif matrix[i][j]==target:
                    return True 
                else:
                    if j==0:
                        return False 
                    else:
                        break
        return False
# （python）对每一行二分查找
# 分治法。

# 左下角的元素是这一行中最小的元素，同时又是这一列中最大的元素。比较左下角元素和目标：
# 若左下角元素等于目标，则找到
# 若左下角元素大于目标，则目标不可能存在于当前矩阵的最后一行，问题规模可以减小为在去掉最后一行的子矩阵中寻找目标
# 若左下角元素小于目标，则目标不可能存在于当前矩阵的第一列，问题规模可以减小为在去掉第一列的子矩阵中寻找目标
# 若最后矩阵减小为空，则说明不存在
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        if n == 0:
            return False

        i = m - 1
        j = 0
        while i >= 0 and j < n:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                j = j + 1
            else:
                i = i - 1
        return False
class Solution:
    def searchMatrix(self, matrix, target):
        row,col=len(matrix),len(matrix[0])
        for i in range(row):
            left,right=0,col-1
            while left<=right:
                mid=(left+right)//2
                if matrix[i][mid]==target:
                    return True
                elif matrix[i][mid]>target:
                    right=mid-1
                else:
                    left=mid+1
        return False 
```

###  1.115. <a name='ValidAnagram'></a>242. Valid Anagram 

[小梦想家](https://www.bilibili.com/video/BV1Db411s78v?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hV411i73u?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala

/**
* chosen solution
* one line version
* time complexity: O(N)
*/

object Solution0 {
  def isAnagram(s: String, t: String): Boolean = {
   s.groupBy(identity).mapValues(_.length).toMap == t.groupBy(identity).mapValues(_.length).toMap  // toMap: transform MapView to Map

  }
}


/**
* my first commit
* time complexity: O(N)
*/

object Solution1 {
  def isAnagram(s: String, t: String): Boolean = {
    charCounter(s) equals charCounter(t)
  }
  private def charCounter(str: String): Map[Char, Int] = {
    str.foldLeft(collection.mutable.Map.empty[Char, Int]) {
      (map, s) =>
        map.get(s) match {
          case Some(e) =>
            map.update(s, e + 1)
            map
          case None =>
            map.update(s, 1)
            map
        }
    }.toMap
  }
}



```

```scala
//Time complexity( O(NlogN + N))
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        if(arr1.size != arr2.size){
            false
        } else{
            java.util.Arrays.sort(arr1)
            java.util.Arrays.sort(arr2)
            
            var flag = true
            import scala.util.control.Breaks._
            var index = 0
            breakable{
            while(index < arr1.size){
                if(arr1(index) != arr2(index)){
                    flag = false
                    break
                }
                index += 1
            }
            }
            flag
        }
    }
}

//Time complexity O(n)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        
        if(arr1.size != arr2.size){
            false
        } else{
            var map = scala.collection.mutable.Map.empty[Char, Int]
            for(elem <- arr1){
                map.get(elem) match{
                    case Some(count) => map += (elem -> (count+1))
                    case None => map += (elem -> 1)
                }
            }
            
            for(elem <- arr2){
                map.get(elem) match{
                    case Some(count) if count == 1 => map.remove(elem)
                    case Some(count) => map += (elem -> (count-1))
                    case None => ()
                }
            }
            
            if(map.keys.isEmpty) true else false
        }
    }
}

//One more: O(N)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        if(s.size != t.size){
            false
        }else{
        var arr = Array.fill(26)(0)
        for(elem <- s){
            arr(elem - 'a') += 1
        }
        
        import scala.util.control.Breaks._
        var flag = true
        breakable{
        for(elem <- t){
            arr(elem - 'a') -= 1
            if(arr(elem - 'a') < 0){
                flag = false
                break
            }
        }
        }
        flag
    }
    }
}

```

###  1.116. <a name='ShortestWordDistance'></a>243. Shortest Word Distance

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Ae?spm_id_from=333.999.0.0)

###  1.117. <a name='StrobogrammaticNumber'></a>246. Strobogrammatic Number

[小梦想家](https://www.bilibili.com/video/BV14b411g7zD?spm_id_from=333.999.0.0)

###  1.118. <a name='-1'></a>257-二叉树的所有路径

[哈哈哈](https://www.bilibili.com/video/BV1rf4y1X7He?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//Given a binary tree, return all root-to-leaf paths.
//
//Note: A leaf is a node with no children.
//
//Example:
//
//Input:
//
//1
///   \
//2     3
//\
//5
//
//Output: ["1->2->5", "1->3"]
//
//Explanation: All root-to-leaf paths are: 1->2->5, 1->3

package lc0257 {

  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def binaryTreePaths(root: TreeNode): List[String] = {
      val tmp = ArrayBuffer[Int]()
      val ret =ArrayBuffer[ArrayBuffer[Int]]()
      helper(root, tmp, ret)
      ret.toList.map({
        x=>x.mkString("->")
      })
    }

    def helper(node:TreeNode,tmp:ArrayBuffer[Int],ret:ArrayBuffer[ArrayBuffer[Int]]): Unit = {
      if (node==null) {
        return
      }

      tmp += node.value

      if (node.left == null && node.right==null) {
          ret += tmp.clone()
      } else {
        helper(node.left, tmp, ret)
        helper(node.right, tmp, ret)
      }
      tmp.remove(tmp.length-1)
    }
  }

  class Test extends BaseExtension {
    def init {
      val t1 = Tree.build(IndexedSeq("1","2 3","5 N N N"))
      println(Solution.binaryTreePaths(t1))
    }
    val name = "257 binary tree path"
  }
}

```

###  1.119. <a name='AddDigits'></a>258. Add Digits

[小梦想家](https://www.bilibili.com/video/BV1ub41137cm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N54y1B7XU?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.120. <a name='III-1'></a>260-只出现一次的数字 III

[哈哈哈](https://www.bilibili.com/video/BV15Z4y1H7Sw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK411J7dN?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.121. <a name='UglyNumber'></a>263 Ugly Number

[花花酱](https://www.bilibili.com/video/BV11W411C7zd?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Mb41157Pa?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.122. <a name='UglyNumberII'></a>264. Ugly Number II

[花花酱](https://www.bilibili.com/video/BV1yW411C7Sm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vT4y1775u?spm_id_from=333.999.0.0)

```py
# python 实习面试这道题挂了，但我就不懂了，第一次见这题目谁能想到3指针的方法？

class Solution(object):
    def nthUglyNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        res = [1]
        idx2 = 0
        idx3 = 0
        idx5 = 0
        for i in range(n-1):
            res.append(min(res[idx2]*2,res[idx3]*3,res[idx5]*5))
            if res[-1] == res[idx2]*2:
                idx2 += 1
            if res[-1] == res[idx3]*3:
                idx3 += 1
            if res[-1] == res[idx5]*5:
                idx5 += 1
        return res[-1]

# 就这？好清晰，牛的牛的

class Solution(object):
    def nthUglyNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        a,b,c = 0,0,0
        dp = [0]*n
        dp[0] = 1
        for i in range(1,n):
            dp[i] = min(dp[a]*2,dp[b]*3,dp[c]*5)
            if dp[i] == dp[a]*2:
                a += 1
            if dp[i] == dp[b]*3:
                b += 1
            if dp[i] == dp[c]*5:
                c += 1
        return dp[n-1]

class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[1] = 1
        p2 = p3 = p5 = 1

        for i in range(2, n + 1):
            num2, num3, num5 = dp[p2] * 2, dp[p3] * 3, dp[p5] * 5
            dp[i] = min(num2, num3, num5)
            if dp[i] == num2:
                p2 += 1
            if dp[i] == num3:
                p3 += 1
            if dp[i] == num5:
                p5 += 1
        
        return dp[n]
# 还可以优化：
# 根据页面hint 来做的
class Solution(object):
    def nthUglyNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1
        else:
            import collections
            q2 = collections.deque()
            q3 = collections.deque()
            q5 = collections.deque()
            q2.append(2)
            q3.append(3)
            q5.append(5)
            while n > 1:
                    x = min(q2[0],q3[0],q5[0])
                    if x == q2[0]:
                            x = q2.popleft()
                            q2.append(2*x)
                            q3.append(3*x)
                            q5.append(5*x)
                    elif x == q3[0]:
                            x = q3.popleft()
                            q3.append(3*x)
                            q5.append(5*x)
                    else:
                            x = q5.popleft()
                            q5.append(5*x)
                    n -= 1
            return x
```

###  1.123. <a name='MissingNumber'></a>268 Missing Number

[小明](https://www.bilibili.com/video/BV1LU4y1p7n7?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        val idealSum = (size * (size + 1))/2
        
        val arraySum = nums.foldLeft(0)(_ + _) // can also use nums.sum
        
        idealSum - arraySum
    }
}

//Removing foldLeft improved time
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        var idealSum = (size * (size + 1))/2
        
        for(num <- nums){
            idealSum -= num
        }

        idealSum
    }
}

```

###  1.124. <a name='ClosestBinarySearchTreeValue'></a>270. Closest Binary Search Tree Value

[哈哈哈](https://www.bilibili.com/video/BV1zy4y1a7mR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1fi4y1u7Sb?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.125. <a name='H-Index'></a>274 H-Index

[小明](https://www.bilibili.com/video/BV1ZV411z7Kx?spm_id_from=333.999.0.0)


###  1.126. <a name='FirstBadVersion'></a>278. First Bad Version

[小梦想家](https://www.bilibili.com/video/BV1rZ4y1P7YF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1cQ4y1N7dc?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/* The isBadVersion API is defined in the parent class VersionControl.
      def isBadVersion(version: Int): Boolean = {} */



/**
* my first commitment
* binary search recursive version
* time complexity
*   log(n)
*/
class Solution1 extends VersionControl {
    def firstBadVersion(n: Int): Int = {
        search(1, n)
    }
  
    def search(left: Int, right: Int): Int  = {
      if (left > right) return -1
       /**
      * it's bad version from mid to n, we could keep right side a bad version
      * the we return left side index as left index equals to right index
      */
      if (left == right) return left
      
      val mid = left + (right - left) / 2
      if (isBadVersion(mid))
     
        search(left, mid) 
      else
        search(mid + 1, right)
    }
}

```

###  1.127. <a name='PerfectSquares'></a>279 Perfect Squares

[小明](https://www.bilibili.com/video/BV1r5411Y7MH?spm_id_from=333.999.0.0)

```py
# 动态规划

# ```
# 1. 初始化 inf 从0开始，所以数组长度 n+1 
# 2. 考虑到是平方，意味着他的间隔可能是跳跃性的，所以 
#         n  =   (n-j*j)  + j*j
#         dp[i] = dp[i-1] + 1
# 3. 那么 min 就是未来找到最小值而存在的，因为需要遍历很多个平方， dp[i] 用户存储最小值
# 4. 返回 dp[-1] 的结果，也就是最终 n 的值
# ```

# ```python
class Solution(object):
    def numSquares(self, n) -> int:
        square_nums = [i**2 for i in range(1, int(n**0.5)+1)]
        dp = [float('inf')] * (n+1)
        dp[0] = 0
        for i in range(1, n+1):
            for square in square_nums:
                if i < square:
                    break
                # print("%s --- %s结果需要一次 --- %s结果需要%s次" % (i, square, i-square, dp[i-square]))
                dp[i] = min(dp[i], dp[i-square] + 1)
        return dp[-1]

# 我会背包了 我真牛逼！ 打开评论 我是s逼
# 超时，最后测试用例7217
class Solution:
    def numSquares(self, n) -> int:
        goods = []
        for i in range(1,101):
            goods.append(i * i)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        for g in goods:
            for j in range(1,n+1):
                if j - g >= 0:
                    dp[j] = min(dp[j-g] + 1,dp[j])
        return dp[n]
# Python：

class Solution:
    def numSquares(self, n) -> int:
        '''版本一，先遍历背包, 再遍历物品'''
        # 初始化
        nums = [i**2 for i in range(1, n + 1) if i**2 <= n]
        dp = [10**4]*(n + 1)
        dp[0] = 0
        # 遍历背包
        for j in range(1, n + 1):
            # 遍历物品
            for num in nums:
                if j >= num:
                    dp[j] = min(dp[j], dp[j - num] + 1)
        return dp[n]
 class Solution:
    '''版本一，先遍历背包, 再遍历物品'''
    def numSquares(self, n) -> int:
        dp = [n] * (n + 1)
        dp[0] = 0
        # 遍历背包
        for j in range(1, n+1):
            for i in range(1, n):
                num = i ** 2
                if num > j: break
                # 遍历物品
                if j - num >= 0:
                    dp[j] = min(dp[j], dp[j - num] + 1)
        return dp[n]   
 class Solution:
    def numSquares1(self, n) -> int:
        '''版本二， 先遍历物品, 再遍历背包'''
        # 初始化
        nums = [i**2 for i in range(1, n + 1) if i**2 <= n]
        dp = [10**4]*(n + 1)
        dp[0] = 0
        # 遍历物品
        for num in nums:
            # 遍历背包
            for j in range(num, n + 1):
                dp[j] = min(dp[j], dp[j - num] + 1)
        return dp[n]
# 有没有python用动态规划超时的兄弟。
# 
class Solution:
    def numSquares(self, n) -> int:
        f = [float('inf')] * (n+1)
        f[0] = 0
        for  i in range(1,n+1):
            i_sqrt = i**0.5
            j = 1
            while j <= i_sqrt:
                f[i] = min(f[i],f[i-j**2]+1)
                j += 1
        return f[n]
class Solution:
    def numSquares(self, n) -> int:
        """
        完全背包问题： f[i][j]: 前i个物品，占据j空间最少可以放几个。
        f[i][j] = min(f[i - 1][j], f[i][j - v[i] + w[i], ..., f[i][j - k * v[i]] + k * w[i])
        = min(f[i-1][j], f[i][j - v[i] + w[i]])
        空间优化之后得到：
        f[i] = min(f[i], f[i- v[i] + w[i]])
        """
        f = [n] * (n + 1)
        f[0] = 0
        for i in range(1, n + 1):
            j = 1
            while j * j <= i:
                f[i] = min(f[i], f[i - j * j] + 1)
                j += 1
        return f[n]
```


```py
# 执行时间7256ms，在超时的边缘反复横跳
from math import ceil
class Solution:
    def numSquares(self, n) -> int:

        def f(n):
            if n <= 3:
                return n
            # if n is square itself
            if sqrt(n) % 1 == 0:
                return 1
            return min(
                (f(n - i**2) + 1 for i in reversed(range(1, ceil(sqrt(n)))))
            )

        return f(n)
```

```py
# 四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。 

# 推论：满足四数平方和定理的数n（四个整数的情况），必定满足 n=4^a(8b+7)

class Solution:
    def numSquares(self, n):
            """
            :type n
            :rtype
            """
            while n % 4 == 0: 
                n /= 4 
            if n % 8 == 7: 
                return 4 
            a = 0 
            while a**2 <= n: 
                b = int((n - a**2)**0.5) 
                if a**2 + b**2 == n: 
                    return (not not a) + (not not b) 
                a += 1 
            return 3
# 一个解题合集，欢迎小伙伴一起
```

###  1.128. <a name='ExpressionAddOperators'></a>282. Expression Add Operators

[花花酱](https://www.bilibili.com/video/BV15W411C727?spm_id_from=333.999.0.0)

###  1.129. <a name='MoveZeros'></a>283. Move Zeros

[小梦想家](https://www.bilibili.com/video/BV1m441187Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ba4y1t7eK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Wp4y1y7pT?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        var p1 = 0
        var p2 = 0
        while(p1 < nums.size && p2 < nums.size){
            if(nums(p1) == 0 && nums(p2) != 0 && p1<p2){
                nums(p1) = nums(p2)
                nums(p2) = 0
                p1 += 1
                p2 += 1
            } else if(nums(p1) != 0 && nums(p2) != 0){
                p1 += 1
            }else{
                p2 += 1
            }
        }
    }
}

//Alternate solution: calculate the number of shifts 
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        
        var zeroCount = 0
        //count of zero is amount character is shifted to left
        //from first zero position traverse array left
        for(a <- 0 to nums.size-1){   
            //count zeroes and shift when not zero
            if(nums(a) == 0){
                zeroCount = zeroCount + 1
            }else if(zeroCount>0){
                //shift left if not 0 by zeroCount
                nums(a-zeroCount) = nums(a)
                nums(a) = 0
            }
        }
    }
}

```

```scala
package com.zhourui.leetcode

package lc0283_movezero {
  object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
//      nums.foldLeft(0) {
//        case (w,b) => {
//          if (b!=0) {
//            nums(w) = b
//
//            w+1
//          } else w
//        }
//      }

      nums.indices.foldLeft(0) {
        case (acc, e) => {
          if (nums(e)!=0) {
            val tmp = nums(e)
            nums(e) = nums(acc)
            nums(acc) = tmp
            acc+1
          } else acc
        }
      }
    }
  }
}

/*
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int w = 0;
        for (int i = 0; i< nums.size(); i++) {
            if (nums[i]!=0) {
                swap(nums[w++], nums[i]);
            }
        }
    }
};
 */

```

###  1.130. <a name='PeekingIterator'></a>284 Peeking Iterator

[小明](https://www.bilibili.com/video/BV1LN411R7U7?spm_id_from=333.999.0.0)

###  1.131. <a name='FindtheDuplicateNumber'></a>287 Find the Duplicate Number

[小明](https://www.bilibili.com/video/BV1Ug4y1v7mF?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pz4y1X7qR?spm_id_from=333.999.0.0)

```py
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        #数组只能读 所以不能排序,不能swap数组下标
        #时间复杂度小于 O(n^2) 不能暴力
        #空间复杂度 O(1) 不能额外开辟数组
        
        ''' 1、暴力不符合题意
        for i in nums:
            count = 0
            for num in nums:
                if num == i:
                    count += 1
            if count > 1:
                return i
        return -1
        '''
        
        '''2、小于O(n^2) 二分查找
        我们不要考虑数组,只需要考虑 数字都在 1 到 n 之间
        示例 1:
        arr = [1,3,4,2,2] 此时数字在 1 — 5 之间

        mid = (1 + 5) / 2 = 3 arr小于等于的3有4个(1,2,2,3)，1到3中肯定有重复的值
        mid = (1 + 3) / 2 = 2 arr小于等于的2有3个(1,2,2)，1到2中肯定有重复的值
        mid = (1 + 2) / 2 = 1 arr小于等于的1有1个(1)，2到2中肯定有重复的值
        所以重复的数是 2 
        '''
        left = 1
        right = len(nums)
        while left < right:
            mid = int(left + (right - left)/2)
            cnt = 0
            for num in nums:
                if num <= mid:
                   cnt += 1
            if cnt <= mid:
                left = mid + 1
            else:
                right = mid
        return right

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        low, high = 1, len(nums) - 1
        while low <= high:
            mid = (low + high) >> 1
            cnt = sum(x <= mid for x in nums)
            if cnt > mid:
                high = mid - 1
            else:
                low = mid + 1

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = {}
        # dic = dict()
        for n in nums:
            dic[n] = dic.get(n, 0) + 1
            print(dic)
            if dic[n] >= 2:
                return n
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        print(set(nums))
        return (sum(nums)-sum(set(nums)))//(len(nums) - len(set(nums)))
```

###  1.132. <a name='GameofLife'></a>289. Game of Life

[花花酱](https://www.bilibili.com/video/BV14W411d7ji?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hp4y1B7D5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vz4y1R7DJ?spm_id_from=333.999.0.0)

```py
# 生命在于调库

import numpy as np
from scipy import signal
class Solution:
    def gameOfLife(self, board):
        arr = np.array(board)
        mask = np.ones((3,3))
        mask[1, 1] = 0
        around = signal.convolve2d(arr, mask, mode='same')
        arr[around < 2] = 0
        arr[around == 3] = 1
        arr[around > 3] = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                board[i][j] = arr[i, j]

        return board

# 卷积法

from scipy.signal import convolve2d
import numpy as np
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """
        b=np.array(board)
        x=convolve2d(b,[[1,1,1],[1,10,1],[1,1,1]],'same')
        board[:]=b*(x//2==6)+(x==3)
        return board
```

```py
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """

        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        rows = len(board)
        cols = len(board[0])

        # 从原数组复制一份到 copy_board 中
        copy_board = [[board[row][col] for col in range(cols)] for row in range(rows)]

        # 遍历面板每一个格子里的细胞
        for row in range(rows):
            for col in range(cols):

                # 对于每一个细胞统计其八个相邻位置里的活细胞数量
                live_neighbors = 0
                for neighbor in neighbors:

                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # 查看相邻的细胞是否是活细胞
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and (copy_board[r][c] == 1):
                        live_neighbors += 1

                # 规则 1 或规则 3        
                if copy_board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    board[row][col] = 0
                # 规则 4
                if copy_board[row][col] == 0 and live_neighbors == 3:
                    board[row][col] = 1
        return board

class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """

        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        rows = len(board)
        cols = len(board[0])

        # 遍历面板每一个格子里的细胞
        for row in range(rows):
            for col in range(cols):

                # 对于每一个细胞统计其八个相邻位置里的活细胞数量
                live_neighbors = 0
                for neighbor in neighbors:

                    # 相邻位置的坐标
                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # 查看相邻的细胞是否是活细胞
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and abs(board[r][c]) == 1:
                        live_neighbors += 1

                # 规则 1 或规则 3 
                if board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    # -1 代表这个细胞过去是活的现在死了
                    board[row][col] = -1
                # 规则 4
                if board[row][col] == 0 and live_neighbors == 3:
                    # 2 代表这个细胞过去是死的现在活了
                    board[row][col] = 2

        # 遍历 board 得到一次更新后的状态
        for row in range(rows):
            for col in range(cols):
                if board[row][col] > 0:
                    board[row][col] = 1
                else:
                    board[row][col] = 0
        return board

class Solution(object):
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        row = len(board)
        col = len(board[0]) if row else 0

        dx = [-1,-1,-1,0,1,1,1,0]
        dy = [-1,0,1,1,1,0,-1,-1]
    
        for i in range(row):
            for j in range(col):
                cnt = 0
                for k in range(8):
                    x, y = i + dx[k], j + dy[k]
                    if x >=0 and x < row and y >=0 and y < col and (board[x][y] == 1  or board[x][y] == 2):
                        cnt += 1

                if board[i][j] and (cnt < 2 or cnt > 3):
                    board[i][j] = 2
                elif board[i][j] == 0 and cnt == 3:
                    board[i][j] = 3

        for i in range(row):
            for j in range(col):
                board[i][j] %= 2
        return board
```

###  1.133. <a name='WordPattern'></a>290. Word Pattern

[小梦想家](https://www.bilibili.com/video/BV1d4411V7mi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1N7wD?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.134. <a name='SerializeandDeserializeBinaryTree'></a>297. Serialize and Deserialize Binary Tree

[花花酱](https://www.bilibili.com/video/BV1Hb411c7cr?spm_id_from=333.999.0.0)

###  1.135. <a name='BullsandCows'></a>299. Bulls and Cows

[小梦想家](https://www.bilibili.com/video/BV1M64y1M7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1bh411R7n4?spm_id_from=333.999.0.0)

```py
from collections import defaultdict
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        n = len(secret)
        s, g = defaultdict(int), defaultdict(int)
        a, b = 0, 0
        for i in range(n) :
            l,r = secret[i], guess[i]
            if l == r :
                a += 1
            else :
                s[l] += 1
                g[r] += 1
        for k,v in s.items() :
            b += min(v, g[k])
        return str(a) + 'A' + str(b) + 'B'

# python
#  你这甚至不如sort之后再一个一个匹配，算两遍不麻烦嘛
#  sort之后一一匹配相等元素对么，那你如何知道bull个数？
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        secret_list = list(secret)
        guess_list = list(guess)

        # 先遍历一遍统计bull
        bull = 0
        for i in range(len(secret_list)):
            if secret_list[i] == guess_list[i]:
                bull += 1
        
        # 再遍历统计一共有多少个相等的元素对
        cow = 0
        for ch in secret_list:
            if ch in guess_list:
                cow += 1
                guess_list.remove(ch)

        # cow - bull 即为真正的 cow
        return str(bull) + 'A' + str(cow-bull) + 'B'

# 做了两次才做出来，需要注意：

# 调整位置时，位置只能用一次 比如1123 1011 输出的是1A1B而不是1A2B

# 先计算公牛（数字和位置都匹配），比如1122 1222 输出的是 3A0B而不是3A1B

class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        a = b = 0
        hashmap = collections.Counter(secret)
        for x, y in zip(secret, guess):
            if x == y:
                a += 1
                hashmap[x] -= 1
        for x, y in zip(secret, guess):
            if x != y:
                if y in hashmap:
                    if hashmap[y] > 0:
                        b += 1
                    hashmap[y] -= 1
        return f'{a}A{b}B'

from collections import Counter
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bull = sum(secret[i] == guess[i] for i in range(len(secret)))
        cow = sum((Counter(secret) & Counter(guess)).values()) - bull
        return f'{bull}A{cow}B'

# 都这么短。。。。。
# 我Python还是用的不行啊
import operator
class Solution(object):
    def getHint(self, secret, guess):
        """
        :type secret: str
        :type guess: str
        :rtype: str
        """
        bull = sum(map(operator.eq, secret, guess))
        sa = collections.Counter(secret)
        sb = collections.Counter(guess)
        cow = sum((sa & sb).values()) - bull
        return str(bull) + 'A' + str(cow) + 'B'
```

###  1.136. <a name='LongestIncreasingSubsequence'></a>300 Longest Increasing Subsequence 最长上升子序列

[花花酱](https://www.bilibili.com/video/BV1Wf4y1y7ou?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1rT4y1u7jV?spm_id_from=333.999.0.0)

```py
# 贪心 + 二分查找

class Solution:
    def lengthOfLIS(self, nums):
        d = []
        for n in nums:
            if not d or n > d[-1]:
                d.append(n)
            else:
                l, r = 0, len(d) - 1
                loc = r
                while l <= r:
                    mid = (l + r) // 2
                    if d[mid] >= n:
                        loc = mid
                        r = mid - 1
                    else:
                        l = mid + 1
                d[loc] = n
        return len(d)

class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        dp = [1 for i in range(len(nums))]
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[j]+1, dp[i])
        return max(dp)

class Solution:
    def lengthOfLIS(self, nums):
        if len(nums) <= 1:
            return len(nums)
        dp = [1] * len(nums)
        result = 0
        for i in range(1, len(nums)):
            for j in range(0, i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
            result = max(result, dp[i]) #取长的子序列
        return result

class Solution:
    def lengthOfLIS(self, nums):
        if not nums:
            return 0
        dp = []
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

```scala



/**
* chosen answer
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution0 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}

/**
* brute force : not Ac
* memo:
* 1. each position have two choice :
*    1. take current value if currentIdx value > previousIdx value 
*    2. do not take current value
* time complexity: O(2^n)
*/
object Solution1 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        lengthOfLIS(nums, 0, -1)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int): Int = {
      if (currentIdx >= nums.length) return 0
      
      val taken = if (previousIdx == -1  ||  (nums(currentIdx) > nums(previousIdx))) {
        lengthOfLIS(nums, currentIdx + 1, currentIdx) + 1
      } else {
        0
      } 
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx)
      taken max nonTaken
    }
}

/**
* with memorized: we just fill the nxn dimension memory array
* time complexity: O(n^2)
* space complexity: O(n^2)
*/
object Solution1-2 {
    def lengthOfLIS(nums: Array[Int]): Int = {
      val memory = Array.fill[Int](nums.length, nums.length)(-1)
      lengthOfLIS(nums, 0, -1, memory)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int, memory: Array[Array[Int]]): Int  = {
      // println(currentIdx, previousIdx)
      if (nums.length == currentIdx) return 0
      if (memory(currentIdx)(previousIdx + 1) != -1) return memory(currentIdx)(previousIdx + 1)
      
      val taken = if (previousIdx == -1 || nums(currentIdx) > nums(previousIdx)) {
        1 + lengthOfLIS(nums, currentIdx + 1, currentIdx, memory)
      } else {
        0
      }
      
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx, memory)
      
      memory(currentIdx)(previousIdx + 1) = taken max nonTaken
      
      memory(currentIdx)(previousIdx + 1) 
    }
  
  
}





/**
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution3 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        

        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}
```

###  1.137. <a name='RemoveInvalidParentheses'></a>301. Remove Invalid Parentheses

[花花酱](https://www.bilibili.com/video/BV1VW411y7Xd?spm_id_from=333.999.0.0)

###  1.138. <a name='-1'></a>303-区域和检索 - 数组不可变

[哈哈哈](https://www.bilibili.com/video/BV1RV411d76R?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV18441137fs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ho4y1U7wF?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.139. <a name='RangeSumQuery2D'></a>304. Range Sum Query 2D

[花花酱](https://www.bilibili.com/video/BV1Jb411k7LQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1R64y127jL?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.140. <a name='BestTimetoBuyandSellStockwithCooldown309-'></a>309. Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期

[花花酱](https://www.bilibili.com/video/BV1qW411C7Xc?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Vy4y1z7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13D4y1U7iU?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala

/**
* my first commitment
* dynamic programming
* memo
*   1. dp definition: dp[i][j] means the best profit we can have at i-th day in state j of without holding / holding / cooldown 
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        /*
        * state definition
        * 0: without holding
        * 1: holding one
        * 2: sold than cooldown
        */
        val dp = Array.tabulate(prices.length, 3){
            case (0, 0) => 0
            case (0, 1) => -prices(0)
            case (0, 2) => 0
            case _ => 0
        }
        
        for(i <- 1 until prices.length) {
            dp(i)(0) = dp(i - 1)(0) max dp(i - 1)(2) // 0 -> 0 or 2 -> 0
            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i)) // 1 -> 1 or  0 -> 1
            dp(i)(2) = dp(i - 1)(1) + prices(i) // 1 -> 2
        }
        
        dp.last.max
    }
}

/**
* dynamic programming
* memo
*    ok! lets reduce the dp array size without keep all i-th state
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-2 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        var withoutHold = 0
        var hold = Int.MinValue
        var coolDown = 0
        
        for(price <- prices) {
            val withoutHold_ = withoutHold  // keep value
            val hold_ = hold // keep value
            withoutHold = withoutHold max coolDown
            hold = hold max (withoutHold_ - price)
            coolDown = hold_ + price  
        }
        withoutHold max coolDown
    }
}

/**
* dynamic programming - function programming
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-3 {
    def maxProfit(prices: Array[Int]): Int = {
        val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) {
            case ((withoutHold, hold, cooldown), cost) => 
             (
                 withoutHold max cooldown,
                 hold max (withoutHold - cost),
                 hold + cost      
             )
        }
        withoutHold max cooldown
    }
}
```

###  1.141. <a name='MinimumHeightTrees'></a>310 Minimum Height Trees

[小明](https://www.bilibili.com/video/BV1eA411j7XQ?spm_id_from=333.999.0.0)

###  1.142. <a name='BurstBalloons'></a>312 Burst Balloons

[小明](https://www.bilibili.com/video/BV1Q64y1f7Vy?spm_id_from=333.999.0.0)

###  1.143. <a name='CountofSmallerNumbersAfterSelf'></a>315. Count of Smaller Numbers After Self

[花花酱](https://www.bilibili.com/video/BV1BW411C7TM?spm_id_from=333.999.0.0)

###  1.144. <a name='RemoveDuplicateLetters'></a>316 Remove Duplicate Letters

[小明](https://www.bilibili.com/video/BV1x54y1R7y7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Tz4y167pC?spm_id_from=333.999.0.0)

```py
# 思路是参考别人的，
# 如果数比栈顶小，而且栈顶在后面还有的话，
# 就弹出栈顶。
# python自带列表弹出和加入最后一个数都是很快的。
# 然后在前面加一个0，因为0比一切字母小，可以不用判空，方便很多

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        result = ["0"] # 初值不要为空，不然index为-1会报错
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            print("s[idx:]",s[idx:],"数量: ",s[idx:].count(result[-1]),"需要大于0,表示要把c删掉，必须后面还有c")
            if char not in result:
                while char < result[-1] and s[idx:].count(result[-1]) > 0:
                    result.pop(-1) # result 删除最后一位
                result.append(char)
        return "".join(result[1:])

# 递归贪心版本
class Solution(object):
    def removeDuplicateLetters(self, str):
        """
        :type s: str
        :rtype: str
        """
        print("-"*50)
        # 先按字典排序
        for char in sorted(set(str)):
            print("-"*20,char)
            suffix = str[str.index(char):]
            print(suffix)


            # 看余下的是否能组成所需的字母
            # if len(set(suffix)) == len(set(str)): 也可以
            if set(suffix) == set(str):
                return char + self.removeDuplicateLetters(suffix.replace(char, ''))
                # 逐步把char后面的char替换掉
        return ''

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = ''
        while s:
            print(list(map(s.rindex, set(s))))
            i = min(map(s.rindex, set(s)))
            c = min(s[:i+1])
            print(s[:i+1])
            result += c
            s = s[s.index(c):].replace(c, '')
            print(s)
        return result

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        rindex = {char: idx for idx, char in enumerate(s)}
        print("rindex",rindex)
        result = '' 
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            if char not in result:
                while char < result[-1:] and idx < rindex[result[-1:]]:
                    # 如果 char 比 最后一位result[-1:] 小
                    # result 删除最后一位
                    print("rindex[result[-1:]",rindex[result[-1:]])
                    result = result[:-1] 
                result += char
        return result

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        n = len(s)
        stack = [s[0]]
        for i in range(1,n):
            if s[i] not in stack and s[i]>stack[-1]:
                stack.append(s[i])
            elif s[i] not in stack:
                while stack and s[i]<stack[-1] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
        return "".join(stack)

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        n = len(s)
        for i in range(n):
            if s[i] in stack:
                continue
            else:
                while stack and stack[-1] > s[i] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
            
        return "".join(stack)

# 思路三：栈
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        from collections import Counter
        c = Counter(s)
        stack = []
        existed = set()
        for a in s:
            # print(stack)
            if a not in existed:
            	# 判断后面还有没有该字母
                while stack and stack[-1] > a and c[stack[-1]] > 0:
                    existed.remove(stack.pop())
                stack.append(a)
                existed.add(a)
            c[a] -= 1
        return "".join(stack)

# 思路二：迭代
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        res = ""
        while s:
            # 从右往左找，找到最小位置的索引号
            loc = min(map(s.rindex, s))
            # 找该索引前面最小的字母
            a = min(s[:loc + 1])
            res += a
            s = s[s.index(a):].replace(a, "")
        return res
```

### 319

```py
class Solution(object):
    def bulbSwitch(self, n):
        """
        :type n: int
        :rtype: int
        """
        bulb = [1] * n # 实际上是从第一轮后，开始算起的，刚好n=0的情况符合
        print("bulb: ",bulb)
        for interval in range(2,n+1):
            for x in range(interval-1, n, interval): # 从第interval开始，间隔interval个
                # ---------切换开关---------
                bulb[x] = 1 if bulb[x] == 0 else 0
                print("bulb: ",bulb)
                # ---------切换开关---------
        return bulb.count(1)
```

###  1.145. <a name='CreateMaximumNumber'></a>321. Create Maximum Number

[花花酱](https://www.bilibili.com/video/BV11W411U7NR?spm_id_from=333.999.0.0)

###  1.146. <a name='CoinChange'></a>322. Coin Change

[花花酱](https://www.bilibili.com/video/BV1SW411C7d1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1tz4y1d7XM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ty4y187dh?spm_id_from=333.999.0.0)

```py
# 方法一：记忆化搜索

class Solution:
    def coinChange(self, coins, amount):
        # @functools.lru_cache(amount)
        def dp(rem) -> int:
            if rem < 0: return -1
            if rem == 0: return 0
            mini = int(1e9)
            for coin in self.coins:
                res = dp(rem - coin)
                if res >= 0 and res < mini:
                    mini = res + 1
            return mini if mini < int(1e9) else -1

        self.coins = coins
        if amount < 1: return 0
        return dp(amount)

# 方法二：动态规划

class Solution:
    def coinChange(self, coins, amount):
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1 

# python 完全背包问题

class Solution:
    def coinChange(self, coins, amount):
        if coins == []: return -1
        dp = [amount+1] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount+1):
            for coin in coins:
                if i >= coin:
                    dp[i] = min(dp[i], dp[i-coin]+1)

        if dp[-1] == amount+1: 
            return -1
        else:
            return dp[amount] 

class Solution:
    def coinChange(self, coins, amount):
        '''版本一'''
        # 初始化
        dp = [amount + 1]*(amount + 1)
        dp[0] = 0
        # 遍历物品
        for coin in coins:
            # 遍历背包
            for j in range(coin, amount + 1):
                dp[j] = min(dp[j], dp[j - coin] + 1)
        return dp[amount] if dp[amount] < amount + 1 else -1

# BFS

class Solution:
    def coinChange(self, coins, amount):
        from collections import deque
        queue = deque([amount])
        step = 0
        visited = set()
        while queue:
            n = len(queue)
            for _ in range(n):
                tmp = queue.pop()
                if tmp == 0:
                    return step
                for coin in coins:
                    if tmp >= coin and tmp - coin not in visited:
                        visited.add(tmp - coin)
                        queue.appendleft(tmp - coin)
            step += 1
        return -1

# 宽度优先,速度飕飕的

class Solution:
    def coinChange(self, coins, amount):
        q = [[0, 0]]
        see = {0}
        while q:
            cur, cnt = q.pop(0)
            if cur == amount:
                return cnt
            for i in coins:
                t = cur + i
                if t <= amount and t not in see:
                    q.append([t, cnt + 1])
                    see.add(t)
        return -1
# 自顶向下

class Solution:
    def coinChange(self, coins, amount):
        import functools
        @functools.lru_cache(None)
        def helper(amount):
            if amount == 0:
                return 0
            return min(helper(amount - c) if amount - c >= 0 else float("inf") for c in coins) + 1
        res = helper(amount)
        return res if res != float("inf") else -1

# DFS

class Solution:
    def coinChange(self, coins, amount):
        coins.sort(reverse=True)
        self.res = float("inf")
        
        def dfs(i, num, amount):
            if amount == 0:
                self.res = min(self.res, num)
                return 
            for j in range(i, len(coins)):
                # 剩下的最大值都不够凑出来了
                if (self.res - num) * coins[j] < amount:
                    break
                if coins[j] > amount:
                    continue
                dfs(j, num + 1, amount - coins[j])
                
        for i in range(len(coins)):
            dfs(i, 0, amount)
            
        return self.res if self.res != float("inf") else -1
```

```scala
/**
* dynamic programming: bottom up
* time complexity: O(S * N), S is the amount, N is the coin denomination count
* space complexity: O(S)
*/

object Solution {
    def coinChange(coins: Array[Int], amount: Int): Int = {
         
        val dp = Array.fill[Int](amount + 1)(amount + 1) // record the minimum needed coins of each denominations

        dp(0) = 0
        for (i <- 1 to amount; denominations <- coins) {

            if(denominations <= i) {
                dp(i) = dp(i) min (dp(i - denominations) + 1)
            }        
        }
    
        if (dp.last > amount) -1 else dp.last
    }
}

```

### 324

```py
class Solution(object):
    def wiggleSort(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        nums.sort()
        half = len(nums[::2])
        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]
```

###  1.147. <a name='PowerofThree'></a>326. Power of Three

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7QC?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1h441137PM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sZ4y1F7Lr?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.148. <a name='OddEvenLinkedList'></a>328. 奇偶链表 (Odd Even Linked List)

[洛阳](https://www.bilibili.com/video/BV1v64y1u7AH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ag4y1B78z?spm_id_from=333.999.0.0)

```py
# 都是奇偶俩个链表然后合并的，我怎么就没想到。。 我直接想的就是快慢指针然后只把奇数节点拿出来插到前面。。。

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        if not head.next:
            return head
        if not head.next.next:
            return head
        p = head
        fast,slow = head.next.next,head
        fast_pre = head.next
        while fast:
            # 把当前fast(奇数)节点放在slow后面，记录fast_pre保证复原
            fast_pre.next,slow.next,fast.next= fast.next,fast,slow.next
            slow = slow.next
            fast_pre = fast_pre.next
            if not fast_pre or not fast_pre.next :
                break
            fast = fast_pre.next
        return head

# 双指针分别对应奇偶链，最后串起来：https://github.com/Brycexxx/leetcode/blob/master/oddEvenList.py

# Definition for singly-linked list.
class ListNode:
   def __init__(self, x):
       self.val = x
       self.next = None


class Solution:
   def oddEvenList(self, head: ListNode) -> ListNode:
       if head == None: return head
       point1, point2 = head, head.next
       p1, p2 = point1, point2
       while p2 != None and p2.next:
           p1.next = p1.next.next
           p2.next = p2.next.next
           p1 = p1.next
           p2 = p2.next
       p1.next = point2
       return point1

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        '''
        slow: 上一个奇数节点
        fast: 下一个奇数节点
        pre: 下一个奇数节点的前缀节点
        post: 上一个奇数节点的后缀节点
        '''
        slow, pre, fast = head, head.next, head.next.next
        while slow and fast:
            q = fast.next.next if fast.next else None
            post = slow.next
            pre.next = fast.next
            fast.next = post
            slow.next = fast
            slow, pre, fast = fast, pre.next, q
        return head


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        # 奇节点在偶节点之前
        if head == None:
            return None
        dummy_head_1 = ListNode(-1)
        dummy_head_2 = ListNode(-1)
        p1 = dummy_head_1  # 奇节点
        p2 = dummy_head_2  # 偶节点
        i = 1  # 题目要求第一个节点是奇节点
        while head:
            if i % 2 == 0:
                p2.next = head
                p2 = p2.next
                head = head.next
            else:
                p1.next = head
                p1 = p1.next
                head = head.next
            i += 1
        p2.next = None
        p1.next = dummy_head_2.next
        return dummy_head_1.next

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        evenHead = head.next
        odd, even = head, evenHead
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = evenHead
        return head

class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None:
            return head

        # odd used to keep track of the tail of odd nodes
        odd = oddHead = head
        # record how many swaps happend
        even = evenHead = head.next
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next 
            even = even.next
        odd.next = evenHead
        return head 
```

###  1.149. <a name='LongestIncreasingPathinaMatrix'></a>329. Longest Increasing Path in a Matrix

[花花酱](https://www.bilibili.com/video/BV1mW411d7q8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK4y1K7SX?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.150. <a name='ReconstructItinerary'></a>332 Reconstruct Itinerary

[小明](https://www.bilibili.com/video/BV1qa4y1h7Ti?spm_id_from=333.999.0.0)

###  1.151. <a name='IncreasingTripletSubseque'></a>334 Increasing Triplet Subseque

[小明](https://www.bilibili.com/video/BV1Kr4y1F7m9?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        # m - min, sm - second min
        m, sm = float('inf'), float('inf')

        for num in nums:
        	print (m, sm)
        	if m >= num:
        		m = num
        	elif sm >= num:
        		sm = num
        	else:
        		return True
        return False


class Solution:
    def increasingTriplet(self, nums):
        n = len(nums)
        if n < 3:
            return False
        small, mid = max(nums), max(nums)
        for i in range(n):
            if nums[i] <= small:
                small = nums[i]
            elif nums[i] <= mid:
                mid = nums[i]
            elif nums[i] > mid:
                return True
        return False

# 循环遍历数组，不断更新数组内出现的最小值与最大值，如果出现的一个大于最大值的数，则表示存在长度为 3 的递增子序列。

class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        length = len(nums)
        if length < 3:
            return False
        
        min_num = float('inf')
        max_num = float('inf')
        
        for n in nums:
            if n < min_num:
                min_num = n
            elif min_num < n and n <= max_num:
                max_num = n
            elif n > max_num:
                return True
        
        return False
```

###  1.152. <a name='HouseRobberIII'></a>337 House Robber III

[小明](https://www.bilibili.com/video/BV1WD4y1X7JQ?spm_id_from=333.999.0.0)

```py
# 补充一个Python的：

class Solution:
    def rob(self, root: TreeNode) -> int:
        def _rob(root):
            if not root: return 0, 0
            
            ls, ln = _rob(root.left)  # 前一项表示根节点偷，后一项表示根节点不偷
            rs, rn = _rob(root.right) # 前一项表示根节点偷，后一项表示根节点不偷
            
            return root.val + ln + rn, max(ls, ln) + max(rs, rn) # 前一项表示根节点偷，后一项表示根节点不偷

        return max(_rob(root))
# ls表示偷左子树能带来的最大收益，ln表示不偷左子树能带来的最大收益，rs、rn同理

# 这个解法好像有点厉害

# 从root开始抢起来，最大能抢到的两个可能： 抢root和不抢root

# - rob_root = max(rob_L + rob_R , no_rob_L + no_nob_R + root.val)
# - no_rob_root = rob_L + rob_R


# 这个递归写起来就很厉害了


# ```
class Solution(object):
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(root):
            if not root: return 0, 0
            rob_L, no_rob_L = dfs(root.left) # 前一项表示根节点偷，后一项表示根节点不偷
            rob_R, no_rob_R = dfs(root.right) # 前一项表示根节点偷，后一项表示根节点不偷
            return max(no_rob_R + no_rob_L + root.val , rob_L + rob_R), rob_L + rob_R # 前一项表示根节点偷，后一项表示根节点不偷
        return dfs(root)[0]

class Solution:
    def rob(self, root: TreeNode) -> int:
        result = self.rob_tree(root)
        return max(result[0], result[1])
    
    def rob_tree(self, node):
        if node is None:
            return (0, 0) # (偷当前节点金额，不偷当前节点金额)
        left = self.rob_tree(node.left)
        right = self.rob_tree(node.right)
        val1 = node.val + left[1] + right[1] # 偷当前节点，不能偷子节点
        val2 = max(left[0], left[1]) + max(right[0], right[1]) # 不偷当前节点，可偷可不偷子节点
        return (val1, val2)

class Solution:
    def rob(self, root: TreeNode) -> int:
        if root is None:
            return 0
        if root.left is None and root.right  is None:
            return root.val
        # 偷父节点
        val1 = root.val
        if root.left:
            val1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            val1 += self.rob(root.right.left) + self.rob(root.right.right)
        # 不偷父节点
        val2 = self.rob(root.left) + self.rob(root.right)
        return max(val1, val2)
```

###  1.153. <a name='CountingBits'></a>338 Counting Bits

[小明](https://www.bilibili.com/video/BV1VK411s7xi?spm_id_from=333.999.0.0)

```scala

/**
* chosen solution
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution0 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}

object Solution1 {
    def countBits(num: Int): Array[Int] = {
        (0 to num).map(_counter).toArray
        
    }
    private def _counter(n: Int): Int = {
        var counter = 0
        var nn = n
        
        while(nn != 0) {
            counter += 1
            nn = nn & (nn - 1)
        }
        counter 
    }
}

/**
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution2 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}
```

###  1.154. <a name='PowerofFour'></a>342. Power of Four

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7D5?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1p5411a7h1?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.155. <a name='-1'></a>343-整数拆分

[哈哈哈](https://www.bilibili.com/video/BV1Dp4y1U79P?spm_id_from=333.999.0.0)

###  1.156. <a name='ReverseString'></a>344. Reverse String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7Ha?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nC4y1a7DR?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1nQ4y1R7nH?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
object Solution {
    def reverseString(s: Array[Char]): Unit = {
        var begin = 0
        var end = s.length - 1
        while(begin < end){
            var temp = s(begin)
            s(begin) = s(end)
            s(end) = temp
            
            begin += 1
            end -= 1
        }
    }
}

```

###  1.157. <a name='ReverseVowelsofaString'></a>345. Reverse Vowels of a String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7JH?spm_id_from=333.999.0.0)

###  1.158. <a name='MovingAveragefromDataStream'></a>346 Moving Average from Data Stream

[小明](https://www.bilibili.com/video/BV1xV411m73u?spm_id_from=333.999.0.0)

###  1.159. <a name='TopKFrequentElements'></a>347. Top K Frequent Elements 

[花花酱](https://www.bilibili.com/video/BV1Mt411371T?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sk4y1B7vj?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
object Solution {
    def topKFrequent(nums: Array[Int], k: Int): Array[Int] = {
        var hm = scala.collection.mutable.Map.empty[Int, Int]
        for(elem <- nums){
            hm.get(elem) match{
                case Some(count) => hm += (elem -> (count+1))
                case None => hm += (elem -> 1)
            }
        }
        
        // hm.toList.sortBy(x => (x._2)*(-1)).take(k).map(_._1).toArray
        // The above is a sorting approach. We can use Heap/PriorityQueue to achieve better time complexity
        
        import scala.math.Ordering.Implicits._
        
        def orderByFrequency(tup: (Int, Int)) = tup._2
        
        val pq = new scala.collection.mutable.PriorityQueue[(Int, Int)]()(Ordering.by(orderByFrequency))
        
        for(entry <- hm){
            pq.enqueue(entry)
        }
        
        println(pq)
        (1 to k).map(_ => pq.dequeue).map(_._1).toArray
        
    }
}

```

###  1.160. <a name='IntersectionofTwoArrays'></a>349. Intersection of Two Arrays

[小梦想家](https://www.bilibili.com/video/BV1zx411o7i1?spm_id_from=333.999.0.0)

###  1.161. <a name='IntersectionofTwoArraysII'></a>350. Intersection of Two Arrays II 

[小梦想家](https://www.bilibili.com/video/BV1gx411X7q8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV165411879H?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        
        val map1 = nums1.groupBy(identity).mapValues(_.length)
        val map2 = nums2.groupBy(identity).mapValues(_.length)
        
        val keys = map1.keySet intersect map2.keySet
        
        keys.map(key => {
            val count1 = map1.get(key).get
            val count2 = map2.get(key).get
            val count = if(count1 > count2) count2 else count1
            Array.fill(count)(key)
        }).toArray.flatten
    }
}


//Alternate solution to keep count in HashMap from 1st array & decrease from second array... whatever is left is intersection
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        var map = scala.collection.mutable.Map.empty[Int, Int]
        var output = List.empty[Int]
        for(item <- nums1){
            map.get(item) match{
                case Some(count) => map += (item -> (count + 1))
                case None => map += (item -> 1)
            }
        }
        
        for(item <- nums2){
            map.get(item) match{
                case Some(count) => {
                    output = output :+ item
                    if(count - 1 == 0) map.remove(item) else map += (item -> (count - 1))
                }
                case None => map.remove(item)
            }
        }
        
        output.toArray
    }
}

```

###  1.162. <a name='DesignTwitter'></a>355. 设计推特 Design Twitter

[官方](https://www.bilibili.com/video/BV1aQ4y1N72N?spm_id_from=333.999.0.0)

###  1.163. <a name='LoggerRateLimiter'></a>359 Logger Rate Limiter

[小明](https://www.bilibili.com/video/BV1k64y1F7dE?spm_id_from=333.999.0.0)

###  1.164. <a name='ValidPerfectSquare'></a>367. Valid Perfect Square

[小梦想家](https://www.bilibili.com/video/BV1Gx411X7Ke?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DT4y1377H?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.165. <a name='LargestDivisibleSubset'></a>368 Largest Divisible Subset

[小明](https://www.bilibili.com/video/BV15D4y1Q74b?spm_id_from=333.999.0.0)

###  1.166. <a name='FindKPairswithSmallestSumsk'></a>373. Find K Pairs with Smallest Sums查找和最小的k对数字

[图灵](https://www.bilibili.com/video/BV1Mv4y1Z79v?spm_id_from=333.999.0.0)

###  1.167. <a name='GuessNumberHigherorLower'></a>374. Guess Number Higher or Lower

[小梦想家](https://www.bilibili.com/video/BV1Hx41197ou?spm_id_from=333.999.0.0)

###  1.168. <a name='-1'></a>376-摆动序列

[哈哈哈](https://www.bilibili.com/video/BV1sk4y167wV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16X4y1376k?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.169. <a name='CombinationSumIV'></a>377. Combination Sum IV

[花花酱](https://www.bilibili.com/video/BV1gW411y7uz?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1zA411L7nu?spm_id_from=333.999.0.0)

```py
# 我们需要一个一维数组dp，其中dp[i]表示目标数为i的解的个数，
# 然后我们从1遍历到target，对于每一个数i，遍历nums数组，
# 如果i>=x, dp[i] += dp[i - x]。这个也很好理解，
# 比如说对于[1,2,3] 4，这个例子，当我们在计算dp[3]的时候，3可以拆分为1+x，
# 而x即为dp[2]，3也可以拆分为2+x，此时x为dp[1]，3同样可以拆为3+x，
# 此时x为dp[0]，我们把所有的情况加起来就是组成3的所有情况了
class Solution(object):
    def combinationSum4(self, candidates, target):
        """
        :type candidates: List[int]
        :type target
        :rtype: List[List[int]]
        """
        dp = [0 for i in range(target+1)]

        dp[0] = 1

        for i in range(target+1):
            for candidate in candidates:
                if i >= candidate:
                    dp[i] += dp[i - candidate]
        return dp[-1]
class Solution:
    def combinationSum4(self, nums, target):
        dp = [0] * (target + 1)
        dp[0] = 1

        for i in range(1, target+1):
            for j in nums:
                if i >= j:
                    dp[i] += dp[i - j]

        return dp[-1]
class Solution:
    def combinationSum4(self, nums: List[int], target) -> int:
        dp = [0]*(target+1)
        dp[0] = 1 # i - num = 0 ----> i = num时，表示只取 i 一个数 就是一种，因此这里赋值为1。
        nums.sort()
        for i in range(1,target+1):
            for num in nums: 
                if i - num >= 0:
                    dp[i] += dp[i-num]
        return dp[target]
# 不需要sort吧，如果你sort的话，可以在 if i - num >= 0: 

# dp[i] += dp[i-num] 后面加一个 else： break 不然白白sort了
class Solution:
    def combinationSum4(self, nums: List[int], target) -> int:
        dp = [1] + [0] * target
        for i in range(1, target + 1):
            for num in nums:
                if num <= i:
                    dp[i] += dp[i - num]
        
        return dp[target]
```

###  1.170. <a name='K'></a>378-有序矩阵中第K小的元素

[哈哈哈](https://www.bilibili.com/video/BV1mT4y1w7u2?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Zy4y127qr?spm_id_from=333.999.0.0)

```py
# 无脑暴力法一行版

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        return sorted(sum(matrix,[]))[k-1]
# 暴力pq一行
import heapq
class Solution(object):
    def kthSmallest(self, matrix, k):
        return heapq.nsmallest(k,sum(matrix,[]))[-1]
#  heapq一行
class Solution(object):
    def kthSmallest(self, matrix, k):
        return list(heapq.merge(*matrix))[k-1]

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        rec = sorted(sum(matrix, []))
        return rec[k - 1]

# 无脑暴力法优化版
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        l=heapq.nlargest(len(lis)-k+1,lis)
        return l[-1]
# 无脑暴力法
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        lis.sort()
        return lis[k-1]
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        n = len(matrix)
        pq = [(matrix[i][0], i, 0) for i in range(n)]
        heapq.heapify(pq)

        ret = 0
        for i in range(k - 1):
            num, x, y = heapq.heappop(pq)
            if y != n - 1:
                heapq.heappush(pq, (matrix[x][y + 1], x, y + 1))
        
        return heapq.heappop(pq)[0]
# binary search
# ```python
import bisect
class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k
        :rtype
        """
        l, r = matrix[0][0], matrix[-1][-1]
        while l <= r:
            mid = l + ((r - l) >> 2)
            if sum(bisect.bisect_right(row, mid) for row in matrix) < k:
                l = mid + 1
            else:
                r = mid - 1
        return l
```


###  1.171. <a name='InsertDeleteGetRandomO1'></a>380 Insert Delete GetRandom O(1)

[小明](https://www.bilibili.com/video/BV1Fg4y1q7Ru?spm_id_from=333.999.0.0)

###  1.172. <a name='LinkedListRandomNode'></a>382 Linked List Random Node

[小明](https://www.bilibili.com/video/BV1xZ4y1G7ie?spm_id_from=333.999.0.0)

###  1.173. <a name='RansomNote'></a>383 Ransom Note

[小明](https://www.bilibili.com/video/BV1GQ4y1N7Q5?spm_id_from=333.999.0.0)

### 386

```py
class Solution:
    def lexicalOrder(self, n):
        def dfs(num):
            if num > n:
                return
            ans.append(num)
            for nxt in range(num * 10, num * 10 + 10):
                dfs(nxt)

        ans = []
        for num in range(1, 10):
            dfs(num)
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(i: int = 1) -> None:
            if i > n:
                return
            for j in range(i, min(n + 1, (10 if i < 10 else i + 10))):
                ans.append(j)
                dfs(j * 10)
        ans = []
        dfs()
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(rec, i, n):
            if i > n: return -1
            rec.append(i);
            child = i * 10
            for j in range(10):
                if dfs(rec, child+j, n) == -1:break
            return
        rec = []
        for i in range(1, 10):
            dfs(rec, i, n)
        return rec
```

```py
class Solution:
    def lexicalOrder(self, n):
        return sorted(list(range(1,n+1)),key=lambda x:str(x))

class Solution:
    def lexicalOrder(self, n):
        return [int(j) for j in sorted([str(i) for i in range(1, n + 1)])]

# 字符串排序

class Solution:
    def lexicalOrder(self, n):
        l = sorted([str(i) for i in range(1, n + 1)])
        return [int(i) for i in l]
```

```py
class Solution:
    def lexicalOrder(self, n):
        orders = []
        stack = [(1, 8)]
        while len(stack) > 0:
            orders.append(stack[-1][0])
            (last, step) = stack.pop()
            if last+1 <= n and step > 0:
                stack.append((last+1, step-1))
            if last*10 <= n:
                stack.append((last*10, 9))
        return orders

class Solution:
    def lexicalOrder(self, n):
        ans = []
        num = 1
        while len(ans) < n:
            while num <= n:  # 不断进入下一层
                ans.append(num)
                num *= 10
            while num % 10 == 9 or num > n:  # 不断返回上一层
                num //= 10
            num += 1  # 遍历该层下一个数
        return ans

class Solution(object):
    def lexicalOrder(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        res = []
        cur = 1
        for i in range(n):
            res.append(cur)
            if (cur * 10 <= n):
                cur *= 10
            elif cur + 1 <= n and (cur + 1) % 10 != 0:
                cur += 1
            else:
                while (cur/10) % 10 == 9:
                    cur /= 10
                cur = cur / 10 + 1
        return res
```

###  1.174. <a name='FirstUniqueCharacterinaString'></a>387. First Unique Character in a String

[小梦想家](https://www.bilibili.com/video/BV1y4411A7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1b541147WU?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
object Solution {
    def firstUniqChar(s: String): Int = {
        var map = scala.collection.mutable.Map.empty[Char, (Int, Int)]
        (0 to s.length-1).map(i =>
            map.get(s.charAt(i)) match{
                case Some(indexAndCount) => map += (s.charAt(i) -> (i, indexAndCount._2 + 1))
                case None => map += (s.charAt(i) -> (i, 1))
            }
        )
        map.toList.filter(x => x._2._2 == 1).map(_._2._1).sorted.headOption.getOrElse(-1)
    }
}

//Alternate/Better SCALA solution
object Solution {
    def firstUniqChar(s: String): Int = {
        val hmap =  s.toCharArray.groupBy(identity).mapValues(_.length)
        val uniqChar = s.toCharArray.zipWithIndex.find (p => hmap(p._1) == 1)
        if(uniqChar.nonEmpty) uniqChar.get._2 else -1 
    }
}

/**How the above solution works:
scala> val a = "akashs"
a: String = akashs

scala> a.toCharArray.groupBy(identity)
res0: scala.collection.immutable.Map[Char,Array[Char]] = Map(h -> Array(h), k -> Array(k), s -> Array(s, s), a -> Array(a, a))

scala> a.toCharArray.groupBy(identity).mapValues(_.length)
res1: scala.collection.immutable.Map[Char,Int] = Map(h -> 1, k -> 1, s -> 2, a -> 2)

scala> a.toCharArray.zipWithIndex
res2: Array[(Char, Int)] = Array((a,0), (k,1), (a,2), (s,3), (h,4), (s,5))

scala> a.toCharArray.zipWithIndex.find(x => res1(x._1) == 1)
res3: Option[(Char, Int)] = Some((k,1))
*/

```

###  1.175. <a name='FindtheDifference'></a>389. Find the Difference

[小梦想家](https://www.bilibili.com/video/BV1Et411K7jP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.176. <a name='PerfectRectangle'></a>391. Perfect Rectangle

[花花酱](https://www.bilibili.com/video/BV184411c7cs?spm_id_from=333.999.0.0)

###  1.177. <a name='IsSubsequence'></a>392. Is Subsequence

[小梦想家](https://www.bilibili.com/video/BV1fg4y1q7eT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Za4y1a73v?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19f4y197yS?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.178. <a name='UTF-8Validation'></a>393. UTF-8 Validation

[花花酱](https://www.bilibili.com/video/BV1SE411w7no?spm_id_from=333.999.0.0)

###  1.179. <a name='DecodeString'></a>394 Decode String

[小明](https://www.bilibili.com/video/BV145411V75E?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GZ4y1p7pE?spm_id_from=333.999.0.0)

```py
# 类似正则表达式
# 神仙神仙，看了半天才看明白，每次只匹配最里层的，
# 将匹配到的字符串自动分成数字和字母，然后用转换函数替换成新串，
# 替换完内层后再去替换外层，直到没有括号为止。函数式编程和正则表达式玩的好秀。
# 牛的，看了半天终于懂了，不过这里r的意思应该是取消python转义吧
import re

class Solution(object):
    def decodeString(self, s):
        """
        :type s: str
        :rtype: str
        """
        def f(m):
            print("m:",m)
            print("m.group(1):",m.group(1))
            print("m.group(2):",m.group(2))
            return int(m.group(1))* m.group(2)
        while '[' in s:
            s = re.sub(r'(\d+)\[([A-Za-z]*)\]', f, s)
        return s
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1a1r7x6jdqww.png" width="50%">

```py
# 当前的 context 有两个值，一个是当前打印的串，一个是重复的数量。

# 我写了个状态机来解这个题目：

class Solution:
    def decodeString(self, s: str) -> str:
        res = ''       # 当前打印串
        count = 0   # 下一个 pattern 的数量
        stack = []
        for c in s:
            if ord('a') <= ord(c) <= ord('z'):
                res += c
            elif ord('0') <= ord(c) <= ord('9'):
                count = count * 10 + int(c)
            elif c == '[':
                stack.append((res, count))
                res = ''
                count = 0
            elif c == ']':
                ctx_res, ctx_count = stack.pop()
                res = ctx_res + res * ctx_count
        return res
class Solution:
    def decodeString(self, s: str) -> str:
        stk = []
        for ch in s:
            if ch == ']':
                sub = ''
                while stk[-1] != '[':
                    sub = stk.pop() + sub
                stk.pop()
                n = ''
                while stk and stk[-1].isdigit():
                    n = stk.pop() + n
                stk.append(int(n) * sub)
            else:
                stk.append(ch)
        return ''.join(stk)
# Python3简洁代码

# 本题核心思路是在栈里面每次存储两个信息, (左括号前的字符串, 左括号前的数字), 
# 比如abc3[def], 当遇到第一个左括号的时候，压入栈中的是("abc", 3), 
# 然后遍历括号里面的字符串def, 当遇到右括号的时候, 从栈里面弹出一个元素(s1, n1), 
# 得到新的字符串为s1+n1*"def", 也就是abcdefdefdef。对于括号里面嵌套的情况也是同样处理方式。
# 凡是遇到左括号就进行压栈处理，遇到右括号就弹出栈，栈中记录的元素很重要。
### 代码

class Solution:
    def decodeString(self, s: str) -> str:
        stack = []  # (str, int) 记录左括号之前的字符串和左括号外的上一个数字
        num = 0
        res = ""  # 实时记录当前可以提取出来的字符串
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c)
            elif c == "[":
                stack.append((res, num))
                res, num = "", 0
            elif c == "]":
                top = stack.pop()
                res = top[0] + res * top[1]
            else:
                res += c
        return res
```

###  1.180. <a name='LongestSubstringwithAtLeastK'></a>395 Longest Substring with At Least K

[小明](https://www.bilibili.com/video/BV1hD4y1X7rq?spm_id_from=333.999.0.0)

###  1.181. <a name='EvaluateDivision'></a>399. Evaluate Division

[花花酱](https://www.bilibili.com/video/BV1iW41167Nb?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XU4y1s7Lk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ko4y1f7eK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rZ4y1N7CW?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.182. <a name='RemoveKDigits'></a>402 Remove K Digits

[小明](https://www.bilibili.com/video/BV1PV411C79X?spm_id_from=333.999.0.0)

###  1.183. <a name='SumofLeftLeaves'></a>404. Sum of Left Leaves

[小梦想家](https://www.bilibili.com/video/BV1Et411K7wa?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15a4y1779U?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.184. <a name='ConvertaNumbertoHexadecimal'></a>405-Convert a Number to Hexadecimal

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7ds?spm_id_from=333.999.0.0)

```py
class Solution:
    def toHex(self, num):
        """
        :type num: int
        :rtype: str
        """
        if num<0:
            num = (1<<32)+num
        return format(num, '0x')

class Solution:
    def toHex(self, num):
        """
        :type num: int
        :rtype: str
        """
        if num == 0:
            return '0'
        if num < 0:
            num += 2 ** 32

        # --------核心代码，确实厉害--------
        ans = ''
        hexdigits = '0123456789abcdef'
        while num:
            ans += hexdigits[num % 16]
            num //= 16
        return ans[::-1]
        # --------核心代码，确实厉害--------

class Solution(object):
    def toHex(self, num):
        """
        :type num: int
        :rtype: str
        """
        if not num :
            return "0"

        result = []
        hexStr ="0123456789abcdef"
        while num and len(result) != 8:
            h = num & 15
            result.append(hexStr[h])
            # num >>= 4,等效
            num //= 16

        return ''.join(result[::-1])
```

###  1.185. <a name='QueueReconstructionbyHeight'></a>406. Queue Reconstruction by Height 

[小明](https://www.bilibili.com/video/BV1xC4y1a72W?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV144411R7ch?spm_id_from=333.999.0.0)

```py
# 代码很简单，思路还不太好想

class Solution(object):
    def reconstructQueue(self, people):
        people = sorted(people, key=lambda x: (-x[0], x[1]))
        result = []
        for each in people:
            result.insert(each[1], each)
        return result

class Solution:
    def reconstructQueue(self, people):
        q = []
        for item in sorted(people, key=lambda x: (-x[0], x[1])):
            q.insert(item[1], item)
        return q

class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x:(-x[0], x[1]))
        res = []
        for p in people:
            res.insert(p[1], p)
        return res

class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x: (-x[0], x[1]))
        n = len(people)
        ans = list()
        for person in people:
            ans[person[1]:person[1]] = [person]
        return ans
```

###  1.186. <a name='ValidWordAbbreviation'></a>408. Valid Word Abbreviation

[小梦想家](https://www.bilibili.com/video/BV1A4411q74A?spm_id_from=333.999.0.0)

###  1.187. <a name='LongestPalindrome'></a>409. Longest Palindrome

[小梦想家](https://www.bilibili.com/video/BV1B441127W2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19C4y1479a?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Lk4y1z7PG?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.188. <a name='SplitArrayLargestSum'></a>410. Split Array Largest Sum

[花花酱](https://www.bilibili.com/video/BV14W411d7D4?spm_id_from=333.999.0.0)

###  1.189. <a name='FizzBuzz'></a>412. Fizz Buzz

[小梦想家](https://www.bilibili.com/video/BV1xE411R7yK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tD4y1m76j?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
object Solution {
    def fizzBuzz(n: Int): List[String] = {
        (1 to n).map(num => {
            if(num%15 == 0)
                "FizzBuzz"
            else if(num%5 == 0)
                "Buzz"
            else if(num%3 == 0)
                "Fizz"
            else
                num.toString
        }).toList
    }
}

```

###  1.190. <a name='-1'></a>413-等差数列划分

[哈哈哈](https://www.bilibili.com/video/BV13a4y1i7tR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13f4y167YZ?spm_id_from=333.999.0.0)

```py
# 双指针，不用递归不用动态规划，i代表数列起始位置，j代表数列终结位置，
# 如果不满足等差数列，就把i移动到j-1处，满足就计数（不是+1，而是＋j-i-1）

class Solution(object):
    def numberOfArithmeticSlices(self, nums):
        n=len(nums)
        if n<3:
            return 0
        i=0
        j=2
        c=0
        while(j<n):
            if j-i<2:
                j+=1
                continue
            if nums[j]-nums[j-1]==nums[j-1]-nums[j-2]:
                c+=j-i-1
                j+=1
            else:
                i=j-1
        return c

class Solution:
    def numberOfArithmeticSlices(self, nums):
        n = len(nums)
        dp = [0]*n
        for i in range(2,n):
            dp[i] = dp[i-1]+1 if nums[i]-nums[i-1]==nums[i-1]-nums[i-2] else 0
        return sum(dp)

class Solution:
    def numberOfArithmeticSlices(self, nums):
        if len(nums) < 3: return 0
        dp = [0] * len(nums)
        for i in range(2, len(nums)):
            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:
                # 如果能和前两位数字组成等差数列
                # 以i为结尾的数字可以和前两位组成新的等差数列（1个）
                # 以i-1位置数字为结尾的等差数列加上i位置的数字可以组成新的等差数列（dp[i-1]）
                # 因此以i位置数字结尾的等差数列为上面两种等差数列数量的和
                dp[i] = dp[i-1] + 1
        return sum(dp)

class Solution:
    def numberOfArithmeticSlices(self, nums):
        i, res = 0, 0
        while i <= len(nums)-3:
            j = i + 1
            differ = nums[j] - nums[i]
            while j + 1 < len(nums) and nums[j+1] - nums[j] == differ:
                j += 1
            
            res += (j - i) * (j - i - 1) // 2
            i = j

        return res

class Solution:
    def numberOfArithmeticSlices(self, nums):
        if len(nums)<3:return 0
        ans=0
        lenth=2
        nums[0]=nums[1]-nums[0]
        for i in range(2,len(nums)):
            nums[i-1]=nums[i]-nums[i-1]
            if nums[i-1]==nums[i-2]:
                lenth+=1
            elif lenth>2:
                ans+=(lenth-2)*(lenth-1)//2
                lenth=2
            else:
                lenth=2
        if lenth>2:
            return (lenth-2)*(lenth-1)//2+ans
        return ans
```

###  1.191. <a name='ThirdMaximumNumber'></a>414. Third Maximum Number

[小梦想家](https://www.bilibili.com/video/BV1UE411X7k1?spm_id_from=333.999.0.0)

###  1.192. <a name='AddStrings'></a>415-Add Strings

[哈哈哈](https://www.bilibili.com/video/BV18E411n7Cy?spm_id_from=333.999.0.0)

###  1.193. <a name='PartitionEqualSubsetSum'></a>416. Partition Equal Subset Sum

[花花酱](https://www.bilibili.com/video/BV1AW411y7So?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oZ4y1G7QY?spm_id_from=333.999.0.0)

```py
# python 一行：
from functools import reduce 
class Solution(object):
    def canPartition(self, s):
        return 1-sum(s)%2==reduce(lambda x,y:x|(x<<y), s, 1)>>sum(s)//2&1
# 思路很简单，就是每次循环拿一个数字，在和既有的求和结果组合。

# 但是能想到这个是真的厉害。牛逼。 我把字典换成集合，加了点注释

class Solution:
    # 讨论区看到的一种解法，很巧妙。
    def canPartition(self, nums: List[int]) -> bool:
        # 常规判定
        if len(nums) < 2:
            return  False

        ac = sum(nums)
        if ac % 2 == 1:
            return  False

        res_ = ac / 2
        # 利用集合记录各种组合下来的和
        d = set()
        #最开始，什么都不取。这也是为了后面，对应不取某个数字的操作
        d.add(0)
        # 顺次取数字
        for num in nums:
            # 和既有的和操作，key = 0时，说明不取这个数，
            for k in list(d):
                r = num + k
                # 每次判定是否达标
                if r == res_:
                    return True
                # 计算的和加入字典
                d.add(r)
        return False

class Solution(object):
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        if not nums or len(nums) == 0:
            return True
        if sum(nums) % 2 != 0: ## 总和必须为偶数，否则肯定无法取两个集合的sum相等
            return False
        half_sum = sum(nums)//2
        dp = [False] * (half_sum+1)
        dp[0] = True
        for i in range(len(nums)):
            for j in range(half_sum, nums[i]-1, -1):
                dp[j] = dp[j] or dp[j-nums[i]]
        print(dp)
        return dp[half_sum]

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        taraget = sum(nums)
        if taraget % 2 == 1: return False
        taraget //= 2
        dp = [0] * 10001
        for i in range(len(nums)):
            for j in range(taraget, nums[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
        return taraget == dp[taraget]
# 可以看成重量和价值都为nums的01背包问题

class Solution(object):
    def canPartition(self, nums):
        sums = sum(nums)
        if sums%2==1:
            return False
        sums= sums//2
        dp = [0 for i in range(sums+1)]
        for i in range(1,len(nums)+1):
            for j in range(sums,0,-1):
                if j>=nums[i-1]:
                    dp[j] = max(dp[j],dp[j-nums[i-1]]+nums[i-1])
        return dp[-1]==sums

# python递归...

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        # @lru_cache(None)
        def dp(i,N):                                #dp(i,N)返回nums[0...i]中且当前和为N的状态下，能否凑成和为target的结果
            if N>target or i<0:return False
            if N==target:return True
            return dp(i-1,N+nums[i]) or dp(i-1,N)   #每次可以选择将nums[i]加进N，或者不将nums[i]加进N

        if sum(nums)%2!=0:return False              #目标和为奇数时不能分割成两个元素相等的子集
        target=sum(nums)//2                         #原问题等价于将nums划分为元素和为nums一半的两个子集的划分方式是否存在
        return dp(len(nums)-1,0)
```

```py

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 2:
            return False
        
        total = sum(nums)
        if total % 2 != 0:
            return False
        
        target = total // 2
        dp = [True] + [False] * target
        for i, num in enumerate(nums):
            for j in range(target, num - 1, -1):
                dp[j] |= dp[j - num]
        
        return dp[target]
```

###  1.194. <a name='PacificAtlanticWaterFlow'></a>417. Pacific Atlantic Water Flow

[花花酱](https://www.bilibili.com/video/BV1Kb411K7ty?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1by4y1h7ab?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.195. <a name='BattleshipsinaBoard'></a>419. Battleships in a Board 

[小梦想家](https://www.bilibili.com/video/BV1TJ411j7QZ?spm_id_from=333.999.0.0)

###  1.196. <a name='MaximumXORofTwoNumbersinanArray'></a>421 Maximum XOR of Two Numbers in an Array

[小明](https://www.bilibili.com/video/BV1s64y1F7Wm?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMaximumXOR(self, nums):
        # 最高位的二进制位编号为 30
        HIGH_BIT = 30

        x = 0
        for k in range(HIGH_BIT, -1, -1):
            seen = set()
            # 将所有的 pre^k(a_j) 放入哈希表中
            for num in nums:
                # 如果只想保留从最高位开始到第 k 个二进制位为止的部分
                # 只需将其右移 k 位
                seen.add(num >> k)

            # 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分
            # 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1
            x_next = x * 2 + 1
            found = False
            
            # 枚举 i
            for num in nums:
                if x_next ^ (num >> k) in seen:
                    found = True
                    break

            if found:
                x = x_next
            else:
                # 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0
                # 即为 x = x*2
                x = x_next - 1
        
        return x

class Solution(object):
    def findMaximumXOR(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        answer = 0
        for i in range(32)[::-1]:
            answer <<= 1
            prefixes = {num >> i for num in nums}
            answer += any(answer^1 ^ p in prefixes for p in prefixes)
        return answer
```

###  1.197. <a name='ReconstructOriginalDigitsfromEnglish'></a>423 Reconstruct Original Digits from English

[小明](https://www.bilibili.com/video/BV1554y1h73S?spm_id_from=333.999.0.0)

###  1.198. <a name='LongestRepeatingCharacterReplacem'></a>424. 替换后的最长重复字符 Longest Repeating Character Replacem

[官方](https://www.bilibili.com/video/BV14r4y1K7rN?spm_id_from=333.999.0.0)

###  1.199. <a name='N-aryTreeLevelOrderTraversal'></a>429. N-ary Tree Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1CE411Q7BQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Uv411K77M?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.200. <a name='FlattenaMultilevelDoublyLinkedList'></a>430 Flatten a Multilevel Doubly Linked List

[小明](https://www.bilibili.com/video/BV1754y1q7Kb?spm_id_from=333.999.0.0)

###  1.201. <a name='AllOoneDataStructure'></a>432. All O`one Data Structure

[花花酱](https://www.bilibili.com/video/BV1XW411d7qR?spm_id_from=333.999.0.0)

###  1.202. <a name='Non-overlappingIntervals'></a>435-Non-overlapping Intervals

[哈哈哈](https://www.bilibili.com/video/BV1i7411p7pv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ak4y1U7f8?spm_id_from=333.999.0.0)

```py
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0:
            return 0
        intervals.sort(key = lambda x:x[1])
        res = 0
        current = intervals[0][1]
        for i in intervals[1:]:
            if i[0] >= current:
                current = i[1]
            else:
                current = min(i[1], current)
                res += 1
        return res

# 最难想通的其实是根据哪个边界排序，看了题解里大佬的理解，

# 想象成参加活动，影响你参加更多活动的是活动的结束时间，

# 只有上一个活动结束了，才能参加下一个，

# 即上一个活动的结束时间要小于下一个活动的开始时间。


class Solution(object):
    def eraseOverlapIntervals(self, intervals):
  
        if not intervals:
            return 0
        intervals.sort(key=lambda x:x[1])
        l=len(intervals)
        count=1
        end=intervals[0][1]
        for i in range(1,l):
            if intervals[i][0]>=end:
                count+=1
                end=intervals[i][1]
        return l-count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0: return 0
        intervals.sort(key=lambda x: x[1])
        count = 1 # 记录非交叉区间的个数
        end = intervals[0][1] # 记录区间分割点
        for i in range(1, len(intervals)):
            if end <= intervals[i][0]:
                count += 1
                end = intervals[i][1]
        return len(intervals) - count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        right = intervals[0][1]
        ans = 1

        for i in range(1, n):
            if intervals[i][0] >= right:
                ans += 1
                right = intervals[i][1]
        
        return n - ans

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort()
        n = len(intervals)
        f = [1]

        for i in range(1, n):
            f.append(max((f[j] for j in range(i) if intervals[j][1] <= intervals[i][0]), default=0) + 1)

        return n - max(f)
```


###  1.203. <a name='FindRightInterval'></a>436 Find Right Interval

[小明](https://www.bilibili.com/video/BV1YT4y1w7EP?spm_id_from=333.999.0.0)

###  1.204. <a name='PathSumIII'></a>437 Path Sum III

[小明](https://www.bilibili.com/video/BV1tZ4y1M7JR?spm_id_from=333.999.0.0)

###  1.205. <a name='FindAllAnagramsinaString'></a>438. Find All Anagrams in a String

[花花酱](https://www.bilibili.com/video/BV1iW411d7Nb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1254y1X7HV?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
* chosen solution
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/
object Solution0 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }
    ret.toList
  }
}

/**
* my first commit
* sliding window + hashMap within windows
* time complexity: O(NM): N: s.length, M: p.length
*/

object Solution1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap

     s.sliding(p.length).zipWithIndex.filter{ case (c, _) => pMap == c.groupBy(identity).mapValues(_.length).toMap}.map(_._2).toList
  }
}


/**
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/

object Solution2 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }

    ret.toList
  }
}

/**
* sliding window - two hashmap version
* using a mutable map storing current window's string element and amount
* time complexity: O(N)
* space complexity: O(2N) -> two hashMap
*/

object Solution2-1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap
    val sMap = scala.collection.mutable.Map[Char, Int]()
    val result = scala.collection.mutable.ListBuffer[Int]()

    for((char, right) <- s.zipWithIndex) {
      sMap.put(char, sMap.getOrElse(char, 0) + 1)

      if(right >= p.length) {
        val leftChar = s(right - p.length)
        sMap.get(leftChar) match {
          case Some(e) if e == 1 => sMap.remove(leftChar)
          case Some(e) => sMap.update(leftChar, e - 1)
          case _ =>
        }
      }
      if(pMap.equals(sMap)) result += (right - p.length + 1)
    }
    result.toList
  }
}

```

###  1.206. <a name='ArrangingCoins'></a>441 Arranging Coins

[小明](https://www.bilibili.com/video/BV1eV411k7rg?spm_id_from=333.999.0.0)

###  1.207. <a name='FindAllDuplicatesinanArray'></a>442 Find All Duplicates in an Array

[小明](https://www.bilibili.com/video/BV1Lh411d7AD?spm_id_from=333.999.0.0)

###  1.208. <a name='StringCompression'></a>443. String Compression

[小梦想家](https://www.bilibili.com/video/BV1rE411f7Ld?spm_id_from=333.999.0.0)

###  1.209. <a name='AddTwoNumbersII'></a>445-Add Two Numbers II

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7Qz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pt4y1m78o?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17a4y1s7BG?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.210. <a name='NumberofBoomerangs'></a>447. Number of Boomerangs

[小梦想家](https://www.bilibili.com/video/BV1hE411o7V2?spm_id_from=333.999.0.0)

###  1.211. <a name='FindAllNumbersDisappearedinanArray'></a>448. Find All Numbers Disappeared in an Array

[小梦想家](https://www.bilibili.com/video/BV1SE411d7FM?spm_id_from=333.999.0.0)

###  1.212. <a name='SerializeandDeserializeBST'></a>449. Serialize and Deserialize BST

[花花酱](https://www.bilibili.com/video/BV1ab411c75V?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1r7FT?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.213. <a name='DeleteNodeinaBST'></a>450. Delete Node in a BST

[花花酱](https://www.bilibili.com/video/BV1XW411d7yU?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1YK4y1h7Mw?spm_id_from=333.999.0.0)

```py
# python 极简递归

class Solution(object):
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        if not root: return None;
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        else:
            if not root.left or not root.right: # 出口就是
                root = root.left if root.left else root.right # 出口就是，删除root
            else:
                cur = root.right # 找到右子树最小值
                while cur.left: cur = cur.left # 找到右子树最小值
                root.val = cur.val # 找到右子树最小值 的值
                root.right = self.deleteNode(root.right, cur.val)  # 删除最小值
            
        return root;

# 不考虑平衡的话可以简单粗暴一些。

# 假如要删除的不是根节点，转为递归子问题。

# 假如删除的是根节点且左子树为空，返回右子树即可。

# 假如删除的是根节点且左子树非空，找到左子树中最大的节点（其必然是没有右子树的），

# 将根节点的右子树作为其右子树即可。

def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
    if not root:
        return None
    if root.val > key:
        root.left = self.deleteNode(root.left, key)
    elif root.val < key:
        root.right = self.deleteNode(root.right, key)
    elif not root.left:
        root = root.right
    else:
        p = root.left
        while p.right:
            p = p.right
        p.right = root.right
        root = root.left
    return root
```

```py
# 分享一个最高128ms，20.66%的沙比方法，原理就是打印除了key以外的排序树，然后生成一个只有右子树的排序树输出

class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        a=[]
        def f(r):
            if not r:return
            f(r.left)
            if r.val!=key:
                a.append(r.val)
            f(r.right)
        f(root)
        n=len(a)
        if not a:
            return 
        r=TreeNode(a[0])
        ans=r
        for i in range(1,n):
            r.right=TreeNode(a[i])
            r=r.right
        return ans
# 但这个复杂度不满足要求啊，虽然这个思路挺有意思
# 这实际就没实现删除节点这个功能，只是把结果找到了
```

###  1.214. <a name='SortCharactersByFrequency'></a>451 Sort Characters By Frequency

[小明](https://www.bilibili.com/video/BV18v411z7iy?spm_id_from=333.999.0.0)

###  1.215. <a name='SumII'></a>454 4Sum II

[小明](https://www.bilibili.com/video/BV1ny4y1D7UL?spm_id_from=333.999.0.0)

###  1.216. <a name='MinimumNumberofArrowstoBurstBalloons'></a>452. Minimum Number of Arrows to Burst Balloons

[花花酱](https://www.bilibili.com/video/BV1bW411d77B?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1PZ4y1L7VM?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.217. <a name='AssignCookies'></a>455-Assign Cookies

[哈哈哈](https://www.bilibili.com/video/BV157411s7b9?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1YE411r7UN?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.218. <a name='Pattern'></a>456 132 Pattern

[小明](https://www.bilibili.com/video/BV18f4y1i734?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1SZ4y1x74J?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.219. <a name='PoorPigs'></a>458 Poor Pigs

[小明](https://www.bilibili.com/video/BV1g5411576M?spm_id_from=333.999.0.0)

###  1.220. <a name='RepeatedSubstringPattern'></a>459 Repeated Substring Pattern

[小明](https://www.bilibili.com/video/BV1Yt4y1S7XZ?spm_id_from=333.999.0.0)

###  1.221. <a name='LFUCacheO1'></a>460. LFU Cache / O(1)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7PR?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1Xb411c7m7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kA41147t8?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.222. <a name='HammingDistance'></a>461 Hamming Distance

[小明](https://www.bilibili.com/video/BV1M5411Y79g?spm_id_from=333.999.0.0)

###  1.223. <a name='IslandPerimeter'></a>463 Island Perimeter

[小明](https://www.bilibili.com/video/BV16V41167bF?spm_id_from=333.999.0.0)

###  1.224. <a name='CanIWin'></a>464. Can I Win

[花花酱](https://www.bilibili.com/video/BV1KW411o7m2?spm_id_from=333.999.0.0)

###  1.225. <a name='CountTheRepetitions'></a>466. 统计重复个数 Count The Repetitions

[官方](https://www.bilibili.com/video/BV1Qk4y1678m?spm_id_from=333.999.0.0)

###  1.226. <a name='ValidateIPAddress'></a>468 Validate IP Address

[小明](https://www.bilibili.com/video/BV1tg4y1q7Kq?spm_id_from=333.999.0.0)

###  1.227. <a name='ImplementRand10UsingRand7'></a>470. Implement Rand10() Using Rand7()

[花花酱](https://www.bilibili.com/video/BV1Ut411Z7KX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AD4y1m7Qb?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.228. <a name='Heaters'></a>475. Heaters

[小梦想家](https://www.bilibili.com/video/BV1vJ41117VH?spm_id_from=333.999.0.0)

###  1.229. <a name='NumberComplement'></a>476. Number Complement

[花花酱](https://www.bilibili.com/video/BV1PW411y7mv?spm_id_from=333.999.0.0)

###  1.230. <a name='TotalHammingDistance'></a>477. Total Hamming Distance

[花花酱](https://www.bilibili.com/video/BV1SW411r78m?spm_id_from=333.999.0.0)

```py
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        s_nums = [bin(s)[2:].rjust(32, "0") for s in nums]
        res = 0
        for item in zip(*s_nums):
            res += item.count("1") * item.count("0")
        return res

# 第一想法就是暴力，直接超时
class Solution(object): # 此法超时
    def totalHammingDistance(self, nums):
        """
        :type nums: List[int]
        :rtype
        """
        res = 0
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                res += bin(nums[i]^nums[j]).count('1')
        return res
class Solution(object): # 此法超时
    def totalHammingDistance(self, nums):
        """
        :type nums: List[int]
        :rtype
        """
        return sum(b.count('0') * b.count('1') for b in zip(*map('{:032b}'.format, nums)))
```

```py
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        res, n = 0, len(nums)
        for i in range(32):
            cnt_1 = 0
            for j in range(n):
                cnt_1 += (nums[j] >> i) & 1
            res += (n - cnt_1) * cnt_1
        return res 

class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(30):
            c = sum(((val >> i) & 1) for val in nums)
            ans += c * (n - c)
        return ans

class Solution(object):
    def totalHammingDistance(self, nums):
        """
        :type nums: List[int]
        :rtype
        """
        # iterate thru "column" or bit position
        # Note: you could stop at 10^9 as stated in the problem if you want to optimize
        res = 0
        for i in range(32):
            mask = 1 << i
            count_ones, count_zeros = 0, 0
            for num in nums:
                if num & mask != 0:
                    count_ones += 1
                else:
                    count_zeros += 1
            res += count_ones * count_zeros
        return res

class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        c0,c1,sm=0,0,0
        for i in range(31):
            c0=c1=0
            for n in nums:
                if (n>>i)&1:
                    c1+=1
                else:
                    c0+=1
            sm+=c0*c1
        return sm
```


###  1.231. <a name='GenerateRandomPointinaCircle'></a>478 Generate Random Point in a Circle

[小明](https://www.bilibili.com/video/BV1Nz4y127a1?spm_id_from=333.999.0.0)

###  1.232. <a name='SlidingWindowMedian'></a>480. Sliding Window Median

[花花酱](https://www.bilibili.com/video/BV15W411C7iy?spm_id_from=333.999.0.0)

###  1.233. <a name='FindPermutation'></a>484 Find Permutation

[小明](https://www.bilibili.com/video/BV1NT4y1L76i?spm_id_from=333.999.0.0)

###  1.234. <a name='MaxConsecutiveOnes'></a>485. Max Consecutive Ones

[小梦想家](https://www.bilibili.com/video/BV1zJ411R7SJ?spm_id_from=333.999.0.0)

###  1.235. <a name='PredicttheWinner'></a>486. Predict the Winner

[花花酱](https://www.bilibili.com/video/BV1kW411d7R2?spm_id_from=333.999.0.0)

###  1.236. <a name='TheMaze'></a>490 The Maze

[小明](https://www.bilibili.com/video/BV1az4y1f7Hn?spm_id_from=333.999.0.0)

###  1.237. <a name='TargetSum'></a>494. Target Sum

[花花酱](https://www.bilibili.com/video/BV1WW411C7Mp?spm_id_from=333.999.0.0)

[花花酱 下](https://www.bilibili.com/video/BV1WW411C7Mr?spm_id_from=333.999.0.0)

```py
# 思路

# 每个数，只有取正、取负数，这两种处理。因此可以做深度优先遍历，为了避免重复计算，加上记忆法。

# DFS 到 nums[i] 时，取正数，则要求后面的数，处理后的 next_target = current_target - nums[i];
# 取负数的处理同上，后续要处理的 next_target = current_target + nums[i]；
# 用 python 语法糖简单演示下：

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        # @lru_cache(None)
        def dfs(startIdx, sum) -> int:
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return dfs(startIdx + 1, sum - nums[startIdx]) + dfs(startIdx + 1, sum + nums[startIdx])

        return dfs(0, target)

# @lru_cache(None) 好神奇，瞬间提高效率
# 如果不用@lru_cache(None)，用这种方式会超时，Java的就不会啊
# 同样的解法，Java 不超时是因为 Java 运行速度比 Python 快得多。
# 而 Python 如果不用 lru_cache 或者显式的记忆数组存储 dfs 的结果，
# 大量重复计算会导致超时，因为 Python 运行速度慢

# DFS

class Solution:
    def findTargetSumWays(self, nums: List[int], V) -> int:
        def dfs(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum==0 else 0
            res = 0
            res += dfs(sum-nums[startIdx], startIdx+1)
            res += dfs(sum+nums[startIdx], startIdx+1)
            return res
        return dfs(V, 0)


# 递归，findSum(s, start_idx) 函数的意思是从start_index开始向后的子集合能有几种得到s的方法

class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S
        :rtype
        """
        def findSum(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return findSum(sum+nums[startIdx], startIdx+1) + findSum(sum-nums[startIdx], startIdx+1)
        return findSum(S, 0)
# 但是这样会超时，所以用cache 记一下

# ```python
class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S
        :rtype
        """
        def findSum(s, start_idx):
            if start_idx == len(nums):
                return 1 if s == 0 else 0
            if (s, start_idx) not in cache:
                cache[(s, start_idx)] = findSum(s+nums[start_idx], start_idx+1) + findSum(s-nums[start_idx], start_idx+1)
            return cache[(s, start_idx)]
            
        cache = {}
        return findSum(S, 0)
```

```py
#  0-1背包

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        s = sum(nums)
        if (target+s)&1: return 0
        
        V = (target+s) >> 1
        f = [1] + [0]*V
        for n in nums:
            for i in range(V, n-1, -1):
                f[i] += f[i-n]
        return f[-1]

class Solution:
    def findTargetSumWays(self, nums, target) -> int:
        tmp=sum(nums)-target
        if tmp<0 or tmp&1:return 0
        neg=tmp>>1
        dp=[1]+[0]*neg
        for num in nums:
            for j in range(neg,num-1,-1):
                dp[j]+=dp[j-num]
        return dp[-1]
# 感觉用sum-target返回0会剪枝更多 速度稍微快那么一点点

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        sumValue = sum(nums)
        if target > sumValue or (sumValue + target) % 2 == 1: return 0
        bagSize = (sumValue + target) // 2
        dp = [0] * (bagSize + 1)
        dp[0] = 1
        for i in range(len(nums)):
            for j in range(bagSize, nums[i] - 1, -1):
                dp[j] += dp[j - nums[i]]
        return dp[bagSize]

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        if not nums or sum(nums) < target or (sum(nums) + target)%2 == 1:
            return 0

        s = (sum(nums)+target)//2 #只一个子集，使得子集和为s

        # 对于每一个数都有加入和不加入两种情况，因此可以使用背包问题的方法求解
        marp = [0 for _ in range(s+1)]
        marp[0] = 1 #当i - num =0也就是这个数加入/不加入正好可以满足要求时，解法为1（这个地方确实想了很久，看了题解）
        for num in nums:
            for i in range(s,num-1,-1):#参考背包问题的自顶向下
                marp[i] = marp[i]+marp[i - num]

        return marp[-1]

# 官方的动态规划
class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        total = sum(nums)
        neg = total - target
        if neg < 0 or neg % 2 == 1:
            return 0
        neg = neg // 2
        dp = [[0] * (neg + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            num = nums[i - 1]
            for j in range(neg + 1):
                dp[i][j] += dp[i - 1][j]
                if j >= num:
                    dp[i][j] += dp[i - 1][j - num]
        return dp[-1][-1]

# 二维数组的外层循环，一般不都是从0到nums.length-1吗，为什么这里是从1到nums.length+1，百思不得其解
class Solution(object):
    def findTargetSumWays(self, nums, target):
        """
        :type nums: List[int]
        :type target
        :rtype
        """
        su = sum(nums)

        """
        su_data - du_data = target
        su_data + du_data = su 
        2 * su_data = target + su 
        su_data = (target + su) / 2

        dp[i][j] 前i个数中（包含i），加和等于j
        """

        if (su + target) % 2 == 1 or su < target: return 0

        new_target = (su - target) // 2

        dp = [[0 for _ in  range(new_target + 1)] for _ in range(len(nums) + 1)] 
        dp[0][0] = 1

        for i in range(1, len(nums) + 1):
            u = nums[i-1]
            for j in range(0, new_target + 1):
                if j >= u:
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-u]
                else:
                    dp[i][j] = dp[i-1][j]

        return dp[len(nums)][new_target]
```

###  1.238. <a name='TeemoAttacking'></a>495 Teemo Attacking

[小明](https://www.bilibili.com/video/BV1LK4y1Y75e?spm_id_from=333.999.0.0)

###  1.239. <a name='INextGreaterElementI'></a>496. 下一个更大元素 I (Next Greater Element I)

[洛阳](https://www.bilibili.com/video/BV1Ce411W7pW?spm_id_from=333.999.0.0)

###  1.240. <a name='RandomPointinNon-overlapping'></a>497 Random Point in Non-overlapping

[小明](https://www.bilibili.com/video/BV12K4y1Y7r6?spm_id_from=333.999.0.0)

###  1.241. <a name='KeyboardRow'></a>500. Keyboard Row

[小梦想家](https://www.bilibili.com/video/BV1vJ411X7BR?spm_id_from=333.999.0.0)

###  1.242. <a name='NextGreaterElementII'></a>503-Next Greater Element II

[哈哈哈](https://www.bilibili.com/video/BV197411L77N?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1k5411t7Pa?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.243. <a name='Base7'></a>504-Base 7

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7o5?spm_id_from=333.999.0.0)

###  1.244. <a name='FibonacciNumber'></a>509. Fibonacci Number

[1:30 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15y4y147Re?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
* chosen solution
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution0 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* iterative - bottom up with memorization
* time complexity O(N)
* space complexity O(N)
*/

object Solution1 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1
        (2 to N).foreach(n => cache(n) = cache(n -1) + cache(n -2))
        cache(N)
    }
}

/**
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution1-2 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* recursive - top-down with memorization
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution2 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1

        def _fib(n: Int):Int = {
            if(n <= 1) return n
            
            if(cache(n) != 0) cache(n)
            else {
                cache(n) = _fib(n-1) + _fib(n-2)
                cache(n)
            }
        }
        _fib(N)
        
    }
}



/**
* recursive version - bottom up
* time complexity: O(2^N）
* space complexity: O(N)
*/

object Solution3 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
           fib(N - 1) + fib(N - 2)
        }
    }
}


/**
* matrix operation with pow operation
* memo
*   n > 1
*   | fn   |    | 1  1  |^ (n -1)  | 1 |
*   | fn-1 |  = | 1  0  |          | 1 |
* time complexity: O(logN)
* space complexity: O(logN) due to stack size
*/
object Solution4 {
  def fib(N: Int): Int = {
    if (N <= 1) return N

    val matrix = Array.ofDim[Int](2, 2)
    matrix(0)(0) = 1
    matrix(0)(1) = 1
    matrix(1)(0) = 1
    matrix(1)(1) = 0

    val identityMatrix = Array.tabulate(2, 2) {
      case (i, j) if i == j => 1
      case _ => 0
    }
    val retMatrix = matrixPow(identityMatrix, matrix, N - 1)
    retMatrix(0)(0)
  }

  @annotation.tailrec
  def matrixPow(current: Array[Array[Int]], base: Array[Array[Int]], pow: Int): Array[Array[Int]] = {
    if (pow == 0) current
    else {
      if ((pow & 1) == 1) {
        val newCurrent = multiply(current, base)
        val newBase = multiply(base, base)

        matrixPow(newCurrent, newBase, pow / 2)
      } else {
        val newBase = multiply(base, base)
        matrixPow(current, newBase, pow / 2)
      }
    }

  }

  def multiply(a: Array[Array[Int]], b: Array[Array[Int]]): Array[Array[Int]] = {
    val a00 = a(0)(0) * b(0)(0) + a(0)(1) * b(1)(0)
    val a01 = a(0)(0) * b(0)(1) + a(0)(1) * b(1)(1)
    val a10 = a(1)(0) * b(0)(0) + a(1)(1) * b(1)(0)
    val a11 = a(1)(0) * b(0)(1) + a(1)(1) * b(1)(1)
    a(0)(0) = a00
    a(0)(1) = a01
    a(1)(0) = a10
    a(1)(1) = a11
    a
  }
}
```

###  1.245. <a name='LongestPalindromicSubsequence'></a>516. Longest Palindromic Subsequence

[花花酱](https://www.bilibili.com/video/BV18W411d7k2?spm_id_from=333.999.0.0)

###  1.246. <a name='CoinChange2'></a>518 Coin Change 2

[小明](https://www.bilibili.com/video/BV1jC4y1a7YT?spm_id_from=333.999.0.0)

###  1.247. <a name='DetectCapital'></a>520. Detect Capital

[小梦想家](https://www.bilibili.com/video/BV1NJ41197da?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xT4y1j7G4?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.248. <a name='ContiguousArray'></a>525. Contiguous Array

[花花酱](https://www.bilibili.com/video/BV14W411d7SD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV185411t7tu?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.249. <a name='BeautifulArrangement'></a>526 Beautiful Arrangement

[小明](https://www.bilibili.com/video/BV1DK411M7QR?spm_id_from=333.999.0.0)

###  1.250. <a name='RandomPickwithWeight'></a>528 Random Pick with Weight

[小明](https://www.bilibili.com/video/BV1UV411r7MK?spm_id_from=333.999.0.0)

###  1.251. <a name='MinimumAbsoluteDifferenceinBST'></a>530. Minimum Absolute Difference in BST

[花花酱](https://www.bilibili.com/video/BV1fW411k7eT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1FJ41147BB?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.252. <a name='K-diffPairsinanArray'></a>532 K-diff Pairs in an Array

[小明](https://www.bilibili.com/video/BV1MV41127o1?spm_id_from=333.999.0.0)

###  1.253. <a name='EncodeandDecodeTinyURL'></a>535. Encode and Decode TinyURL

[小梦想家](https://www.bilibili.com/video/BV1hb411e7zp?spm_id_from=333.999.0.0)

###  1.254. <a name='ComplexNumberMultiplicatin'></a>537 Complex Number Multiplicatin

[小明](https://www.bilibili.com/video/BV1sP4y1p7Px?spm_id_from=333.999.0.0)

###  1.255. <a name='ConvertBSTtoGreaterTree'></a>538 Convert BST to Greater Tree

[小明](https://www.bilibili.com/video/BV1k541177bt?spm_id_from=333.999.0.0)

###  1.256. <a name='SingleElementinaSortedArray540-'></a>540. Single Element in a Sorted Array 540-有序数组中的单一元素

[花花酱](https://www.bilibili.com/video/BV1gW411y7N3?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1P64y1F7cd?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Tg4y1B7Va?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.257. <a name='Matrix'></a>542. 01 矩阵 01 Matrix 

[官方](https://www.bilibili.com/video/BV1cZ4y1s727?spm_id_from=333.999.0.0)

###  1.258. <a name='DiameterofBinaryTree'></a>543 Diameter of Binary Tree

[小明](https://www.bilibili.com/video/BV12K4y1r78T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qA411t7LR?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.259. <a name='RemoveBoxes'></a>546 Remove Boxes

[花花酱](https://www.bilibili.com/video/BV11W411Z7jG?spm_id_from=333.999.0.0)

###  1.260. <a name='-1'></a>547-朋友圈

[哈哈哈](https://www.bilibili.com/video/BV1Ta411F7rk?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala


/**
* union & find: implement both union by rank and path compression
* time complexity : 
*   in union & find each op:
*           find: very very close to O(1) amortized
*           union: very very close to O(1) amortized
*   the entire ：
*       O(n + M), n is node size, M is the times we call Union operation which cause O(1) 
*       n (constructor) + M (call union times)
*/

object Solution1 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    unionFind.counter

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)
  var counter = M

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
    counter -= 1
  }
}

/**
* union & find: without counter in union&find to record current cluster
*       O(n + M + n), n is node size, M is the times we call Union operation which cause O(1) 
*       n (construct union & find ) + M (call union times)  + n (n time call findRoot)
*/
object Solution1-2 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    M.indices.map(unionFind.findRoot).distinct.size

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
  }
}


```

###  1.261. <a name='BrickWall'></a>554 Brick Wall

[小明](https://www.bilibili.com/video/BV1mo4y1f7wc?spm_id_from=333.999.0.0)

###  1.262. <a name='NextGreaterElementIII'></a>556 Next Greater Element III

[小明](https://www.bilibili.com/video/BV19t4y167yb?spm_id_from=333.999.0.0)

###  1.263. <a name='SubarraySumEqualsKK'></a>560. Subarray Sum Equals K 和为K的子数组

[花花酱](https://www.bilibili.com/video/BV1XW411d71i?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d54y127ri?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vK4y1k7ku?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV13t4y1y7ya?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.264. <a name='BinaryTreeTilt'></a>563 Binary Tree Tilt

[小明](https://www.bilibili.com/video/BV1KV41117ho?spm_id_from=333.999.0.0)

###  1.265. <a name='PermutationinString567-'></a>567. Permutation in String 567-字符串的排列

[花花酱](https://www.bilibili.com/video/BV14W411d7g6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1z54y1C7qB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV175411E761?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1154y1X7qB?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala


/**
* my first commitment: sliding window: hashcode with build-in sliding method
*/
object Solution1 {
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1Length = s1.length
      val s1Hash = s1.groupBy(identity).mapValues(_.length).toMap.hashCode

      s2.sliding(s1Length).exists(seq => seq.groupBy(identity).mapValues(_.length).toMap.hashCode == s1Hash)
    }
}


/**
* optimize from 1-1 : maintain sliding window and hashmap by my self
* time complexity: O(s1.length + s2.length)
* space complexity: O(s1.distinct.length)
*/
object Solution1-2 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1HashCode = s1.groupBy(identity).mapValues(_.length).toMap.hashCode
      val s2Map = mutable.Map.empty[Char, Int]
      
      (0 until s2.length).exists {
        case idx if idx < s1.length =>
          val char = s2(idx)
          mapIncrement(s2Map, char)
          s2Map.hashCode == s1HashCode
        case idx => 
          val rightChar = s2(idx)
          val leftChar = s2(idx - s1.length)
          mapIncrement(s2Map, rightChar)
          mapDecrement(s2Map, leftChar) 
          s2Map.hashCode == s1HashCode
      }
    }
    def mapIncrement(map: mutable.Map[Char, Int], char: Char): Unit = {
      map.get(char) match {
            case Some(v) => map.update(char, v + 1)
            case None => map.update(char, 1)
      }
    }
    def mapDecrement(map: mutable.Map[Char, Int], char: Char) = map.get(char) match {
      case Some(v) if v == 1 => map.remove(char)
      case Some(v) => map.update(char, v - 1)
      case None =>
    }
}

/**
* sliding windows: using only 1 map to record differential
* 1. if diff map is empty, s2 contains the permutation of s1
* 2. initial map with foreach instead of groupBy witch is time consuming
* time complexity (l1 + l2)
*/
object Solution1-3 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val diffMap = mutable.Map.empty[Char, Int]
      s1.foreach(mapUpdate(diffMap, _, 1))
      
      (0 until s2.length).exists {case idx =>
        if (idx >= s1.length) {
          val leftChar = s2(idx - s1.length)
          mapUpdate(diffMap, leftChar, 1)
        }
        val rightChar = s2(idx)
        mapUpdate(diffMap, rightChar, -1)
        diffMap.isEmpty
      }
    }
    def mapUpdate(map: mutable.Map[Char, Int], char: Char, value: Int): Unit = {
      map.get(char) match {
            case Some(v) if v + value == 0 => map.remove(char)
            case Some(v) => map.update(char, v + value)
            case None => map.update(char, value)
      }
    }
}
```

###  1.266. <a name='-1'></a>572-另一个树的子树

[哈哈哈](https://www.bilibili.com/video/BV1cA411t7zD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1wt4y197aB?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.267. <a name='DistributeCandies'></a>575 Distribute Candies

[小明](https://www.bilibili.com/video/BV11i4y1T7Pr?spm_id_from=333.999.0.0)

###  1.268. <a name='OutofBoundaryPaths'></a>576. Out of Boundary Paths

[花花酱](https://www.bilibili.com/video/BV18W411d7Cf?spm_id_from=333.999.0.0)

###  1.269. <a name='ShortestUnsortedContinuousSuba'></a>581 Shortest Unsorted Continuous Suba

[小明](https://www.bilibili.com/video/BV1Y54y1h7Xa?spm_id_from=333.999.0.0)

###  1.270. <a name='N-aryTreePreorderTraversal'></a>589 N-ary Tree Preorder Traversal

[小明](https://www.bilibili.com/video/BV1io4y1f7qT?spm_id_from=333.999.0.0)

###  1.271. <a name='ValidSquare'></a>593 Valid Square

[小明](https://www.bilibili.com/video/BV1j5411V73U?spm_id_from=333.999.0.0)

###  1.272. <a name='LongestHarmoniousSubsequence'></a>594 Longest Harmonious Subsequence

[小明](https://www.bilibili.com/video/BV1Pp4y1p7ss?spm_id_from=333.999.0.0)

###  1.273. <a name='CanPlaceFlowers'></a>605 Can Place Flowers

[小明](https://www.bilibili.com/video/BV1Uz4y1k7xU?spm_id_from=333.999.0.0)

### 611

```py
# 双指针

class Solution:
    # 双指针
    def triangleNumber(self, nums):
        nums.sort()
        n = len(nums)
        count = 0
        for c in range(2, n):
            a, b = 0, c-1
            while a < b:
                if nums[a] + nums[b] <= nums[c]:
                    a += 1
                else:
                    count += b - a 
                    b -= 1
        return count

class Solution(object):
    def triangleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)[::-1]
        res = 0
        for i in range(len(nums)-2):
            j, k = i + 1, len(nums) - 1
            while j < k:
                if nums[k] + nums[j] > nums[i]:
                    res += k - j
                    j += 1                
                else:
                    k -= 1
        return res

class Solution:
    def triangleNumber(self, nums):
        nums.sort()
        res = 0
        # 从大到小遍历
        for i in range(len(nums) - 1, 1, -1):
            l, r = 0, i -1
            while l < r:
                # 只要较小的两个值之和大于最大的值，则一定可组成三角形
                if nums[l] + nums[r] > nums[i]:
                    #i, r 和从l到r-1都可组成三角形，个数为 (r-1) - l + 1 = r - l
                    res += (r-1) - l + 1
                    r -= 1
                else: l += 1
        return res

class Solution:
    def triangleNumber(self, nums):
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n):
            k = i
            for j in range(i + 1, n):
                while k + 1 < n and nums[k + 1] < nums[i] + nums[j]:
                    k += 1
                ans += max(k - j, 0)
        return ans

class Solution:
    def triangleNumber(self, nums):
        nums.sort()
        res = 0
        for k in range(len(nums)):
            i, j = 0, k - 1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    res += j - i
                    j -= 1
                else:
                    i += 1
        return res
```

###  1.274. <a name='TaskScheduler'></a>621. Task Scheduler

[花花酱](https://www.bilibili.com/video/BV1Wt411Y7Y9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1LZ4y1M7Bg?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.275. <a name='DesignCircularQueue'></a>622 Design Circular Queue

[小明](https://www.bilibili.com/video/BV1kV411n7Uk?spm_id_from=333.999.0.0)

###  1.276. <a name='AddOneRowtoTree'></a>623 Add One Row to Tree

[小明](https://www.bilibili.com/video/BV1AK4y1U7ud?spm_id_from=333.999.0.0)

###  1.277. <a name='SumofSquareNumbers'></a>633-Sum of Square Numbers

[哈哈哈](https://www.bilibili.com/video/BV1a7411h7on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qh411i7Yh?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.278. <a name='ExclusiveTimeofFunctions'></a>636. Exclusive Time of Functions

[花花酱](https://www.bilibili.com/video/BV1PW411o7Bh?spm_id_from=333.999.0.0)

###  1.279. <a name='AverageofLevelsinBinaryTree'></a>637 Average of Levels in Binary Tree

[小明](https://www.bilibili.com/video/BV1eb4y1976M?spm_id_from=333.999.0.0)

###  1.280. <a name='DecodeWaysII'></a>639. Decode Ways II

[花花酱](https://www.bilibili.com/video/BV1YW411r75q?spm_id_from=333.999.0.0)

###  1.281. <a name='MaximumAverageSubarrayI'></a>643. Maximum Average Subarray I

[小梦想家](https://www.bilibili.com/video/BV1dV411k7i6?spm_id_from=333.999.0.0)

###  1.282. <a name='-1'></a>645-错误的集合

[哈哈哈](https://www.bilibili.com/video/BV1az411e7zU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1479j?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.283. <a name='-1'></a>646-最长数对链

[哈哈哈](https://www.bilibili.com/video/BV1rz411q7pZ?spm_id_from=333.999.0.0)

```py
# python3 贪心

class Solution:
    def findLongestChain(self, pairs):
        length = len(pairs)
        if length<=1:
            return length
        pairs = sorted(pairs, key=lambda x:x[1])
        pre = -1
        res = 0
        for i in range(length):
            if pre == -1:
                pre = i
                res += 1
            elif pairs[i][0] > pairs[pre][1]:
                pre = i
                res += 1
        return res

# python3, 贪心思想，具体参看附加上的归类的两道题的思路：

class Solution:
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x: (x[1], x[0]))
        count = 0
        end = -float('inf')
        for i, p in enumerate(pairs):
            if p[0] > end:
                count += 1
                end = p[1]
        return count 

class Solution(object):
    def findLongestChain(self, pairs):
        """
        :type pairs: List[List[int]]
        :rtype: int
        """
        if not pairs or len(pairs) == 0:
            return 0
        pairs = sorted(pairs, key=lambda x:x[0])
        dp = [1] * len(pairs)
        for i in range(1, len(pairs)):
            for j in range(i):
                dp[i] = max(dp[i], dp[j] + 1 if pairs[i][0] > pairs[j][1] else dp[j])
        return dp[-1]

class Solution(object):
    def findLongestChain(self, pairs):
        """
        :type pairs: List[List[int]]
        :rtype: int
        """
        if not pairs or len(pairs) == 0:
            return 0
        cur, res = float('-inf'), 0
        for p in sorted(pairs, key=lambda x: x[1]):
            if cur < p[0]: cur, res = p[1], res + 1
        return res
# 条件反射python3

class Solution:
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x:x[0])
        dp = []
        for i in range(len(pairs)):
            dp.append(1)
            for j in range(i):
                if pairs[i][0] > pairs[j][1]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return dp[-1]

import operator
class Solution(object):
    def findLongestChain(self, pairs):
        cur, ans = float('-inf'), 0
        for x, y in sorted(pairs, key = operator.itemgetter(1)):
            if cur < x:
                cur = y
                ans += 1
        return ans
```

###  1.284. <a name='PalindromicSubstrings'></a>647 Palindromic Substrings

[小明](https://www.bilibili.com/video/BV1g54y1h7uv?spm_id_from=333.999.0.0)

```py
# python无敌啊！！！有没有天理啊，手动滑稽😏😏😏😏！一行解法：
# ```python
import os
class Solution(object):
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype
        """
        return sum(len(os.path.commonprefix((s[:i][::-1], s[i:]))) 
                   + len(os.path.commonprefix((s[:i][::-1], s[i + 1:]))) + 1 
                        for i in range(len(s)))
# ```
# 解释下为啥要加两次，因为回文串有以下两种形式：
# - ‘abcba’
# - 'abba'

# 那为啥要加那个1呢，上面解释过了，单个字符也算是一个回文子串呀，嘻嘻😁

class Solution(object):
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype
        """
        '''
        双指针太暴力了吧
        '''
        cnt = 0
        for i in range(0,len(s)):
            for j in range(i+1,len(s)+1):
                # print(s[i:j])
                if s[i:j] == s[i:j][::-1]:
                    cnt += 1
        return cnt
```

```py
# 我傻了，看到范围1000，直接上On方 的解法了。
# 应对笔试不考虑空间复杂度，就直接dp动态规划了，
# 按照最长回文子串的思路，怎么写得快，怎么来。。。

class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[True] * n for _ in range(n)]
        ans = 0
        for d in range(n):
            for x in range(n):
                y = x + d
                if y >= n:
                    break
                if d == 0:
                    dp[x][y] = True
                elif d == 1:
                    dp[x][y] = (s[x] == s[y])
                else:
                    dp[x][y] = dp[x+1][y-1] and (s[x] == s[y])
                if dp[x][y]:
                    ans += 1
        return ans
```

```py
# 动态规划：

class Solution:
    def countSubstrings(self, s: str) -> int:
        dp = [[False] * len(s) for _ in range(len(s))]
        result = 0
        for i in range(len(s)-1, -1, -1): #注意遍历顺序
            for j in range(i, len(s)):
                if s[i] == s[j]:
                    if j - i <= 1: #情况一 和 情况二
                        result += 1
                        dp[i][j] = True
                    elif dp[i+1][j-1]: #情况三
                        result += 1
                        dp[i][j] = True
        return result

# 动态规划：简洁版

class Solution:
    def countSubstrings(self, s: str) -> int:
        dp = [[False] * len(s) for _ in range(len(s))]
        result = 0
        for i in range(len(s)-1, -1, -1): #注意遍历顺序
            for j in range(i, len(s)):
                if s[i] == s[j] and (j - i <= 1 or dp[i+1][j-1]): 
                    result += 1
                    dp[i][j] = True
        return result

class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        res = 0
        for i in range(n):
            for j in range(i, -1, -1):
                if s[i] == s[j] and (i - j + 1 <= 2 or dp[i - 1][j + 1]):
                    #print(i,j)
                    dp[i][j] = 1
                if dp[i][j]:res += 1
        return res
class Solution:
    def countSubstrings(self, s: str) -> int:
        n=len(s)
        dp = [[0]*n for i in range(n)]
        for i in range(n):
            dp[i][i]=1
        ans = n
        for i in range(n):
            for j in range(i-1,-1,-1):
                if s[j]==s[i] and dp[j+1][i-1]==i-j-1:
                    dp[j][i] = dp[j+1][i-1]+2
                    ans+=1
        return ans
```


```py
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        self.res = 0

        def helper(i, j):
            while i >= 0 and j < n and s[i] == s[j]:
                self.res += 1
                i -= 1
                j += 1

        for i in range(n):
            helper(i, i)
            helper(i, i + 1)
        return self.res
# 暴力，中心扩展

class Solution:
    def countSubstrings(self, s: str) -> int:
        length = len(s)
        if length == 0:return 0
        count = 0
        def centerExpand(left,right):
            cnt = 0
            while left >= 0 and right < length:
                if s[left] == s[right]:
                    cnt += 1
                    left -= 1
                    right += 1
                else:
                    return cnt
            return cnt
        for i in range(length):
            count += centerExpand(i,i)
            count += centerExpand(i,i+1)
        return count
# 双指针法：

class Solution:
    def countSubstrings(self, s: str) -> int:
        result = 0
        for i in range(len(s)):
            result += self.extend(s, i, i, len(s)) #以i为中心
            result += self.extend(s, i, i+1, len(s)) #以i和i+1为中心
        return result
    
    def extend(self, s, i, j, n):
        res = 0
        while i >= 0 and j < n and s[i] == s[j]:
            i -= 1
            j += 1
            res += 1
        return res
# python 每个位置向两端搜索

class Solution:
    def countSubstrings(self, s: str) -> int:
        def extend(i, j, s):
            count = 0
            while i >= 0 and j < len(s) and s[i] == s[j]:
                count += 1
                i -= 1
                j += 1
            return count

        count = 0
        m = len(s)
        for i in range(m):
            count += extend(i, i, s)
            count += extend(i, i+1, s)
        return count
# Python3中心扩展法非常简洁代码

# 直接利用中心扩展法, 依次计数找到的所有的回文子串即可；
# 无需在字符串中插入特殊字符, center中心位置从0到最后一个元素移动,

# 每次移动0.5, 表示移动到当前元素与下一个元素中间作为中心。
### 代码
from math import floor,ceil
class Solution:
    def countSubstrings(self, s: str) -> int:
        center = ans = 0
        while center < len(s):
            low, high = floor(center), ceil(center)
            while low >=0 and high < len(s) and s[low] == s[high]:
                low, high, ans = low-1, high+1, ans+1
            center += 0.5
        return ans
```

###  1.285. <a name='-1'></a>650-只有两个键的键盘

[哈哈哈](https://www.bilibili.com/video/BV1254y1z7ze?spm_id_from=333.999.0.0)

###  1.286. <a name='FindDuplicateSubtrees'></a>652. Find Duplicate Subtrees

[花花酱](https://www.bilibili.com/video/BV1cW411y7d1?spm_id_from=333.999.0.0)

###  1.287. <a name='TwoSumIV'></a>653. Two Sum IV

[小梦想家](https://www.bilibili.com/video/BV1Qz4y197h1?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AQ4y117mc?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.288. <a name='MaximumWidthofBinaryTree'></a>662. Maximum Width of Binary Tree

[花花酱](https://www.bilibili.com/video/BV1cv411q7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16a4y1h7fG?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.289. <a name='BeautifulArrangementII'></a>667 Beautiful Arrangement II

[小明](https://www.bilibili.com/video/BV1j54y1b7Br?spm_id_from=333.999.0.0)

###  1.290. <a name='KthSmallestNumberinMultiplicationTable'></a>668. Kth Smallest Number in Multiplication Table

[花花酱](https://www.bilibili.com/video/BV17W411C7ai?spm_id_from=333.999.0.0)

###  1.291. <a name='TrimaBinarySearchTree'></a>669 Trim a Binary Search Tree

[小明](https://www.bilibili.com/video/BV19y4y1J7fu?spm_id_from=333.999.0.0)

###  1.292. <a name='NumberofLongestIncreasingSubse'></a>673 Number of Longest Increasing Subse

[小明](https://www.bilibili.com/video/BV1gT4y1F7y3?spm_id_from=333.999.0.0)

###  1.293. <a name='ValidParenthesisString'></a>678 Valid Parenthesis String

[小明](https://www.bilibili.com/video/BV1ap4y1X7nu?spm_id_from=333.999.0.0)

###  1.294. <a name='ValidPalindromeII'></a>680-Valid Palindrome II

[哈哈哈](https://www.bilibili.com/video/BV167411h7x1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y147xn?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.295. <a name='KEmptySlots'></a>683. K Empty Slots

[花花酱](https://www.bilibili.com/video/BV1Jb411k7Yu?spm_id_from=333.999.0.0)

###  1.296. <a name='RedundantConnection684-'></a>684. Redundant Connection 684-冗余连接

[花花酱](https://www.bilibili.com/video/BV1mt411J79j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1oe411p7qF?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.297. <a name='RedundantConnectionII'></a>685. Redundant Connection II

[花花酱](https://www.bilibili.com/video/BV1St411J7Ur?spm_id_from=333.999.0.0)

###  1.298. <a name='LongestUnivaluePath'></a>687. Longest Univalue Path

[花花酱](https://www.bilibili.com/video/BV1wt411r7Pr?spm_id_from=333.999.0.0)

###  1.299. <a name='KnightProbabilityinChessboard'></a>688. Knight Probability in Chessboard

[花花酱](https://www.bilibili.com/video/BV1Hb411c7mu?spm_id_from=333.999.0.0)

###  1.300. <a name='EmployeeImportance'></a>690. Employee Importance

[花花酱](https://www.bilibili.com/video/BV1Ut411J7uC?spm_id_from=333.999.0.0)

###  1.301. <a name='TopKFrequentWords'></a>692. Top K Frequent Words

[花花酱](https://www.bilibili.com/video/BV1Mt41137eL?spm_id_from=333.999.0.0)

### 693

```py
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while n:
            prenum = (n//2) & 1 # 背一背，和16进制差不多
            nownum = n%2
            if prenum == nownum:
                return False
            n>>=1
        return True

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while n:
            x = n & 1 # 如果两个相应位都为1,则该位的结果为1
            n>>=1 # 把">>"左边的运算数的各二进位全部右移1位
            y = n & 1
            if x==y:
                return False
        return True

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        tmp = str(bin(n))[2:]
        res = [tmp[i] != tmp[i-1] for i in range(1, len(tmp))]
        return all(res)

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        return not ('11' in str(bin(n)) or '00' in str(bin(n)))

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        return not('11' in bin(n) or '00' in bin(n))

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        n = str(bin(n))[2:]
        for i in range(0, len(n)-1):
            if n[i] == n[i+1]:
                return False
        return True

# bin()本身返回的就是字符串

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        b = n >> 1
        res = bin(b^n)[2:]
        if '0' in res:
            return False
        else:
            return True
```

###  1.302. <a name='-1'></a>695-岛屿的最大面积

[哈哈哈](https://www.bilibili.com/video/BV1s54y1B77k?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wz4y1R7e6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1k64y1c798?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.303. <a name='CountBinarySubstrings'></a>696 Count Binary Substrings

[小明](https://www.bilibili.com/video/BV14p4y1b7nV?spm_id_from=333.999.0.0)

###  1.304. <a name='FallingSquares'></a>699. Falling Squares

[花花酱](https://www.bilibili.com/video/BV1Lt41137EM?spm_id_from=333.999.0.0)

###  1.305. <a name='SearchinaBinarySearchTree'></a>700 Search in a Binary Search Tree

[小明](https://www.bilibili.com/video/BV14z411e76U?spm_id_from=333.999.0.0)

###  1.306. <a name='InsertintoaBinarySearchTree'></a>701 Insert into a Binary Search Tree

[小明](https://www.bilibili.com/video/BV1q54y1k76s?spm_id_from=333.999.0.0)

###  1.307. <a name='KthLargestElementinaStreamK'></a>703.Kth Largest Element in a Stream数据流中的第K大元素

[图灵](https://www.bilibili.com/video/BV1g5411w7o8?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
* using min heap
*/
class KthLargest(_k: Int, _nums: Array[Int]) {
    private val pq = scala.collection.mutable.PriorityQueue.empty[Int](Ordering[Int].reverse)
    val k = _k
    _nums.foreach(add)


    def add(`val`: Int): Int = {
        if (pq.size < k)
            /* if only add one element at once, += is more effective than enqueue op */
            pq += `val`
            // pq.enqueue(`val`)
        else if(pq.head < `val`){
            pq.dequeue
            pq += `val`
            // pq.enqueue(`val`)
        }
        // println(pq.clone.dequeueAll)
        pq.head
               
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(`val`)
 */
```

###  1.308. <a name='BinarySearch'></a>704.Binary Search二分查找

[图灵](https://www.bilibili.com/video/BV1Dh411v7yT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qa4y157E4?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala

/**
* my first commitment:
* time complexity: O(logn)
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        println(left, right)
        val mid: Int = left  + (right - left) / 2
        if(nums(mid) == target){
          ans = mid
        } else if(target > nums(mid)) {
          left = mid + 1
        } else {
          right = mid - 1
        }
 
      }
      ans
    }
}

/**
* recursive version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
        search(nums, target, 0, nums.length - 1)
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      
      val mid = left + (right - left) / 2
      if (nums(mid) == target) 
        mid
      else if (target > nums(mid))
        search(nums, target, mid + 1, right)
      else 
        search(nums, target, left, right - 1)
      
    }
}
```

###  1.309. <a name='DesignHashSet'></a>705 Design HashSet

[小明](https://www.bilibili.com/video/BV1hV411z73p?spm_id_from=333.999.0.0)

###  1.310. <a name='DesignHashMap'></a>706. Design HashMap设计哈希映射

[图灵](https://www.bilibili.com/video/BV1Ho4y1Q7cr?spm_id_from=333.999.0.0)

###  1.311. <a name='DesignLinkedList'></a>707. Design Linked List

[花花酱](https://www.bilibili.com/video/BV1yW411Z7dV?spm_id_from=333.999.0.0)

###  1.312. <a name='MinimumASCIIDeleteSumforTwoStrings'></a>712. Minimum ASCII Delete Sum for Two Strings

[花花酱](https://www.bilibili.com/video/BV17W411d7m2?spm_id_from=333.999.0.0)

###  1.313. <a name='SubarrayProductLessThanK'></a>713 Subarray Product Less Than K

[小明](https://www.bilibili.com/video/BV1T5411j7tC?spm_id_from=333.999.0.0)

###  1.314. <a name='-1'></a>714-买卖股票的最佳时机含手续费

[哈哈哈](https://www.bilibili.com/video/BV1WK4y1E7mP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1t54y187Qy?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
/**
* my first commitment
* dynamic programming
*     dp(i)(j) means the best profit we can have at i-th day in different state un-holding stock or holding a share of stock.
* 
*  memo:
*    this problem is similar to problem no 122
*  time complexity: O(N)
*  space complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        if(prices == null || prices.isEmpty) return 0
        
        /*
        *  0 for un-holding any stack
        *  1 for holding a share of stock
        */
        val dp = Array.tabulate(prices.length, 2) {
            case (0, 0) => 0
            case (0, 1) => -prices(0)
            case _ => 0
        }
        
        // 0: without holding, 1 holding
        for(i <- 1 until prices.length) {
            /** only pay the transition fee in selling a share of stock */
            dp(i)(0) = dp(i - 1)(0) max (dp(i - 1)(1) + prices(i) - fee)
            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i))
        }
        dp.last(0) // last time's state 0
        
    }
}

/**
* dynamic programming: only create an array keeping holding and un-holding
* time complexity: O(N)
* space complexity:  O(1)
*/
object Solution1-1 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        if(prices == null || prices.isEmpty) return 0
        val dp = Array.ofDim[Int](2)
        dp(0) = 0
        dp(1) = -prices(0)
        // 0 un-holding, 1 holding
        for(i <- 1 until prices.length){
        /*
        * it may causes a problem here, because we overwrite the previous dp(0) by new state i value and dp(1) would utilizes dp(0) which was overwritten 
        */
            dp(0) = dp(0) max (dp(1) + prices(i) - fee)
            dp(1) = dp(1) max (dp(0) - prices(i))
        }
        dp(0)
    }
}

/**
* dynamic programming 
* function programming
*/
object Solution2 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        val (unholding, holding) = prices.foldLeft((0, Int.MinValue)){
            case ((unholding, holding), price) =>
            (
            // avoiding overflow
                if((price - fee) > 0) unholding max (holding + price - fee) else unholding,
                holding max (unholding - price)
            )
        }
        unholding
    }
}
```

###  1.315. <a name='RangeModule'></a>715. Range Module

[花花酱](https://www.bilibili.com/video/BV1jt411379W?spm_id_from=333.999.0.0)

###  1.316. <a name='FindK-thSmallestPairDistance'></a>719. Find K-th Smallest Pair Distance

[花花酱](https://www.bilibili.com/video/BV1zb411u7iP?spm_id_from=333.999.0.0)

###  1.317. <a name='LongestWordinDictionary'></a>720. Longest Word in Dictionary

[花花酱](https://www.bilibili.com/video/BV1vW411r75D?spm_id_from=333.999.0.0)

###  1.318. <a name='FindPivotIndex'></a>724. Find Pivot Index

[花花酱](https://www.bilibili.com/video/BV1KW411S7nG?spm_id_from=333.999.0.0)

###  1.319. <a name='SplitLinkedListinParts'></a>725. Split Linked List in Parts

[花花酱](https://www.bilibili.com/video/BV1KW411S7ti?spm_id_from=333.999.0.0)

###  1.320. <a name='NumberofAtoms'></a>726. Number of Atoms

[花花酱](https://www.bilibili.com/video/BV11W411U7KT?spm_id_from=333.999.0.0)

###  1.321. <a name='CountDifferentPalindromicSubsequences'></a>730. Count Different Palindromic Subsequences

[花花酱](https://www.bilibili.com/video/BV12W41167vQ?spm_id_from=333.999.0.0)

###  1.322. <a name='MyCalendarIII'></a>732. My Calendar III

[花花酱](https://www.bilibili.com/video/BV1fW411k75b?spm_id_from=333.999.0.0)

###  1.323. <a name='FloodFill'></a>733. 图像渲染 Flood Fill

[花花酱](https://www.bilibili.com/video/BV1yW41167S4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fp4y1v7Pn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1p7vH?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.324. <a name='AsteroidCollision'></a>735 Asteroid Collision

[小明](https://www.bilibili.com/video/BV1jT4y1F76n?spm_id_from=333.999.0.0)

###  1.325. <a name='SentenceSimilarityII'></a>737. Sentence Similarity II

[花花酱](https://www.bilibili.com/video/BV1qW41167iB?spm_id_from=333.999.0.0)

###  1.326. <a name='DailyTemperatures'></a>739-Daily Temperatures

[哈哈哈](https://www.bilibili.com/video/BV1Q7411L7w8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ov411z7rM?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.327. <a name='DeleteandEarn'></a>740. Delete and Earn

[24:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1xW41167b5?spm_id_from=333.999.0.0)

```py
# 动态规划。
from collections import Counter
class Solution:
    def deleteAndEarn(self, nums):
        # 统计每个数字出现的次数、去重、排序
        dic = Counter(nums)
        nums = list(set(nums))
        nums.sort()
        
        # dp[i][0]: nums[0：i+1]中，不删除nums[i]所能获得的最大点数
        # dp[i][1]: 删除nums[i]所能获得的最大点数和
        dp = [[0 for i in range(2)] for _ in range(len(nums))]
        dp[0][0] = 0
        dp[0][1] = nums[0] * dic[nums[0]]

        for i in range(1, len(dp)):
            if nums[i] - nums[i-1] == 1:
                # 与上一元素相差1，则删除nums[i]的情况dp[i][1]，依赖于不删除nums[i-1]的情况，即dp[i-1][0]。
                dp[i][1] = dp[i-1][0] + nums[i] * dic[nums[i]]
            else:
                # 上一元素是否删除，与当前状态无关，选取前一状态获得的最大点数。
                dp[i][1] = max(dp[i-1][0],dp[i-1][1]) + nums[i] * dic[nums[i]]
            # 不删除当前元素，直接取前一状态的最大值。
            dp[i][0] = max(dp[i-1][0],dp[i-1][1])
        
        return max(dp[-1])

# 次数统计 + 动态规划
from collections import Counter
class Solution:
    def deleteAndEarn(self, nums):
        count = Counter(nums)
        tmp = sorted(count)
        n = len(tmp)
        dp = [0]*(1+n) # dp[i] 表示的是在[tmp[0],...tmp[i-1]]能获得的最大点数
        dp[1] = tmp[0] * count[tmp[0]]

        for i in range(2, 1+n):
            dp[i] = max(dp[i-1], dp[i-2] + tmp[i-1] * count[tmp[i-1]])
            if tmp[i-1] - tmp[i-2] > 1:
                dp[i] = max(dp[i], dp[i-1] + tmp[i-1] * count[tmp[i-1]])
        
        return dp[-1]

# 先排序，后 DP

class Solution:
    def deleteAndEarn(self, nums):
        nums.sort()
        # dp[0] 表示当前数不选，dp[1] 表示当前数选。从第一个数向后辗转递推
        dp = [0, nums[0]]
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                # 如果当前数和前一个数相等，则在前一个被选择的条件下，再选当前数。
                dp[1] += nums[i]
            elif nums[i] == nums[i - 1] + 1:
                # 如果当前数和前一个数相差 1，则一种情况是前一个数没选的条件下，选择当前数；
                # 或者在前一个数被选择的条件下，舍弃掉当前数
                temp = dp[0]
                dp[0] = max(dp)  # 舍弃掉当前数
                dp[1] = temp + nums[i]  # 选择当前数
            else:
                # 如果当前数和前一个数相差大于 1，则一种情况是前一个数已选的条件下，舍弃当前数
                # 第二种情况是，前一个数已选的条件下，选择当前数；
                # 第三种情况是，前一个数未选的条件下，选择当前数；（该情况必然非最大，不用考虑）
                # 第四种情况是，前一个数未选的条件下，舍弃当前数；（同上，非最大，不用考虑）
                dp[0] = max(dp)
                dp[1] = dp[0] + nums[i]
        return max(dp)

# 让我们一起来帮助撬家人，然后用获得的点数去超商买些好吃的

class Solution:
    def deleteAndEarn(self, nums):
        max_num = max(nums)
        table = [0]*(max_num+1)
        for i in nums:
            table[i] += 1

        # dp[i][0]和dp[i][1]分别表示第i个数不选和选的最大所得
        # dp = [[0]*2 for _ in range(max_num+1)]

        # for i in range(1,max_num+1):
        #     dp[i][0] = max(dp[i-1][0],dp[i-1][1])
        #     # 选择第i个数 第i-1个数一定不选而且可以选走所有的i  
        #     dp[i][1] = dp[i-1][0] + i*table[i]

        # 优化一下空间
        dp_0,dp_1 = 0,0
        for i in range(1,max_num+1):
            dp_0,dp_1 = max(dp_0,dp_1),dp_0+i*table[i]
            
        return max(dp_0,dp_1)

class Solution(object):
    def deleteAndEarn(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [0] * 10001
        for num in nums:
            dp[num] += num
        for i in range(2, 10001):
            dp[i] = max(dp[i]+dp[i-2], dp[i-1])
        return dp[-1]
```

###  1.328. <a name='CherryPickup'></a>741. Cherry Pickup

[花花酱](https://www.bilibili.com/video/BV1tW41167jy?spm_id_from=333.999.0.0)

###  1.329. <a name='NetworkDelayTime'></a>743. Network Delay Time

[花花酱](https://www.bilibili.com/video/BV1UW411r7S8?spm_id_from=333.999.0.0)

###  1.330. <a name='PrefixandSuffixSearch'></a>745. Prefix and Suffix Search

[花花酱](https://www.bilibili.com/video/BV1TW411k7PY?spm_id_from=333.999.0.0)

###  1.331. <a name='MinCostClimbingStairs'></a>746. Min Cost Climbing Stairs

[7:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1VW411y7Dq?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.332. <a name='ShortestCompletingWord'></a>748. Shortest Completing Word

[花花酱](https://www.bilibili.com/video/BV15W411y7sJ?spm_id_from=333.999.0.0)

###  1.333. <a name='OpentheLock'></a>752. Open the Lock

[花花酱](https://www.bilibili.com/video/BV1NW411y74z?spm_id_from=333.999.0.0)

###  1.334. <a name='PartitionLabels'></a>763 Partition Labels

[小明](https://www.bilibili.com/video/BV1Ca4y177LW?spm_id_from=333.999.0.0)

###  1.335. <a name='CouplesHoldingHands'></a>765. 情侣牵手 Couples Holding Hands

[官方](https://www.bilibili.com/video/BV1pv411Y7wX?spm_id_from=333.999.0.0)

###  1.336. <a name='MaxChunksToMakeSorted'></a>769. Max Chunks To Make Sorted

[花花酱](https://www.bilibili.com/video/BV1LW411C7nD?spm_id_from=333.999.0.0)

###  1.337. <a name='JewelsandStones'></a>771 Jewels and Stones

[小明](https://www.bilibili.com/video/BV1RC4y1W7yH?spm_id_from=333.999.0.0)

###  1.338. <a name='SlidingPuzzle'></a>773. Sliding Puzzle

[花花酱](https://www.bilibili.com/video/BV1PW411o7g4?spm_id_from=333.999.0.0)

###  1.339. <a name='GlobalandLocalInversions'></a>775. Global and Local Inversions

[花花酱](https://www.bilibili.com/video/BV1JW411d75t?spm_id_from=333.999.0.0)

### 777

```py
# LR不能互相穿过
# R只能右移
# L只能左移
class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        # -----------去掉X,两个字符串应该相等-----------
        s = start.replace('X','')
        if s != end.replace('X',''):
            return False
        # -----------去掉X,两个字符串应该相等-----------

        # start中R的索引要小于等于end的
        # start中L的索引要大于等于end的
        d1 = [index for index,char in enumerate(start) if char !='X']
        d2 = [index for index,char in enumerate(end) if char !='X']


        for index,char in enumerate(s):
            # R 则start大于end的都是False
            if char == 'R' and d1[index] > d2[index]:
                return False
            if char == 'L' and d1[index] < d2[index]:
                return False

        return True

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        start = [(index, char) for index, char in enumerate(start) if char in ["L", "R"]]
        end = [(index, char) for index, char in enumerate(end) if char in ["L", "R"]]
        return len(start) == len(end) and all(c1 == c2 == "L" and i1 >= i2 or c1 == c2 == "R" and i1 <= i2 for (i1, c1), (i2, c2) in zip(start, end))

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        start_id = []
        print("enumerate: ", list(enumerate(start)))
        for i, c in enumerate(start):
            if c in ['L', 'R']:
                start_id.append((i, c))
                
        end_id = []
        for i, c in enumerate(end):
            if c in ['L', 'R']:
                end_id.append((i, c))
                
        if len(start_id) != len(end_id):
            return False
        
        for (i1, c1), (i2, c2) in zip(start_id, end_id):
            print("list(zipped): ",list(zip(start_id, end_id)))
            if c1 != c2:
                return False
            if c1 == c2 == 'L' and i1 < i2:
                return False
            if c1 == c2 == 'R' and i1 > i2:
                return False
        return True

class Solution:
    def canTransform(self, start, end):
        judge = lambda idxStart,idxEnd,f : len(idxStart)==len(idxEnd) and all(f(x,y) for x,y in zip(idxStart,idxEnd)) # f(x,y)是 lambda x,y
        # start和end 长度相等，且不能有 false
        # 如果满足if条件，则返回i
        gen = lambda string,char : [i for i in string if i in char] # char是'LR'
        # 如果满足if条件，则返回i
        genIdx = lambda string,char : [i for i in range(len(string)) if string[i] in char] # char是'L'或者 'R'
        return len(start)==len(end) and\
               gen(start,'LR')==gen(end,'LR') and \
               judge(genIdx(start,'L'),genIdx(end,'L'),lambda x,y:x>=y) and\
               judge(genIdx(start,'R'),genIdx(end,'R'),lambda x,y:x<=y)
```

###  1.340. <a name='SwiminRisingWater'></a>778. Swim in Rising Water

[花花酱](https://www.bilibili.com/video/BV1ab411k7TH?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kv4y1f7to?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.341. <a name='LetterCasePermutation'></a>784. Letter Case Permutation

[花花酱](https://www.bilibili.com/video/BV1wW411o7WK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sv411a7Gx?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.342. <a name='-1'></a>785-判断二分图

[哈哈哈](https://www.bilibili.com/video/BV1KQ4y1N72Z?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11r4y1P7Wr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1254y1i7Ut?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.343. <a name='K-thSmallestPrimeFraction'></a>786. K-th Smallest Prime Fraction

[花花酱](https://www.bilibili.com/video/BV1AW411o7oi?spm_id_from=333.999.0.0)

###  1.344. <a name='CheapestFlightsWithinKStops'></a>787. Cheapest Flights Within K Stops

[花花酱](https://www.bilibili.com/video/BV13W411o7wc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DZ4y1H7oH?spm_id_from=333.999.0.0)

```py

```

```py

```


###  1.345. <a name='DominoandTrominoTiling'></a>790. Domino and Tromino Tiling

[花花酱](https://www.bilibili.com/video/BV13W411o7AW?spm_id_from=333.999.0.0)

###  1.346. <a name='NumberofMatchingSubsequences'></a>792. Number of Matching Subsequences

[花花酱](https://www.bilibili.com/video/BV13W411o7Af?spm_id_from=333.999.0.0)

###  1.347. <a name='AllPathsFromSourcetoTarget'></a>797 All Paths From Source to Target

[小明](https://www.bilibili.com/video/BV1qa4y1E7sg?spm_id_from=333.999.0.0)

###  1.348. <a name='ChampagneTower'></a>799 Champagne Tower

[小明](https://www.bilibili.com/video/BV1Da411A7u5?spm_id_from=333.999.0.0)

###  1.349. <a name='MinimumSwapsToMakeSequencesIncreasing'></a>801. Minimum Swaps To Make Sequences Increasing

[花花酱](https://www.bilibili.com/video/BV1FW411o7tL?spm_id_from=333.999.0.0) 

###  1.350. <a name='BricksFallingWhenHit'></a>803. Bricks Falling When Hit 

[花花酱](https://www.bilibili.com/video/BV13W411o7kA?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xv411W74B?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.351. <a name='UniqueMorseCodeWords'></a>804 Unique Morse Code Words

[小明](https://www.bilibili.com/video/BV1RD4y1Q7AM?spm_id_from=333.999.0.0)

###  1.352. <a name='LargestSumofAverages'></a>813. Largest Sum of Averages

[花花酱](https://www.bilibili.com/video/BV1XW411d7RB?spm_id_from=333.999.0.0)

###  1.353. <a name='BusRoutes'></a>815. Bus Routes

[花花酱](https://www.bilibili.com/video/BV1QW411d794?spm_id_from=333.999.0.0)

###  1.354. <a name='LinkedListComponents'></a>817. Linked List Components

[花花酱](https://www.bilibili.com/video/BV1cW411o7Eu?spm_id_from=333.999.0.0)

###  1.355. <a name='RaceCar'></a>818. Race Car (上)

[花花酱](https://www.bilibili.com/video/BV1cW411o7Tb?spm_id_from=333.999.0.0)

###  1.356. <a name='ShortestDistancetoaCharacter'></a>821 Shortest Distance to a Character

[小明](https://www.bilibili.com/video/BV1gy4y1Y784?spm_id_from=333.999.0.0)

###  1.357. <a name='BinaryTreesWithFactors'></a>823. Binary Trees With Factors

[花花酱](https://www.bilibili.com/video/BV1CW411d7RX?spm_id_from=333.999.0.0)

###  1.358. <a name='GoatLatin'></a>824 Goat Latin

[小明](https://www.bilibili.com/video/BV1Th411o782?spm_id_from=333.999.0.0)

###  1.359. <a name='MakingALargeIsland'></a>827. Making A Large Island

[花花酱](https://www.bilibili.com/video/BV1mW411d7rc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Cg4117727?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.360. <a name='FlippinganImage'></a>832 Flipping an Image

[小明](https://www.bilibili.com/video/BV1q54y1r7f3?spm_id_from=333.999.0.0)

###  1.361. <a name='ImageOverlap'></a>835 Image Overlap

[小明](https://www.bilibili.com/video/BV1NK4y1a7Yf?spm_id_from=333.999.0.0)

###  1.362. <a name='New21Game'></a>837. 新 21 点 New 21 Game

[官方](https://www.bilibili.com/video/BV1Sz4y197cA?spm_id_from=333.999.0.0)

###  1.363. <a name='KeysandRooms'></a>841 Keys and Rooms

[小明](https://www.bilibili.com/video/BV1Wb4y1Q7hE?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1HK411F7JQ?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.364. <a name='SplitArrayintoFibonacciSequence'></a>842. Split Array into Fibonacci Sequence

[花花酱](https://www.bilibili.com/video/BV1ZJ411H7t4?spm_id_from=333.999.0.0)

###  1.365. <a name='BackspaceStringCompare'></a>844 Backspace String Compare

[小明](https://www.bilibili.com/video/BV1aC4y1s7LK?spm_id_from=333.999.0.0)

###  1.366. <a name='LongestMountaininArray'></a>845 Longest Mountain in Array

[小明](https://www.bilibili.com/video/BV1zi4y1L7yV?spm_id_from=333.999.0.0)

###  1.367. <a name='ShortestPathVisitingAllNodes'></a>847 Shortest Path Visiting All Nodes

[花花酱](https://www.bilibili.com/video/BV1hW411d7MU?spm_id_from=333.999.0.0)

###  1.368. <a name='MaximizeDistancetoClosestPerson'></a>849 Maximize Distance to Closest Person

[小明](https://www.bilibili.com/video/BV1ZZ4y1G7iT?spm_id_from=333.999.0.0)

###  1.369. <a name='ScoreofParentheses'></a>856. Score of Parentheses

[花花酱](https://www.bilibili.com/video/BV1bW411d7gp?spm_id_from=333.999.0.0)

###  1.370. <a name='MirrorReflection'></a>858 Mirror Reflection

[小明](https://www.bilibili.com/video/BV1av411r7MW?spm_id_from=333.999.0.0)

###  1.371. <a name='BuddyStrings'></a>859 Buddy Strings

[小明](https://www.bilibili.com/video/BV1nz4y1o7Wo?spm_id_from=333.999.0.0)

###  1.372. <a name='AllNodesDistanceKinBinaryTree'></a>863. All Nodes Distance K in Binary Tree

[花花酱](https://www.bilibili.com/video/BV14W411d7mz?spm_id_from=333.999.0.0)

###  1.373. <a name='ShortestPathtoGetAllKeys'></a>864. Shortest Path to Get All Keys

[花花酱](https://www.bilibili.com/video/BV1LW411d7th?spm_id_from=333.999.0.0)

###  1.374. <a name='ReorderedPowerof2'></a>869 Reordered Power of 2

[小明](https://www.bilibili.com/video/BV1M64y1D78v?spm_id_from=333.999.0.0)

###  1.375. <a name='SmallestSubtreewithalltheDeepestNodes'></a>865. Smallest Subtree with all the Deepest Nodes

[花花酱](https://www.bilibili.com/video/BV14W411d7ZR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CV41187ZA?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.376. <a name='MinimumNumberofRefuelingStops'></a>871. Minimum Number of Refueling Stops

[花花酱](https://www.bilibili.com/video/BV1JW411d7VK?spm_id_from=333.999.0.0)

###  1.377. <a name='LengthofLongestFibonacciSubsequence'></a>873. Length of Longest Fibonacci Subsequence

[花花酱](https://www.bilibili.com/video/BV1jW411d79H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ab411i7wx?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.378. <a name='KokoEatingBananas'></a>875.Koko Eating Bananas科科吃香蕉

[图灵](https://www.bilibili.com/video/BV1iV411s7eU?spm_id_from=333.999.0.0)

###  1.379. <a name='MiddleoftheLinkedList'></a>876.Middle of the Linked List 链表的中间结点

[图灵](https://www.bilibili.com/video/BV1Kv411p7vf?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Pz41187WS?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK411T74X?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.380. <a name='StoneGame'></a>877 Stone Game

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Hr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xq4y1Q7uL?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.381. <a name='ProfitableSchemes'></a>879. Profitable Schemes

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Jt?spm_id_from=333.999.0.0)

###  1.382. <a name='DecodedStringatIndex'></a>880 Decoded String at Index

[小明](https://www.bilibili.com/video/BV1Tt4y1k7GJ?spm_id_from=333.999.0.0)

###  1.383. <a name='BoatstoSavePeople'></a>881 Boats to Save People

[小明](https://www.bilibili.com/video/BV1MT4y1K7yq?spm_id_from=333.999.0.0)

###  1.384. <a name='ReachableNodesInSubdividedGraph'></a>882. Reachable Nodes In Subdivided Graph

[花花酱](https://www.bilibili.com/video/BV11W411Z71N?spm_id_from=333.999.0.0)

###  1.385. <a name='PossibleBipartition'></a>886. Possible Bipartition

[花花酱](https://www.bilibili.com/video/BV1DW411Z7G6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FT4y1g77u?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.386. <a name='SuperEggDrop'></a>887. Super Egg Drop

[花花酱](https://www.bilibili.com/video/BV1Tv411i7cP?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ri4y1t78d?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.387. <a name='ConstructBinaryTreefromPreorderandPostorder'></a>889. Construct Binary Tree from Preorder and Postorder

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Qi?spm_id_from=333.999.0.0)

###  1.388. <a name='SumofSubsequenceWidths'></a>891. Sum of Subsequence Widths

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Yv?spm_id_from=333.999.0.0)

###  1.389. <a name='AllPossibleFullBinaryTrees'></a>894. All Possible Full Binary Trees

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Sb?spm_id_from=333.999.0.0)

###  1.390. <a name='MaximumFrequencyStack'></a>895. Maximum Frequency Stack

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Hp?spm_id_from=333.999.0.0)

###  1.391. <a name='BitwiseORsofSubarrays'></a>898. Bitwise ORs of Subarrays

[花花酱](https://www.bilibili.com/video/BV1kW411Z7HV?spm_id_from=333.999.0.0)

###  1.392. <a name='OnlineStockSpan'></a>901. Online Stock Span

[花花酱](https://www.bilibili.com/video/BV1kW411k77K?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Jg4y1B74H?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.393. <a name='NumbersAtMostNGivenDigitSet'></a>902 Numbers At Most N Given Digit Set

[小明](https://www.bilibili.com/video/BV19A411j7Wf?spm_id_from=333.999.0.0)

###  1.394. <a name='-1'></a>904-水果成篮

[哈哈哈](https://www.bilibili.com/video/BV19i4y1M7Xn?spm_id_from=333.999.0.0)

###  1.395. <a name='SortArrayByParity'></a>905 Sort Array By Parity

[小明](https://www.bilibili.com/video/BV1Xk4y117rK?spm_id_from=333.999.0.0)

###  1.396. <a name='SuperPalindromes'></a>906 Super Palindromes

[小明](https://www.bilibili.com/video/BV1LA41157Wf?spm_id_from=333.999.0.0)

###  1.397. <a name='SnakesandLadders'></a>909. Snakes and Ladders

[小梦想家](https://www.bilibili.com/video/BV1cy4y1W7u9?spm_id_from=333.999.0.0)

###  1.398. <a name='SmallestRangeII'></a>910 Smallest Range II

[小明](https://www.bilibili.com/video/BV1p5411H7mS?spm_id_from=333.999.0.0)

###  1.399. <a name='WordSubsetse'></a>916 Word Subsetse

[小明](https://www.bilibili.com/video/BV1vh411S7r3?spm_id_from=333.999.0.0)

###  1.400. <a name='MaximumSumCircularSub'></a>918 Maximum Sum Circular Sub

[小明](https://www.bilibili.com/video/BV1c5411s7jZ?spm_id_from=333.999.0.0)

###  1.401. <a name='SumWithMultiplicity'></a>923. 3Sum With Multiplicity 

[花花酱](https://www.bilibili.com/video/BV14t411o7QT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pv41187sq?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.402. <a name='FlipStringtoMonotoneIncreasing'></a>926. Flip String to Monotone Increasing

[花花酱](https://www.bilibili.com/video/BV1ft411R7qv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Vh411i7Wg?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.403. <a name='-1'></a>930-和相同的二元子数组(滑动窗口+前缀和)

[哈哈哈](https://www.bilibili.com/video/BV1iy4y1T7M3?spm_id_from=333.999.0.0)

###  1.404. <a name='NumberofRecentCalls'></a>933 Number of Recent Calls

[小明](https://www.bilibili.com/video/BV1gA41177jm?spm_id_from=333.999.0.0)

###  1.405. <a name='ShortestBridge'></a>934. Shortest Bridge

[花花酱](https://www.bilibili.com/video/BV19t411y7rL?spm_id_from=333.999.0.0)

###  1.406. <a name='StampingTheSequence'></a>936 Stamping The Sequence

[小明](https://www.bilibili.com/video/BV1d64y1D7fq?spm_id_from=333.999.0.0)

###  1.407. <a name='RangeSumofBST'></a>938 Range Sum of BST

[小明](https://www.bilibili.com/video/BV1WV411a7VR?spm_id_from=333.999.0.0)

###  1.408. <a name='ValidMountainArray'></a>941 Valid Mountain Array

[小明](https://www.bilibili.com/video/BV1n5411G7qs?spm_id_from=333.999.0.0)

###  1.409. <a name='FindtheShortestSuperstring'></a>943. Find the Shortest Superstring

[花花酱](https://www.bilibili.com/video/BV1yt411171k?spm_id_from=333.999.0.0)

###  1.410. <a name='Python-'></a>946-Python-栈的压入、弹出序列

[哈哈哈](https://www.bilibili.com/video/BV1JD4y1o7ZD?spm_id_from=333.999.0.0)

###  1.411. <a name='ValidateStackSequences'></a>946 Validate Stack Sequences

[小明](https://www.bilibili.com/video/BV1fz4y1y7rS?spm_id_from=333.999.0.0)

###  1.412. <a name='MostStonesRemovedwithSame'></a>947. 移除最多的同行或同列石头 Most Stones Removed with Same

[官方](https://www.bilibili.com/video/BV1Nr4y1K7Gj?spm_id_from=333.999.0.0)

###  1.413. <a name='BagofTokens'></a>948 Bag of Tokens

[小明](https://www.bilibili.com/video/BV1MK411P7K6?spm_id_from=333.999.0.0)

###  1.414. <a name='LargestTimeforGivenDigits'></a>949 Largest Time for Given Digits

[小明](https://www.bilibili.com/video/BV13v41117QS?spm_id_from=333.999.0.0)

###  1.415. <a name='LargestComponentSizebyCommo'></a>952 Largest Component Size by Commo

[小明](https://www.bilibili.com/video/BV1oK4y1h7Jt?spm_id_from=333.999.0.0)

###  1.416. <a name='VerifyinganAlienDictionary'></a>953 Verifying an Alien Dictionary

[小明](https://www.bilibili.com/video/BV1C64y1S7tT?spm_id_from=333.999.0.0)

###  1.417. <a name='ArrayofDoubledPairs'></a>954 Array of Doubled Pairs

[小明](https://www.bilibili.com/video/BV1Hq4y1S7xR?spm_id_from=333.999.0.0)

###  1.418. <a name='RegionsCutBySlashes'></a>959. 由斜杠划分区域 Regions Cut By Slashes

[官方](https://www.bilibili.com/video/BV1Ry4y117HD?spm_id_from=333.999.0.0)

###  1.419. <a name='LeastOperatorstoExpressNumber'></a>964. Least Operators to Express Number

[花花酱](https://www.bilibili.com/video/BV1Pt411k7qn?spm_id_from=333.999.0.0)

###  1.420. <a name='VowelSpellchecker'></a>966 Vowel Spellchecker

[小明](https://www.bilibili.com/video/BV1oK4y1T7kR?spm_id_from=333.999.0.0)

###  1.421. <a name='NumbersWithSameConsecutiveDifferences'></a>967. Numbers With Same Consecutive Differences

[花花酱](https://www.bilibili.com/video/BV1gt411B7oG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.422. <a name='BinaryTreeCameras'></a>968 Binary Tree Cameras

[小明](https://www.bilibili.com/video/BV1Q5411u72B?spm_id_from=333.999.0.0)

###  1.423. <a name='PancakeSorting'></a>969 Pancake Sorting

[小明](https://www.bilibili.com/video/BV1hk4y127yJ?spm_id_from=333.999.0.0)

###  1.424. <a name='FlipBinaryTreeToMatchPreorder'></a>971 Flip Binary Tree To Match Preorder

[小明](https://www.bilibili.com/video/BV1NB4y1P7qL?spm_id_from=333.999.0.0)

###  1.425. <a name='KClosestPointstoOrigin'></a>973 K Closest Points to Origin

[小明](https://www.bilibili.com/video/BV1Vf4y1278J?spm_id_from=333.999.0.0)

###  1.426. <a name='KSubarraySumsDivisiblebyK'></a>974. 和可被 K 整除的子数组 Subarray Sums Divisible by K 

[官方](https://www.bilibili.com/video/BV19z4y1X79a?spm_id_from=333.999.0.0)

###  1.427. <a name='OddEvenJump'></a>975. Odd Even Jump

[花花酱](https://www.bilibili.com/video/BV1pt411p7M4?spm_id_from=333.999.0.0)

###  1.428. <a name='MiddleoftheLinkedList-1'></a>976 Middle of the Linked List

[小明](https://www.bilibili.com/video/BV1N5411t7Xm?spm_id_from=333.999.0.0)

###  1.429. <a name='SquaresofaSortedArray'></a>977 Squares of a Sorted Array

[小明](https://www.bilibili.com/video/BV1EX4y1u7Mb?spm_id_from=333.999.0.0)

###  1.430. <a name='LongestTurbulentSubarray'></a>978. 最长湍流子数组 Longest Turbulent Subarray 

[官方](https://www.bilibili.com/video/BV1PV411i73Y?spm_id_from=333.999.0.0)

###  1.431. <a name='UniquePathsIII'></a>980. Unique Paths III 

[花花酱](https://www.bilibili.com/video/BV1yt41187Si?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oK4y1a7Qp?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.432. <a name='MinimumCostForTickets'></a>983 Minimum Cost For Tickets

[小明](https://www.bilibili.com/video/BV1Wz4y1f7hG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1WK4y1t7pP?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.433. <a name='IntervalListIntersections'></a>986 Interval List Intersections

[小明](https://www.bilibili.com/video/BV1wg4y1z7Xz?spm_id_from=333.999.0.0)

###  1.434. <a name='VerticalOrderTraversalofaBinary'></a>987 Vertical Order Traversal of a Binary

[小明](https://www.bilibili.com/video/BV1yZ4y1M7CL?spm_id_from=333.999.0.0)

###  1.435. <a name='SatisfiabilityofEqualityEquations'></a>990. 等式方程的可满足性 Satisfiability of Equality Equations 

[官方](https://www.bilibili.com/video/BV1gz411i7kD?spm_id_from=333.999.0.0)

###  1.436. <a name='K-1'></a>992-K 个不同整数的子数组

[哈哈哈](https://www.bilibili.com/video/BV1t44y1q7th?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xy4y1Y7GL?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.437. <a name='-1'></a>993. 二叉树的堂兄弟节点

[小明](https://www.bilibili.com/video/BV17t4y11725?spm_id_from=333.999.0.0)

###  1.438. <a name='-1'></a>994-腐烂的橘子

[哈哈哈](https://www.bilibili.com/video/BV1Yp4y1D7Kg?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1bB4y1A7tG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qk4y1m7fz?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.439. <a name='-1'></a>993, 994, 995, 996

[花花酱](https://www.bilibili.com/video/BV1bb41117PB?spm_id_from=333.999.0.0)

###  1.440. <a name='FindtheTownJudge'></a>997 Find the Town Judge

[小明](https://www.bilibili.com/video/BV1Ka4y1i7Qt?spm_id_from=333.999.0.0)

###  1.441. <a name='MinimumCosttoMergeStones'></a>1000. Minimum Cost to Merge Stones

[花花酱](https://www.bilibili.com/video/BV1db411v7DG?spm_id_from=333.999.0.0)

###  1.442. <a name='GridIllumination'></a>1001 Grid Illumination

[小明](https://www.bilibili.com/video/BV1NT4y1V7Vk?spm_id_from=333.999.0.0)

###  1.443. <a name='III-1'></a>1004-最大连续1的个数 III

[哈哈哈](https://www.bilibili.com/video/BV1Zg411L7Qu?spm_id_from=333.999.0.0)

###  1.444. <a name='MinimumDominoRotationsForEq'></a>1007 Minimum Domino Rotations For Eq

[小明](https://www.bilibili.com/video/BV1br4y1w7TM?spm_id_from=333.999.0.0)

###  1.445. <a name='ConstructBinarySearchTreefrom'></a>1008 Construct Binary Search Tree from

[小明](https://www.bilibili.com/video/BV1yk4y1R7oF?spm_id_from=333.999.0.0)

###  1.446. <a name='ComplementofBase10Integer'></a>1009 Complement of Base 10 Integer

[小明](https://www.bilibili.com/video/BV1oK4y187ZM?spm_id_from=333.999.0.0)

###  1.447. <a name='PairsofSongsWithTotalDurations'></a>1010 Pairs of Songs With Total Durations 

[小明](https://www.bilibili.com/video/BV1t64y1f7hc?spm_id_from=333.999.0.0)

###  1.448. <a name='PartitionArrayIntoThreePartsWithEqu'></a>1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ

[官方](https://www.bilibili.com/video/BV1ZK4y1t7Sf?spm_id_from=333.999.0.0)

###  1.449. <a name='SmallestIntegerDivisiblebyK'></a>1015 Smallest Integer Divisible by K

[小明](https://www.bilibili.com/video/BV1PZ4y1G7iU?spm_id_from=333.999.0.0)

###  1.450. <a name='NextGreaterNodeInLinkedList'></a>1019. Next Greater Node In Linked List

[花花酱](https://www.bilibili.com/video/BV12b411s77J?spm_id_from=333.999.0.0)

###  1.451. <a name='SumofRootToLeafBinaryNumbers'></a>1022 Sum of Root To Leaf Binary Numbers

[小明](https://www.bilibili.com/video/BV11A411E7AN?spm_id_from=333.999.0.0)

###  1.452. <a name='-1'></a>1025,1026,1027,1028

[花花酱](https://www.bilibili.com/video/BV1Nb411j7qr?spm_id_from=333.999.0.0)

###  1.453. <a name='VideoStitching'></a>1024. Video Stitching

[花花酱](https://www.bilibili.com/video/BV1kb411u7Qk?spm_id_from=333.999.0.0)

###  1.454. <a name='MaximumDifferenceBetweenNod'></a>1026 Maximum Difference Between Nod

[小明](https://www.bilibili.com/video/BV1fi4y157ZS?spm_id_from=333.999.0.0)

###  1.455. <a name='TwoCityScheduling'></a>1029 Two City Scheduling

[小明](https://www.bilibili.com/video/BV1t54y1Q7G8?spm_id_from=333.999.0.0)

###  1.456. <a name='StreamofCharacters'></a>1032 Stream of Characters

[小明](https://www.bilibili.com/video/BV15T4y1L7RG?spm_id_from=333.999.0.0)

###  1.457. <a name='UncrossedLines'></a>1035 Uncrossed Lines

[小明](https://www.bilibili.com/video/BV1si4y1s79e?spm_id_from=333.999.0.0)

###  1.458. <a name='RobotBoundedInCircle'></a>1041 Robot Bounded In Circle

[小明](https://www.bilibili.com/video/BV1dk4y1y7RH?spm_id_from=333.999.0.0)

###  1.459. <a name='PartitionArrayforMaximumSum'></a>1043. Partition Array for Maximum Sum

[花花酱](https://www.bilibili.com/video/BV154411J7so?spm_id_from=333.999.0.0)

###  1.460. <a name='LongestDuplicateSubstring'></a>1044 Longest Duplicate Substring

[小明](https://www.bilibili.com/video/BV1Kv411B7a3?spm_id_from=333.999.0.0)

###  1.461. <a name='LastStoneWeight'></a>1046 Last Stone Weight

[小明](https://www.bilibili.com/video/BV1w54y197Ln?spm_id_from=333.999.0.0)

###  1.462. <a name='LongestStringChain'></a>1048 Longest String Chain

[小明](https://www.bilibili.com/video/BV17K4y1G7et?spm_id_from=333.999.0.0)



###  1.463. <a name='ShortestWaytoFormString'></a>1055.Shortest Way to Form String 形成字符串的最短路径

[图灵](https://www.bilibili.com/video/BV1SZ4y1G7WX?spm_id_from=333.999.0.0)

###  1.464. <a name='-1'></a>1091-二进制矩阵中的最短路径

[哈哈哈](https://www.bilibili.com/video/BV17k4y1r7EP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ro4y197kU?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.465. <a name='CarPooling'></a>1094 Car Pooling

[小明](https://www.bilibili.com/video/BV1Xk4y1k7UX?spm_id_from=333.999.0.0)

###  1.466. <a name='FindinMountainArray'></a>1095. Find in Mountain Array

[花花酱](https://www.bilibili.com/video/BV1m5411V7x7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK4115778?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.467. <a name='FillingBookcaseShelves'></a>1105. Filling Bookcase Shelves

[花花酱](https://www.bilibili.com/video/BV1Mx411X7Ks?spm_id_from=333.999.0.0)

###  1.468. <a name='ParsingABooleanExpression'></a>1106. Parsing A Boolean Expression

[花花酱](https://www.bilibili.com/video/BV1Cx411X7aF?spm_id_from=333.999.0.0)

###  1.469. <a name='DeleteNodesAndReturnForest'></a>1110. Delete Nodes And Return Forest

[花花酱](https://www.bilibili.com/video/BV1u4411977H?spm_id_from=333.999.0.0)

###  1.470. <a name='MaximumNestingDepthofTwoValidParentheses'></a>1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses

[官方](https://www.bilibili.com/video/BV11a4y1v7Bb?spm_id_from=333.999.0.0)

###  1.471. <a name='threading'></a>1114 - 1115 - 1116 - 多线程 threading

[花花酱](https://www.bilibili.com/video/BV12t411P79a?spm_id_from=333.999.0.0)

###  1.472. <a name='LowestCommonAncestorofDeepestLeaves'></a>1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖

[小明](https://www.bilibili.com/video/BV16f4y1q7eA?spm_id_from=333.999.0.0)

###  1.473. <a name='LongestWell-PerformingInterval'></a>1124. Longest Well-Performing Interval

[花花酱](https://www.bilibili.com/video/BV1Et41157Jw?spm_id_from=333.999.0.0)

###  1.474. <a name='SmallestSufficientTeam'></a>1125. Smallest Sufficient Team

[花花酱](https://www.bilibili.com/video/BV14t411G7WL?spm_id_from=333.999.0.0)

###  1.475. <a name='NumberofEquivalentDominoPairs'></a>1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs

[官方](https://www.bilibili.com/video/BV1fV411q7ZY?spm_id_from=333.999.0.0)

###  1.476. <a name='ShortestPathwithAlternatingColors'></a>1129. Shortest Path with Alternating Colors

[花花酱](https://www.bilibili.com/video/BV1Et411J7Dh?spm_id_from=333.999.0.0)

###  1.477. <a name='N-thTribonacciNumber'></a>1137. N-th Tribonacci Number

[3:55 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

###  1.478. <a name='StoneGameII'></a>1140. Stone Game II

[花花酱](https://www.bilibili.com/video/BV1Gt411c7hM?spm_id_from=333.999.0.0)

###  1.479. <a name='LongestCommonSubsequence'></a>1143 Longest Common Subsequence

[小明](https://www.bilibili.com/video/BV19Z4y1W7Xi?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
package com.zhourui.leetcode
import com.zhourui.codech.BaseExtension

//问题转化为dp[0...i][0..j]是否存在公共字串
//1.text1[i]==text2[j] && dp[i-1][j-1]存在公共字串
//2.否则从已有的dp中选择最大值 max(dp[i-1][j], dp[i][j-1]);
package lc1143{



  object Solution {
    def longestCommonSubsequence(text1: String, text2: String): Int = {
      val m = text1.length
      val n = text2.length
      //val dp = Array.ofDim[Int](1001,1001)
      val dp = Array.fill(1001,1001)(0)
      for (i<- 1 to m) { // must have space?
        for (j<- 1 to n) {
          dp(i)(j) = if (text1(i-1)== text2(j-1)) dp(i-1)(j-1)+1 else Math.max(dp(i-1)(j),dp(i)(j-1))
        }
      }
      dp(m)(n)
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.longestCommonSubsequence("abcde", "ace") == 3)
    }
    val name = "1143 Longest common sequence"
  }
}

```

###  1.480. <a name='BinaryTreeColoringGame'></a>1145. Binary Tree Coloring Game

[花花酱](https://www.bilibili.com/video/BV1ft411K7Gf?spm_id_from=333.999.0.0)

###  1.481. <a name='NumberofDiceRollsWithTargetSum'></a>1155. Number of Dice Rolls With Target Sum

[花花酱](https://www.bilibili.com/video/BV1t4411Q7JN?spm_id_from=333.999.0.0)

###  1.482. <a name='FindWordsThatCanBeFormedbyCharacters'></a>1160. 拼写单词 Find Words That Can Be Formed by Characters 

[官方](https://www.bilibili.com/video/BV1Lt4y1Q7Yx?spm_id_from=333.999.0.0)

###  1.483. <a name='DinnerPlateStacks'></a>1172. Dinner Plate Stacks

[花花酱](https://www.bilibili.com/video/BV1E4411z7xb?spm_id_from=333.999.0.0)

###  1.484. <a name='NumberofValidWordsforEachPuzzle'></a>1178. Number of Valid Words for Each Puzzle

[花花酱](https://www.bilibili.com/video/BV1x441117vz?spm_id_from=333.999.0.0)

###  1.485. <a name='MakeArrayStrictlyIncreasing'></a>1187. Make Array Strictly Increasing

[花花酱](https://www.bilibili.com/video/BV1sJ411N7jD?spm_id_from=333.999.0.0)

###  1.486. <a name='K-ConcatenationMaximumSum'></a>1191. K-Concatenation Maximum Sum

[花花酱](https://www.bilibili.com/video/BV1AJ411w756?spm_id_from=333.999.0.0)

###  1.487. <a name='UglyNumberIII'></a>1201. Ugly Number III

[花花酱](https://www.bilibili.com/video/BV1QJ411M7Jx?spm_id_from=333.999.0.0)

###  1.488. <a name='SmallestStringWithSwaps'></a>1202. Smallest String With Swaps

[花花酱](https://www.bilibili.com/video/BV1PJ411T7Wq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Yh41127VH?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.489. <a name='SortItemsbyGroupsRespectingDependencies'></a>1203. 项目管理 Sort Items by Groups Respecting Dependencies

[官方](https://www.bilibili.com/video/BV1iy4y1m7ye?spm_id_from=333.999.0.0)

###  1.490. <a name='DesignSkiplist'></a>1206. Design Skiplist 

[花花酱](https://www.bilibili.com/video/BV1kT4y1F7Nr?spm_id_from=333.999.0.0)

###  1.491. <a name='RemoveAllAdjacentDuplicatesin'></a>1209 Remove All Adjacent Duplicates in 

[小明](https://www.bilibili.com/video/BV1qA411L7z9?spm_id_from=333.999.0.0)

###  1.492. <a name='MinimumCosttoMoveChips'></a>1217 Minimum Cost to Move Chips

[小明](https://www.bilibili.com/video/BV1zt4y1e7fK?spm_id_from=333.999.0.0)

###  1.493. <a name='LongestArithmeticSubsequenceofGivenDifference'></a>1218. Longest Arithmetic Subsequence of Given Difference

[花花酱](https://www.bilibili.com/video/BV1tE411f73y?spm_id_from=333.999.0.0)

###  1.494. <a name='CountVowelsPermutation'></a>1220. Count Vowels Permutation

[花花酱](https://www.bilibili.com/video/BV1FJ411c7pT?spm_id_from=333.999.0.0)

###  1.495. <a name='DiceRollSimulation'></a>1223 Dice Roll Simulation

[花花酱](https://www.bilibili.com/video/BV17E411k7PR?spm_id_from=333.999.0.0)

###  1.496. <a name='TilingaRectanglewiththeFewestSquares'></a>1240 Tiling a Rectangle with the Fewest Squares

[花花酱](https://www.bilibili.com/video/BV1UE411t7Gb?spm_id_from=333.999.0.0)

###  1.497. <a name='-1'></a>1248-统计「优美子数组」

[哈哈哈](https://www.bilibili.com/video/BV1FU4y1H76T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wk4y1r7t7?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.498. <a name='MinimumRemovetoMakeValidPare'></a>1249 Minimum Remove to Make Valid Pare

[小明](https://www.bilibili.com/video/BV1wK4y1X7G7?spm_id_from=333.999.0.0)

###  1.499. <a name='-1'></a>1252 1253 1254 1255

[花花酱](https://www.bilibili.com/video/BV1kE411Y7rg?spm_id_from=333.999.0.0)

###  1.500. <a name='MinimumMovestoMoveaBoxtoTheirTarget'></a>1263. Minimum Moves to Move a Box to Their Target

[花花酱](https://www.bilibili.com/video/BV1AJ411Q7B6?spm_id_from=333.999.0.0)

###  1.501. <a name='-1'></a>1277-统计全为1的正方形子矩阵

[哈哈哈](https://www.bilibili.com/video/BV1nk4y1k7vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Kp4y1X7n4?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.502. <a name='PalindromePartitioningIII'></a>1278. Palindrome Partitioning III

[花花酱](https://www.bilibili.com/video/BV1HJ411q7nc?spm_id_from=333.999.0.0)

###  1.503. <a name='FindtheSmallestDivisorGivena'></a>1283 Find the Smallest Divisor Given a

[小明](https://www.bilibili.com/video/BV1Fv411r7Nw?spm_id_from=333.999.0.0)

###  1.504. <a name='MinimumNumberofFlipstoConvertBinaryMatrix'></a>1284. Minimum Number of Flips to Convert Binary Matrix

[花花酱](https://www.bilibili.com/video/BV1nJ411y7m1?spm_id_from=333.999.0.0)

###  1.505. <a name='ConvertBinaryNumberinaLinkedList'></a>1290. 二进制链表转整数 (Convert Binary Number in a Linked List

[洛阳](https://www.bilibili.com/video/BV1kc411h7Rs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nD4y1R7QH?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.506. <a name='SequentialDigits'></a>1291 Sequential Digits

[小明](https://www.bilibili.com/video/BV11v411C7so?spm_id_from=333.999.0.0)

###  1.507. <a name='ShortestPathinaGridwithObstaclesElimination'></a>1293. Shortest Path in a Grid with Obstacles Elimination

[花花酱](https://www.bilibili.com/video/BV1VJ411k72A?spm_id_from=333.999.0.0)

###  1.508. <a name='DivideArrayinSetsofKConsecutiveNumbers'></a>1296. Divide Array in Sets of K Consecutive Numbers

[花花酱](https://www.bilibili.com/video/BV1gJ411e7cS?spm_id_from=333.999.0.0)

###  1.509. <a name='NumberofPathswithMaxScore'></a>1301. Number of Paths with Max Score

[花花酱](https://www.bilibili.com/video/BV1pJ411a7ry?spm_id_from=333.999.0.0)

###  1.510. <a name='DeepestLeavesSum'></a>1302 Deepest Leaves Sum

[小明](https://www.bilibili.com/video/BV1Bb4y1D7Cp?spm_id_from=333.999.0.0)

###  1.511. <a name='AllElementsinTwoBinarySearch'></a>1305 All Elements in Two Binary Search

[小明](https://www.bilibili.com/video/BV1kK411N7az?spm_id_from=333.999.0.0)

###  1.512. <a name='JumpGameIII'></a>1306 Jump Game III

[小明](https://www.bilibili.com/video/BV13y4y1q7Gi?spm_id_from=333.999.0.0)

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0:
            return True

        n = len(arr)
        used = {start}
        q = collections.deque([start])

        while len(q) > 0:
            u = q.popleft()
            for v in [u + arr[u], u - arr[u]]:
                if 0 <= v < n and v not in used:
                    if arr[v] == 0:
                        return True
                    q.append(v)
                    used.add(v)
        
        return False

```

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(site, n):
            if flag[0]:
                return
            if arr[site] == 0:
                flag[0] = True
                return
            see[site] = True
            for next_site in (site+arr[site], site-arr[site]):
                if 0 <= next_site < n and see[next_site] == False:
                    dfs(next_site, n)
        n = len(arr)
        flag = [False]
        see = [False] * n
        dfs(start, n)
        return flag[0]
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()

        def dfs(index):
            if index in seen:
                return False

            seen.add(index)
            if index < 0 or index >= len(arr):
                return False

            if arr[index] == 0:
                return True

            return dfs(index + arr[index]) or dfs(index - arr[index])

        return dfs(start)
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()
        queue = [(start, 0)]

        while queue:
            index, step = queue.pop(0)

            if index in seen:
                continue

            seen.add(index)

            if index < 0 or index >= len(arr):
                continue

            if arr[index] == 0:
                return True

            queue.extend([(index + arr[index], step+1), (index - arr[index], step+1)])

        return False

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(index,d):
            if index<0 or index>=len(arr) or len(d)!=len(set(d)):return False
            if arr[index]==0:return True
            return dfs(index+arr[index],d+[index+arr[index]]) or  dfs(index-arr[index],d+[index-arr[index]])
        return dfs(start,[start])

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start]==0:return True
        q=collections.deque([start])
        visited={start}
        while q:
            node=q.popleft()
            for n in [node+arr[node],node-arr[node]]:
                if 0<=n<len(arr) and n not in visited:
                    if arr[n]==0:return True
                    q.append(n)
                    visited.add(n)
        return False

bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        q, v, n = [start], {start}, len(arr)
        while q:
            p = []
            for i in q:
                if not arr[i]:
                    return True
                for j in i - arr[i], i + arr[i]:
                    if 0 <= j < n and j not in v:
                        p.append(j)
                        v.add(j)
            q = p
        return False
dfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        n, v = len(arr), set()
        def f(i):
            if not arr[i]:
                return True
            elif i not in v:
                v.add(i)
                return 0 <= i - arr[i] < n and f(i - arr[i]) or 0 <= i + arr[i] < n and f(i + arr[i])
        return f(start)

python bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        l, mark, queue= len(arr), [1 for i in range(len(arr))], [start]
        while len(queue)!=0:
            n = len(queue)
            for i in range(n):
                tmp = queue.pop()
                if arr[tmp]==0:
                    return True
                mark[tmp] = 0
                for cur in tmp+arr[tmp], tmp-arr[tmp]:
                    if 0<=cur<l and mark[cur]:
                        queue.insert(0, cur)
        return False
```

###  1.513. <a name='XORQueriesofaSubarray'></a>1310. XOR Queries of a Subarray

[花花酱](https://www.bilibili.com/video/BV1oJ411L78Y?spm_id_from=333.999.0.0)

###  1.514. <a name='MinimumInsertionStepstoMakeaStringPalindrom'></a>1312. Minimum Insertion Steps to Make a String Palindrom

[花花酱](https://www.bilibili.com/video/BV1HJ411L7b2?spm_id_from=333.999.0.0)

###  1.515. <a name='MinimumDistancetoTypeaWordUsingTwoFinger'></a>1320. Minimum Distance to Type a Word Using Two Finger

[花花酱](https://www.bilibili.com/video/BV11J411n7fN?spm_id_from=333.999.0.0)

###  1.516. <a name='SorttheMatrixDiagonally'></a>1329 Sort the Matrix Diagonally

[小明](https://www.bilibili.com/video/BV1hU4y147b1?spm_id_from=333.999.0.0)

###  1.517. <a name='RemovePalindromicSubsequences'></a>1332 Remove Palindromic Subsequences

[小明](https://www.bilibili.com/video/BV1tK4y1D7aV?spm_id_from=333.999.0.0)

###  1.518. <a name='FindtheCityWithSmallestNumberofNeighbors'></a>1334. Find the City With Smallest Number of Neighbors

[花花酱](https://www.bilibili.com/video/BV1b7411z7Tb?spm_id_from=333.999.0.0)

###  1.519. <a name='MinimumDifficultyofaJobSchedule'></a>1335. Minimum Difficulty of a Job Schedule

[花花酱](https://www.bilibili.com/video/BV1K7411r7xj?spm_id_from=333.999.0.0)

###  1.520. <a name='TheKWeakestRowsinaMatrix'></a>1337 The K Weakest Rows in a Matrix

[小明](https://www.bilibili.com/video/BV1bX4y157ju?spm_id_from=333.999.0.0)

###  1.521. <a name='MaximumProductofSplitt'></a>1339 Maximum Product of Splitt

[小明](https://www.bilibili.com/video/BV1Ch411i7yS?spm_id_from=333.999.0.0)

###  1.522. <a name='JumpGameV'></a>1340. Jump Game V

[花花酱](https://www.bilibili.com/video/BV1h7411W7wS?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        pathdic = defaultdict(list)
        n = len(arr)
        if n<=1: return n
        indegrees = [0]*n
        for i in range(n):
            for j in range(i+1,n):
                if arr[j]<arr[i] and j-i<=d:
                    pathdic[i].append(j)
                    indegrees[j] += 1
                else:
                    break
            for j in range(i-1, -1, -1):
                if arr[j]<arr[i] and i-j<=d:
                    pathdic[i].append(j)
                    indegrees[j] += 1
                else:
                    break
        # 拓扑排序
        queue = Deque()
        for i,degree in enumerate(indegrees):
            if degree == 0:
                queue.append((i,1))
        ans = 1
        while queue:
            node, level = queue.popleft()
            for nx_node in pathdic[node]:
                ans = max(ans, level+1)
                indegrees[nx_node] -= 1
                if indegrees[nx_node] == 0:
                    queue.append((nx_node, level+1))
        return ans

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        D = {}
        l = len(arr)
        def P(n):
            if n in D:
                return D[n]
            t = 1
            for i in range(1, d + 1):
                if n + i >= l or arr[n] <= arr[n + i]:
                    break
                t = max(t, 1 + P(n + i))
            for i in range(1, d + 1):
                if n - i < 0 or arr[n] <= arr[n - i]:
                    break
                t = max(t, 1 + P(n - i))
            D[n] = t
            return t
        return max(P(i) for i in range(l))
```

```py
记忆化 DFS

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        n = len(arr)
        @lru_cache(None)
        def helper(i):
            res = 0
            for j in range(i + 1, i + d + 1):
                if j >= n or arr[j] >= arr[i]:
                    break
                res = max(res, helper(j))
            for j in range(i - 1, i - d - 1, -1):
                if j < 0 or arr[j] >= arr[i]:
                    break
                res = max(res, helper(j))
            return res + 1
        return max(helper(i) for i in range(n))
```

```py
排序之后对向两边进行拓展

#python3
class Solution:
	def maxJumps(self,arr,d):
		fans=1
		size=len(arr)
		has,dp=[[0]*size for _ in range(2)]
		for i in sorted(range(size),key=arr.__getitem__):
			tans=has[i]=1
			for j in range(i+1,min(size,i+d+1)):
				if not has[j] or arr[j]==arr[i]:
					break
				tans=max(tans,dp[j]+1)
			for j in range(i-1,max(-1,i-d-1),-1):
				if not has[j] or arr[j]==arr[i]:
					break
				tans=max(tans,dp[j]+1)
			dp[i]=tans
			fans=max(fans,tans)
		return fans

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        # 不能往比自己的高的跳
        # 能跳的区间内不能有比自己高的
        # dp[i]从 i开始的最大跳跃
        n = len(arr)
        height = [(jump,i) for i, jump in enumerate(arr)]
        height = sorted(height, key=lambda x: x[0])
        dp = [1 for _ in range(n)]
        #print(idx)
        #idx1 = map(lambda x: x[1], idx)
        for jump, i in height:
            cur = 1
            for j in range(i-1, max(-1, i - d) - 1, -1): # 向左跳
                if arr[j] >= jump: break
                cur = max(dp[j] + 1,cur)

            for j in range(i + 1, min(n, i + d + 1)):
                if arr[j] >= jump: break
                cur = max(dp[j] + 1, cur)
            dp[i] = cur
        return max(dp)

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        seen = dict()

        def dfs(pos):
            if pos in seen:
                return
            seen[pos] = 1

            i = pos - 1
            while i >= 0 and pos - i <= d and arr[pos] > arr[i]:
                dfs(i)
                seen[pos] = max(seen[pos], seen[i] + 1)
                i -= 1
            i = pos + 1
            while i < len(arr) and i - pos <= d and arr[pos] > arr[i]:
                dfs(i)
                seen[pos] = max(seen[pos], seen[i] + 1)
                i += 1

        for i in range(len(arr)):
            dfs(i)
        print(seen)
        return max(seen.values())

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/jump-game-v/solution/tiao-yue-you-xi-v-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  1.523. <a name='MaximumStudentsTakingExam'></a>1349. Maximum Students Taking Exam

[花花酱](https://www.bilibili.com/video/BV1w7411V7eC?spm_id_from=333.999.0.0)

###  1.524. <a name='MaximumNumberofEventsThatCanBeAttended'></a>1353. Maximum Number of Events That Can Be Attended 

[花花酱](https://www.bilibili.com/video/BV1C7411j7YJ?spm_id_from=333.999.0.0)

###  1.525. <a name='ConstructTargetArrayWithMultipleSums'></a>1354. Construct Target Array With Multiple Sums

[花花酱](https://www.bilibili.com/video/BV1g7411c793?spm_id_from=333.999.0.0)

###  1.526. <a name='MinimumCosttoMakeatLeastOneValidPath'></a>1368. Minimum Cost to Make at Least One Valid Path

[花花酱](https://www.bilibili.com/video/BV1oE411E74t?spm_id_from=333.999.0.0)

###  1.527. <a name='FindtheLongestSubstringContainingVowelsinEve'></a>1371. Find the Longest Substring Containing Vowels in Eve

[花花酱](https://www.bilibili.com/video/BV1CE411K7hb?spm_id_from=333.999.0.0)

###  1.528. <a name='MaximumSumBSTinBinaryTree'></a>1373. Maximum Sum BST in Binary Tree

[花花酱](https://www.bilibili.com/video/BV17E411u797?spm_id_from=333.999.0.0)

###  1.529. <a name='FrogPositionAfterTSeconds'></a>1377. Frog Position After T Seconds

[花花酱](https://www.bilibili.com/video/BV1mE411K7vc?spm_id_from=333.999.0.0)

###  1.530. <a name='FindCorrespondingNodeofBinaryTreeinaClone'></a>1379 Find Corresponding Node of Binary Tree in a Clone

[小明](https://www.bilibili.com/video/BV1A54y147HN?spm_id_from=333.999.0.0)

###  1.531. <a name='BalanceaBinarySearchTree'></a>1382. Balance a Binary Search Tree

[花花酱](https://www.bilibili.com/video/BV1y7411f7v2?spm_id_from=333.999.0.0)

###  1.532. <a name='CountNumberofTeams'></a>1395. Count Number of Teams

[花花酱](https://www.bilibili.com/video/BV1cc411h73E?spm_id_from=333.999.0.0)

###  1.533. <a name='DesignUndergroundSystem'></a>1396 Design Underground System

[小明](https://www.bilibili.com/video/BV1uA411N7q6?spm_id_from=333.999.0.0)

###  1.534. <a name='StoneGameIII'></a>1406. Stone Game III

[花花酱](https://www.bilibili.com/video/BV1zT4y1G7Tb?spm_id_from=333.999.0.0)

###  1.535. <a name='QueriesonaPermutationWithKey'></a>1409. Queries on a Permutation With Key

[花花酱](https://www.bilibili.com/video/BV1mz411b7Uw?spm_id_from=333.999.0.0)

###  1.536. <a name='RestoreTheArray'></a>1416. Restore The Array

[花花酱](https://www.bilibili.com/video/BV1gK4y1k7Rv?spm_id_from=333.999.0.0)

###  1.537. <a name='DiagonalTraverseII'></a>1424. Diagonal Traverse II

[花花酱](https://www.bilibili.com/video/BV1r5411x7Tm?spm_id_from=333.999.0.0)

###  1.538. <a name='ConstrainedSubsetSum'></a>1425. Constrained Subset Sum

[花花酱](https://www.bilibili.com/video/BV13t4y1m7fD?spm_id_from=333.999.0.0)

###  1.539. <a name='CountingElements'></a>1426  Counting Elements

[小明](https://www.bilibili.com/video/BV1Eg4y187vx?spm_id_from=333.999.0.0)

###  1.540. <a name='KidsWiththeGreatestNumberofCandie'></a>1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie

[官方](https://www.bilibili.com/video/BV1vD4y1D7yo?spm_id_from=333.999.0.0)

###  1.541. <a name='CheckIfAll1sAreatLeastLength'></a>1437 Check If All 1's Are at Least Length

[小明](https://www.bilibili.com/video/BV1Yo4y1R78P?spm_id_from=333.999.0.0)

###  1.542. <a name='LongestContinuousSubarrayWithAbsolute'></a>1438. Longest Continuous Subarray With Absolute

[花花酱](https://www.bilibili.com/video/BV1Cf4y1m7aN?spm_id_from=333.999.0.0)

###  1.543. <a name='BuildanArrayWithStackOperations'></a>1441 Build an Array With Stack Operations

[小明](https://www.bilibili.com/video/BV1Gg4y167ZD?spm_id_from=333.999.0.0)

###  1.544. <a name='CountTripletsThatCanFormTwoArraysofEqual'></a>1442. Count Triplets That Can Form Two Arrays of Equal

[花花酱](https://www.bilibili.com/video/BV17g4y1B7yo?spm_id_from=333.999.0.0)

###  1.545. <a name='MinimumTimetoCollectAllApplesinaTree'></a>1443. Minimum Time to Collect All Apples in a Tree

[花花酱](https://www.bilibili.com/video/BV1e541147oZ?spm_id_from=333.999.0.0)

###  1.546. <a name='NumberofWaysofCuttingaPizza'></a>1444. Number of Ways of Cutting a Pizza

[花花酱](https://www.bilibili.com/video/BV1CK411W7nR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gg4y1B7zS?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.547. <a name='ConsecutiveCharacters'></a>1446 Consecutive Characters

[小明](https://www.bilibili.com/video/BV1QA411j7Qt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pp4y1Q7Rh?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.548. <a name='CountGoodNodesinBinaryTree'></a>1448 Count Good Nodes in Binary Tree

[小明](https://www.bilibili.com/video/BV1Zg4y1q7kc?spm_id_from=333.999.0.0)

###  1.549. <a name='FormLargestIntegerWithDigitsThatAdd'></a>1449. Form Largest Integer With Digits That Add

[花花酱](https://www.bilibili.com/video/BV19Q4y1A7Rf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1j54y1D7vf?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.550. <a name='RearrangeWordsinaSentence'></a>1451 Rearrange Words in a Sentence

[小明](https://www.bilibili.com/video/BV1UA411t7Eg?spm_id_from=333.999.0.0)

###  1.551. <a name='MaximumNumberofDartsInsideofaCircularDartb'></a>1453 Maximum Number of Darts Inside of a Circular Dartb

[小明](https://www.bilibili.com/video/BV1Ut4y117jp?spm_id_from=333.999.0.0)

###  1.552. <a name='Pseudo-PalindromicPathsinaBin'></a>1457 Pseudo-Palindromic Paths in a Bin

[小明](https://www.bilibili.com/video/BV1t54y1t7KK?spm_id_from=333.999.0.0)

###  1.553. <a name='CheckIfaStringContainsAllBinar'></a>1461 Check If a String Contains All Binar

[小明](https://www.bilibili.com/video/BV13Z4y1w7K9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oU4y1p7Tr?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.554. <a name='CherryPickupII'></a>1463 Cherry Pickup II

[小明](https://www.bilibili.com/video/BV1AA411s7Tc?spm_id_from=333.999.0.0)

###  1.555. <a name='PaintHouseIII'></a>1473. Paint House III

[花花酱](https://www.bilibili.com/video/BV15K411p7nT?spm_id_from=333.999.0.0)

###  1.556. <a name='FinalPricesWithaSpecialDiscountinaSho'></a>1475. Final Prices With a Special Discount in a Sho

[花花酱](https://www.bilibili.com/video/BV1na4y1Y7VU?spm_id_from=333.999.0.0)

###  1.557. <a name='KthAncestorofaTreeNode'></a>1483. Kth Ancestor of a Tree Node

[花花酱](https://www.bilibili.com/video/BV1kt4y1X7fk?spm_id_from=333.999.0.0)

###  1.558. <a name='AvoidFloodinTheCity'></a>1488. Avoid Flood in The City

[花花酱](https://www.bilibili.com/video/BV1af4y1y7uW?spm_id_from=333.999.0.0)

###  1.559. <a name='FindCriticalandPseudo-CriticalEdgesin'></a>1489. Find Critical and Pseudo-Critical Edges in

[花花酱](https://www.bilibili.com/video/BV1cV41167oi?spm_id_from=333.999.0.0)

###  1.560. <a name='ThekthFactorofn'></a>1492 The kth Factor of n

[小明](https://www.bilibili.com/video/BV1ha4y1H7vz?spm_id_from=333.999.0.0)

###  1.561. <a name='LongestSubarrayof1sAfterDeletingOne'></a>1493. Longest Subarray of 1's After Deleting One

[花花酱](https://www.bilibili.com/video/BV1rC4y18751?spm_id_from=333.999.0.0)

###  1.562. <a name='MaxValueofEquation'></a>1499. Max Value of Equation

[花花酱](https://www.bilibili.com/video/BV1VK411H7zy?spm_id_from=333.999.0.0)

###  1.563. <a name='CanMakeArithmeticProgressionFromSequence'></a>1502 Can Make Arithmetic Progression From Sequence

[小明](https://www.bilibili.com/video/BV12T4y177vU?spm_id_from=333.999.0.0)

###  1.564. <a name='LastMomentBeforeAllAntsFallOutofaPlank'></a>1503 Last Moment Before All Ants Fall Out of a Plank

[小明](https://www.bilibili.com/video/BV1Fg4y1i7na?spm_id_from=333.999.0.0)

###  1.565. <a name='MinimumPossibleIntegerAfteratMostKAdjacent'></a>1505. Minimum Possible Integer After at Most K Adjacent

[花花酱](https://www.bilibili.com/video/BV1YD4y1S7BQ?spm_id_from=333.999.0.0)

###  1.566. <a name='RangeSumofSortedSubarraySums'></a>1508. Range Sum of Sorted Subarray Sums

[花花酱](https://www.bilibili.com/video/BV1fg4y1v7qe?spm_id_from=333.999.0.0)

###  1.567. <a name='StoneGameIV'></a>1510 Stone Game IV

[小明](https://www.bilibili.com/video/BV1pr4y1w7ao?spm_id_from=333.999.0.0)

###  1.568. <a name='PathwithMaximumProbability'></a>1514 Path with Maximum Probability

[小明](https://www.bilibili.com/video/BV1Ak4y1B7yR?spm_id_from=333.999.0.0)

###  1.569. <a name='BestPositionforaServiceCentre'></a>1515 Best Position for a Service Centre

[小明](https://www.bilibili.com/video/BV1UA411e7PC?spm_id_from=333.999.0.0)

###  1.570. <a name='MaximumNumberofNon-OverlappingSubstrings'></a>1520. Maximum Number of Non-Overlapping Substrings

[花花酱](https://www.bilibili.com/video/BV1yz4y1D7p3?spm_id_from=333.999.0.0)

###  1.571. <a name='NumberofGoodLeafNodesPairs'></a>1530. Number of Good Leaf Nodes Pairs

[花花酱](https://www.bilibili.com/video/BV1bv411q7SD?spm_id_from=333.999.0.0)

###  1.572. <a name='StringCompressionII'></a>1531. String Compression II

[花花酱](https://www.bilibili.com/video/BV1aK4y1v7B9?spm_id_from=333.999.0.0)

###  1.573. <a name='CountGoodTriplets'></a>1534 Count Good Triplets

[小明](https://www.bilibili.com/video/BV11k4y1m7rV?spm_id_from=333.999.0.0)

###  1.574. <a name='FindtheWinnerofanArrayGame'></a>1535 Find the Winner of an Array Game

[小明](https://www.bilibili.com/video/BV1Xp4y1i7ey?spm_id_from=333.999.0.0)

###  1.575. <a name='GettheMaximumScore'></a>1537. Get the Maximum Score

[小梦想家](https://www.bilibili.com/video/BV1KC4y1t7P8?spm_id_from=333.999.0.0)

###  1.576. <a name='KthMissingPositiveNumber'></a>1539. Kth Missing Positive Number

[小梦想家](https://www.bilibili.com/video/BV1SC4y147Eo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK4y1p7E3?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.577. <a name='FindLongestAwesomeSubstring'></a>1542. Find Longest Awesome Substring

[花花酱](https://www.bilibili.com/video/BV1ZD4y1U79Y?spm_id_from=333.999.0.0)

###  1.578. <a name='MaximumNumberofNon-OverlappingSubarraysWithSum'></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum

[小梦想家](https://www.bilibili.com/video/BV1LA411n7L8?spm_id_from=333.999.0.0)

###  1.579. <a name='ThreeConsecutiveOdds'></a>1550. Three Consecutive Odds

[小梦想家](https://www.bilibili.com/video/BV1aV411m7fy?spm_id_from=333.999.0.0)

###  1.580. <a name='MinimumOperationstoMakeArray'></a>1551 Minimum Operations to Make Array

[小明](https://www.bilibili.com/video/BV1u64y1S7fx?spm_id_from=333.999.0.0)

###  1.581. <a name='MinimumNumberofDaystoEatNOranges'></a>1553. Minimum Number of Days to Eat N Oranges

[花花酱](https://www.bilibili.com/video/BV1Qf4y197Zk?spm_id_from=333.999.0.0)

###  1.582. <a name='ThousandSeparator'></a>1556. Thousand Separator

[小梦想家](https://www.bilibili.com/video/BV1Ka4y177HV?spm_id_from=333.999.0.0)

###  1.583. <a name='MinimumNumbersofFunctionCallstoMakeTarget'></a>1558. Minimum Numbers of Function Calls to Make Target

[花花酱](https://www.bilibili.com/video/BV1xC4y1t7Q3?spm_id_from=333.999.0.0)

###  1.584. <a name='StoneGameV'></a>1563. Stone Game V 

[花花酱](https://www.bilibili.com/video/BV1B54y1U77f?spm_id_from=333.999.0.0)

###  1.585. <a name='NumberofWaystoReorderArraytoGetSa'></a>1569. Number of Ways to Reorder Array to Get Sa

[花花酱](https://www.bilibili.com/video/BV1pZ4y1T7TY?spm_id_from=333.999.0.0)

###  1.586. <a name='NumberofWaystoSplitaString'></a>1573. Number of Ways to Split a String

[花花酱](https://www.bilibili.com/video/BV1bi4y1u7c3?spm_id_from=333.999.0.0)

###  1.587. <a name='CheckIfStringIsTransformableWith'></a>1585. Check If String Is Transformable With

[花花酱](https://www.bilibili.com/video/BV1a54y1m75Y?spm_id_from=333.999.0.0)

###  1.588. <a name='SplitaStringIntotheMaxNumberofUniqueSubstri'></a>1593. Split a String Into the Max Number of Unique Substri

[花花酱](https://www.bilibili.com/video/BV14y4y1k77x?spm_id_from=333.999.0.0) 

###  1.589. <a name='MinimumCosttoConnectTwoGroupsofPoints'></a>1595. Minimum Cost to Connect Two Groups of Points

[花花酱](https://www.bilibili.com/video/BV1Xf4y1D7SW?spm_id_from=333.999.0.0)

###  1.590. <a name='NumberofSetsofKNon-OverlappingLine'></a>1621. Number of Sets of K Non-Overlapping Line

[花花酱](https://www.bilibili.com/video/BV1JV411y7eK?spm_id_from=333.999.0.0)

###  1.591. <a name='PathWithMinimumEffort'></a>1631. Path With Minimum Effort

[花花酱](https://www.bilibili.com/video/BV1tr4y1w725?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ft4y1z71X?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.592. <a name='RankTransformofaMatrix'></a>1632 Rank Transform of a Matrix

[小明](https://www.bilibili.com/video/BV1KX4y1F7UA?spm_id_from=333.999.0.0)

###  1.593. <a name='CheckArrayFormationThrough'></a>1640 Check Array Formation Through

[小明](https://www.bilibili.com/video/BV1uh411274P?spm_id_from=333.999.0.0)

###  1.594. <a name='CountSortedVowelStrings'></a>1641 Count Sorted Vowel Strings

[小明](https://www.bilibili.com/video/BV1jf4y1k7bJ?spm_id_from=333.999.0.0)

###  1.595. <a name='FurthestBuildingYouCanReach'></a>1642. Furthest Building You Can Reach

[花花酱](https://www.bilibili.com/video/BV1az4y1C7Pk?spm_id_from=333.999.0.0)

###  1.596. <a name='GetMaximuminGeneratedArray'></a>1646 Get Maximum in Generated Array

[小明](https://www.bilibili.com/video/BV1W54y1s7mg?spm_id_from=333.999.0.0)

###  1.597. <a name='SellDiminishing-ValuedColoredBalls'></a>1648. Sell Diminishing-Valued Colored Balls

[花花酱](https://www.bilibili.com/video/BV11z4y1C7PC?spm_id_from=333.999.0.0)

###  1.598. <a name='CreateSortedArraythroughInstru'></a>1649 Create Sorted Array through Instru

[小明](https://www.bilibili.com/video/BV1ua4y1H7KK?spm_id_from=333.999.0.0)

###  1.599. <a name='DistributeRepeatingIntegers'></a>1655. Distribute Repeating Integers

[花花酱](https://www.bilibili.com/video/BV1qt4y1a7Lm?spm_id_from=333.999.0.0)

###  1.600. <a name='DetermineifTwoStringsAreClose'></a>1657 Determine if Two Strings Are Close

[小明](https://www.bilibili.com/video/BV18z4y1S779?spm_id_from=333.999.0.0)

###  1.601. <a name='MinimumOperationstoReduceX'></a>1658 Minimum Operations to Reduce X

[小明](https://www.bilibili.com/video/BV18t4y1z7Hq?spm_id_from=333.999.0.0)

###  1.602. <a name='MaximizeGridHappiness'></a>1659. Maximize Grid Happiness

[花花酱](https://www.bilibili.com/video/BV1kf4y1v7Js?spm_id_from=333.999.0.0)

###  1.603. <a name='CheckIfTwoStringArraysareEqui'></a>1662 Check If Two String Arrays are Equi

[小明](https://www.bilibili.com/video/BV1LV411t7v4?spm_id_from=333.999.0.0)

###  1.604. <a name='SmallestStringWithAGivenNumer'></a>1663 Smallest String With A Given Numer

[小明](https://www.bilibili.com/video/BV1gv411e7Ly?spm_id_from=333.999.0.0)

###  1.605. <a name='FindtheMostCompetitiveSubseq'></a>1673 Find the Most Competitive Subseq

[小明](https://www.bilibili.com/video/BV1yK4y1H7ni?spm_id_from=333.999.0.0)

###  1.606. <a name='MinimumMovestoMakeArrayComplement'></a>1674. Minimum Moves to Make Array Complement

[花花酱](https://www.bilibili.com/video/BV1qz4y1k7Cm?spm_id_from=333.999.0.0)

###  1.607. <a name='MinimizeDeviationinArray'></a>1675. Minimize Deviation in Array

[花花酱](https://www.bilibili.com/video/BV15541157p6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16f4y167uf?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.608. <a name='MaxNumberofK-SumPairs'></a>1679 Max Number of K-Sum Pairs】

[小明](https://www.bilibili.com/video/BV16t4y1z7kY?spm_id_from=333.999.0.0)

###  1.609. <a name='ConcatenationofConsecutiveBina'></a>1680 Concatenation of Consecutive Bina

[小明](https://www.bilibili.com/video/BV1Py4y117o5?spm_id_from=333.999.0.0)

###  1.610. <a name='MinimumIncompatibility'></a>1681. Minimum Incompatibility

[花花酱](https://www.bilibili.com/video/BV16p4y1z79z?spm_id_from=333.999.0.0)

###  1.611. <a name='StoneGameVII'></a>1690. Stone Game VII

[花花酱](https://www.bilibili.com/video/BV1wf4y1e7xH?spm_id_from=333.999.0.0)

###  1.612. <a name='JumpGameVI'></a>1696. Jump Game VI

[花花酱](https://www.bilibili.com/video/BV1554y1t7Tz?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        
        
        # dp[i] = max(dp[j])+ nums[i] for j in range(i - k, i)
        
        dp = [0] * len(nums)
        dp[0] = nums[0]
        
        q = [0]
        for i in range(1, len(nums)):
            while q and i - q[0] > k:
                q.pop(0)
            dp[i] = dp[q[0]] + nums[i]
            while q and dp[q[-1]] <= dp[i]:
                q.pop(-1)
            q.append(i)     
        return dp[-1]
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        from queue import PriorityQueue
        ans, q = nums[0], PriorityQueue()
        q.put([-nums[0], 0])
        for i in range(1, len(nums)):
            while not q.empty():
                top = q.get()
                if i - top[-1] <= k:
                    q.put(top)
                    break
            ans = -top[0] + nums[i]
            q.put([-ans, i])
        return ans
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        #维护当前最大值  方法1：最大堆  方法2:单调递减队列（队首）
        n = len(nums)
        maxHeap = []
        heapq.heapify(maxHeap)
        heapq.heappush(maxHeap, (-nums[0], 0) )
        res = nums[0]

        for i in range(1, n):
            while maxHeap and i - maxHeap[0][1] > k:    #index的距离太大，以后i越来越大，top()就没用了
                heapq.heappop(maxHeap)
            res = -maxHeap[0][0] + nums[i]
            heapq.heappush(maxHeap, (-res, i) )         #dp的思想
        return res
```

###  1.613. <a name='DetermineifStringHalvesAreAlike'></a>1704 Determine if String Halves Are Alike

[小明](https://www.bilibili.com/video/BV1WA41157sf?spm_id_from=333.999.0.0)

###  1.614. <a name='MaximumXORWithanElementFromArray'></a>1707. Maximum XOR With an Element From Array

[花花酱](https://www.bilibili.com/video/BV13v411t742?spm_id_from=333.999.0.0)

###  1.615. <a name='MinimumOperationstoMakeaSubsequence'></a>1713. Minimum Operations to Make a Subsequence

[花花酱](https://www.bilibili.com/video/BV1Yy4y127DQ?spm_id_from=333.999.0.0)

###  1.616. <a name='SwappingNodesinaLinkedList'></a>1721 Swapping Nodes in a Linked List

[小明](https://www.bilibili.com/video/BV1Ji4y1P7Xc?spm_id_from=333.999.0.0)

###  1.617. <a name='LargestSubmatrixWithRearrangements'></a>1727. Largest Submatrix With Rearrangements

[花花酱](https://www.bilibili.com/video/BV1XT4y1N7gy?spm_id_from=333.999.0.0)

###  1.618. <a name='PalindromePartitioningIV'></a>1745. Palindrome Partitioning IV

[花花酱](https://www.bilibili.com/video/BV1yo4y1R75T?spm_id_from=333.999.0.0)

###  1.619. <a name='MinimumLimitofBallsinaBag'></a>1760. Minimum Limit of Balls in a Bag

[花花酱](https://www.bilibili.com/video/BV1bK4y1H7Ly?spm_id_from=333.999.0.0)

###  1.620. <a name='MaximumScorefromPerformingMultiplication'></a>1770. Maximum Score from Performing Multiplication

[花花酱](https://www.bilibili.com/video/BV1Li4y1T7j6?spm_id_from=333.999.0.0)

###  1.621. <a name='MaximizePalindromeLengthFromSubsequences'></a>1771. Maximize Palindrome Length From Subsequences

[花花酱](https://www.bilibili.com/video/BV1Cp4y1H7Xq?spm_id_from=333.999.0.0)

###  1.622. <a name='EqualSumArraysWithMinimumNumberofOperatio'></a>1775. Equal Sum Arrays With Minimum Number of Operatio

[花花酱](https://www.bilibili.com/video/BV1Di4y1T7nF?spm_id_from=333.999.0.0)

###  1.623. <a name='NumberofRestrictedPathsFromFirsttoLastNode'></a>1786. Number of Restricted Paths From First to Last Node

[花花酱](https://www.bilibili.com/video/BV1Df4y147TB?spm_id_from=333.999.0.0)

###  1.624. <a name='MaximumAveragePassRatio'></a>1792. Maximum Average Pass Ratio

[花花酱](https://www.bilibili.com/video/BV1qb4y197zc?spm_id_from=333.999.0.0)

###  1.625. <a name='MaximizeScoreAfterNOperations'></a>1799. Maximize Score After N Operations

[花花酱](https://www.bilibili.com/video/BV1Sf4y1x7Cy?spm_id_from=333.999.0.0)

###  1.626. <a name='MaximumNumberofGroupsGettingFreshDonuts'></a>1815. Maximum Number of Groups Getting Fresh Donuts

[花花酱](https://www.bilibili.com/video/BV1CU4y187tk?spm_id_from=333.999.0.0)

###  1.627. <a name='FrequencyoftheMostFrequentElement'></a>1838. Frequency of the Most Frequent Element

[花花酱](https://www.bilibili.com/video/BV1Ai4y1P7Yt?spm_id_from=333.999.0.0)

###  1.628. <a name='ClosestRoom'></a>1847. Closest Room

[花花酱](https://www.bilibili.com/video/BV1cy4y1x7sz?spm_id_from=333.999.0.0)

###  1.629. <a name='StoneGameVIII'></a>1872. Stone Game VIII

[花花酱](https://www.bilibili.com/video/BV1vb4y1z7wx?spm_id_from=333.999.0.0)

###  1.630. <a name='s'></a>s
