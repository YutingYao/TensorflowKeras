<!-- vscode-markdown-toc -->
* 1. [题目](#)
	* 1.1. [100-Same Tree](#SameTree)
	* 1.2. [101-Symmetric tree](#Symmetrictree)
	* 1.3. [102-Binary Tree Level Order Traversal](#BinaryTreeLevelOrderTraversal)
	* 1.4. [103. Binary Tree Zigzag Level Order Traversal](#BinaryTreeZigzagLevelOrderTraversal)
	* 1.5. [104-Maximum Depth of Binary](#MaximumDepthofBinary)
	* 1.6. [105-从前序与中序遍历序列构](#-1)
	* 1.7. [106-从中序与后序遍历序列构造二叉树](#-1)
	* 1.8. [107-Binary Tree Level Order Traversal II](#BinaryTreeLevelOrderTraversalII)
	* 1.9. [108 Convert Sorted Array to Binary Search Tree](#ConvertSortedArraytoBinarySearchTree)
	* 1.10. [109题. 有序链表转换二叉搜索树](#-1)
	* 1.11. [110-Balanced Binary Tree](#BalancedBinaryTree)
	* 1.12. [111-Minimum Depth of Binary Tree](#MinimumDepthofBinaryTree)
	* 1.13. [112-Path Sum](#PathSum)
	* 1.14. [113. 二叉树中和为某一值的路径](#-1)
	* 1.15. [114题. 二叉树展开为链表](#-1)
	* 1.16. [115. Distinct Subsequences](#DistinctSubsequences)
	* 1.17. [116. Populating Next Right Pointers in Each Node](#PopulatingNextRightPointersinEachNode)
	* 1.18. [117 Populating Next Right Pointers in Ea](#PopulatingNextRightPointersinEa)
	* 1.19. [118-Pascal's Triangle](#PascalsTriangle)
	* 1.20. [119-Pascal's Triangle II](#PascalsTriangleII)
	* 1.21. [120 Triangle](#Triangle)
	* 1.22. [121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机](#BestTimetoBuyandSellStock121-)
	* 1.23. [122-买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II](#II122-BestTimetoBuyandSellStockII)
	* 1.24. [123-买卖股票的最佳时机 III](#III)
	* 1.25. [124. Binary Tree Maximum Path Sum](#BinaryTreeMaximumPathSum)
	* 1.26. [125-Valid Palindrome](#ValidPalindrome)
	* 1.27. [126. Word Ladder II](#WordLadderII)
	* 1.28. [127. Word Ladder](#WordLadder)
	* 1.29. [128. Longest Consecutive Sequence](#LongestConsecutiveSequence)
	* 1.30. [129 Sum Root to Leaf Numbers](#SumRoottoLeafNumbers)
	* 1.31. [130. Surrounded Regions 130-被围绕的区域](#SurroundedRegions130-)
	* 1.32. [131-分割回文串](#-1)
	* 1.33. [132. Palindrome Partitioning II](#PalindromePartitioningII)
	* 1.34. [133. Clone Graph](#CloneGraph)
	* 1.35. [134. Gas Station](#GasStation)
	* 1.36. [138 Copy List with Random Pointer](#CopyListwithRandomPointer)
	* 1.37. [136-Single Number](#SingleNumber)
	* 1.38. [137 Single Number II](#SingleNumberII)
	* 1.39. [139 Word Break](#WordBreak)
	* 1.40. [140 Word Break II](#WordBreakII)
	* 1.41. [141-Linked List Cycle](#LinkedListCycle)
	* 1.42. [142 Linked List Cycle II](#LinkedListCycleII)
	* 1.43. [143 Reorder List](#ReorderList)
	* 1.44. [144-Preorder with stack](#Preorderwithstack)
	* 1.45. [144-Binary Tree Preorder Traversal](#BinaryTreePreorderTraversal)
	* 1.46. [145-Postorder with stack](#Postorderwithstack)
	* 1.47. [145-Binary Tree Postorder Traversal](#BinaryTreePostorderTraversal)
	* 1.48. [146 LRU Cache](#LRUCache)
	* 1.49. [147 Insertion Sort List](#InsertionSortList)
	* 1.50. [148. Sort List](#SortList)
	* 1.51. [149. Max Points on a Line](#MaxPointsonaLine)
	* 1.52. [150. Evaluate Reverse Polish Notation](#EvaluateReversePolishNotation)
	* 1.53. [151. Reverse Words in a String](#ReverseWordsinaString)
	* 1.54. [152-乘积最大子数组](#-1)
	* 1.55. [153-寻找旋转排序数组中的最小值](#-1)
	* 1.56. [154 Find Minimum in Rotated Sorted Arr](#FindMinimuminRotatedSortedArr)
	* 1.57. [155-Min Stack](#MinStack)
	* 1.58. [160-Intersection of Two Linked Lists](#IntersectionofTwoLinkedLists)
	* 1.59. [162. Find Peak Element](#FindPeakElement)
	* 1.60. [165. Compare Version Numbers](#CompareVersionNumbers)
	* 1.61. [166. Fraction to Recurring Decimal](#FractiontoRecurringDecimal)
	* 1.62. [167-Two Sum II - Input array is sorted](#TwoSumII-Inputarrayissorted)
	* 1.63. [168-Excel Sheet Column Title](#ExcelSheetColumnTitle)
	* 1.64. [169. Majority Element](#MajorityElement)
	* 1.65. [171. Excel Sheet Column Number](#ExcelSheetColumnNumber)
	* 1.66. [172-Factorial Trailing Zeroes](#FactorialTrailingZeroes)
	* 1.67. [173 Binary Search Tree Iterator](#BinarySearchTreeIterator)
	* 1.68. [174 Dungeon Game](#DungeonGame)
	* 1.69. [179 Largest Number](#LargestNumber)
	* 1.70. [186. Reverse Words in a String II](#ReverseWordsinaStringII)
	* 1.71. [187 Repeated DNA Sequences](#RepeatedDNASequences)
	* 1.72. [188 Best Time to Buy and Sell Stock IV](#BestTimetoBuyandSellStockIV)
	* 1.73. [189. Rotate Array](#RotateArray)
	* 1.74. [190. Reverse Bits](#ReverseBits)
	* 1.75. [191 Number of 1 Bits](#Numberof1Bits)
	* 1.76. [198. House Robber 198-打家劫舍](#HouseRobber198-)
	* 1.77. [199 Binary Tree Right Side View](#BinaryTreeRightSideView)
	* 1.78. [200-岛屿数量](#-1)
	* 1.79. [201 Bitwise AND of Numbers Range](#BitwiseANDofNumbersRange)
	* 1.80. [202. 快乐数 Happy Number](#HappyNumber)
	* 1.81. [203. Remove Linked List Elements](#RemoveLinkedListElements)
	* 1.82. [204-Count Primes](#CountPrimes)
	* 1.83. [205. isomorphic strings](#isomorphicstrings)
	* 1.84. [206-Reverse Linked List](#ReverseLinkedList)
	* 1.85. [207-课程表](#-1)
	* 1.86. [208. Implement Trie (Prefix Tree)](#ImplementTriePrefixTree)
	* 1.87. [209-长度最小的子数组](#-1)
	* 1.88. [210. Course Schedule II 210-课程表II](#CourseScheduleII210-II)
	* 1.89. [211 Add and Search Word](#AddandSearchWord)
	* 1.90. [212. Word Search II](#WordSearchII)
	* 1.91. [213. House Robber II 213-打家劫舍II](#HouseRobberII213-II)
	* 1.92. [216. Combination Sum III 216-组合总和 III](#CombinationSumIII216-III)
	* 1.93. [217. Contains Duplicate](#ContainsDuplicate)
	* 1.94. [218. The Skyline Problem](#TheSkylineProblem)
	* 1.95. [219. Contains Duplicate II](#ContainsDuplicateII)
	* 1.96. [220 Contains Duplicate III](#ContainsDuplicateIII)
	* 1.97. [221-最大正方形](#-1)
	* 1.98. [222. Count Complete Tree Nodes](#CountCompleteTreeNodes)
	* 1.99. [223. Rectangle Area](#RectangleArea)
	* 1.100. [225-Implement Stack using Queues](#ImplementStackusingQueues)
	* 1.101. [226-翻转二叉树](#-1)
	* 1.102. [227 Basic Calculator II](#BasicCalculatorII)
	* 1.103. [228 Summary Ranges](#SummaryRanges)
	* 1.104. [229. Majority Element II](#MajorityElementII)
	* 1.105. [230 Kth Smallest Element in a B](#KthSmallestElementinaB)
	* 1.106. [231. Power of Two](#PowerofTwo)
	* 1.107. [232-Implement Queue using Stacks](#ImplementQueueusingStacks)
	* 1.108. [234. Palindrome Linked List](#PalindromeLinkedList)
	* 1.109. [235. Lowest Common Ancestor of a Binary Search Tree](#LowestCommonAncestorofaBinarySearchTree)
	* 1.110. [236-二叉树的最近公共祖先](#-1)
	* 1.111. [237. Delete Node in a Linked List](#DeleteNodeinaLinkedList)
	* 1.112. [238 Product of Array Except Self](#ProductofArrayExceptSelf)
	* 1.113. [239. Sliding Window Maximum](#SlidingWindowMaximum)
	* 1.114. [240. 二维数组的查找](#-1)
	* 1.115. [242. Valid Anagram](#ValidAnagram)
	* 1.116. [243. Shortest Word Distance](#ShortestWordDistance)
	* 1.117. [246. Strobogrammatic Number](#StrobogrammaticNumber)
	* 1.118. [257-二叉树的所有路径](#-1)
	* 1.119. [258. Add Digits](#AddDigits)
	* 1.120. [260-只出现一次的数字 III](#III-1)
	* 1.121. [263 Ugly Number](#UglyNumber)
	* 1.122. [264. Ugly Number II](#UglyNumberII)
	* 1.123. [268 Missing Number](#MissingNumber)
	* 1.124. [270. Closest Binary Search Tree Value](#ClosestBinarySearchTreeValue)
	* 1.125. [274 H-Index](#H-Index)
	* 1.126. [278. First Bad Version](#FirstBadVersion)
	* 1.127. [279 Perfect Squares](#PerfectSquares)
	* 1.128. [282. Expression Add Operators](#ExpressionAddOperators)
	* 1.129. [283. Move Zeros](#MoveZeros)
	* 1.130. [284 Peeking Iterator](#PeekingIterator)
	* 1.131. [287 Find the Duplicate Number](#FindtheDuplicateNumber)
	* 1.132. [289. Game of Life](#GameofLife)
	* 1.133. [290. Word Pattern](#WordPattern)
	* 1.134. [297. Serialize and Deserialize Binary Tree](#SerializeandDeserializeBinaryTree)
	* 1.135. [299. Bulls and Cows](#BullsandCows)
	* 1.136. [300 Longest Increasing Subsequence 最长上升子序列](#LongestIncreasingSubsequence)
	* 1.137. [301. Remove Invalid Parentheses](#RemoveInvalidParentheses)
	* 1.138. [303-区域和检索 - 数组不可变](#-1)
	* 1.139. [304. Range Sum Query 2D](#RangeSumQuery2D)
	* 1.140. [309. Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期](#BestTimetoBuyandSellStockwithCooldown309-)
	* 1.141. [310 Minimum Height Trees](#MinimumHeightTrees)
	* 1.142. [312 Burst Balloons](#BurstBalloons)
	* 1.143. [315. Count of Smaller Numbers After Self](#CountofSmallerNumbersAfterSelf)
	* 1.144. [316 Remove Duplicate Letters](#RemoveDuplicateLetters)
	* 1.145. [321. Create Maximum Number](#CreateMaximumNumber)
	* 1.146. [322. Coin Change](#CoinChange)
	* 1.147. [326. Power of Three](#PowerofThree)
	* 1.148. [328. 奇偶链表 (Odd Even Linked List)](#OddEvenLinkedList)
	* 1.149. [329. Longest Increasing Path in a Matrix](#LongestIncreasingPathinaMatrix)
	* 1.150. [332 Reconstruct Itinerary](#ReconstructItinerary)
	* 1.151. [334 Increasing Triplet Subseque](#IncreasingTripletSubseque)
	* 1.152. [337 House Robber III](#HouseRobberIII)
	* 1.153. [338 Counting Bits](#CountingBits)
	* 1.154. [342. Power of Four](#PowerofFour)
	* 1.155. [343-整数拆分](#-1)
	* 1.156. [344. Reverse String](#ReverseString)
	* 1.157. [345. Reverse Vowels of a String](#ReverseVowelsofaString)
	* 1.158. [346 Moving Average from Data Stream](#MovingAveragefromDataStream)
	* 1.159. [347. Top K Frequent Elements](#TopKFrequentElements)
	* 1.160. [349. Intersection of Two Arrays](#IntersectionofTwoArrays)
	* 1.161. [350. Intersection of Two Arrays II](#IntersectionofTwoArraysII)
	* 1.162. [355. 设计推特 Design Twitter](#DesignTwitter)
	* 1.163. [359 Logger Rate Limiter](#LoggerRateLimiter)
	* 1.164. [367. Valid Perfect Square](#ValidPerfectSquare)
	* 1.165. [368 Largest Divisible Subset](#LargestDivisibleSubset)
	* 1.166. [373. Find K Pairs with Smallest Sums查找和最小的k对数字](#FindKPairswithSmallestSumsk)
	* 1.167. [374. Guess Number Higher or Lower](#GuessNumberHigherorLower)
	* 1.168. [376-摆动序列](#-1)
	* 1.169. [377. Combination Sum IV](#CombinationSumIV)
	* 1.170. [378-有序矩阵中第K小的元素](#K)
	* 1.171. [380 Insert Delete GetRandom O(1)](#InsertDeleteGetRandomO1)
	* 1.172. [382 Linked List Random Node](#LinkedListRandomNode)
	* 1.173. [383 Ransom Note](#RansomNote)
	* 1.174. [387. First Unique Character in a String](#FirstUniqueCharacterinaString)
	* 1.175. [389. Find the Difference](#FindtheDifference)
	* 1.176. [391. Perfect Rectangle](#PerfectRectangle)
	* 1.177. [392. Is Subsequence](#IsSubsequence)
	* 1.178. [393. UTF-8 Validation](#UTF-8Validation)
	* 1.179. [394 Decode String](#DecodeString)
	* 1.180. [395 Longest Substring with At Least K](#LongestSubstringwithAtLeastK)
	* 1.181. [399. Evaluate Division](#EvaluateDivision)
	* 1.182. [402 Remove K Digits](#RemoveKDigits)
	* 1.183. [404. Sum of Left Leaves](#SumofLeftLeaves)
	* 1.184. [405-Convert a Number to Hexadecimal](#ConvertaNumbertoHexadecimal)
	* 1.185. [406. Queue Reconstruction by Height](#QueueReconstructionbyHeight)
	* 1.186. [408. Valid Word Abbreviation](#ValidWordAbbreviation)
	* 1.187. [409. Longest Palindrome](#LongestPalindrome)
	* 1.188. [410. Split Array Largest Sum](#SplitArrayLargestSum)
	* 1.189. [412. Fizz Buzz](#FizzBuzz)
	* 1.190. [413-等差数列划分](#-1)
	* 1.191. [414. Third Maximum Number](#ThirdMaximumNumber)
	* 1.192. [415-Add Strings](#AddStrings)
	* 1.193. [416. Partition Equal Subset Sum](#PartitionEqualSubsetSum)
	* 1.194. [417. Pacific Atlantic Water Flow](#PacificAtlanticWaterFlow)
	* 1.195. [419. Battleships in a Board](#BattleshipsinaBoard)
	* 1.196. [421 Maximum XOR of Two Numbers in an Array](#MaximumXORofTwoNumbersinanArray)
	* 1.197. [423 Reconstruct Original Digits from English](#ReconstructOriginalDigitsfromEnglish)
	* 1.198. [424. 替换后的最长重复字符 Longest Repeating Character Replacem](#LongestRepeatingCharacterReplacem)
	* 1.199. [429. N-ary Tree Level Order Traversal](#N-aryTreeLevelOrderTraversal)
	* 1.200. [430 Flatten a Multilevel Doubly Linked List](#FlattenaMultilevelDoublyLinkedList)
	* 1.201. [432. All O`one Data Structure](#AllOoneDataStructure)
	* 1.202. [435-Non-overlapping Intervals](#Non-overlappingIntervals)
	* 1.203. [436 Find Right Interval](#FindRightInterval)
	* 1.204. [437 Path Sum III](#PathSumIII)
	* 1.205. [438. Find All Anagrams in a String](#FindAllAnagramsinaString)
	* 1.206. [441 Arranging Coins](#ArrangingCoins)
	* 1.207. [442 Find All Duplicates in an Array](#FindAllDuplicatesinanArray)
	* 1.208. [443. String Compression](#StringCompression)
	* 1.209. [445-Add Two Numbers II](#AddTwoNumbersII)
	* 1.210. [447. Number of Boomerangs](#NumberofBoomerangs)
	* 1.211. [448. Find All Numbers Disappeared in an Array](#FindAllNumbersDisappearedinanArray)
	* 1.212. [449. Serialize and Deserialize BST](#SerializeandDeserializeBST)
	* 1.213. [450. Delete Node in a BST](#DeleteNodeinaBST)
	* 1.214. [451 Sort Characters By Frequency](#SortCharactersByFrequency)
	* 1.215. [454 4Sum II](#SumII)
	* 1.216. [452. Minimum Number of Arrows to Burst Balloons](#MinimumNumberofArrowstoBurstBalloons)
	* 1.217. [455-Assign Cookies](#AssignCookies)
	* 1.218. [456 132 Pattern](#Pattern)
	* 1.219. [458 Poor Pigs](#PoorPigs)
	* 1.220. [459 Repeated Substring Pattern](#RepeatedSubstringPattern)
	* 1.221. [460. LFU Cache / O(1)](#LFUCacheO1)
	* 1.222. [461 Hamming Distance](#HammingDistance)
	* 1.223. [463 Island Perimeter](#IslandPerimeter)
	* 1.224. [464. Can I Win](#CanIWin)
	* 1.225. [466. 统计重复个数 Count The Repetitions](#CountTheRepetitions)
	* 1.226. [468 Validate IP Address](#ValidateIPAddress)
	* 1.227. [470. Implement Rand10() Using Rand7()](#ImplementRand10UsingRand7)
	* 1.228. [475. Heaters](#Heaters)
	* 1.229. [476. Number Complement](#NumberComplement)
	* 1.230. [477. Total Hamming Distance](#TotalHammingDistance)
	* 1.231. [478 Generate Random Point in a Circle](#GenerateRandomPointinaCircle)
	* 1.232. [480. Sliding Window Median](#SlidingWindowMedian)
	* 1.233. [484 Find Permutation](#FindPermutation)
	* 1.234. [485. Max Consecutive Ones](#MaxConsecutiveOnes)
	* 1.235. [486. Predict the Winner](#PredicttheWinner)
	* 1.236. [490 The Maze](#TheMaze)
	* 1.237. [494. Target Sum](#TargetSum)
	* 1.238. [495 Teemo Attacking](#TeemoAttacking)
	* 1.239. [496. 下一个更大元素 I (Next Greater Element I)](#INextGreaterElementI)
	* 1.240. [497 Random Point in Non-overlapping](#RandomPointinNon-overlapping)
	* 1.241. [500. Keyboard Row](#KeyboardRow)
	* 1.242. [503-Next Greater Element II](#NextGreaterElementII)
	* 1.243. [504-Base 7](#Base7)
	* 1.244. [509. Fibonacci Number](#FibonacciNumber)
	* 1.245. [516. Longest Palindromic Subsequence](#LongestPalindromicSubsequence)
	* 1.246. [518 Coin Change 2](#CoinChange2)
	* 1.247. [520. Detect Capital](#DetectCapital)
	* 1.248. [525. Contiguous Array](#ContiguousArray)
	* 1.249. [526 Beautiful Arrangement](#BeautifulArrangement)
	* 1.250. [528 Random Pick with Weight](#RandomPickwithWeight)
	* 1.251. [530. Minimum Absolute Difference in BST](#MinimumAbsoluteDifferenceinBST)
	* 1.252. [532 K-diff Pairs in an Array](#K-diffPairsinanArray)
	* 1.253. [535. Encode and Decode TinyURL](#EncodeandDecodeTinyURL)
	* 1.254. [537 Complex Number Multiplicatin](#ComplexNumberMultiplicatin)
	* 1.255. [538 Convert BST to Greater Tree](#ConvertBSTtoGreaterTree)
	* 1.256. [540. Single Element in a Sorted Array 540-有序数组中的单一元素](#SingleElementinaSortedArray540-)
	* 1.257. [542. 01 矩阵 01 Matrix](#Matrix)
	* 1.258. [543 Diameter of Binary Tree](#DiameterofBinaryTree)
	* 1.259. [546 Remove Boxes](#RemoveBoxes)
	* 1.260. [547-朋友圈](#-1)
	* 1.261. [554 Brick Wall](#BrickWall)
	* 1.262. [556 Next Greater Element III](#NextGreaterElementIII)
	* 1.263. [560. Subarray Sum Equals K 和为K的子数组](#SubarraySumEqualsKK)
	* 1.264. [563 Binary Tree Tilt](#BinaryTreeTilt)
	* 1.265. [567. Permutation in String 567-字符串的排列](#PermutationinString567-)
	* 1.266. [572-另一个树的子树](#-1)
	* 1.267. [575 Distribute Candies](#DistributeCandies)
	* 1.268. [576. Out of Boundary Paths](#OutofBoundaryPaths)
	* 1.269. [581 Shortest Unsorted Continuous Suba](#ShortestUnsortedContinuousSuba)
	* 1.270. [589 N-ary Tree Preorder Traversal](#N-aryTreePreorderTraversal)
	* 1.271. [593 Valid Square](#ValidSquare)
	* 1.272. [594 Longest Harmonious Subsequence](#LongestHarmoniousSubsequence)
	* 1.273. [605 Can Place Flowers](#CanPlaceFlowers)
	* 1.274. [621. Task Scheduler](#TaskScheduler)
	* 1.275. [622 Design Circular Queue](#DesignCircularQueue)
	* 1.276. [623 Add One Row to Tree](#AddOneRowtoTree)
	* 1.277. [633-Sum of Square Numbers](#SumofSquareNumbers)
	* 1.278. [636. Exclusive Time of Functions](#ExclusiveTimeofFunctions)
	* 1.279. [637 Average of Levels in Binary Tree](#AverageofLevelsinBinaryTree)
	* 1.280. [639. Decode Ways II](#DecodeWaysII)
	* 1.281. [643. Maximum Average Subarray I](#MaximumAverageSubarrayI)
	* 1.282. [645-错误的集合](#-1)
	* 1.283. [646-最长数对链](#-1)
	* 1.284. [647 Palindromic Substrings](#PalindromicSubstrings)
	* 1.285. [650-只有两个键的键盘](#-1)
	* 1.286. [652. Find Duplicate Subtrees](#FindDuplicateSubtrees)
	* 1.287. [653. Two Sum IV](#TwoSumIV)
	* 1.288. [662. Maximum Width of Binary Tree](#MaximumWidthofBinaryTree)
	* 1.289. [667 Beautiful Arrangement II](#BeautifulArrangementII)
	* 1.290. [668. Kth Smallest Number in Multiplication Table](#KthSmallestNumberinMultiplicationTable)
	* 1.291. [669 Trim a Binary Search Tree](#TrimaBinarySearchTree)
	* 1.292. [673 Number of Longest Increasing Subse](#NumberofLongestIncreasingSubse)
	* 1.293. [678 Valid Parenthesis String](#ValidParenthesisString)
	* 1.294. [680-Valid Palindrome II](#ValidPalindromeII)
	* 1.295. [683. K Empty Slots](#KEmptySlots)
	* 1.296. [684. Redundant Connection 684-冗余连接](#RedundantConnection684-)
	* 1.297. [685. Redundant Connection II](#RedundantConnectionII)
	* 1.298. [687. Longest Univalue Path](#LongestUnivaluePath)
	* 1.299. [688. Knight Probability in Chessboard](#KnightProbabilityinChessboard)
	* 1.300. [690. Employee Importance](#EmployeeImportance)
	* 1.301. [692. Top K Frequent Words](#TopKFrequentWords)
	* 1.302. [695-岛屿的最大面积](#-1)
	* 1.303. [696 Count Binary Substrings](#CountBinarySubstrings)
	* 1.304. [699. Falling Squares](#FallingSquares)
	* 1.305. [700 Search in a Binary Search Tree](#SearchinaBinarySearchTree)
	* 1.306. [701 Insert into a Binary Search Tree](#InsertintoaBinarySearchTree)
	* 1.307. [703.Kth Largest Element in a Stream数据流中的第K大元素](#KthLargestElementinaStreamK)
	* 1.308. [704.Binary Search二分查找](#BinarySearch)
	* 1.309. [705 Design HashSet](#DesignHashSet)
	* 1.310. [706. Design HashMap设计哈希映射](#DesignHashMap)
	* 1.311. [707. Design Linked List](#DesignLinkedList)
	* 1.312. [712. Minimum ASCII Delete Sum for Two Strings](#MinimumASCIIDeleteSumforTwoStrings)
	* 1.313. [713 Subarray Product Less Than K](#SubarrayProductLessThanK)
	* 1.314. [714-买卖股票的最佳时机含手续费](#-1)
	* 1.315. [715. Range Module](#RangeModule)
	* 1.316. [719. Find K-th Smallest Pair Distance](#FindK-thSmallestPairDistance)
	* 1.317. [720. Longest Word in Dictionary](#LongestWordinDictionary)
	* 1.318. [724. Find Pivot Index](#FindPivotIndex)
	* 1.319. [725. Split Linked List in Parts](#SplitLinkedListinParts)
	* 1.320. [726. Number of Atoms](#NumberofAtoms)
	* 1.321. [730. Count Different Palindromic Subsequences](#CountDifferentPalindromicSubsequences)
	* 1.322. [732. My Calendar III](#MyCalendarIII)
	* 1.323. [733. 图像渲染 Flood Fill](#FloodFill)
	* 1.324. [735 Asteroid Collision](#AsteroidCollision)
	* 1.325. [737. Sentence Similarity II](#SentenceSimilarityII)
	* 1.326. [739-Daily Temperatures](#DailyTemperatures)
	* 1.327. [740. Delete and Earn](#DeleteandEarn)
	* 1.328. [741. Cherry Pickup](#CherryPickup)
	* 1.329. [743. Network Delay Time](#NetworkDelayTime)
	* 1.330. [745. Prefix and Suffix Search](#PrefixandSuffixSearch)
	* 1.331. [746. Min Cost Climbing Stairs](#MinCostClimbingStairs)
	* 1.332. [748. Shortest Completing Word](#ShortestCompletingWord)
	* 1.333. [752. Open the Lock](#OpentheLock)
	* 1.334. [763 Partition Labels](#PartitionLabels)
	* 1.335. [765. 情侣牵手 Couples Holding Hands](#CouplesHoldingHands)
	* 1.336. [769. Max Chunks To Make Sorted](#MaxChunksToMakeSorted)
	* 1.337. [771 Jewels and Stones](#JewelsandStones)
	* 1.338. [773. Sliding Puzzle](#SlidingPuzzle)
	* 1.339. [775. Global and Local Inversions](#GlobalandLocalInversions)
	* 1.340. [778. Swim in Rising Water](#SwiminRisingWater)
	* 1.341. [784. Letter Case Permutation](#LetterCasePermutation)
	* 1.342. [785-判断二分图](#-1)
	* 1.343. [786. K-th Smallest Prime Fraction](#K-thSmallestPrimeFraction)
	* 1.344. [787. Cheapest Flights Within K Stops](#CheapestFlightsWithinKStops)
	* 1.345. [790. Domino and Tromino Tiling](#DominoandTrominoTiling)
	* 1.346. [792. Number of Matching Subsequences](#NumberofMatchingSubsequences)
	* 1.347. [797 All Paths From Source to Target](#AllPathsFromSourcetoTarget)
	* 1.348. [799 Champagne Tower](#ChampagneTower)
	* 1.349. [801. Minimum Swaps To Make Sequences Increasing](#MinimumSwapsToMakeSequencesIncreasing)
	* 1.350. [803. Bricks Falling When Hit](#BricksFallingWhenHit)
	* 1.351. [804 Unique Morse Code Words](#UniqueMorseCodeWords)
	* 1.352. [813. Largest Sum of Averages](#LargestSumofAverages)
	* 1.353. [815. Bus Routes](#BusRoutes)
	* 1.354. [817. Linked List Components](#LinkedListComponents)
	* 1.355. [818. Race Car (上)](#RaceCar)
	* 1.356. [821 Shortest Distance to a Character](#ShortestDistancetoaCharacter)
	* 1.357. [823. Binary Trees With Factors](#BinaryTreesWithFactors)
	* 1.358. [824 Goat Latin](#GoatLatin)
	* 1.359. [827. Making A Large Island](#MakingALargeIsland)
	* 1.360. [832 Flipping an Image](#FlippinganImage)
	* 1.361. [835 Image Overlap](#ImageOverlap)
	* 1.362. [837. 新 21 点 New 21 Game](#New21Game)
	* 1.363. [841 Keys and Rooms](#KeysandRooms)
	* 1.364. [842. Split Array into Fibonacci Sequence](#SplitArrayintoFibonacciSequence)
	* 1.365. [844 Backspace String Compare](#BackspaceStringCompare)
	* 1.366. [845 Longest Mountain in Array](#LongestMountaininArray)
	* 1.367. [847 Shortest Path Visiting All Nodes](#ShortestPathVisitingAllNodes)
	* 1.368. [849 Maximize Distance to Closest Person](#MaximizeDistancetoClosestPerson)
	* 1.369. [856. Score of Parentheses](#ScoreofParentheses)
	* 1.370. [858 Mirror Reflection](#MirrorReflection)
	* 1.371. [859 Buddy Strings](#BuddyStrings)
	* 1.372. [863. All Nodes Distance K in Binary Tree](#AllNodesDistanceKinBinaryTree)
	* 1.373. [864. Shortest Path to Get All Keys](#ShortestPathtoGetAllKeys)
	* 1.374. [869 Reordered Power of 2](#ReorderedPowerof2)
	* 1.375. [865. Smallest Subtree with all the Deepest Nodes](#SmallestSubtreewithalltheDeepestNodes)
	* 1.376. [871. Minimum Number of Refueling Stops](#MinimumNumberofRefuelingStops)
	* 1.377. [873. Length of Longest Fibonacci Subsequence](#LengthofLongestFibonacciSubsequence)
	* 1.378. [875.Koko Eating Bananas科科吃香蕉](#KokoEatingBananas)
	* 1.379. [876.Middle of the Linked List 链表的中间结点](#MiddleoftheLinkedList)
	* 1.380. [877 Stone Game](#StoneGame)
	* 1.381. [879. Profitable Schemes](#ProfitableSchemes)
	* 1.382. [880 Decoded String at Index](#DecodedStringatIndex)
	* 1.383. [881 Boats to Save People](#BoatstoSavePeople)
	* 1.384. [882. Reachable Nodes In Subdivided Graph](#ReachableNodesInSubdividedGraph)
	* 1.385. [886. Possible Bipartition](#PossibleBipartition)
	* 1.386. [887. Super Egg Drop](#SuperEggDrop)
	* 1.387. [889. Construct Binary Tree from Preorder and Postorder](#ConstructBinaryTreefromPreorderandPostorder)
	* 1.388. [891. Sum of Subsequence Widths](#SumofSubsequenceWidths)
	* 1.389. [894. All Possible Full Binary Trees](#AllPossibleFullBinaryTrees)
	* 1.390. [895. Maximum Frequency Stack](#MaximumFrequencyStack)
	* 1.391. [898. Bitwise ORs of Subarrays](#BitwiseORsofSubarrays)
	* 1.392. [901. Online Stock Span](#OnlineStockSpan)
	* 1.393. [902 Numbers At Most N Given Digit Set](#NumbersAtMostNGivenDigitSet)
	* 1.394. [904-水果成篮](#-1)
	* 1.395. [905 Sort Array By Parity](#SortArrayByParity)
	* 1.396. [906 Super Palindromes](#SuperPalindromes)
	* 1.397. [909. Snakes and Ladders](#SnakesandLadders)
	* 1.398. [910 Smallest Range II](#SmallestRangeII)
	* 1.399. [916 Word Subsetse](#WordSubsetse)
	* 1.400. [918 Maximum Sum Circular Sub](#MaximumSumCircularSub)
	* 1.401. [923. 3Sum With Multiplicity](#SumWithMultiplicity)
	* 1.402. [926. Flip String to Monotone Increasing](#FlipStringtoMonotoneIncreasing)
	* 1.403. [930-和相同的二元子数组(滑动窗口+前缀和)](#-1)
	* 1.404. [933 Number of Recent Calls](#NumberofRecentCalls)
	* 1.405. [934. Shortest Bridge](#ShortestBridge)
	* 1.406. [936 Stamping The Sequence](#StampingTheSequence)
	* 1.407. [938 Range Sum of BST](#RangeSumofBST)
	* 1.408. [941 Valid Mountain Array](#ValidMountainArray)
	* 1.409. [943. Find the Shortest Superstring](#FindtheShortestSuperstring)
	* 1.410. [946-Python-栈的压入、弹出序列](#Python-)
	* 1.411. [946 Validate Stack Sequences](#ValidateStackSequences)
	* 1.412. [947. 移除最多的同行或同列石头 Most Stones Removed with Same](#MostStonesRemovedwithSame)
	* 1.413. [948 Bag of Tokens](#BagofTokens)
	* 1.414. [949 Largest Time for Given Digits](#LargestTimeforGivenDigits)
	* 1.415. [952 Largest Component Size by Commo](#LargestComponentSizebyCommo)
	* 1.416. [953 Verifying an Alien Dictionary](#VerifyinganAlienDictionary)
	* 1.417. [954 Array of Doubled Pairs](#ArrayofDoubledPairs)
	* 1.418. [959. 由斜杠划分区域 Regions Cut By Slashes](#RegionsCutBySlashes)
	* 1.419. [964. Least Operators to Express Number](#LeastOperatorstoExpressNumber)
	* 1.420. [966 Vowel Spellchecker](#VowelSpellchecker)
	* 1.421. [967. Numbers With Same Consecutive Differences](#NumbersWithSameConsecutiveDifferences)
	* 1.422. [968 Binary Tree Cameras](#BinaryTreeCameras)
	* 1.423. [969 Pancake Sorting](#PancakeSorting)
	* 1.424. [971 Flip Binary Tree To Match Preorder](#FlipBinaryTreeToMatchPreorder)
	* 1.425. [973 K Closest Points to Origin](#KClosestPointstoOrigin)
	* 1.426. [974. 和可被 K 整除的子数组 Subarray Sums Divisible by K](#KSubarraySumsDivisiblebyK)
	* 1.427. [975. Odd Even Jump](#OddEvenJump)
	* 1.428. [976 Middle of the Linked List](#MiddleoftheLinkedList-1)
	* 1.429. [977 Squares of a Sorted Array](#SquaresofaSortedArray)
	* 1.430. [978. 最长湍流子数组 Longest Turbulent Subarray](#LongestTurbulentSubarray)
	* 1.431. [980. Unique Paths III](#UniquePathsIII)
	* 1.432. [983 Minimum Cost For Tickets](#MinimumCostForTickets)
	* 1.433. [986 Interval List Intersections](#IntervalListIntersections)
	* 1.434. [987 Vertical Order Traversal of a Binary](#VerticalOrderTraversalofaBinary)
	* 1.435. [990. 等式方程的可满足性 Satisfiability of Equality Equations](#SatisfiabilityofEqualityEquations)
	* 1.436. [992-K 个不同整数的子数组](#K-1)
	* 1.437. [993. 二叉树的堂兄弟节点](#-1)
	* 1.438. [994-腐烂的橘子](#-1)
	* 1.439. [993, 994, 995, 996](#-1)
	* 1.440. [997 Find the Town Judge](#FindtheTownJudge)
	* 1.441. [1000. Minimum Cost to Merge Stones](#MinimumCosttoMergeStones)
	* 1.442. [1001 Grid Illumination](#GridIllumination)
	* 1.443. [1004-最大连续1的个数 III](#III-1)
	* 1.444. [1007 Minimum Domino Rotations For Eq](#MinimumDominoRotationsForEq)
	* 1.445. [1008 Construct Binary Search Tree from](#ConstructBinarySearchTreefrom)
	* 1.446. [1009 Complement of Base 10 Integer](#ComplementofBase10Integer)
	* 1.447. [1010 Pairs of Songs With Total Durations](#PairsofSongsWithTotalDurations)
	* 1.448. [1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ](#PartitionArrayIntoThreePartsWithEqu)
	* 1.449. [1015 Smallest Integer Divisible by K](#SmallestIntegerDivisiblebyK)
	* 1.450. [1019. Next Greater Node In Linked List](#NextGreaterNodeInLinkedList)
	* 1.451. [1022 Sum of Root To Leaf Binary Numbers](#SumofRootToLeafBinaryNumbers)
	* 1.452. [1025,1026,1027,1028](#-1)
	* 1.453. [1024. Video Stitching](#VideoStitching)
	* 1.454. [1026 Maximum Difference Between Nod](#MaximumDifferenceBetweenNod)
	* 1.455. [1029 Two City Scheduling](#TwoCityScheduling)
	* 1.456. [1032 Stream of Characters](#StreamofCharacters)
	* 1.457. [1035 Uncrossed Lines](#UncrossedLines)
	* 1.458. [1041 Robot Bounded In Circle](#RobotBoundedInCircle)
	* 1.459. [1043. Partition Array for Maximum Sum](#PartitionArrayforMaximumSum)
	* 1.460. [1044 Longest Duplicate Substring](#LongestDuplicateSubstring)
	* 1.461. [1046 Last Stone Weight](#LastStoneWeight)
	* 1.462. [1048 Longest String Chain](#LongestStringChain)
	* 1.463. [1055.Shortest Way to Form String 形成字符串的最短路径](#ShortestWaytoFormString)
	* 1.464. [1091-二进制矩阵中的最短路径](#-1)
	* 1.465. [1094 Car Pooling](#CarPooling)
	* 1.466. [1095. Find in Mountain Array](#FindinMountainArray)
	* 1.467. [1105. Filling Bookcase Shelves](#FillingBookcaseShelves)
	* 1.468. [1106. Parsing A Boolean Expression](#ParsingABooleanExpression)
	* 1.469. [1110. Delete Nodes And Return Forest](#DeleteNodesAndReturnForest)
	* 1.470. [1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses](#MaximumNestingDepthofTwoValidParentheses)
	* 1.471. [1114 - 1115 - 1116 - 多线程 threading](#threading)
	* 1.472. [1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖](#LowestCommonAncestorofDeepestLeaves)
	* 1.473. [1124. Longest Well-Performing Interval](#LongestWell-PerformingInterval)
	* 1.474. [1125. Smallest Sufficient Team](#SmallestSufficientTeam)
	* 1.475. [1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs](#NumberofEquivalentDominoPairs)
	* 1.476. [1129. Shortest Path with Alternating Colors](#ShortestPathwithAlternatingColors)
	* 1.477. [1137. N-th Tribonacci Number](#N-thTribonacciNumber)
	* 1.478. [1140. Stone Game II](#StoneGameII)
	* 1.479. [1143 Longest Common Subsequence](#LongestCommonSubsequence)
	* 1.480. [1145. Binary Tree Coloring Game](#BinaryTreeColoringGame)
	* 1.481. [1155. Number of Dice Rolls With Target Sum](#NumberofDiceRollsWithTargetSum)
	* 1.482. [1160. 拼写单词 Find Words That Can Be Formed by Characters](#FindWordsThatCanBeFormedbyCharacters)
	* 1.483. [1172. Dinner Plate Stacks](#DinnerPlateStacks)
	* 1.484. [1178. Number of Valid Words for Each Puzzle](#NumberofValidWordsforEachPuzzle)
	* 1.485. [1187. Make Array Strictly Increasing](#MakeArrayStrictlyIncreasing)
	* 1.486. [1191. K-Concatenation Maximum Sum](#K-ConcatenationMaximumSum)
	* 1.487. [1201. Ugly Number III](#UglyNumberIII)
	* 1.488. [1202. Smallest String With Swaps](#SmallestStringWithSwaps)
	* 1.489. [1203. 项目管理 Sort Items by Groups Respecting Dependencies](#SortItemsbyGroupsRespectingDependencies)
	* 1.490. [1206. Design Skiplist](#DesignSkiplist)
	* 1.491. [1209 Remove All Adjacent Duplicates in](#RemoveAllAdjacentDuplicatesin)
	* 1.492. [1217 Minimum Cost to Move Chips](#MinimumCosttoMoveChips)
	* 1.493. [1218. Longest Arithmetic Subsequence of Given Difference](#LongestArithmeticSubsequenceofGivenDifference)
	* 1.494. [1220. Count Vowels Permutation](#CountVowelsPermutation)
	* 1.495. [1223 Dice Roll Simulation](#DiceRollSimulation)
	* 1.496. [1240 Tiling a Rectangle with the Fewest Squares](#TilingaRectanglewiththeFewestSquares)
	* 1.497. [1248-统计「优美子数组」](#-1)
	* 1.498. [1249 Minimum Remove to Make Valid Pare](#MinimumRemovetoMakeValidPare)
	* 1.499. [1252 1253 1254 1255](#-1)
	* 1.500. [1263. Minimum Moves to Move a Box to Their Target](#MinimumMovestoMoveaBoxtoTheirTarget)
	* 1.501. [1277-统计全为1的正方形子矩阵](#-1)
	* 1.502. [1278. Palindrome Partitioning III](#PalindromePartitioningIII)
	* 1.503. [1283 Find the Smallest Divisor Given a](#FindtheSmallestDivisorGivena)
	* 1.504. [1284. Minimum Number of Flips to Convert Binary Matrix](#MinimumNumberofFlipstoConvertBinaryMatrix)
	* 1.505. [1290. 二进制链表转整数 (Convert Binary Number in a Linked List](#ConvertBinaryNumberinaLinkedList)
	* 1.506. [1291 Sequential Digits](#SequentialDigits)
	* 1.507. [1293. Shortest Path in a Grid with Obstacles Elimination](#ShortestPathinaGridwithObstaclesElimination)
	* 1.508. [1296. Divide Array in Sets of K Consecutive Numbers](#DivideArrayinSetsofKConsecutiveNumbers)
	* 1.509. [1301. Number of Paths with Max Score](#NumberofPathswithMaxScore)
	* 1.510. [1302 Deepest Leaves Sum](#DeepestLeavesSum)
	* 1.511. [1305 All Elements in Two Binary Search](#AllElementsinTwoBinarySearch)
	* 1.512. [1306 Jump Game III](#JumpGameIII)
	* 1.513. [1310. XOR Queries of a Subarray](#XORQueriesofaSubarray)
	* 1.514. [1312. Minimum Insertion Steps to Make a String Palindrom](#MinimumInsertionStepstoMakeaStringPalindrom)
	* 1.515. [1320. Minimum Distance to Type a Word Using Two Finger](#MinimumDistancetoTypeaWordUsingTwoFinger)
	* 1.516. [1329 Sort the Matrix Diagonally](#SorttheMatrixDiagonally)
	* 1.517. [1332 Remove Palindromic Subsequences](#RemovePalindromicSubsequences)
	* 1.518. [1334. Find the City With Smallest Number of Neighbors](#FindtheCityWithSmallestNumberofNeighbors)
	* 1.519. [1335. Minimum Difficulty of a Job Schedule](#MinimumDifficultyofaJobSchedule)
	* 1.520. [1337 The K Weakest Rows in a Matrix](#TheKWeakestRowsinaMatrix)
	* 1.521. [1339 Maximum Product of Splitt](#MaximumProductofSplitt)
	* 1.522. [1340. Jump Game V](#JumpGameV)
	* 1.523. [1349. Maximum Students Taking Exam](#MaximumStudentsTakingExam)
	* 1.524. [1353. Maximum Number of Events That Can Be Attended](#MaximumNumberofEventsThatCanBeAttended)
	* 1.525. [1354. Construct Target Array With Multiple Sums](#ConstructTargetArrayWithMultipleSums)
	* 1.526. [1368. Minimum Cost to Make at Least One Valid Path](#MinimumCosttoMakeatLeastOneValidPath)
	* 1.527. [1371. Find the Longest Substring Containing Vowels in Eve](#FindtheLongestSubstringContainingVowelsinEve)
	* 1.528. [1373. Maximum Sum BST in Binary Tree](#MaximumSumBSTinBinaryTree)
	* 1.529. [1377. Frog Position After T Seconds](#FrogPositionAfterTSeconds)
	* 1.530. [1379 Find Corresponding Node of Binary Tree in a Clone](#FindCorrespondingNodeofBinaryTreeinaClone)
	* 1.531. [1382. Balance a Binary Search Tree](#BalanceaBinarySearchTree)
	* 1.532. [1395. Count Number of Teams](#CountNumberofTeams)
	* 1.533. [1396 Design Underground System](#DesignUndergroundSystem)
	* 1.534. [1406. Stone Game III](#StoneGameIII)
	* 1.535. [1409. Queries on a Permutation With Key](#QueriesonaPermutationWithKey)
	* 1.536. [1416. Restore The Array](#RestoreTheArray)
	* 1.537. [1424. Diagonal Traverse II](#DiagonalTraverseII)
	* 1.538. [1425. Constrained Subset Sum](#ConstrainedSubsetSum)
	* 1.539. [1426  Counting Elements](#CountingElements)
	* 1.540. [1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie](#KidsWiththeGreatestNumberofCandie)
	* 1.541. [1437 Check If All 1's Are at Least Length](#CheckIfAll1sAreatLeastLength)
	* 1.542. [1438. Longest Continuous Subarray With Absolute](#LongestContinuousSubarrayWithAbsolute)
	* 1.543. [1441 Build an Array With Stack Operations](#BuildanArrayWithStackOperations)
	* 1.544. [1442. Count Triplets That Can Form Two Arrays of Equal](#CountTripletsThatCanFormTwoArraysofEqual)
	* 1.545. [1443. Minimum Time to Collect All Apples in a Tree](#MinimumTimetoCollectAllApplesinaTree)
	* 1.546. [1444. Number of Ways of Cutting a Pizza](#NumberofWaysofCuttingaPizza)
	* 1.547. [1446 Consecutive Characters](#ConsecutiveCharacters)
	* 1.548. [1448 Count Good Nodes in Binary Tree](#CountGoodNodesinBinaryTree)
	* 1.549. [1449. Form Largest Integer With Digits That Add](#FormLargestIntegerWithDigitsThatAdd)
	* 1.550. [1451 Rearrange Words in a Sentence](#RearrangeWordsinaSentence)
	* 1.551. [1453 Maximum Number of Darts Inside of a Circular Dartb](#MaximumNumberofDartsInsideofaCircularDartb)
	* 1.552. [1457 Pseudo-Palindromic Paths in a Bin](#Pseudo-PalindromicPathsinaBin)
	* 1.553. [1461 Check If a String Contains All Binar](#CheckIfaStringContainsAllBinar)
	* 1.554. [1463 Cherry Pickup II](#CherryPickupII)
	* 1.555. [1473. Paint House III](#PaintHouseIII)
	* 1.556. [1475. Final Prices With a Special Discount in a Sho](#FinalPricesWithaSpecialDiscountinaSho)
	* 1.557. [1483. Kth Ancestor of a Tree Node](#KthAncestorofaTreeNode)
	* 1.558. [1488. Avoid Flood in The City](#AvoidFloodinTheCity)
	* 1.559. [1489. Find Critical and Pseudo-Critical Edges in](#FindCriticalandPseudo-CriticalEdgesin)
	* 1.560. [1492 The kth Factor of n](#ThekthFactorofn)
	* 1.561. [1493. Longest Subarray of 1's After Deleting One](#LongestSubarrayof1sAfterDeletingOne)
	* 1.562. [1499. Max Value of Equation](#MaxValueofEquation)
	* 1.563. [1502 Can Make Arithmetic Progression From Sequence](#CanMakeArithmeticProgressionFromSequence)
	* 1.564. [1503 Last Moment Before All Ants Fall Out of a Plank](#LastMomentBeforeAllAntsFallOutofaPlank)
	* 1.565. [1505. Minimum Possible Integer After at Most K Adjacent](#MinimumPossibleIntegerAfteratMostKAdjacent)
	* 1.566. [1508. Range Sum of Sorted Subarray Sums](#RangeSumofSortedSubarraySums)
	* 1.567. [1510 Stone Game IV](#StoneGameIV)
	* 1.568. [1514 Path with Maximum Probability](#PathwithMaximumProbability)
	* 1.569. [1515 Best Position for a Service Centre](#BestPositionforaServiceCentre)
	* 1.570. [1520. Maximum Number of Non-Overlapping Substrings](#MaximumNumberofNon-OverlappingSubstrings)
	* 1.571. [1530. Number of Good Leaf Nodes Pairs](#NumberofGoodLeafNodesPairs)
	* 1.572. [1531. String Compression II](#StringCompressionII)
	* 1.573. [1534 Count Good Triplets](#CountGoodTriplets)
	* 1.574. [1535 Find the Winner of an Array Game](#FindtheWinnerofanArrayGame)
	* 1.575. [1537. Get the Maximum Score](#GettheMaximumScore)
	* 1.576. [1539. Kth Missing Positive Number](#KthMissingPositiveNumber)
	* 1.577. [1542. Find Longest Awesome Substring](#FindLongestAwesomeSubstring)
	* 1.578. [1546. Maximum Number of Non-Overlapping Subarrays With Sum](#MaximumNumberofNon-OverlappingSubarraysWithSum)
	* 1.579. [1550. Three Consecutive Odds](#ThreeConsecutiveOdds)
	* 1.580. [1551 Minimum Operations to Make Array](#MinimumOperationstoMakeArray)
	* 1.581. [1553. Minimum Number of Days to Eat N Oranges](#MinimumNumberofDaystoEatNOranges)
	* 1.582. [1556. Thousand Separator](#ThousandSeparator)
	* 1.583. [1558. Minimum Numbers of Function Calls to Make Target](#MinimumNumbersofFunctionCallstoMakeTarget)
	* 1.584. [1563. Stone Game V](#StoneGameV)
	* 1.585. [1569. Number of Ways to Reorder Array to Get Sa](#NumberofWaystoReorderArraytoGetSa)
	* 1.586. [1573. Number of Ways to Split a String](#NumberofWaystoSplitaString)
	* 1.587. [1585. Check If String Is Transformable With](#CheckIfStringIsTransformableWith)
	* 1.588. [1593. Split a String Into the Max Number of Unique Substri](#SplitaStringIntotheMaxNumberofUniqueSubstri)
	* 1.589. [1595. Minimum Cost to Connect Two Groups of Points](#MinimumCosttoConnectTwoGroupsofPoints)
	* 1.590. [1621. Number of Sets of K Non-Overlapping Line](#NumberofSetsofKNon-OverlappingLine)
	* 1.591. [1631. Path With Minimum Effort](#PathWithMinimumEffort)
	* 1.592. [1632 Rank Transform of a Matrix](#RankTransformofaMatrix)
	* 1.593. [1640 Check Array Formation Through](#CheckArrayFormationThrough)
	* 1.594. [1641 Count Sorted Vowel Strings](#CountSortedVowelStrings)
	* 1.595. [1642. Furthest Building You Can Reach](#FurthestBuildingYouCanReach)
	* 1.596. [1646 Get Maximum in Generated Array](#GetMaximuminGeneratedArray)
	* 1.597. [1648. Sell Diminishing-Valued Colored Balls](#SellDiminishing-ValuedColoredBalls)
	* 1.598. [1649 Create Sorted Array through Instru](#CreateSortedArraythroughInstru)
	* 1.599. [1655. Distribute Repeating Integers](#DistributeRepeatingIntegers)
	* 1.600. [1657 Determine if Two Strings Are Close](#DetermineifTwoStringsAreClose)
	* 1.601. [1658 Minimum Operations to Reduce X](#MinimumOperationstoReduceX)
	* 1.602. [1659. Maximize Grid Happiness](#MaximizeGridHappiness)
	* 1.603. [1662 Check If Two String Arrays are Equi](#CheckIfTwoStringArraysareEqui)
	* 1.604. [1663 Smallest String With A Given Numer](#SmallestStringWithAGivenNumer)
	* 1.605. [1673 Find the Most Competitive Subseq](#FindtheMostCompetitiveSubseq)
	* 1.606. [1674. Minimum Moves to Make Array Complement](#MinimumMovestoMakeArrayComplement)
	* 1.607. [1675. Minimize Deviation in Array](#MinimizeDeviationinArray)
	* 1.608. [1679 Max Number of K-Sum Pairs】](#MaxNumberofK-SumPairs)
	* 1.609. [1680 Concatenation of Consecutive Bina](#ConcatenationofConsecutiveBina)
	* 1.610. [1681. Minimum Incompatibility](#MinimumIncompatibility)
	* 1.611. [1690. Stone Game VII](#StoneGameVII)
	* 1.612. [1696. Jump Game VI](#JumpGameVI)
	* 1.613. [1704 Determine if String Halves Are Alike](#DetermineifStringHalvesAreAlike)
	* 1.614. [1707. Maximum XOR With an Element From Array](#MaximumXORWithanElementFromArray)
	* 1.615. [1713. Minimum Operations to Make a Subsequence](#MinimumOperationstoMakeaSubsequence)
	* 1.616. [1721 Swapping Nodes in a Linked List](#SwappingNodesinaLinkedList)
	* 1.617. [1727. Largest Submatrix With Rearrangements](#LargestSubmatrixWithRearrangements)
	* 1.618. [1745. Palindrome Partitioning IV](#PalindromePartitioningIV)
	* 1.619. [1760. Minimum Limit of Balls in a Bag](#MinimumLimitofBallsinaBag)
	* 1.620. [1770. Maximum Score from Performing Multiplication](#MaximumScorefromPerformingMultiplication)
	* 1.621. [1771. Maximize Palindrome Length From Subsequences](#MaximizePalindromeLengthFromSubsequences)
	* 1.622. [1775. Equal Sum Arrays With Minimum Number of Operatio](#EqualSumArraysWithMinimumNumberofOperatio)
	* 1.623. [1786. Number of Restricted Paths From First to Last Node](#NumberofRestrictedPathsFromFirsttoLastNode)
	* 1.624. [1792. Maximum Average Pass Ratio](#MaximumAveragePassRatio)
	* 1.625. [1799. Maximize Score After N Operations](#MaximizeScoreAfterNOperations)
	* 1.626. [1815. Maximum Number of Groups Getting Fresh Donuts](#MaximumNumberofGroupsGettingFreshDonuts)
	* 1.627. [1838. Frequency of the Most Frequent Element](#FrequencyoftheMostFrequentElement)
	* 1.628. [1847. Closest Room](#ClosestRoom)
	* 1.629. [1872. Stone Game VIII](#StoneGameVIII)
	* 1.630. [s](#s)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name=''></a>题目

###  1.1. <a name='SameTree'></a>100-Same Tree 

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7ti?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vf4y1R7Ue?spm_id_from=333.999.0.0)

> python:

```py
self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

```py
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        return str(p)==str(q)
```



> scala

```scala
object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        if (p == null && q == null) {
        true
        } else if (p == null || q == null) {
        false
        } else if (p.value == q.value) {
        isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        } else {
        false
        }
    }
}


object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
     if (p!=null && q!=null) {
       p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
     } else {
       p == q
     }
   }
}

object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        (p,q) match {
          case (p,q) if (p!=null && q!=null) => p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
          case (p,q) => p==q
        }
    }
  }
```

###  1.2. <a name='Symmetrictree'></a>101-Symmetric tree

[哈哈哈](https://www.bilibili.com/video/BV1VJ41197KD?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xv41167z8?spm_id_from=333.999.0.0)

> Python 迭代：其实就是层序遍历，然后检查每一层是不是回文数组

```py
class Solution(object):
    def isSymmetric(self, root):
        layer = [root]
        
        while(layer):
            nextLayer = []
            vals = []
            for node in layer:
                if not node # 有一种情况是[None]
                    vals.append(None)
                    continue
                nextLayer.append(node.left)
                nextLayer.append(node.right)
                
                vals.append(node.val)
                
            if vals != vals[::-1]:
                return False
            layer = nextLayer
            
        return True
```

> Python 递归：

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def twoSym(node1, node2):
            if node1 and node2 and node1.val == node2.val: 
                return twoSym(node1.left, node2.right) and twoSym(node1.right, node2.left)
            elif not node1 and not node2:
                return True
            else:
                return False
        return twoSym(root.left, root.right)
```

> scala:

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def symmetric(nodeA: TreeNode, nodeB: TreeNode): Boolean = {
        if(nodeA == null && nodeB == null){
            true
        }else if(nodeA !=null && nodeB != null){
            if(nodeA.value != nodeB.value){
                false
            }else{
                symmetric(nodeA.left, nodeB.right) && symmetric(nodeA.right, nodeB.left)
            }
        }else{
            false
        }
    }
    
    def isSymmetric(root: TreeNode): Boolean = {
        if(root == null){
            true
        } else{
            symmetric(root.left, root.right)
        }
    }
}

```

###  1.3. <a name='BinaryTreeLevelOrderTraversal'></a>102-Binary Tree Level Order Traversal

[哈哈哈](https://www.bilibili.com/video/BV1W54y197Lc?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14T4y1u7Wk?spm_id_from=333.999.0.0)

> python queue

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)): # 当前层的个数!!!
                node=queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res


from collections import deque
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []

        queue = deque([root]) 
        res = []
        
        while queue: 
            level = [] 
            for _ in range(len(queue)): 
                node = queue.popleft() 
                level.append(node.val) 
                if node.left:
                    queue.append(node.left) 
                if node.right:
                    queue.append(node.right) 
            res.append(level) 
        return res
```


> python 递归


```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []

        def bfs(node, level):
            if node: 
                if len(res) < level + 1:
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level+1)
                bfs(node.right, level+1)

        bfs(root, 0)
        return res

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        dic = collections.defaultdict(list)

        def bfs(node, level):
            if node:
                dic[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0) 
        return [*dic.values()]
```

> scala queue

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val buffer =  scala.collection.mutable.Queue[TreeNode]()
        val res =  scala.collection.mutable.ListBuffer[List[Int]]()

        if(root == null) return List[List[Int]]()
        buffer.enqueue(root)
	
        while(buffer.nonEmpty) {
          val cur = scala.collection.mutable.ListBuffer[Int]()
          for ( _ <- 0 until buffer.size) {
            val node = buffer.dequeue
            cur.append(node.value)
            if(node.left != null) buffer.enqueue(node.left)
            if(node.right != null) buffer.enqueue(node.right)
        }
        res += cur.toList
        }
        res.toList
    }
}
```

> scala 递归

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val oderMap = scala.collection.mutable.Map[Int, List[Int]]()
        bfs(root, 1, oderMap)
        oderMap.values.toList
    }
    def bfs(node: TreeNode, level: Int, map: scala.collection.mutable.Map[Int, List[Int]]): Unit = {
        if (node != null) {
            val l = map.get(level)
                .map(_ :+ node.value)
                .getOrElse(List(node.value))

            map(level) = l
            bfs(node.left, level + 1, map)
            bfs(node.right, level + 1, map)
        }
    }
}
```

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        bfs(if(root == null) List() else List(root), List())
    }

    // @annotation.tailrec
    // @annotation.tailrec 告诉编译器，下面这个函数是递归的，在栈桢的管理上，希望编译器能所有优化。
    def bfs(queue: List[TreeNode], ans: List[List[Int]]): List[List[Int]] = {
        if(queue.isEmpty) ans
        else{
        bfs(queue.flatMap(n => List(n.left, n.right)).filter(_ != null), ans :+ queue.map(n => n.value))
        }
    }
}
```

###  1.4. <a name='BinaryTreeZigzagLevelOrderTraversal'></a>103. Binary Tree Zigzag Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1NE411M7Fm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15h411Z7h5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GA411W7NY?spm_id_from=333.999.0.0)

> python 队列

```py
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: 
            return []

        queue = [root]
        res = []
        indexflag = 1 
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        queue = [root]
        res = []
        indexflag = 1 
        while queue and queue[0]: # 或者
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

# python 双端duque
from collections import deque
class Solution:
    def zigzagLevelOrder(self, root):
        queue = deque([root])
        res = []
        flag = True # flag
        while queue and queue[0]:
            level = []
            for _ in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            if flag: # flag
                res.append(level)
            else:
                res.append(level[::-1])  # [::-1]反转
            flag = bool(1-flag) # flag
        return res
```

递归

```py
class Solution:
    def zigzagLevelOrder(self, root):
        res = []
        def bfs(node, level):
            if node:
                if level >= len(res):
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0)
        for i in range(1, len(res), 2): # flag，各两个逆序
            res[i] = res[i][::-1]
        return res
```

###  1.5. <a name='MaximumDepthofBinary'></a>104-Maximum Depth of Binary

[哈哈哈](https://www.bilibili.com/video/BV1AJ411Q7xG?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1u54y1D7Nx?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tK41137GM?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

```scala
object Solution1 {
    def maxDepth(root: TreeNode): Int = {
        if (root == null) return 0
        math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}

object Solution {
    def maxDepth(root: TreeNode): Int = root match {
        case null => 0
        case x: TreeNode => Math.max((1 + maxDepth(x.left)), (1 + maxDepth(x.right)))
    }
}

object Solution2 {
    def maxDepth(root: TreeNode): Int = {
        if(root == null) return 0
        var depth = 0
        val queue = scala.collection.mutable.Queue[TreeNode]()
        queue.enqueue(root)

        while(queue.nonEmpty) {
            depth += 1
            for(_ <- 0 until queue.size){
                val node = queue.dequeue
                if(node.left != null) queue.enqueue(node.left)
                if(node.right != null) queue.enqueue(node.right)
            }
        }   
        depth
    }
}
```

###  1.6. <a name='-1'></a>105-从前序与中序遍历序列构

[哈哈哈](https://www.bilibili.com/video/BV1uv411B73D?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1x54y1d7e8?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1ry4y1U7ZR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14A411q7Nv?spm_id_from=333.999.0.0)

> PYTHON 递归

```py
class Solution:
    def buildTree(self, preorder, inorder):
        if inorder:
            root = TreeNode(preorder.pop(0))
            i = inorder.index(root.val)
            root.left = self.buildTree(preorder, inorder[: i])
            root.right = self.buildTree(preorder, inorder[i + 1:])
            return root

class Solution:
    def buildTree(self, preorder, inorder):
        if preorder: # 也可以
        if inorder:
          root = TreeNode(preorder.pop(0))
          i = inorder.index(root.val)
          root.left = self.buildTree(preorder[:i], inorder[:i])
          root.right = self.buildTree(preorder[i:], inorder[i+1:])
          return root

```

###  1.7. <a name='-1'></a>106-从中序与后序遍历序列构造二叉树

[哈哈哈](https://www.bilibili.com/video/BV1r5411W7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jh411Z7y8?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if inorder:
            root = TreeNode(postorder.pop())
            i = inorder.index(root.val)
            root.left = self.buildTree(inorder[:i], postorder[:i])
            root.right = self.buildTree(inorder[i+1:], postorder[i:])
            return root
```

###  1.8. <a name='BinaryTreeLevelOrderTraversalII'></a>107-Binary Tree Level Order Traversal II

[哈哈哈](https://www.bilibili.com/video/BV1eJ411z7d6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1yK411n76R?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qA411i7P4?spm_id_from=333.999.0.0)


```py
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res[::-1]
```

###  1.9. <a name='ConvertSortedArraytoBinarySearchTree'></a>108 Convert Sorted Array to Binary Search Tree 

[花花酱](https://www.bilibili.com/video/BV1F7411H7tH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1JJ411q74U?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wa411c7tS?spm_id_from=333.999.0.0)

> python

```py
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if nums:
            mid = len(nums) // 2
            root = TreeNode(nums[mid])
            root.left = self.sortedArrayToBST(nums[:mid])
            root.right = self.sortedArrayToBST(nums[mid+1:])
            return root
```

scala 中没有这种形式的写法 nums[:mid]，nums[mid+1:]

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def formTree(nums: Array[Int], begin: Int, end: Int): TreeNode = {
        var mid = begin + Math.ceil((end - begin)/2).toInt
        TreeNode(
            nums(mid), 
            if(mid <= begin) null else formTree(nums, begin, mid-1), 
            if(mid >= end) null else formTree(nums, mid+1, end)
        )
    }
    
    def sortedArrayToBST(nums: Array[Int]): TreeNode = {
        if(nums.isEmpty){
            null
        }else{
            formTree(nums, 0, nums.size - 1)
        }
    }
}

```

###  1.10. <a name='-1'></a>109题. 有序链表转换二叉搜索树

https://www.bilibili.com/video/BV19a4y157U8?spm_id_from=333.999.0.0

https://www.bilibili.com/video/BV1ff4y197dS?spm_id_from=333.999.0.0

当递归的是一个链表`头`时，需要切断

```py
class Solution:
    def sortedListToBST(self, head) -> TreeNode:
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)

        fast = head
        slow = head
        pre =  head

        while fast and fast.next:
            pre = slow # pre切断
            slow = slow.next
            fast = fast.next.next
        mid = TreeNode(slow.val)
        # print(head.val,node.val,last.val)
        mid.right = self.sortedListToBST(slow.next) # 从mid+1到tail
        pre.next = None # pre切断
        mid.left = self.sortedListToBST(head) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        return mid
```

https://www.bilibili.com/video/BV19K411T73P?p=2&spm_id_from=pageDriver

当递归的是一个链表`头尾`时，不需要切断

```py
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getMedian(head: ListNode, tail: ListNode) -> ListNode:
            fast = slow = head
            while fast != tail and fast.next != tail:
                fast = fast.next.next
                slow = slow.next
            return slow
        
        def buildTree(left: ListNode, right: ListNode) -> TreeNode:
            if left == right:
                return None
            mid = getMedian(left, right)
            root = TreeNode(mid.val)
            root.left = buildTree(left, mid) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
            root.right = buildTree(mid.next, right) # 从mid+1到tail
            return root
        
        return buildTree(head, None)
```

###  1.11. <a name='BalancedBinaryTree'></a>110-Balanced Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1NJ411v7b1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Lb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sV411b7hR?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            return max(height(root.left), height(root.right)) + 1

        if not root:
            return True
        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)
        # 注意：左右两个子树也必须balanced


其实就是二叉树先序遍历和后序遍历的区别，每种遍历方式都有它的用武之地。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        ans = True
        
        def postorder(root):
            nonlocal ans
            if not root or not ans:
                return 0
            leftH = postorder(root.left)
            rightH = postorder(root.right)
            if abs(leftH-rightH) > 1:
                ans = False
            return max(leftH, rightH) + 1
        
        postorder(root)
        return ans

必须用

nonlocal + ans

如下返回错误结果 postorder(root,bol)

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        bol = True
        
        def postorder(root,bol):
            if not root or not bol:
                return 0
            leftH = postorder(root.left,bol)
            rightH = postorder(root.right,bol)
            if abs(leftH-rightH) > 1:
                bol = False
            return max(leftH, rightH) + 1
        
        postorder(root,bol)
        return bol
```

###  1.12. <a name='MinimumDepthofBinaryTree'></a>111-Minimum Depth of Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1E7411k7KY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1XZ4y1G7xM?spm_id_from=333.999.0.0)

递归

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root:
            if root.left and root.right:
                return 1+min(self.minDepth(root.left),self.minDepth(root.right))
            elif root.left:
                return 1+self.minDepth(root.left) #较高一层的值
            elif root.right:
                return 1+self.minDepth(root.right) #较高一层的值
            else:
                return 1
        else:
            return 0
```

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        # 如果 没有 root
        if not root:
            return 0
        # 如果 只有 root
        elif not root.left and not root.right:
            return 1
        else:
        # 如果 root 有 子树
            minDepth = float('inf')
            if root.left:
                minDepth = min(self.minDepth(root.left), minDepth) 
            if root.right:
                minDepth = min(self.minDepth(root.right), minDepth) 
            return minDepth + 1
```

队列

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        que = collections.deque([(root, 1)]) # 注意这个写法：[(root, 1)] 的括号
        while que:
            node, depth = que.popleft()
            if not node.left and not node.right:
                return depth
            if node.left: 
                que.append((node.left, depth + 1)) # 注意这个写法：(node.left, depth + 1) 的括号
            if node.right:
                que.append((node.right, depth + 1))
        
        return 0
```

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        bfs(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def bfs(queue: List[TreeNode], res: Int): Int = {
        if(queue.isEmpty) res
        // node has no child 
        else if(queue.exists(t => t.left == null && t.right == null)) res + 1
        else bfs(queue.flatMap(t => List(t.left, t.right)).filter(_ != null), res + 1)
    }
}

object Solution1 {
    def minDepth(root: TreeNode): Int = {
        if (root == null) return 0
        val left = minDepth(root.left) 
        val right = minDepth(root.right) 

        if (left == 0 || right == 0) left + right + 1 else math.min(left, right) + 1
        
    }
}

object Solution1_2 {
    def minDepth(root: TreeNode): Int = {
        if(root == null) 0
        else if(root.left == null) minDepth(root.right) + 1
        else if(root.right == null) minDepth(root.left) + 1
        else minDepth(root.right) + 1 min minDepth(root.left) + 1
    
    }
}
```

队列

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        if(root == null) return 0
        val que = scala.collection.mutable.Queue[TreeNode]()
        var depth = 0
        var flag = true
        que.enqueue(root)
        
        while(que.nonEmpty && flag){
            depth += 1
            for(_ <- 0 until que.size; if flag){
                val node = que.dequeue
                if(node.left == null && node.right == null) flag = false
                else {
                    if(node.left != null) que.enqueue(node.left)
                    if(node.right != null) que.enqueue(node.right)
                } 
            } 
        }
        depth
        
    }
} 
```

###  1.13. <a name='PathSum'></a>112-Path Sum

[哈哈哈](https://www.bilibili.com/video/BV1T7411r7Yr?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1pb411e7r7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1uK411T7kX?spm_id_from=333.999.0.0)

递归

```py
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if root is None:
            return False
        if root.val==targetSum:
            return True
        return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
```

```py
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que = collections.deque([(root, root.val)])
        while que:
            node, tmp = que.popleft()
            if not node.left and not node.right:
                if tmp == sum:
                    return True
                continue
            if node.left:
                que.append((node.left,node.left.val + tmp))
            if node.right:
                que.append((node.right,node.right.val + tmp))
        return False
```

###  1.14. <a name='-1'></a>113. 二叉树中和为某一值的路径

[哈哈哈](https://www.bilibili.com/video/BV1P54y1i73U?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1k54y177fu?spm_id_from=333.999.0.0)

```py
# 注意比较这两个写法
# 路径记忆，计算效率好像更😕
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        path = []
        
        def dfs(node, tsum):
            if not node:
                return
            
            path.append(node.val)
            tsum -= node.val # 对于每一个node，当前node的sum = 总和sum - root的值
            
            if not node.left and not node.right and tsum == 0: # 结束条件
                res.append(path[:])
            dfs(node.left, tsum)
            dfs(node.right, tsum)
            
            path.pop()
        
        dfs(root, targetSum)
        return res
```

```py
# 注意比较这两个写法
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        
        def dfs(node, path, tsum):
            
            if not node:
                return 
            
            tsum -= node.val # 对于每一个node，当前node的sum = 总和sum - root的值
            
            if not node.left and not node.right and tsum == 0: # 结束条件
                res.append(path + [node.val]) # 可以不需要深拷贝
                
            dfs(node.left, path + [node.val], tsum)
            dfs(node.right, path + [node.val], tsum)
        
        dfs(root, [], targetSum)
        return res

class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res=[]

        def dfs(node,path,tsum):

            if node is None:
                return

            if node.val == tsum and node.left is None and node.right is None:
                res.append(path[:] + [node.val])  # 需要深拷贝

            dfs(node.left,path + [node.val], tsum-node.val)
            dfs(node.right,path + [node.val], tsum-node.val)
            
        dfs(root,[],targetSum)
        return res
```

###  1.15. <a name='-1'></a>114题. 二叉树展开为链表

https://www.bilibili.com/video/BV1T7411A7S8?from=search&seid=15731266160913668837&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6tma3pncods0.png" width="80%">

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5csg54lu3lw0.png" width="50%">

递归

```py
class Solution(object):
    def flatten(self, root):
        if not root:
            return
        #把子树备份一下
        tmpleft = root.left
        tmpright = root.right
        root.left = None #记得把左子树置空
        #先把左右子树捋直
        self.flatten(tmpleft)
        self.flatten(tmpright)
        if tmpleft:
            root.right = tmpleft #把捋直的左子树放到右边
            while tmpleft.right: #找到现在右子树的最后一个node
                tmpleft = tmpleft.right 
            tmpleft.right = tmpright #左子树接上右子树
```

stack: 先看144题

```py
class Solution:
    def flatten(self, root: TreeNode) -> None:
        if not root:
            return
        
        stack = [root]
        pre = None # 穿针引线
        
        while stack:
            cur = stack.pop()
            if pre:
                pre.left = None # 穿针引线
                pre.right = cur # 穿针引线
            left, right = cur.left, cur.right
            if right:
                stack.append(right)
            if left:
                stack.append(left)
            pre = cur # 穿针引线

        return root

class Solution:
    def flatten(self, root: TreeNode) -> None:
        preorderList = list()
        stack = list()
        node = root

        while node or stack:
            while node:
                preorderList.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        
        n = len(preorderList)
        for i in range(1, n):
            prev, curr = preorderList[i - 1], preorderList[i] # 穿针引线
            prev.left = None # 穿针引线
            prev.right = curr # 穿针引线
```


###  1.16. <a name='DistinctSubsequences'></a>115. Distinct Subsequences

[花花酱](https://www.bilibili.com/video/BV1EW411d7PC?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV185411G7F6?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        for i in range(sN+1):
            for j in range(tN+1):
                if j == 0:  
                    dp[i][j] = 1
                elif i == 0:  
                    dp[i][j] = 0
                elif s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
Python3:

class SolutionDP2:
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(s), len(t)
        if n1 < n2:
            return 0

        dp = [0 for _ in range(n2 + 1)]
        dp[0] = 1

        for i in range(1, n1 + 1):
            prev = dp[:] # 深拷贝一下
            end = i if i < n2 else n2 # 剪枝，保证s的长度大于等于t, 因为对于任意i，i > n1, dp[i] = 0, 没必要跟新状态。 
            for j in range(1, end + 1):
                if s[i - 1] == t[j - 1]:
                    dp[j] = prev[j - 1] + prev[j]
                else:
                    dp[j] = prev[j]
        return dp[-1]
```

###  1.17. <a name='PopulatingNextRightPointersinEachNode'></a>116. Populating Next Right Pointers in Each Node

[花花酱](https://www.bilibili.com/video/BV1b4411R7G4?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1zQ4y1M75t?spm_id_from=333.999.0.0)

```py
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        
        que = [root]
        while que:
            n = len(que)
            pre = Node(0) # 指针
            for _ in range(n):
                node = que.pop(0)
                if pre:
                    pre.next = node
                pre = node

                if node.left:
                    que.append(node.left)
                if node.right:
                    que.append(node.right)
        
        return root

class Solution:
    # 层次遍历
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        que = deque([root])
        while que:
            n = len(que)
            for i in range(n):        # 每一层n固定
                cur = que.popleft()
                if i < n - 1:         # 只要不是最后一个，就连上
                    cur.next = que[0] # 只要不是最后一个，就连上
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            
        return root
```

```py
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if root:
            l,r=root.left,root.right
            while l:
                l.next=r
                l,r=l.right,r.left
            self.connect(root.left)
            self.connect(root.right)
        return root
```

###  1.18. <a name='PopulatingNextRightPointersinEa'></a>117 Populating Next Right Pointers in Ea (可跳过)

[小明](https://www.bilibili.com/video/BV1np4y1r7fQ?spm_id_from=333.999.0.0)

看不懂，懵逼了

```py
# 看不懂，懵逼了

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        dummy = Node()
        dummy.next = root
        while dummy.next:
            curp = dummy.next
            dummy.next = None
            pre = dummy
            while curp:
                for cur in [curp.left, curp.right]:
                    if cur:
                        pre.next = cur
                        pre = cur
                curp = curp.next
        return root

# python 非递归方法，常数空间，从顶到下，逐层连接
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        first = root # left_most表示当前层的最左边节点
        while first: # 每次循环连接当前层的下一层
            dummy = pre = Node(0) # head表示下一层的虚拟头部
            cur = first
            while cur : # 遍历当前层，将下一层连接
                if cur.left :
                    pre.next = cur.left
                    pre = pre.next
                if cur.right :
                    pre.next = cur.right
                    pre = pre.next
                cur = cur.next
            first = dummy.next
        return root
```


###  1.19. <a name='PascalsTriangle'></a>118-Pascal's Triangle

[哈哈哈](https://www.bilibili.com/video/BV1T741167KS?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7tJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1D54y147NY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generate(self, numRows):
        res = []
        for i in range(numRows):
            curlevel = [1]*(i+1)
            if i >= 2:
                for n in range(1,i):
                    curlevel[n] = pre[n-1]+pre[n]
                    # 头尾为1，中间的第j个为上一层的第j-1个和j个的和
            res += [curlevel]
            pre = curlevel
        return res
        
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for i in range(numRows):
            level = []
            for j in range(0, i + 1):
                if j == 0 or j == i:
                    level.append(1)
                else:
                    level.append(res[i - 1][j] + res[i - 1][j - 1])
            res.append(level)
        return res
```

```py
库函数重拳出击！
它本质上评估为n! /(k! *(n-k)! )它也被称为二项式系数
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        return [[comb(i, j) for j in range(i + 1)] for i in range(numRows)]
```

```scala
object Solution {
    def generate(numRows: Int): List[List[Int]] = {
        var output = List.empty[List[Int]]
        var curr = 1
        if(numRows == 0){
            output
        }else{
            while(curr <= numRows){
                curr match{
                    case 1 => output = List(List(1))
                    case _ => {
                        val prev = output(curr-2)
                        val begin = 0
                        val end = curr - 1
                        val row = 
                        (0 to curr-1)
                        .map(i => if(i == begin || i == end) 1 else prev(i)+prev(i-1))
                        .toList
                        
                        output = output :+ row
                    }
                }
                curr += 1
            }
        }
        output
    }
}

```

###  1.20. <a name='PascalsTriangleII'></a>119-Pascal's Triangle II

[哈哈哈](https://www.bilibili.com/video/BV187411B7Hj?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7hA?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ni4y1g7Lv?spm_id_from=333.999.0.0)

```py
class Solution3:
    def generate(self, rowIndex):
        for i in range(rowIndex + 1):
            # 用 1 先填充每行所有元素
            curlevel = [1] * (i + 1)
            # 由上一行循环生成当前行元素（除两端）
            for j in range(1, i):
                curlevel[j] = pre[j - 1] + pre[j]
            pre = curlevel
        return curlevel

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        res = [1]
        for i in range(rowIndex):
            res.append(0)
            j = i + 1
            while j > 0:
                res[j] = res[j] + res[j - 1]
                j -= 1
        return res
```

###  1.21. <a name='Triangle'></a>120 Triangle

[小明](https://www.bilibili.com/video/BV1m54y1L7Af?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        i = len(triangle) - 2
        while i >= 0:
            subi = i
            while subi >= 0:
                triangle[i][subi] += min(triangle[i+1][subi],triangle[i+1][subi+1])
                subi -= 1
            i -= 1
        return triangle[0][0]
```

```scala
object Solution {
    def minimumTotal(triangle: List[List[Int]]): Int = {
        val depth = triangle.size
        val dp = triangle.last.toArray
        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices) {
            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) 
        }
        dp(0)
    }
}
```

###  1.22. <a name='BestTimetoBuyandSellStock121-'></a>121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机

[花花酱](https://www.bilibili.com/video/BV1oW411C7UB?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1cZ4y1K7HP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1D7411s7A1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7by?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16z4y1Z7jD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1hA411t76C?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        minprice = 1e9
        for price in prices:
            maxprofit = max(maxprofit,price - minprice)
            minprice = min(minprice,price)
        return maxprofit
```

```scala
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices.foldLeft((Int.MaxValue, 0)){
            case ((minPriceSoFar, maxProfit), price) => (minPriceSoFar min price, maxProfit max (price - minPriceSoFar))
        }._2
    }
}
```

###  1.23. <a name='II122-BestTimetoBuyandSellStockII'></a>122-买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II

[哈哈哈](https://www.bilibili.com/video/BV12K411A7rL?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d7411x78d?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7iq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Fk4y1R7ve?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y1L7LG?spm_id_from=333.999.0.0)

```py
我的写法：

贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度O(n)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
                # preprice = 1e9 是错误的，比如[1,2,3,4,5] 会返回2，应该返回4
                preprice = price
            else:
                preprice = price
        return maxprofit

# 简化为
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
            preprice = price
        return maxprofit
```

```py

其他写法：

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i] > 0])



class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                ans += prices[i] - prices[i-1]
        return ans
```

```scala
/**
* my first commitment
* greedy alg
* time complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices.length > 1){
            prices.sliding(2).collect{ case arr: Array[Int] if arr(1) > arr(0)=> arr}
    .foldLeft(0){(sum, arr) => 
      sum + arr(1) - arr(0)}
        } else {
            0
        }
    }
}

/**
* greedy alg: one line pass
*/

object Solution1-2 {
  def maxProfit(prices: Array[Int]): Int = {
    if(prices.length > 1) prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum else 0
  }
}

//Alternate solution
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices
            .foldLeft(0,Int.MaxValue)((t, current) => (t._1 + 0.max(current-t._2), current))
            ._1
    }
}
 
  object Solution {
    def maxProfit(prices: Array[Int]): Int = {
      if (prices.isEmpty) return 0
      else (0 until prices.length-1).foldLeft(0)(
        (profit,i) =>{
          if (prices(i)<prices(i+1)) profit+prices(i+1)-prices(i) else profit
        }
      )
    }
  }

```

###  1.24. <a name='III'></a>123-买卖股票的最佳时机 III

[哈哈哈](https://www.bilibili.com/video/BV1Xp4y1k7aD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rk4y117z8?spm_id_from=333.999.0.0)

```py
# 我的写法：
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        profit1 = profit2 = 0
        buy1 = buy2 = prices[0]
        for i in range(1,n):
            # 实际上，是从卖出那天开始算，也就是第二天
            buy1 = min(buy1,prices[i])
            profit1 = max(profit1,prices[i]-buy1)
            buy2 = min(buy2,prices[i]-profit1)  # buy2[i]-profit1[i-1] 相当于一个虚拟的买入价格
            profit2 = max(profit2,prices[i]-buy2)
        return profit2

## 未进行空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = [0] * n
        sell1 = [0] * n
        buy2 = [0] * n
        sell2 = [0] * n
        buy1[0] = buy2[0] = -prices[0]
        sell1[0] = sell2[0] = 0
        for i in range(1, n):
            buy1[i]  = max(buy1[i-1], -prices[i]) 
            sell1[i] = max(sell1[i-1], buy1[i-1] + prices[i])
            buy2[i]  = max(buy2[i-1], sell1[i-1] - prices[i])
            sell2[i] = max(sell2[i-1], buy2[i-1] + prices[i])
        return sell2[-1]
```

```scala
object Solution3{
    def maxProfit(prices: Array[Int]): Int = {
        val r = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case (acc, px) =>
                val (buy1, sell1, buy2, sell2) = acc
                val newBuy1 = buy1 max - px
                val newSell1 =  sell1 max (buy1 + px)
                val newBuy2 = buy2 max (sell1 - px)
                val newSell2 = sell2 max (buy2 + px)
                (newBuy1, newSell1, newBuy2, newSell2)
        }
        r._2 max r._4
    }
}

object Solution3-1 {
    def maxProfit(prices: Array[Int]): Int = {
        val (buy1, sell1, buy2, sell2) = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case ((buy1, sell1, buy2, sell2), cost) =>
                (
                    buy1 max -cost,
                    sell1 max (buy1 + cost),
                    buy2 max (sell1 - cost),
                    sell2 max (buy2 + cost)
                )
        }
        sell1 max.sell2
    }
}
```

###  1.25. <a name='BinaryTreeMaximumPathSum'></a>124. Binary Tree Maximum Path Sum

[花花酱](https://www.bilibili.com/video/BV1ct411r7qw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CT4y1g7bR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qT4y1J71C?spm_id_from=333.999.0.0)

```py
我的思考：
        # 有两种情况：
        # node.val 往上回收, 构成递归
        return max(left,right) + node.val
        # node.val 不往上回收, 左中右
        res = max(left+right + node.val, res)

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = -1e9
        # left = right = 0
        def dfs(node) -> int:
            nonlocal res # 也可以写成 self.res
            if not node:
                return 0
            # if node.left:
            left = max(dfs(node.left), 0)     # 正负性：left 为负，就不回收
            # if node.right:
            right = max(dfs(node.right), 0)   # 正负性：right 为负，就不回收
            # 有两种情况：node.val 不往上回收, 左中右
            res = max(left + right + node.val, res)
            # 有两种情况：node.val 往上回收, 构成递归
            return max(left,right) + node.val # 正负性：node.val必须回收
        dfs(root)
        return res
```

```scala
object Solution1 {
    def maxPathSum(root: TreeNode): Int = {
        dfs(root)._1
    }

    def dfs(node: TreeNode): (Int, Int) = {
      if (node == null) return (Int.MinValue, 0)
      
      val (leftSoFar, leftEndingHere) = dfs(node.left)
      val (rightSoFar, rightEndingHere) = dfs(node.right)

      val maxSoFar = leftSoFar max rightSoFar max (node.value + leftEndingHere + rightEndingHere)

      val maxEndingHere = 0 max (node.value + (leftEndingHere max rightEndingHere))
      (maxSoFar, maxEndingHere)
    }
}
```

###  1.26. <a name='ValidPalindrome'></a>125-Valid Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1d7411n7cF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7ML?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17h411Z7ey?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

isalnum() 方法检测字符串是否由字母和数字组成。

isalpha() 方法检测字符串是否只由字母组成。

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) - 1
        while left < right:
            # 易错点：if not s[left].isalnum(): 是不对的，因为存在连续多个“非数字的情况”
            while left < right and not s[left].isalnum(): 
                left += 1
            while left < right and not s[right].isalnum(): 
                right -= 1
            if s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else:
                return False
        return True
```

python牛逼的一行代码：

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        sgood = "".join(ch.lower() for ch in s if ch.isalnum())
        return sgood == sgood[::-1]

class Solution:
    def isPalindrome(self, s):
        s = ''.join(filter(str.isalnum,s)).lower()
        return s==s[::-1]

练习一下正则

import re
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s=re.sub('[^a-zA-Z0-9]','',s)
        s=s.lower()
        return s==s[::-1]
```


```scala

/**
* two pointer comparison
* memo
*  1. alphanumeric = letters + numerals
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def isPalindrome(s: String): Boolean = {
      val newString = s.filter(_.isLetterOrDigit).toLowerCase
      isPalindrome(newString, 0, newString.length - 1)
    }
    @annotation.tailrec
    def isPalindrome(s: String, left: Int, right: Int): Boolean = {
      if (left > right) return true
      if (s(left) == s(right)) isPalindrome(s, left + 1, right - 1)
      else false
    }
}
```


###  1.27. <a name='WordLadderII'></a>126. (bfs好难暂时放弃) Word Ladder II

[花花酱](https://www.bilibili.com/video/BV1yt411Y7gH?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV16K4y1j7hX?spm_id_from=333.999.0.0)

```py
# dfs
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList:
            return []

        allpath = []
        visited = {beginWord}

        def findWords(target,words):
            res = []
            for word in words:
                n = len(target)
                for i in range(n):
                    if target[i] == word[i]: 
                        n -= 1
                if n == 1: 
                    res.append(word)
            return res


        def dfs(path,middlelist):
            nonlocal allpath
            if not middlelist:
                return
            if endWord in middlelist:
                path.append(endWord)
                allpath.append(path)
                return 
            for item in middlelist:
              if item not in path:
                dfs(path+[item],findWords(item,wordList))
        dfs([beginWord],findWords(beginWord,wordList))
        return allpath
    
if __name__ == "__main__":
  s = Solution()
  res = s.findLadders("hit","cog",["hot","dot","dog","lot","log","cog"])
  print('res:',res)

# res: [['hit', 'hot', 'dot', 'dog', 'cog'], 
# ['hit', 'hot', 'dot', 'lot', 'log', 'cog'], 
# ['hit', 'hot', 'lot', 'dot', 'dog', 'cog'], 
# ['hit', 'hot', 'lot', 'log', 'cog']]
```

```py
import collections
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList:
            return []
        lookup = collections.defaultdict(list)
        L = len(beginWord)
        for word in wordList:
            for i in range(L):
                lookup[word[:i] + '*' + word[i+1:]].append(word)
        
        res = []
        que = [(beginWord, 1, [[beginWord]])] # 终点，长度，path
        visited = {beginWord:[[beginWord]]}
        mindepth = len(wordList) + 1  # 剪枝
        print(visited)
        while que:
            cur, depth, paths = que.pop(0)
            if depth > mindepth: continue  # 剪枝           
            for i in range(L):
                dummyword = cur[:i] + '*' + cur[i+1:]
                for word in lookup[dummyword]:
                    if word == endWord:
                        for path in paths:
                            mindepth = depth  # 剪枝
                            res.append(path + [endWord])
                    elif word not in visited:
                        newPaths = [path+[word] for path in paths]
                        visited[cur] = newPaths
                        que.append((word, depth+1, newPaths))

        return res
    
if __name__ == "__main__":
  s = Solution()
  res = s.findLadders("hit","cog",["hot","dot","dog","lot","log","cog"])
  print('res:',res)
```

```py
把单词到通配串的路径生成，再把通配串到单词的路径生成，
然后再单向宽搜，写双向就更复杂了，单向速度也马马虎虎吧，148ms。 py

import collections
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList) :
        lookup = collections.defaultdict(list)
        for word in wordList + [beginWord]:
            w = [*word]
            for i, c in enumerate(word):
                w[i] = '.'
                dummyword = ''.join(w)
                lookup[dummyword].append(word)
                lookup[word].append(dummyword)
                w[i] = c
        if endWord in lookup:
            que, visited = {beginWord: [[beginWord]]}, {beginWord}
            while que:
                # que是达到的点与路径的映射
                if endWord in que:
                    return [*que[endWord]]
                tmp = collections.defaultdict(set)
                
                for i in que:
                    for dummyword in lookup[i]:
                        for w in lookup[dummyword]:
                            if w not in visited:
                                tmp[w].update((*path, w) for path in que[i]) #看不懂更新path路径😂
                que = tmp
                visited.update(que.keys())
        return []
```

###  1.28. <a name='WordLadder'></a>127. Word Ladder

[花花酱](https://www.bilibili.com/video/BV1yt411Y7Me?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1BK4y157k1?spm_id_from=333.999.0.0)

```py
(压根没想到用虚拟节点的方法，用了最蠢的遍历a-z的方法。没想到竟然能通过= =)

附上我的低效python代码，仅供参考。

from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList):
        lookup = set(wordList)
        visited = set(['beginWord'])
        queue = deque([(beginWord, 1)])
        while queue:
            pop, depth = queue.popleft()
            if pop == endWord:
                return depth
            for i in range(len(pop)):
                for j in range(97, 123):
                    char26word = pop[:i] + chr(j) + pop[i+1:]
                    if char26word not in visited and char26word in lookup:
                        queue.append((char26word, depth + 1))
                        visited.add(char26word)
        return 0
```

```py
还有个更巧妙的想法，将 word 的某一位改为 '*' 作为 word 的 key。

例如 hit 的 key 为 '*it'、'h*t'、'hi*'。

在 wordList 中找到 key 相同的单词，即是能转换的单词。

于是提前将 wordList 的单词按 key 存在哈希表中，就可以进一步减少搜索范围到 len(word)。

from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        lookup = defaultdict(list)
        genKey = lambda w: [w[:i] + '*' + w[i+1:] for i in range(len(w))]
        for word in wordList:
            for dummyword in genKey(word):
                lookup[dummyword].append(word)
        queue, visited = deque([(beginWord, 1)]), {beginWord}
        while queue:
            word, depth = queue.popleft()
            for dummyword in genKey(word):
                for nextword in lookup[dummyword]:
                    if nextword not in visited:
                        if nextword == endWord:
                            return depth+1
                        visited.add(nextword)
                        queue.append([nextword, depth+1])
        return 0
```

###  1.29. <a name='LongestConsecutiveSequence'></a>128. Longest Consecutive Sequence

[花花酱](https://www.bilibili.com/video/BV14t411Y7cg?spm_id_from=333.999.0.0)

###  1.30. <a name='SumRoottoLeafNumbers'></a>129 Sum Root to Leaf Numbers

[小明](https://www.bilibili.com/video/BV1VK411H7o5?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        sums = 0
        def dfs(node,cur):
            nonlocal sums
            if not node:
                return
            else:
                cur = cur*10 + node.val
                if not node.left and not node.right: # 易错点：不要忽视了这种情况
                    sums += cur
                    return
                else:
                    dfs(node.right,cur)
                    dfs(node.left,cur)
        dfs(root,0)
        return sums # 在根节点处cur为0，而不是sums


其他写法：

class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        ans = 0
        
        def dfs(root, acc):
            nonlocal ans
            if not root.left and not root.right:
                ans += acc * 10 + root.val
                return
            if root.left:
                dfs(root.left, acc*10+root.val)
            if root.right:
                dfs(root.right, acc*10+root.val)
        dfs(root, 0)
        return ans

```

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return 0

        sums = 0
        que = collections.deque([(root,root.val)])
        
        while que:
            node, num = que.popleft()
            left, right = node.left, node.right
            if not left and not right:
                sums += num
            else:
                if left:
                    que.append((left, num * 10 + left.val))
                if right:
                    que.append((right, num * 10 + right.val))
        return sums
```

###  1.31. <a name='SurroundedRegions130-'></a>130. Surrounded Regions 130-被围绕的区域

[花花酱](https://www.bilibili.com/video/BV1dE411f7U4?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV18y4y1j7JH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411k7TH?spm_id_from=333.999.0.0)


```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m = len(board)
        n = len(board[0])
        que = collections.deque()

        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1: # 易错点：m 和 n 不要写反了
                    if board[i][j] == 'O':
                        que.append((i,j))

        while que:
            x,y = que.popleft()
            board[x][y] = 'A'
            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                # 易错点：x+dx 和 x 不要写反了
                if 0 <= x+dx < m-1 and 0 <= y+dy < n-1 and board[x+dx][y+dy] == 'O': # 易错点：'O'不要写成0
                    board[x+dx][y+dy] = 'A'
                    que.append((x+dx,y+dy))

        for i in range(m):
            for j in range(n):
                # 易错点：== 和 = 不要写反了
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == 'A':
                    board[i][j] = 'O'

        return board
```

另一种写法

```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        n, m = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < n or not 0 <= y < m or board[x][y] != 'O':
                return
            
            board[x][y] = "A"
            dfs(x + 1, y)
            dfs(x - 1, y)
            dfs(x, y + 1)
            dfs(x, y - 1)
        
        for i in range(n):
            dfs(i, 0)
            dfs(i, m - 1)
        
        for i in range(m - 1):
            dfs(0, i)
            dfs(n - 1, i)
        
        for i in range(n):
            for j in range(m):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"
```



###  1.32. <a name='-1'></a>131-分割回文串

[哈哈哈](https://www.bilibili.com/video/BV1dK411p7eU?spm_id_from=333.999.0.0)

```py
# 递归解法
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtrack(startIndex):
            if startIndex == len(s):
                res.append(path[:])
                return
            
            for end in range(startIndex, len(s)):
                seg = s[startIndex:end+1]
                if seg == seg[::-1]:
                    path.append(seg)
                    backtrack(end+1)
                    path.pop()
            
        path = []
        res = []
        backtrack(0)
        return res

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)

        res = []
        path = []

        @cache
        def isPalindrome(i: int, j: int) -> int:
            if i >= j:
                return 1
            return isPalindrome(i + 1, j - 1) if s[i] == s[j] else -1

        def backtrack(startIndex: int):
            if startIndex == n:
                res.append(path[:])
                return
            
            for end in range(startIndex, n):
                if isPalindrome(startIndex, end) == 1:
                    path.append(s[startIndex:end+1])
                    backtrack(end + 1)
                    path.pop()

        backtrack(0)
        isPalindrome.cache_clear()
        return res

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # ------------------------ 背一背 ------------------------
        n = len(s)
        isPalinDP = [[True] * n for _ in range(n)]
        
        for start in range(n - 1, -1, -1): # start 指向 倒数第二位, start 向前扫描
            for end in range(start + 1, n): # end 指向 倒数第一位, end 向后扫描
                isPalinDP[start][end] = (s[start] == s[end]) and isPalinDP[start + 1][end - 1] 
        # ------------------------ 背一背 ------------------------

        res = []
        path = []

        def backtrack(startIndex: int):
            if startIndex == n:
                res.append(path[:])
                return
            
            for end in range(startIndex, n):
                if isPalinDP[startIndex][end]:
                    path.append(s[startIndex:end+1])
                    backtrack(end + 1)
                    path.pop()

        backtrack(0)
        return res



class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtrack(start):
            if start == len(s):
                ans.append(tmp[:])
                return
            
            for end in range(start+1, len(s)+1):
                seg = s[start:end]
                if seg == seg[::-1]:
                    tmp.append(seg)
                    backtrack(end)
                    tmp.pop()
            
        tmp = []
        ans = []
        backtrack(0)
        return ans


```

```py

python3 用回溯递归的方法去试探每一种可能性 对于一个字符串s，

有len(s)种方法把它分成左右两个部分（分割方法看代码），

假如左侧的不是回文，则舍弃这次尝试；

假如左侧的是回文串，则把右侧的进行递归的分割，并返回右侧的分割的所有情况

class Solution:
    @cache
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        res = []
        if n == 0:
            res.append([])

        for i in range(1, n+1):
            if s[:i] != s[:i][::-1]:
                continue
            left = [s[:i]]
            rights = self.partition(s[i:])
            for right in rights:
                res.append(left+right)
        return res


class Solution(object):
    def partition(self, s):

        n = len(s)
        res = []

        
        if n == 0:
            return [[]]
        if n == 1:
            return [[s]]


        for i in range(1, n+1):
            if s[:i] != s[:i][::-1]:
                continue
            left = [s[:i]]
            rights = self.partition(s[i:])
            for right in rights:
                res.append(left+right)
        return res


不需要预处理，没有递归，然后代码简洁的动态规划

我真牛逼

class Solution:
    def partition(self, s: str):
        
        n = len(s)
        res = [[s[0]]]
        
# 下一个位置的分割结果 = 前一个位置所有分割结果 + 当前位置的字母s[i]得到的结果 
        for char in s[1:]:
            for path in res[:]: # 一定要写成res[:],而不是res
                
# + 判断前一个位置每个分割结果中最后一个回文串和当前字母s[i]是否组成回文串得到的结果 --> 也就是偶数个回文
                if len(path[-1]) == 1 and path[-1] == char:
                    res.append(path[:-1] + [char + char])
                    
# + 判断前一个位置每个分割结果中最后两个回文串和当前字母s[i]是否组成回文串得到的结果 --> 也就是奇数个回文
                if len(path) > 1 and len(path[-2]) == 1 and path[-2] == char:
                    res.append(path[:-2] + [char + path[-1] + char])
                    
                path.append(char)
        return res
```

###  1.33. <a name='PalindromePartitioningII'></a>132. Palindrome Partitioning II

[花花酱](https://www.bilibili.com/video/BV1NJ411v7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1944y1C71s?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5d4nophqby00.webp" width="70%">

```py
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        isPalinDP = [[True] * n for _ in range(n)]
        
        for start in range(n - 1, -1, -1): # start 指向 倒数第二位, start 向前扫描
            for end in range(start + 1, n): # end 指向 倒数第一位, end 向后扫描
                isPalinDP[start][end] = (s[start] == s[end]) and isPalinDP[start + 1][end - 1] 

        cutDP = [float("inf")] * n
        for endcut in range(n):
            # 如果前一小段是回文
            if isPalinDP[0][endcut]:
                cutDP[endcut] = 0
            # 如果前一小段不是回文，则从start开始继续拆分
            else:
                for startcut in range(endcut):
                    if isPalinDP[startcut + 1][endcut]:
                        cutDP[endcut] = min(cutDP[endcut], cutDP[startcut] + 1) # 动态转移，将 cutDP[start] + 1处的转移过来
        
        return cutDP[n - 1]
```

```py
看不懂
class Solution:
    def minCut(self, s: str) -> int:
        def dfs(startI):
            if startI >= len(s):
                return -1
            elif startI == len(s)-1: 
                dp[startI] = 0
                return 0
            
            if dp[startI] < 1e9: 
                return dp[startI]

            for i in range(startI,len(s)):
                # 如果某个子序列回文
                if s[startI:i+1]==s[startI:i+1][::-1] :
                    dp[startI] = min(dfs(i+1),dp[startI])
            dp[startI] += 1
            return dp[startI]
        
        dp = [1e9]*len(s)
        return dfs(0)

```

###  1.34. <a name='CloneGraph'></a>133. Clone Graph

[小梦想家](https://www.bilibili.com/video/BV1wA411T7SM?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV18i4y1c7FE?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12K411A7Zb?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1hzav19bp1wg.png" width="70%">

https://www.bilibili.com/video/BV1Cy4y127Di?from=search&seid=15236791324980694232&spm_id_from=333.337.0.0

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6d4fzq5ov200.png)


```py
class Solution(object):

    def __init__(self):
        self.visited = {}

    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        # 递归结束条件：
        # 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回
        if node in self.visited:
            return self.visited[node]
        # 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表
        cloneNode = Node(node.val, [])
        # 哈希表存储
        self.visited[node] = cloneNode
        # 遍历该节点的邻居并更新克隆节点的邻居列表
        if node.neighbors:
            cloneNode.neighbors = [self.cloneGraph(n) for n in node.neighbors] # 递归在这里，neighbors里面是😁
        return cloneNode
```

```py
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        def dfs(nod): # dfs的本质在于赋值
            VisitDic[nod] = Node(nod.val)
            # 对node的neighbors,如果在目录里面，返回这些邻居的值nod.val,否则dfs
            VisitDic[nod].neighbors = [dfs(n) if n not in VisitDic else VisitDic[n] for n in nod.neighbors] # 递归在这里，neighbors里面是😁
            return VisitDic[nod]
        VisitDic = {}
        return dfs(node) if node else None

# bfs模板加一个dict记录即可！

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        visited = {}
        def dfs(nod,visited):
            if not nod:
                return None # dfs 返回的是neighbors
            elif nod in visited:
                # 易错点：return nod
                return visited[nod]
            else:
                visited[nod] = Node(nod.val)
                for neigh in nod.neighbors:
                    visited[nod].neighbors.append(dfs(neigh,visited))
            return visited[nod]
        return dfs(node,visited) # 易错点：一定要返回
```

```py
类似的三种写法：

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        nodecp = Node(node.val)
        visited = {node:nodecp}
        stack = [node]
        while stack:
            tmp = stack.pop() #
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) # 😁 注意，append是字典内的neigh，也就是 Node(node.val)
        return nodecp

类似的三种写法：


class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        visited = {}
        visited[node] = Node(node.val)
        stack = [node]
        while stack:
            tmp = stack.pop() 
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) 
        return visited[node]

类似的三种写法：

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        visited = {}
        stack = [node]
        while stack:
            tmp = stack.pop() 
            if tmp not in visited: # 这行必须要有
                visited[tmp] = Node(tmp.val)
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) 
        return visited[node]
```


###  1.35. <a name='GasStation'></a>134. Gas Station

[小梦想家](https://www.bilibili.com/video/BV1BC4y1472f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1754y1176F?spm_id_from=333.999.0.0)

```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        start = 0
        curSum = 0
        totalSum = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            if curSum < 0:
                curSum = 0
                start = i + 1
        if totalSum < 0: return -1
        return start
```

###  1.36. <a name='CopyListwithRandomPointer'></a>138 Copy List with Random Pointer

[小明](https://www.bilibili.com/video/BV1BN411R7a8?spm_id_from=333.999.0.0)

###  1.37. <a name='SingleNumber'></a>136-Single Number

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7bf?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Sp4y1D7M3?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7PU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pa4y1t7tr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```py
class Solution:
    def singleNumber(self, nums):
        a = 0
        for num in nums:
            a = a ^ num
        return a

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)
```

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.reduce(_^_)
    }
}
```

###  1.38. <a name='SingleNumberII'></a>137 Single Number II

[小明](https://www.bilibili.com/video/BV1Hv411B7rd?spm_id_from=333.999.0.0)

###  1.39. <a name='WordBreak'></a>139 Word Break

[小明](https://www.bilibili.com/video/BV1p54y1k7vf?spm_id_from=333.999.0.0)

```py
# python 动态规划

# 从 i = 0 开始分析：i = 0， 遍历 j in range(1, n+1)， 

# 即遍历所有以 s[0]开头的组合，把第一个单词可能的情况全部找出来。

# 此时相当于把打头的单词可能的情况全部找出来了。

# 然后基于第一个单词一个单词一个单词地接上去。

class Solution(object):
    def wordBreak(self, s, wordDict):

        dp = [True]
        for end in range(1, len(s)+1):
            dp += [any(dp[start] and s[start:end] in wordDict for start in range(end))]
        return dp[-1]

class Solution:
    def wordBreak(self, s, wordDict):
        n = len(s) 
        dp = [True] + [False]*n

        for end in range(1, n + 1):
            for start in range(end):
                if dp[start] and s[start: end] in wordDict:
                    dp[end] = True # 说明s[: i] 在wordDict中
                    break # 优化部分：剩下的切分点j不用再寻找了，也可以不写，像下方一样
        return dp[-1]

```

###  1.40. <a name='WordBreakII'></a>140 Word Break II

[小明](https://www.bilibili.com/video/BV1ht4y1X7DJ?spm_id_from=333.999.0.0)

```py
# 直接回溯过了，这是样例出问题了还是标错难度了。。。
class Solution(object):
    def wordBreak(self, s, wordDict):
        res = []
        
        # 也是左右🐧切
        def backtrack(s, path):
            # nonlocal res
            if len(s) == 0:
                res.append(path[1:])
                return

            n = len(s)
            for i in range(n):
                if s[:i+1] in cash:
                    backtrack(s[i+1:], path+" "+s[:i+1])
                    
        backtrack(s, "")
        return res

class Solution:
    def wordBreak(self, s, wordDict):
        # @lru_cache(None)
        def backtrack(index: int):
            if index == len(s):
                return [[]]
            res = []
            for i in range(index + 1, len(s) + 1):
                left = s[index:i]
                if left in wordSet:
                    rightBreaks = backtrack(i)
                    for right in rightBreaks:
                        res.append(right[:] + [left])
            return res
        
        wordSet = set(wordDict)
        breakList = backtrack(0)
        return [" ".join(words[::-1]) for words in breakList]

class Solution(object):
    def wordBreak(self, s, wordDict):
        memo = {len(s): ['']}
        def sentences(i):
            if i not in memo:
                memo[i] = [s[i:j] + (tail and ' ' + tail)
                           for j in range(i+1, len(s)+1)
                           if s[i:j] in wordDict
                           for tail in sentences(j)]
            return memo[i]
        return sentences(0)
```

###  1.41. <a name='LinkedListCycle'></a>141-Linked List Cycle

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7ta?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411H7XP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1KX4y157vh?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1PA411b7gq?spm_id_from=333.999.0.0)

```py
方法一：集合 如果发现节点已在集合内则说明存在环

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            visited.add(head)
            head = head.next
            if head in visited:
                return True
        return False

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            if head in visited:
                return True
            visited.add(head)
            head = head.next
        return False

感觉初始时把快慢指针都指向 head 反而更简洁：

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
        
```


```scala
object Solution1 {
    def hasCycle(head: ListNode): Boolean = {
        
        var cur = head
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        
        var res: Boolean = false
        while (cur != null && res != true) {

            if(visited.contains(cur))  
                res = true
            else {
                visited += cur
                cur = cur.next
            }
        }
        res
    }
}


object Solution3 {
    def hasCycle(head: ListNode): Boolean = {
        var fast = head
        var slow = head
        
        
        var result = false
        while (fast != null && fast.next != null && result != true) {
            fast = fast.next.next
            slow = slow.next
        
            if(fast == slow) result = true
        }
        result
    }
}

object Solution {
    def hasCycle(head: ListNode): Boolean = {
        
        if(head == null){
            false
        }else{
        
        var slow = head
        var fast = head.next
        var output = true
        
        import scala.util.control.Breaks._
        breakable{
            while(slow != fast){
                if(fast == null || fast.next == null){
                    output=false
                    break
                }
                slow = slow.next
                fast = fast.next.next
            }
        }
        output
    }
    }
}

/**
* two pointer - tail recursive
*/
object Solution {
    def hasCycle(head: ListNode): Boolean = {
        if(head != null && head.next != null) 
            _hasCycle(head.next.next, head.next)
        else false
    }
    
    @annotation.tailrec
    def _hasCycle(fast: ListNode, slow: ListNode): Boolean = {
        if(fast == null || fast.next == null || slow == null) return false
        else if(fast == slow) return true
        else _hasCycle(fast.next.next, slow.next)
    }
}
//Alternate solution: Slow & Fast pointer
```

###  1.42. <a name='LinkedListCycleII'></a>142 Linked List Cycle II

[小明](https://www.bilibili.com/video/BV1W5411L7AF?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV15e41147EY?spm_id_from=333.999.0.0)

```py
我这个都在一个循环中，简洁点

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow, res = head, head, head
        flag = False

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if flag: res = res.next

            if slow == fast: flag = True
            if flag and slow == res: return res
        return None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            # 如果相遇
            if slow == fast:
                p = head
                q = slow
                while p!=q:
                    p = p.next
                    q = q.next
                #你也可以return q
                return p

        return None
```

```py
在for循环与while循环中的else语句块

旨在循环正常遍历了所有内容或由于循环条件不成立而结束循环时执行，

如果for循环与while循环因为break退出，则不执行else语句块中的内容。

continue对else没影响。 

这样在while循环之后使用else代码块，就可以达到代码中使用flag的效果

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head:
            return None
        fast, slow = head,  head
        while slow.next and fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return None
        
        slow = head
        while slow != fast:
             slow = slow.next
             fast = fast.next
        return slow

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        # 首先初始化快指针和慢指针，确保快指针走的路的长度是慢指针长度的2倍
        if head and head.next:
            fast = head.next.next
            slow = head.next
        else:
            return None  # 说明无环

        # 进行循环，首先让快指针和慢指针第一次相遇
        while fast:
            if fast != slow:

                # 快指针走两步
                if fast.next:
                    fast = fast.next.next
                else:
                    return None  # 说明无环

                # 慢指针走一步
                slow = slow.next
            else:
                detection = head
                while detection != slow:  # 此时由于slow和fast是一样的，用哪个都行
                    slow = slow.next
                    detection = detection.next

                return detection

```

```scala
object Solution {
    def detectCycle(head: ListNode): ListNode = {
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        var cur = head
        
        var result: ListNode = null

        while (cur != null && result == null) {
            // println(result)
            if(visited.contains(cur))  
                result = cur
            else {
                visited += cur
                cur = cur.next
            }
        }
        result
        
    }
}

```

###  1.43. <a name='ReorderList'></a>143 Reorder List

[小明](https://www.bilibili.com/video/BV1Jf4y1Q7y7?spm_id_from=333.999.0.0)

###  1.44. <a name='Preorderwithstack'></a>144-Preorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1HT4y1G74i?spm_id_from=333.999.0.0)

###  1.45. <a name='BinaryTreePreorderTraversal'></a>144-Binary Tree Preorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7NZ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Ch411Q74P?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1RD4y1D7C7?spm_id_from=333.999.0.0)


```py
Python递归

class Solution(object):
    def preorderTraversal(self, root):
        if not root:
            return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
```

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def dfs(node):
            if not node:
                return
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        res = []
        dfs(root)
        return res
```

stack

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        ans = []
        if not root:
            return ans
        stack = [root]
        while stack:
            node = stack.pop()
            ans.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return ans
```


###  1.46. <a name='Postorderwithstack'></a>145-Postorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1Ti4y187jL?spm_id_from=333.999.0.0)

###  1.47. <a name='BinaryTreePostorderTraversal'></a>145-Binary Tree Postorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7ub?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1uv411h7Gc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1xZ4y1H7uS?spm_id_from=333.999.0.0)

```py
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def postorder(root: TreeNode):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = []
        postorder(root)
        return res

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        from collections import deque
        res, que = [], deque()
        que.append(root) if root else None
        while que:
            tmp = que.pop()
            res.append(tmp.val)
            que.append(tmp.left) if tmp.left else None
            que.append(tmp.right) if tmp.right else None
        return res[::-1]

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return list()
        
        res = list()
        stack = list()
        prev = None

        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if not root.right or root.right == prev:
                res.append(root.val)
                prev = root
                root = None
            else:
                stack.append(root)
                root = root.right
        
        return res

```

###  1.48. <a name='LRUCache'></a>146 LRU Cache 

[花花酱](https://www.bilibili.com/video/BV19b411c7ue?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7c6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1t7zj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ZQ4y1A74H?spm_id_from=333.999.0.0)

```py

from clecode import decorator_default
import collections

class LRUCache(collections.OrderedDict):

    def __init__(self, capacity: int):
        super().__init__()
        self.capacity = capacity


    def get(self, key: int) -> int:
        if key not in self:
            return -1
        self.move_to_end(key)
        return self[key]

    def put(self, key: int, value: int) -> None:
        if key in self:
            self.move_to_end(key)
        self[key] = value
        if len(self) > self.capacity:
            self.popitem(last=False)


if __name__ == "__main__":  
    import doctest  
    
    doctest.testmod()
```


```py
import collections
class LRUCache:
    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.capacity = capacity
        self.cache = collections.OrderedDict()

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key in self.cache:
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
            
        return -1

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if key in self.cache:
            self.cache.pop(key)
        else:
            if len(self.cache) == self.capacity:
                self.cache.popitem(last=False)
                
        self.cache[key] = value

```

```scala

/**
* chosen solution
* build-in linkedHashMap
* time complexity: O(1)
*/
class LRUCache0(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
    cache.get(key) match {
        case Some(v) => 
            cache.remove(key)
            cache.put(key, v)
            v
        case None => -1
    }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}



/**
* build-in linkedHashMap
*/
class LRUCache3(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
  /**
   *cache.get(key).map{
   *   value =>
   *     cache.remove(key)
   *     cache.update(key, value)
   *     value
   * }.getOrElse(-1)
   */
   cache.get(key) match {
            case Some(v) => 
                cache.remove(key)
                cache.put(key, v)
                v
            case None => -1
        }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}

```

```scala
import scala.collection.mutable._

  class LRUCache(_capacity: Int) {

    val hm = HashMap[Int, Int]()
    val lb = ListBuffer.empty[Int]
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key)
      } else {
        -1
      }

    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key) = value
      } else {
        if (hm.size == c) {
          val lk = lb.head
          hm.remove(lk)
          lb.remove(0)
        }
        hm(key) = value
        lb += key
      }
    }
  }


// test case
//  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
//  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]

//  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]
  class LRUCache3(_capacity: Int) {
    val hm = HashMap[Int, Node]()
    val dl = new DoublyLinkedList()
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v
      } else { // not found
        -1
      }
    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v = value
      } else {
        if (hm.size == c) {
          val old = dl.tail
          if (old!=null) {
            dl.erase(old)
            hm.remove(old.v.k)
          }
        }
        val node = Node(KV(key,value),null,null)
        hm(key) = node
        dl.push_front(node)
      }
    }
  }
```

```scala
  class Test extends BaseExtension {
    def init {
      val lru = new LRUCache(2)
      lru.put(1,1)
      lru.put(2,2)
      println(lru.get(1) == 1)
    }

    val name = "146 LRU chache"
  }

//  ["LRUCache","put","put","get","put","get","put","get","get","get"]
//  [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
  class Test2 extends BaseExtension {
    def init {
      val lru = new LRUCache2(2)
      lru.put(2,1)
      lru.put(1,1)
      lru.put(2,3)
      lru.put(4,1)
      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }

  //  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
  //  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]
  //  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]

  class Test3 extends BaseExtension {
    def init {
      val lru = new LRUCache3(10)
      lru.put(10,13)
      lru.put(3,17)
      lru.put(6,11)
      lru.put(10,5)
      lru.put(9,10)

      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }
```

###  1.49. <a name='InsertionSortList'></a>147 Insertion Sort List

[小明](https://www.bilibili.com/video/BV1F54y1k7oU?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Ti4y187pN?spm_id_from=333.999.0.0)

```py
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        dummy = ListNode(0)
        dummy.next = head
        tmp = head
        cur = head.next

        while cur:
            if tmp.val <= cur.val:
                tmp = tmp.next
            else:
                pre = dummy
                while pre.next.val <= cur.val:
                    pre = pre.next
                tmp.next = cur.next
                cur.next = pre.next
                pre.next = cur
            cur = tmp.next
        
        return dummy.next

class Solution(object):
    def insertionSortList(self, head):
        if head == None or head.next == None:
            return head

        dummy = ListNode(0)
        dummy.next = head

        tmp = head 
        cur = head.next

        while cur:
            pre = dummy
            while pre.next.val <= cur.val and pre != tmp:
                pre = pre.next
            if pre != tmp:
                tmp.next = cur.next
                cur.next = pre.next
                pre.next = cur
            tmp = cur
            cur = cur.next

        return dummy.next


# 菜鸡版 python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        cur = head.next
        dummy.next.next = None
        while cur:
            pre = dummy
            while pre.next and cur.val > pre.next.val:
                pre = pre.next
            tmp = cur.next
            cur.next = pre.next
            pre.next = cur
            cur = tmp
        return dummy.next
```

###  1.50. <a name='SortList'></a>148. Sort List

[花花酱](https://www.bilibili.com/video/BV1jW411d7z7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK411A7Gm?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        sortlist = []
        while(head is not None):
            aft = head.next
            head.next = None
            sortlist.append(head)
            head = aft
        sortlist = sorted(sortlist, key=lambda x: x.val)
        n = len(sortlist)
        if n == 0:
            return None
        dummy.next = sortlist[0]
        for i in range(n-1):
            sortlist[i].next = sortlist[i+1]
        
        return dummy.next
```

```py
# py3 归并排序，递归实现。空间复杂度主要在递归栈深度：O( log(n) )，整个递归过程有点像后序遍历

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        mid=self.findmid(head)
        left=head # 指定左右
        right=mid.next # 指定左右
        mid.next=None # 断开链接
        l=self.sortList(left)
        r=self.sortList(right)
        return self.merge(l,r)

    def findmid(self,head):
        slow=head
        fast=head
        while fast.next and fast.next.next:
            slow=slow.next
            fast=fast.next.next
        return slow

    def merge(self,l,r):
        dummy=ListNode(None)
        cur=dummy
        while l and r:
            if l.val<=r.val:
                cur.next=l
                l=l.next # 下一个
            else:
                cur.next=r
                r=r.next # 下一个
            cur=cur.next # 下一个
        cur.next=l or r
        return dummy.next

        # 基本用法：
        # v = p1 or p2

        # 它完成的效果等同于：
        # if p1:
        #     v = p1
        # else:
        #     v = p2
```

###  1.51. <a name='MaxPointsonaLine'></a>149. Max Points on a Line

[花花酱](https://www.bilibili.com/video/BV1zb411u7WW?spm_id_from=333.999.0.0)

###  1.52. <a name='EvaluateReversePolishNotation'></a>150. Evaluate Reverse Polish Notation

[花花酱](https://www.bilibili.com/video/BV14f4y127K8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16B4y1P7Nx?spm_id_from=333.999.0.0)

```py
class Solution:
    def evalRPN(self, tokens):
        f1 = lambda a,b:a+b
        f2 = lambda a,b:a-b
        f3 = lambda a,b:a*b
        f4 = lambda a,b:int(a/b)
        maps = {'+':f1,'-':f2,'*':f3,'/':f4}
        stack = []
        for i in tokens:
            if i in maps:
                a = stack.pop()
                b = stack.pop()
                stack.append(maps[i](b,a))
            else:
                i = int(i)
                stack.append(i)
        return stack[-1]

class Solution:
    def evalRPN(self, tokens):
        stack = []
        for item in tokens:
            if item not in {"+", "-", "*", "/"}:
                stack.append(item)
            else:
                first_num, second_num = stack.pop(), stack.pop()
                stack.append(
                    int(eval(f'{second_num} {item} {first_num}'))   # 第一个出来的在运算符后面
                )
        return int(stack.pop()) # 如果一开始只有一个数，那么会是字符串形式的

class Solution:
    def evalRPN(self, tokens):
        """
        解题思路:数字入栈，算数符号出栈两个数字栈并计算，计算结果入栈
        """
        stack = []
        
        for item in tokens:

            if item not in ['+', '-', '*', '/']:
                stack.append(int(item))
            else:
                a = stack.pop()
                b = stack.pop()
                if item == '+': stack.append(a + b)
                elif item == '-': stack.append(b - a)
                elif item == '*': stack.append(a * b)
                elif item == '/': stack.append(int(b / float(a)))   # 注意如何取整
        return stack[0]
```

###  1.53. <a name='ReverseWordsinaString'></a>151. Reverse Words in a String

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7g4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rT4y1g7AJ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ei4y1V7yA?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        left, right = 0, len(s) - 1
        # 去掉字符串开头的空白字符
        while left <= right and s[left] == ' ':
            left += 1
        
        # 去掉字符串末尾的空白字符
        while left <= right and s[right] == ' ':
            right -= 1
            
        que, word = collections.deque(), []
        # 将单词 push 到队列的头部
        while left <= right:
            if s[left] == ' ' and word:
                que.appendleft(''.join(word))
                word = []
            elif s[left] != ' ':
                word.append(s[left])
            left += 1
        que.appendleft(''.join(word))
        
        return ' '.join(que)
```

```py
一种没有用split 和reverse的方法[^1]

分三步:

先翻转整个数组
再翻转单个单词
清除多余空格
class Solution:
    def reverseWords(self, s: str) -> str:
        s = list(s)
        n = len(s)
        #print(s)
        
        # 翻转数组
        def reverse(s, i, j):
            while i < j:
                s[i], s[j] = s[j], s[i]
                i += 1
                j -= 1

        # 翻转单个单词
        def word_reverse(s):
            # 用双指针找到一个单词
            i = 0
            j = 0
            while i < n:
                # 找到一个单词首字母
                while i < n and s[i] == " ":
                    i += 1
                j = i
                # 找到一个单词末位置
                while j < n and s[j] != " ":
                    j += 1
                reverse(s, i, j - 1)
                i = j

        # 清除多余空格
        def clean_space(s):
            i = 0
            j = 0
            while j < n:
                # 找到一个单词
                while j < n and s[j] == " ":
                    j += 1
                # 单词朝前移
                while j < n and s[j] != " ":
                    s[i] = s[j]
                    i += 1
                    j += 1
                # 移动下一个单词
                while j < n and s[j] == " ":
                    j += 1
                if j < n:
                    s[i] = " "
                    i += 1
            return "".join(s[:i])

        reverse(s, 0, n - 1)
        #print(s)
        word_reverse(s)
        #print(s)
        return clean_space(s)
```



###  1.54. <a name='-1'></a>152-乘积最大子数组

[哈哈哈](https://www.bilibili.com/video/BV12a4y1i76G?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iK411K7yG?spm_id_from=333.999.0.0)

```py
# 动态规划：遍历时，每次分别存储 前i个中连续数组 [最大的乘积和] 和 [最小乘积和]

# 之所有存 [最小乘积和]，是因为 [最小乘积和] 如果是负数有可能遇到负数，

# 相乘后结果更大 Python

class Solution(object):
    def maxProduct(self, nums):
        n = len(nums)
        maxdp = [ nums[0] for i in range(n)]
        mindp = [ nums[0] for i in range(n)]

        for i in range(1,n):
        	maxdp[i] = max(mindp[i-1]*nums[i], maxdp[i-1]*nums[i],nums[i])
        	mindp[i] = min(maxdp[i-1]*nums[i], mindp[i-1]*nums[i],nums[i])

        return max(maxdp)

class Solution:
    def maxProduct(self,nums):
        dp_max, dp_min = nums[0],nums[0] 
        maxp = nums[0]
        for i in range(1,len(nums)):
            dp_max = max(nums[i], dp_max*nums[i], dp_min*nums[i]) 
            dp_min = min(nums[i], dp_max*nums[i], dp_min*nums[i])
            maxp = max(maxp, dp_max)
        return maxp


class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        max_num = []
        min_num = []

        max_num.append(nums[0])
        min_num.append(nums[0])

        res = nums[0]

        for i in range(1,len(nums)):
            max_num.append(max(nums[i], nums[i]*max_num[i-1], nums[i]*min_num[i-1]))
            min_num.append(min(nums[i], nums[i]*max_num[i-1], nums[i]*min_num[i-1]))
            res = max(res, max_num[i])
        return res
# 优化空间
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        maxF, minF, ans = nums[0], nums[0], nums[0]
        length = len(nums)
        for i in range(1, length):
            mx, mn = maxF, minF # 只用两个变量来维护i−1时刻的状态,优化空间
            maxF = max(mx * nums[i], nums[i], mn * nums[i])
            minF = min(mn * nums[i], nums[i], mx * nums[i])
            ans = max(maxF, ans)
        
        return ans


class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        dp_min = [1] * n
        dp_max = [1] * n
        dp_min[0] = nums[0]
        dp_max[0] = nums[0]
        res = dp_max[0]
        for i in range(1, n):
            dp_min[i] = min(dp_min[i-1]*nums[i], dp_max[i-1]*nums[i], nums[i])
            dp_max[i] = max(dp_min[i-1]*nums[i], dp_max[i-1]*nums[i], nums[i])
            res = max(res, dp_max[i])
        return res


class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums: return 
        res = nums[0]
        pre_max = nums[0]
        pre_min = nums[0]
        for num in nums[1:]:
            cur_max = max(pre_max * num, pre_min * num, num)
            cur_min = min(pre_max * num, pre_min * num, num)
            res = max(res, cur_max)
            pre_max = cur_max
            pre_min = cur_min
        return res
```

```scala

object Solution2-1 {
    def maxProduct(nums: Array[Int]): Int = {
        
        val (_, _, ans) = (1 until nums.length).foldLeft((nums.head, nums.head, nums.head)){
            case ((min, max, ans), idx) => 
                val a = nums(idx) * min 
                val b = nums(idx) * max
                val newMin = a min b min nums(idx)
                val newMax = a max b max nums(idx)
                (newMin, newMax, ans max newMax)
        }
        ans
    }
}


object Solution0 {
  def maxProduct(nums: Array[Int]): Int = {
    val dp = Array.ofDim[Int](nums.length, 2) // record each position n's max product( from 0 to n)
    var result = nums(0)
    dp(0)(0) = nums(0)
    dp(0)(1) = nums(0)

    /* 0 for min, 1 for max */
    for (i <- 1 until nums.length) {
      val a = dp(i - 1)(0) * nums(i)
      val b = dp(i - 1)(1) * nums(i)
      dp(i)(0) = nums(i) min a min b // record min
      dp(i)(1) = nums(i) max a max b // record max
      result = result max dp(i)(1)
    }
    result
  }
}


/**
* optimize above one
* don't copy subArray during transmit parameters
* time complexity： O(N^2)
*/
object Solution {
  def maxProduct(nums: Array[Int]): Int = {
    (1 to nums.length).map(n =>  _maxProduct(nums(n - 1), n, nums)).max
  }
  def _maxProduct(curr: Int, idx: Int, nums: Array[Int]): Int = {
      if(idx >= nums.length) return curr   
      curr max  _maxProduct( curr * nums(idx), idx + 1, nums)
  }

}




object Solution {
    def maxProduct(nums: Array[Int]): Int = {
        if (nums == null || nums.size == 0) {
            return 0;
        }
        val list: List[Int] = nums.toList
        val head: Int = list.head
        val tail: List[Int] = list.tail
        _MaxProduct(tail, head, head, head)
    }
    
    def _MaxProduct(nums: List[Int], min: Int, max: Int, result: Int): Int = nums match {
        case Nil => result
        case x :: xs => {
            val cur_min = math.min(x, math.min(x * max, x * min))
            val cur_max = math.max(x, math.max(x * max, x * min))
            _MaxProduct(xs, cur_min, cur_max, math.max(cur_max, result))
        }
    }
}
```

###  1.55. <a name='-1'></a>153-寻找旋转排序数组中的最小值

[哈哈哈](https://www.bilibili.com/video/BV1bT4y1w7yK?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1yK411L7rp?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMin(self, nums):
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == nums[right]:    # 此时 left 和 right 相等，直接返回
                return nums[right]
            elif nums[mid] < nums[right]:   # 比右界小，nums[mid] 可能是最小值，不能去掉
                right = mid
            else:                           # 比右界大，nums[mid] 肯定不会是最小值     
                left = mid + 1

        return 1000000    # 这里写什么都无所谓，正常情况下不会走到这里的

# 二分法

class Solution:
    def findMin(self, nums):
        l,r= 0,len(nums) -1
        while l < r:
            if nums[l] < nums[r]:
                return nums[l]
            mid = (l + r) // 2
            if nums[mid] >= nums[r]:
                l = mid +1
            else:  
                r = mid
        return nums[l]
```

```scala

/**
* my first commitment binary search
*/
object Solution1 {
    def findMin(nums: Array[Int]): Int = {
        search(nums, 0, nums.length - 1)
    }
  
    def search(nums: Array[Int], left: Int, right: Int): Int = {
      if (left > right) return nums(left)
      val mid = left + (right - left) / 2
      val leftAns = if (nums(mid) >= nums(left)){ // left part in order
        nums(left)
      } else {
        search(nums, left, mid - 1)
      }
      
      val rightAns = if (nums(mid) <= nums(right)) { // right part in order
        nums(mid)
      } else {
        search(nums, mid + 1, right)
      }
      
      leftAns min rightAns
    }
}
```

###  1.56. <a name='FindMinimuminRotatedSortedArr'></a>154 Find Minimum in Rotated Sorted Arr

[小明](https://www.bilibili.com/video/BV1ik4y1B7de?spm_id_from=333.999.0.0)

###  1.57. <a name='MinStack'></a>155-Min Stack

[哈哈哈](https://www.bilibili.com/video/BV1H74118748?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1r77W?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ja4y1Y7vY?spm_id_from=333.999.0.0)

```py
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = [math.inf]

    def push(self, x: int) -> None:
        self.stack.append(x)
        self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

面试的时候被问到不能用额外空间，就去网上搜了下不用额外空间的做法。思路是栈里保存差值。

class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min_value = -1

    def push(self, x: int) -> None:
        if not self.stack:
            self.stack.append(0)
            self.min_value = x
        else:
            diff = x-self.min_value
            self.stack.append(diff)
            self.min_value = self.min_value if diff > 0 else x

    def pop(self) -> None:
        if self.stack:
            diff = self.stack.pop()
            if diff < 0:
                top = self.min_value
                self.min_value = top - diff
            else:
                top = self.min_value + diff
            return top

    def top(self) -> int:
        return self.min_value if self.stack[-1] < 0 else self.stack[-1] + self.min_value

    def getMin(self) -> int:
        return self.min_value if self.stack else -1

class MinStack:

    def __init__(self):
        # 另外用一个stack，栈顶表示原栈里所有值的最小值
        self.min_stack = []
        self.stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.min_stack == []:
            self.min_stack.append(val)
            return
        if self.min_stack[-1] >= val:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack[-1] == self.min_stack[-1]:
            self.min_stack.pop()
        return self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]


    def getMin(self) -> int:
        return self.min_stack[-1]        
```


```scala
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var min = Int.MaxValue

    def push(x: Int) {
        stack = stack :+ x
        if(x < min){
            min = x
        }
    }

    def pop() {
        stack = stack.init
        min = Int.MaxValue
        stack.map(x => {
            if(x < min) min = x
        })
    }

    def top(): Int = {
        stack.last
    }

    def getMin(): Int = {
        min
    }

}

//替代解决方案：更快
//这里我们将元素添加到列表中而不是附加
//请注意，由于List实际上是一个LinkedList，因此处理列表的“头部”要容易得多
//还有另一个列表来维护列表的最小元素
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var mins = List.empty[Int]

    def push(x: Int) {
        //如果我们将第二个条件设为 x < mins.head，则此行失败
        //with NoSuchElementException: 空列表的头部
        //为什么？？？
        if(mins.isEmpty || mins.head >= x) mins = x +: mins
        stack = x +: stack
    }

    def pop() {
        if(mins.head == stack.head) mins = mins.tail
        stack = stack.tail
    }

    def top(): Int = {
        stack.head
    }

    def getMin(): Int = {
        mins.head
    }

}

```

###  1.58. <a name='IntersectionofTwoLinkedLists'></a>160-Intersection of Two Linked Lists

[哈哈哈](https://www.bilibili.com/video/BV1n741187X6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411H7uq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K4y1J7wx?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1np4y1y789?spm_id_from=333.999.0.0)

```py
## 1. 哈希表

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        listA = set()
        while headA:
            listA.add(headA)
            headA = headA.next
        while headB:
            if headB in listA:
                return headB
            headB = headB.next
        return None

# > 时间复杂度 $O(M+N)$, 空间复杂度 $O(M)$

## 2. 双指针

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        pa,pb = headA, headB
        while pa != pb:
            pa = pa.next if pa else headB
            pb = pb.next if pb else headA
        return pa

# > 时间复杂度 $O(M+N)$, 空间复杂度 $O(1)$
```

```py

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        lengthA,lengthB = 0,0
        curA,curB = headA,headB
        while(curA!=None): #求链表A的长度
            curA = curA.next
            lengthA +=1
        
        while(curB!=None): #求链表B的长度
            curB = curB.next
            lengthB +=1
        
        curA, curB = headA, headB

        if lengthB>lengthA: #让curA为最长链表的头，lenA为其长度
            lengthA, lengthB = lengthB, lengthA
            curA, curB = curB, curA

        gap = lengthA - lengthB #求长度差
        while(gap!=0): 
            curA = curA.next #让curA和curB在同一起点上
            gap -= 1
        
        while(curA!=None):
            if curA == curB:
                return curA
            else:
                curA = curA.next
                curB = curB.next
        return None
```



```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {
        var ha = headA
        var hb = headB
        
        while(ha != hb){
            if(ha == null){
                ha = headB
            }else{
                ha = ha.next
            }
            
            if(hb == null){
                hb = headA
            }else{
                hb = hb.next
            }
        }
        
        ha
    }
}

```

###  1.59. <a name='FindPeakElement'></a>162. Find Peak Element

[小梦想家](https://www.bilibili.com/video/BV1Rb411n7dT?spm_id_from=333.999.0.0)

```py
# 努力接受了一下。就是想象一下峰顶在中间，那么左右两侧都是有序的，可根据mid和mid+1的值判断当前是在哪一侧，然后最后定位到峰值
class Solution(object):
    def findPeakElement(self, nums):
        l = 0 
        r = len(nums) - 1 

        while l <= r:
        	mid = (l + r) >> 1

        	if l == r : return l # 关键在于这里

        	if nums[mid] < nums[mid+1]: # 关键在于这里，背一背吧
        		l = mid + 1
        	else:
        		r = mid
```

###  1.60. <a name='CompareVersionNumbers'></a>165. Compare Version Numbers

[小梦想家](https://www.bilibili.com/video/BV19K4y1C7L3?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pk4y117dF?spm_id_from=333.999.0.0)

```py
简洁版

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        for x, y in zip_longest(version1.split('.'), version2.split('.'), fillvalue='0'):
            a, b = int(x), int(y)
            if a != b: return 1 if a > b else -1
        return 0 

```

```py
python 精简版

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = version1.split(".")
        v2 = version2.split(".")

        while v1 or v2:
            x = int(v1.pop(0)) if v1 else 0
            y = int(v2.pop(0)) if v2 else 0

            if x>y:
                return 1
            elif x<y:
                return -1
        return 0
```

###  1.61. <a name='FractiontoRecurringDecimal'></a>166. Fraction to Recurring Decimal

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7PE?spm_id_from=333.999.0.0)

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # ----------情况一：没有余数----------
        if numerator % denominator == 0:
            return str(numerator // denominator)
        # ----------情况一：没有余数----------


        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        s = []

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if (numerator < 0) != (denominator < 0):
            s.append('-')
        # ----------------得到负数----------------
        # ----------------得到负数----------------


        # 整数部分
        numerator = abs(numerator)
        denominator = abs(denominator)
        integerPart = numerator // denominator
        s.append(str(integerPart))
        s.append('.')

        # 小数部分
        indexMap = {}
        remainder = numerator % denominator
        while remainder and remainder not in indexMap:
            indexMap[remainder] = len(s) 

            # 这里需要一个计数器，s的长度递增，所以用len(s)
            # 解法二中：
            # i = 0
            # i += 1
            # 也是可以的。
            # len(s) 可以直接指向 insertIndex-插入位置

            print("余数remainder: ",indexMap.keys())
            remainder *= 10
            s.append(str(remainder // denominator))
            remainder %= denominator
        if remainder:  # 有循环节
            insertIndex = indexMap[remainder]
            s.insert(insertIndex, '(') #左侧插入
            s.append(')')

        return ''.join(s)
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
```

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        dic = {}
        res = []

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if numerator*denominator<0:
            sign = "-"
        else:
            sign = ""
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator = abs(numerator)
        denominator = abs(denominator)
        intPart,res = divmod(numerator, denominator)


        # ----------情况一：没有余数----------
        if res==0:
            return sign + str(intPart)
        # ----------情况一：没有余数----------
        
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        res.append(str(intPart))
        res.append(".")

        dic[res]= len(res) # 是 2
        while res!=0:
            intPart,res = divmod(10*res,denominator)
            res.append(str(intPart))
            # 如果余数出现在字典中，加上（）并返回
            if res in dic:
                res.insert(dic[res],"(") #左侧插入
                res.append(")")     #右侧插入
                return sign + "".join(res)
            # 继续记录余数和(索引位置
            
            dic[res] = len(res) # i+=1
        # 如果余数为0
        return sign + "".join(res) 
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # 处理整数部分
        ans = ""

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if numerator * denominator < 0:
            ans += "-"
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart, res = divmod(numerator, denominator)
        # ans += f"{q}"
        ans += str(intPart)


        # ----------情况一：没有余数----------
        if 0 == res:
            return ans
        # ----------情况一：没有余数----------

        
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        ans += '.'
        # 小数部分：除法发现循环节
        index = len(ans)  # 小数点后一个位置
        numerator = res * 10  # 被除数增加十倍
        dic = {numerator: index}
        while True:
            intPart, res = divmod(numerator, denominator)
            ans += str(intPart)
            if res == 0:
                break
            numerator = res * 10
            if numerator in dic:  # 发现循环节
                return ans[:dic[numerator]] + f"({ans[dic[numerator]:]})" # 直接加括号（）
            dic[numerator] = index + 1  # 新被除数位置
            index += 1
        return ans
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        sign = "" if numerator * denominator >= 0 else "-"
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart = numerator // denominator

        # ----------情况一：没有余数----------
        if numerator % denominator == 0: return sign + str(intPart)
        # ----------情况一：没有余数----------

        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        res, dic, index = numerator % denominator, {}, 3
        ans = [sign, str(intPart), "."]
        while res:
            if res not in dic:
                dic[res] = index
            else:
                ans.insert(dic[res], "(")
                ans.append(")")
                break
            res *= 10
            ans.append(str(res // denominator))
            res %= denominator
            index += 1
        return "".join(ans)
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
```

###  1.62. <a name='TwoSumII-Inputarrayissorted'></a>167-Two Sum II - Input array is sorted

[哈哈哈](https://www.bilibili.com/video/BV167411h7ou?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7id?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1VZ4y1M7eu?spm_id_from=333.999.0.0)

```py
python 3 有点二分法的味道

    # 双指针
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r =0, n-1 
        while l <= r:
            if numbers[l] + numbers[r] == target:
                return [l+1, r+1]
            elif numbers[l] + numbers[r] < target:
                l +=1
            else:
                r -=1
        return [-1, -1]

    # hasn表，利用hash表记录所有的差值
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        visited = dict()
        for index, num in enumerate(numbers):
            if num in visited:
                return [visited[num]+1, index+1]
            visited[target - num] = index
```

###  1.63. <a name='ExcelSheetColumnTitle'></a>168-Excel Sheet Column Title

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7FY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H777?spm_id_from=333.999.0.0)

```py
## A的ascii码为65
# 又想了好久才知道在哪里减一。。
class Solution:
    def convertToTitle(self, n: int) -> str:
        res = ''
        while(n):
            n -= 1
            res = chr(n%26+65) + res
            n = n//26
        return res



class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        res = ""

        while columnNumber-1 >= 0:
            columnNumber -= 1
            res += chr(columnNumber % 26 + ord('A'))
            columnNumber //= 26
        return res[::-1]

class Solution(object):
    def convertToTitle(self, columnNumber):
        res = ''
        while columnNumber:
            columnNumber -= 1
            res = chr(columnNumber % 26 + 65) + res
            columnNumber = columnNumber // 26 
        return res
```

###  1.64. <a name='MajorityElement'></a>169. Majority Element

[花花酱](https://www.bilibili.com/video/BV1hb411c7bF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7pW?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ff4y1U7Vn?spm_id_from=333.999.0.0)

```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        return sorted(nums)[len(nums) // 2]

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[len(nums) // 2]


class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)

# 投票策略，半数以上获胜

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = None

        for vot in nums:
            if count == 0:
                candidate = vot
            count += (1 if vot == candidate else -1)

        return candidate
```

```scala
/**
* HashMap
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution2 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.groupBy(identity).mapValues(_.length).maxBy(_._2)._1  
    }
}


/**
* sorting array and pick middle element
* time complexity O(NlogN)
*/

object Solution3 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.sorted(Ordering.Int)(nums.length / 2)
    }
}
```


```scala

/**
* chosen solution
* 投票测量
* Boyer-Moore Voting Algorithm
* time complexity N(N)
* space complexity O(1)
*/
object Solution
    def majorityElement(nums: Array[Int]): Int = {
      var counter = 0
      var candidate = nums(0)
      for (idx <- 1 until nums.length) {
        val vot = nums(idx)
        if(candidate == vot)
          counter += 1
        else {
          if(counter == 0)
            candidate = vot
          else
            counter -= 1
        }
      }
      candidate
    }
}


object Solution1 {
  def majorityElement(nums: Array[Int]): Int = {
    var candidate = nums(0)
    var counter = 0
    candidate.foreach { vot =>
      if (candidate == vot) {
        counter += 1
      } else {
        counter -= 1
        if (counter == 0) {
          candidate = vot
          counter += 1
        }
      }
    }
    candidate
  }
}


//Alternate solution O(n) but NO EXTRA SPACE
object Solution {
    def majorityElement(nums: Array[Int]): Int = {     
        var candidate = nums.head
        var count = 0
        nums.foreach(vot => {
            if(count == 0) { 
                candidate = vot
                count = 0
            }
            if(vot == candidate) count+=1;
            else count-=1;
        })
        
        candidate
    }
}

```

###  1.65. <a name='ExcelSheetColumnNumber'></a>171. Excel Sheet Column Number

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7nT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1h541187Sv?spm_id_from=333.999.0.0)

```py
# python 从左到右遍历
        #26进制转10进制
class Solution:
def titleToNumber(self, columnTitle: str) -> int:
        res = 0
        for char in columnTitle:
            res *= 26
            res += ord(char) - ord('A') + 1 
        return res
```


```scala
//Alternate solution
object Solution {
    def titleToNumber(s: String): Int = 
        s.foldLeft(0)((acc, ch) => acc * 26 + (ch - 'A' + 1))
}

```

###  1.66. <a name='FactorialTrailingZeroes'></a>172-Factorial Trailing Zeroes

[哈哈哈](https://www.bilibili.com/video/BV1hE411n7TM?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7tS?spm_id_from=333.999.0.0)

```py
class Solution:
    def trailingZeroes(self, n: int) -> int:
        # Calculate n!
        factorial = 1
        for i in range(2, n + 1):
            factorial *= i
        # Count how many 0's are on the end.
        res = 0
        while factorial % 10 == 0:
            res += 1
            factorial //= 10
            
        return res



class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n > 0:
            n //= 5
            ans += n
        return ans


class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n >= 5:
            ans += n//5
            n = n//5
        return ans
```

```scala
object Solution {
    def trailingZeroes(n: Int): Int = {
        var count5 = 0
        var count2 = 0
        
        var temp = n
        while(temp>=5){
            count5 += temp/5
            temp = temp/5
        }
        
        temp = n
        while(temp>=2){
            count2 += temp/2
            temp = temp/2
        }
        
        if(count5 < count2) count5 else count2
    }
}

```

###  1.67. <a name='BinarySearchTreeIterator'></a>173 Binary Search Tree Iterator

[小明](https://www.bilibili.com/video/BV1qK41137h1?spm_id_from=333.999.0.0)

```py
# 在数据上设计迭代器的话，是「一定」不能修改原始的数据的。
# ------
# 借楼贴个 Morris 遍历。O(1) 空间复杂度，均摊 O(1) 时间复杂度。

class BSTIterator:
    def __init__(self, root: TreeNode):
        self.curr = root

    def next(self) -> int:
        while self.curr.left:
            left = self.curr.left
            while left.right and left.right != self.curr:
                left = left.right
            # left child has been visited
            if left.right:
                left.right = None
                break
            # left child has not been visited
            else:
                left.right = self.curr
                self.curr = self.curr.left
        # visit current node and go right
        ans = self.curr.val
        self.curr = self.curr.right
        return ans

    def hasNext(self) -> bool:
        return True if self.curr else False

# 这并不是一种好办法。如果在数据上设计迭代器的话，
# 是「一定」不能修改原始的数据的。
# 请教下为什么不能修改原始数据？
# 是因为某些情况下会造成迭代器失效吗？
# 有些迭代器设计时也允许这种情况，比如STL中的某些容器。Thanks!
# 是「迭代器在迭代的过程中不能修改原始的数据结构」，
# 不是「不能通过迭代器本身修改原始的数据」。
# 想一想 const iterator 就知道是怎么回事了

# Python 72ms 击败100%，关键是构建一个最小值存储栈，实现O(h)空间复杂度。

class BSTIterator(object):

    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self):
        """
        @return the next smallest number
        :rtype: int
        """
        temp = self.stack.pop()
        res = temp.val
        temp = temp.right
        while temp:
            self.stack.append(temp)
            temp = temp.left
        return res

    def hasNext(self):
        """
        @return whether we have a next smallest number
        :rtype: bool
        """
        return self.stack != []

# 在next中回溯的，这个用的是非递归，栈的方法来遍历的
# 在next中 ，把pop 的节点看做root， 将其右节点压入栈。自下往上
# 每一次调用next都是在return 之余去看一下当前节点的右子节点，
# 如果有右子节点，那么树的深度会比当前遍历深度大，
# 也就是说，next在右子节点代表的子树中，
# 那就按照正常遍历左子树的思路去遍历该子树即可，就跟init一样；
# 如果没有右子树，那么当前子树达到最大深度，next就得往上一层找，
# 就是说继续从stack中pop，因为stack中存的是每一层的左子树，
# pop到上一层再看看有没有右子树，如果有，还是一样的道理，去遍历该右子树的左子树。
# 总的来说stack总能pop出树的最小值，也就是当前状态下的左子树的最深左节点。

class BSTIterator(object):
    def __init__(self, root):

        #二叉搜索树中序遍历是递增数组
        self.res = []

        def inorder(root):
            if root == None:
                return
            inorder(root.left)
            self.res.append(root.val)
            inorder(root.right)
        inorder(root)
        self.index = 0


    def next(self):
        """
        :rtype: int
        """
        self.index += 1
        return self.res[self.index-1]

    def hasNext(self):
        """
        :rtype: bool
        """
        if self.index < len(self.res):
            return True
        else:
            return False
# 这样似乎空间复杂度大于题目要求的O(h)了吧
# 是的 不能用递归 应该用迭代

# 还是用栈空间吧

class BSTIterator:
    def __init__(self, root: TreeNode):
        self.data = []
        self.enqueue(root)
        
    def enqueue(self, root):
        while root:
            self.data.append(root)
            root = root.left

    def next(self) -> int:
        res = self.data.pop()
        self.enqueue(res.right)
        return res.val

    def hasNext(self) -> bool:
        return bool(self.data)

# 同样没有听题目要求，一开始就取巧，用InOrder，这样得到BSF有序排列，然后使用
class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.root = root
        self.lst = []
        self.inOrder(root)
        self.lst.reverse()

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.lst != []

    def next(self):
        """
        :rtype: int
        """
        return self.lst.pop()
    
    def inOrder(self, root):
        if root == None:
            return
        self.inOrder(root.left)
        self.lst.append(root.val)
        self.inOrder(root.right)

# 谷歌了一下，得到如何满足题目要求的hint，从root开始，
# 往左走，把左孩子压入stack，直到左边为空。

# 然后开始取node，如果node有右孩子，
# 则同样要把node的右孩子的所有左孩子全部append入stack，画了一个图，可行。
class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.root = root
        self.stack = []
        self.pushAllLeft(root)
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.stack != []
        

    def next(self):
        """
        :rtype: int
        """
        if self.hasNext():
            cur = self.stack.pop()
            if cur.right:
                self.pushAllLeft(cur.right)
            return cur.val
            
    def pushAllLeft(self, node):
        """
        :type node: TreeNode
        """
        cur = node
        while cur:
            self.stack.append(cur)
            cur = cur.left
```

###  1.68. <a name='DungeonGame'></a>174 Dungeon Game

[小明](https://www.bilibili.com/video/BV1TK411W7T1?spm_id_from=333.999.0.0)

###  1.69. <a name='LargestNumber'></a>179 Largest Number

[小明](https://www.bilibili.com/video/BV1mV411m7aN?spm_id_from=333.999.0.0)

```py
from functools import cmp_to_key
class Solution(object):
    def largestNumber(self, nums):
        # 比较函数
        def compare(a, b):
            return int(b + a) - int(a + b)
        nums = sorted([str(x) for x in nums], key=cmp_to_key(compare))
        return str(int(''.join(nums)))
```

```py
class Solution:
    def largestNumber(self, nums):
        # 第一步：定义比较函数，把最大的放左边
        # 第二步：排序
        # 第三步：返回结果
        def compare(x, y): return int(y+x) - int(x+y)
        nums = sorted(map(str, nums), key=cmp_to_key(compare))
        return "0" if nums[0]=="0" else "".join(nums)
```

```py
# 大小的比较不是常规的字符串比较
# 正常来说'30' > '3' 但是'303' < '330'
# 需要自己定义排序规则
import functools
class Solution:
    def largestNumber(self, nums):

        res = []
        for i in nums:
            res.append(str(i))

        def cmp(a,b):
            return 1 if (a+b) < (b+a) else -1
        res.sort(key=functools.cmp_to_key(cmp))
        return str(int(''.join(res)))
```

```py
class Solution:
    def largestNumber(self, nums):
        nums = sorted([str(x) for x in nums],reverse=True)
        for i in range(len(nums)-1):
            for j in range(i,len(nums)):
                if str(nums[i]) + str(nums[j]) < str(nums[j]) + str(nums[i]):
                    nums[i],nums[j] = nums[j],nums[i]
        return str(int(''.join(nums)))
```

###  1.70. <a name='ReverseWordsinaStringII'></a>186. Reverse Words in a String II 

[哈哈哈](https://www.bilibili.com/video/BV1GV411Z7fo?spm_id_from=333.999.0.0)

###  1.71. <a name='RepeatedDNASequences'></a>187 Repeated DNA Sequences

[小明](https://www.bilibili.com/video/BV1mp4y1r7v5?spm_id_from=333.999.0.0)

###  1.72. <a name='BestTimetoBuyandSellStockIV'></a>188 Best Time to Buy and Sell Stock IV

[小明](https://www.bilibili.com/video/BV1f54y1k7cX?spm_id_from=333.999.0.0)

```py
Python： 版本一

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) == 0:
            return 0
        dp = [[0] * (2*k+1) for _ in range(len(prices))]
        for j in range(1, 2*k, 2):
            dp[0][j] = -prices[0]
        for i in range(1, len(prices)):
            for j in range(0, 2*k-1, 2):
                dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j] - prices[i])
                dp[i][j+2] = max(dp[i-1][j+2], dp[i-1][j+1] + prices[i])
        return dp[-1][2*k]
版本二

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if len(prices) == 0: return 0
        dp = [0] * (2*k + 1)
        for i in range(1,2*k,2):
            dp[i] = -prices[0]
        for i in range(1,len(prices)):
            for j in range(1,2*k + 1):
                if j % 2:
                    dp[j] = max(dp[j],dp[j-1]-prices[i])
                else:
                    dp[j] = max(dp[j],dp[j-1]+prices[i])
        return dp[2*k]

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0

        n = len(prices)
        k = min(k, n // 2)
        buy = [[0] * (k + 1) for _ in range(n)]
        sell = [[0] * (k + 1) for _ in range(n)]

        buy[0][0], sell[0][0] = -prices[0], 0
        for i in range(1, k + 1):
            buy[0][i] = sell[0][i] = float("-inf")

        for i in range(1, n):
            buy[i][0] = max(buy[i - 1][0], sell[i - 1][0] - prices[i])
            for j in range(1, k + 1):
                buy[i][j] = max(buy[i - 1][j], sell[i - 1][j] - prices[i])
                sell[i][j] = max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);  

        return max(sell[n - 1])

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0

        n = len(prices)
        k = min(k, n // 2)
        buy = [0] * (k + 1)
        sell = [0] * (k + 1)

        buy[0], sell[0] = -prices[0], 0
        for i in range(1, k + 1):
            buy[i] = sell[i] = float("-inf")

        for i in range(1, n):
            buy[0] = max(buy[0], sell[0] - prices[i])
            for j in range(1, k + 1):
                buy[j] = max(buy[j], sell[j] - prices[i])
                sell[j] = max(sell[j], buy[j - 1] + prices[i]); 

        return max(sell)


```

```py
## 未进行空间优化
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0


        n = len(prices)
        k = min(k, n // 2)  # k最大为总天数的一半
        have = [[0] * (k + 1) for _ in range(n)]
        no = [[0] * (k + 1) for _ in range(n)]


        have[0][0], no[0][0] = -prices[0], 0
        for i in range(1, k + 1): # 不合法状态
            have[0][i] = no[0][i] = float("-inf")


        for i in range(1, n): # j=0时, no[i][0]不合法
            have[i][0] = max(have[i - 1][0], no[i - 1][0] - prices[i])
            for j in range(1, k + 1):
                have[i][j] = max(have[i - 1][j], no[i - 1][j] - prices[i])
                no[i][j] = max(no[i - 1][j], have[i - 1][j - 1] + prices[i]);  


        return max(no[n - 1])

## 进行空间优化
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0


        n = len(prices)
        k = min(k, n // 2)  # k最大为总天数的一半
        have = [0] * (k + 1)
        no = [0] * (k + 1)


        have[0], no[0] = -prices[0], 0
        for i in range(1, k + 1): # 不合法状态
            have[i] = no[i] = float("-inf")


        for i in range(1, n): # j=0时, no[0]不合法
            have[0] = max(have[0], no[0] - prices[i])
            for j in range(k, 0, -1): # 优化空间, k倒序
                have[j] = max(have[j], no[j] - prices[i])
                no[j] = max(no[j], have[j - 1] + prices[i]); 


        return max(no)

```

```py

标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。

首先初始化三维数组，填充第1天操作j次的没买或买了的情况的初始值，没买就是0，第一天就买入即-prices[0]。这里定义卖出操作时交易次数加1

然后是状态转移方程，下面描述的i, j都大于0

「第i天交易次数0不持有股票」的情况只能来自「第i-1天交易次数0不持有股票」；

「第i天交易j次不持有股票」的状态可以来自「第i-1天交易j次不持有股票」或者「第i-1天交易j-1次持有股票」(即今天卖出股票，然后交易次数+1)；

「第i天交易j次持有股票」的状态可以来自「第i-1天交易j次持有股票」或者「第i-1天交易j次不持有股票」(即今天买入股票，因为是买入操作所以交易次数不变)

最后对于这题LeetCode的测试样例里有超大k值的情况，退化成122题不限次数的操作，可以用贪心解决或者直接替换k值为数组长度的一半

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices or not k:
            return 0
        n = len(prices)
        
        # 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数
        if k > n//2:
            return self.greedy(prices)
        
        dp, res = [[[0]*2 for _ in range(k+1)] for _ in range(n)], []
        # dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票
        # 设定在卖出时加1次交易次数
        for i in range(k+1):
            dp[0][i][0], dp[0][i][1] = 0, - prices[0]
        for i in range(1, n):
            for j in range(k+1):
                if not j:
                    dp[i][j][0] = dp[i-1][j][0]
                else:
                    dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j-1][1] + prices[i])
                dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0] - prices[i])
        # 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解
        for m in range(k+1):
            res.append(dp[n-1][m][0])
        return max(res)
    
    # 处理k过大导致超时的问题，用贪心解决
    def greedy(self, prices):
        res = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                res += prices[i] - prices[i-1]
        return res



```




```scala
/**
* chosen solution
* dynamic programming
* memo 
*    1: using an 3-dim array to record previous state
*     dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's restrictions
*  space complexity: O(K),  worst case: O(N)N
*/ 
object Solution0 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
/**
* my first commitment
* dynamic programming
* memo 
*    1: using an 3-dim array to record all previous state
*         dp[state index][k times transaction][buy or sell]
*     dp definition: dp[i][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's constraint
*/
object Solution1 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum
    val profits = Array.ofDim[Int](prices.length, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val ii = (i + prices.length - 1) % prices.length
      profits(i)(j)(1) = profits(ii)(j)(1)  max ( profits(ii)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(i)(j)(0) = profits(ii)(j)(0)  max ( profits(ii)(j - 1)(1) - prices(i)) // buy
      else
        profits(i)(j)(0) = profits(ii)(j)(0)  max  - prices(i) // buy
    }

    profits(prices.length - 1).map(_.max).max
  }
}

/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/

object Solution1-2 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum


    val profits = Array.ofDim[Int](2, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val currentI = (i + 1) % 2
      val preciousI = i % 2
      profits(currentI)(j)(1) = profits(preciousI)(j)(1)  max ( profits(preciousI)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max ( profits(preciousI)(j - 1)(1) - prices(i)) // buy
      else
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max  - prices(i) // buy
    }
    profits(prices.length % 2).map(_.max).max // prices.length % 2: decide the newest status index
  }

  private def debugProfits(profits: Array[Array[Array[Int]]]): Unit = {
        profits.zipWithIndex.foreach{
          case (p, i) =>
            println(s"status: $i")
            p.zipWithIndex.foreach{
            case (pp, j) =>
                println(s"transaction $j: hold: ${pp(0)}, sell: ${pp(1)}")
          }
            println(" ")
        }
  }
}
/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/
object Solution1-3 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
```

###  1.73. <a name='RotateArray'></a>189. Rotate Array 

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Yy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N541177Bk?spm_id_from=333.999.0.0)

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        r = k % len(nums)
        if r:
            nums[:] = nums[::-1]
            nums[:r] = nums[:r][::-1]
            nums[r:] = nums[r:][::-1]

class Solution:
    def rotate( nums, k):
        n = len(nums)
        k = k % n
        for _ in range(k):
            nums.insert(0,nums.pop())

class Solution:
    def rotate(self, A: List[int], k: int) -> None:
        def reverse(i, j):
            while i < j:
                A[i], A[j] = A[j], A[i]
                i += 1
                j -= 1
        n = len(A)
        k %= n
        reverse(0, n - 1)
        reverse(0, k - 1)
        reverse(k, n - 1)
```


```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        nums[: ] = nums[-k % len(nums): ] + nums[: -k % len(nums)]

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        nums[: ] = (nums[i] for i in range(-(k % len(nums)), len(nums) - k % len(nums)))
```

###  1.74. <a name='ReverseBits'></a>190. Reverse Bits

[花花酱](https://www.bilibili.com/video/BV1NJ411k7VP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qv411i7Wg?spm_id_from=333.999.0.0)

```py
# 从n的右侧开始，逐个检查是否是1（利用一个s）

# ans逐渐<<1，如果当前n&s==s，则说明此位为1，ans+=1

# 最后ans就是n的二进制位的颠倒了


class Solution:
    def reverseBits(self, n: int) -> int:
        ans = 0
        s = 1
        for _ in range(31):
            if n&s == s:   #说明此位为1，那么ans中也+1
                ans += 1
            ans = ans<<1  #最先加入的，到最后就是最前面的数字
            s = s<<1  #1,10,100,1000...
        if n & s == s:   #最后处理一次
            ans += 1
        return ans

# 每次只对最低位进行操作，理论上效率高于对 31 的循环

class Solution:
    def reverseBits(self, n: int) -> int:
        b = n & ((1 << 32) - 1)
        base = 1 << 31
        ans = 0
        while b:
            ans |=  base // (b & (-b))
            b &= b-1
        return ans    
```

```py
class Solution:
    def reverseBits(self, n):
        return int(bin(n)[2:].zfill(32)[::-1],2)
```

```scala
object Solution {
    // you need treat n as an unsigned value
    def reverseBits(x: Int): Int = {
        var binaryString = x.toBinaryString.toList
        
        var additional = (1 to (32 - binaryString.length)).map(_ => '0').toList
        
        binaryString = additional ++ binaryString
        
        val reversed = reverseBinary(binaryString, "")
        
        Integer.parseUnsignedInt(reversed.mkString, 2)
    }
    
    def reverseBinary(x: List[Char], str: String): String = x match{
        case Nil => str
        case x::xs => reverseBinary(xs, x + str)
    }
}

```

###  1.75. <a name='Numberof1Bits'></a>191 Number of 1 Bits

[小明](https://www.bilibili.com/video/BV1i5411J7SA?spm_id_from=333.999.0.0)

```py
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = sum(1 for i in range(32) if n & (1 << i)) 
        return ret

class Solution:
    def hammingWeight(self, n: int) -> int:
        return ('{:0b}'.format(n).count('1'))

class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')
#  python 输入的是10进制的 直接转str不行 可以试试 bin(n) 将10进制 转成 二进制然后 count
```

```py
# 从1开始，每次<<一位，与n做与运算，如果不为0，则该位为1
class Solution:
    def hammingWeight(self, n: int) -> int:

        res = 0
        while n:
            n &= n - 1
            res += 1
        return res

class Solution:
    def hammingWeight(self, n: int) -> int:
        a, res = 0, 0
        while a <= 32:
            if (1<<a)&n != 0:
                res += 1
            a += 1
        return res
```

```scala

// 使用位操作:x = x & (x -1)将最后一个非零pos设置为零  

//Alternate(需要理解这里发生了什么)和num, num-1  
// num & num-1返回最后一个SET位  
//交替位移位和计数1  

object Solution{
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        _hammingWeight(n, 0)
    }
    
    @annotation.tailrec
    def _hammingWeight(n: Int, counter: Int): Int = {
        if(n  == 0) counter
        else _hammingWeight(n & (n - 1), counter + 1 )
    }
}


object Solution0 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {

        var mask = 1
        var counter = 0
        for (_ <- 0 to 32) {

            if ((n & mask) != 0) {
                counter += 1
            }
            mask  = mask << 1
        }
        counter
    }
}


def hammingWeight(n: Int): Int = {
        var count = 0
        var num   = n

        while (num != 0) {
            if ((num & 1) > 0) { count = count + 1 }
            num = num >>> 1
        }
    count
}

def hammingWeight(n: Int): Int = {
        var counter = 0
        var num = n         
        while (num != 0) {
            counter += 1
            num &= (num-1)                
        }
        counter
    }

```

```scala
object Solution {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        n.toBinaryString.toCharArray.filter(_ == '1').length
    }
}
```

###  1.76. <a name='HouseRobber198-'></a>198. House Robber 198-打家劫舍

[12:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1tW411676f?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1u64y1M7PA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7hu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gZ4y1N75c?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV18g4y1i7f9?spm_id_from=333.999.0.0)

```py
动态规划，典型例题：

class Solution(object):
    def rob(self, nums):
        last = 0 
        now = 0
        for i in nums: 
            #这是一个动态规划问题
            #其实就是一个奇数和偶数位元素求和，哪个更大么？
            last, now = now, max(last + i, now)
        return now

class Solution:
    def rob(self, nums: List[int]) -> int:
        y = yesterday = 0
        t = today = 0
        for j in nums:
            y, t = t, max(y + j, t)
        return t
```

```py
状态转移方程，dp[i]=max(dp[i-1],dp[i-2]+nums[i]

而后发现dp[i] ,只与dp[i-2],dp[i-1]有关了

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0

        size = len(nums)
        if size == 1:
            return nums[0]
        
        dp = [0] * size
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, size):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        
        return dp[size - 1]



class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0

        size = len(nums)
        if size == 1:
            return nums[0]
        
        first, second = nums[0], max(nums[0], nums[1])
        for i in range(2, size):
            first, second = second, max(first + nums[i], second)
        
        return second


class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], (dp[i-2]+nums[i]))
        return dp[len(nums)-1]


class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        return dp[-1]
```

```py
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        sums = [0, 0]
        ret = 0
        for i in range(n):
            t = i % 2;
            sums[t] += nums[i]
            if sums[t] <= sums[1 - t]:
                ret += sums[1 - t]
                sums[0] = sums[1] = 0
        ret += max(sums[0], sums[1])
        return ret
```


```scala
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else if(nums.length == 1){
            nums(0)
        }else if(nums.length == 2){
            Math.max(nums(0), nums(1))
        }else{
            Math.max(
                nums(0) + rob(nums.drop(2)),
                nums(1) + rob(nums.drop(3))
            )
        }
    }
}

//The above solution worked for small input arrays
//but had MEMORY LIMIT EXCEEDED for large input

//While using DP: we try to store values of repetitive calculations
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var dp = Array.fill(nums.length+1)(0)
            
            dp(0) = 0
            dp(1) = nums(0)
            (1 to nums.length-1).map(i => {
                dp(i+1) = Math.max(dp(i), dp(i-1) + nums(i))
            })
            
            dp(nums.length)
        }
    }
}

//Another way to do the same
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.isEmpty){
            0
        }else{
            var rob = nums(0)
            var no_rob = 0
            var prev = rob
            for(i <- 1 until nums.length){
                prev = rob
                rob = no_rob + nums(i)
                no_rob = Math.max(prev, no_rob)
                
            }
            Math.max(no_rob, rob)
        }
    }
}

```

###  1.77. <a name='BinaryTreeRightSideView'></a>199 Binary Tree Right Side View

[小明](https://www.bilibili.com/video/BV1854y1W7CB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xK4y1b7Wh?spm_id_from=333.999.0.0)

```py

class Solution:
    def rightSideView(self, root: TreeNode):
        dic, dfs = {}, lambda node, startI: node and (dic.__setitem__(startI, node.val) or dfs(node.left, startI + 1) or dfs(node.right, startI + 1))
        return dfs(root, 0) or [*dic.values()]
# __setitem__:每当属性被赋值的时候都会调用该方法，因此不能再该方法内赋值 self.name = value 会死循环
#  bfs 层序遍历，每次保留最后一个值stack

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root: return []
        ans = []
        stack = deque([root])
        while stack:
            for _ in range(len(stack)):
                node = stack.popleft()
                if node.left: stack.append(node.left)
                if node.right: stack.append(node.right)
            ans.append(node.val)
        return ans

# 基础方法，层次遍历：

class Solution:
    def rightSideView(self, root: TreeNode):
        res, level = [], root and [root]
        while level:
            res.append(level[-1].val)
            level = [right for tree in level for right in (tree.left, tree.right) if right]
        return res

# 老层序遍历了

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root:
            return []
        res = []
        node = [root]
        while node:
            tmpNode = []
            for n in node:
                if n.left:
                    tmpNode.append(n.left)
                if n.right:
                    tmpNode.append(n.right)
            res.append(node[-1].val)
            node = tmpNode
        return res

# 递归

class Solution:
    def rightSideView(self, root: TreeNode):
        res = []
        def dfs(node, startIndex):
            if node:
                startIndex == len(res) and res.append(node.val)
                dfs(node.right, startIndex + 1)
                dfs(node.left, startIndex + 1)
        dfs(root, 0)
        return res
```

###  1.78. <a name='-1'></a>200-岛屿数量

[哈哈哈](https://www.bilibili.com/video/BV15K411p72j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Cg4y1i7dZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1KK4y1U7Ds?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1E64y1T7Nk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Np4y1977S?spm_id_from=333.999.0.0)


<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3v3ayrrcjf60.png" width="50%">

```py
# dfs
from pprint import pprint
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # 行列
        ans = 0
        # 就像是把岛屿一个个蚕食
        def dfs(i, j): 
            if 0 <= i < m and 0 <= j < n and grid[i][j] == '1':   # 补充边界条件，防止溢出
                grid[i][j] = '0' # dfs置为0
                dfs(i + 1, j)  # 遍历4个领域
                dfs(i - 1, j)  # 遍历4个领域
                dfs(i, j - 1)  # 遍历4个领域
                dfs(i, j + 1)  # 遍历4个领域

        for i in range(m): # 行列
            for j in range(n): # 行列
                if grid[i][j] == '1': # 如果grid[i][j]为1，则dfs
                    pprint(grid)
                    ans += 1
                    dfs(i, j)
        return ans

# 看了别人的代码，写的真美 ╮(╯_╰)╭ 啊

class Solution(object):
    def numIslands(self, grid):
        def dfs(gird, used, row, col, x, y):
            if gird[x][y] == '0' or used[x][y]:
                return 
            used[x][y] = True

            if x!= 0:
                dfs(grid, used, row,col, x-1,y)
            if x!= row -1 :
                dfs(grid, used, row,col, x+1, y)
            if y!= 0:
                dfs(grid, used, row,col, x, y-1)
            if y!= col - 1:
                dfs(grid, used, row,col, x, y+1)


        row = len(grid) # 行列
        col = len(grid[0]) if row else 0 # 行列

        used = [[0 for i in range(col)] for i in range(row)]

        count = 0
        for i in range(row): # 行列
            for j in range(col): # 行列
                if grid[i][j] == '1' and not used[i][j]: # 如果grid[i][j]为1，则dfs
                    dfs(grid,used,row,col,i,j)
                    count += 1
        return count

class Solution:
    def dfs(self, grid, r, c):
        grid[r][c] = 0
        nr, nc = len(grid), len(grid[0]) # 行列
        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                self.dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid) # 行列
        if nr == 0:
            return 0
        nc = len(grid[0]) # 行列

        num_islands = 0
        for r in range(nr): # 行列
            for c in range(nc): # 行列
                if grid[r][c] == "1": # 如果grid[i][j]为1，则dfs
                    num_islands += 1
                    self.dfs(grid, r, c)
        
        return num_islands
```

```py
# 厉害的解法：Sink and count the islands.
class Solution(object):
    def numIslands(self, grid):
        def sink(i, j):
            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1':
                grid[i][j] = '0'
                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))
                return 1
            return 0
        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[0])))

```

```scala
/**
* chosen solution
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/

object Solution0 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}


/**
* my first commit
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/
object Solution1 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}

/**
* Union & Find 
* memo
*    1. without modify original grid's elements
* time complexity: O(N * M) both N M is the dimension of grid 
*     both union and find operation's amortized time complexity in UnionFind class are very very close to 1 but not 1
*/


object Solution {
  private val endLabel = '0'
  def numIslands(grid: Array[Array[Char]]): Int = {
    val unionFind = new UnionFind(grid)
    for(i <- grid.indices; j <- grid(0).indices)
      union((i, j), unionFind, grid)
    unionFind.counter

  }

  def union(coord: (Int, Int), unionFind: UnionFind, grid: Array[Array[Char]]): Unit = {
    val (row, col) = coord
    if(grid(row)(col) == endLabel) return

    neighbors(coord, (grid.length, grid(0).length)).foreach {
      case (nr, nc) if grid(nr)(nc) != endLabel  =>
        unionFind.union(coord, (nr, nc))
      case _ =>
    }
  }

  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{ case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

###  1.79. <a name='BitwiseANDofNumbersRange'></a>201 Bitwise AND of Numbers Range

[小明](https://www.bilibili.com/video/BV1dT4y1g75m?spm_id_from=333.999.0.0)


```py
//我们知道，数组的数字是连续的，
// 那么m,n范围内的二进制表示的末尾相同位置一定会出现不同的0,1.我们只要找出m,n的做左边起的最长相同的二进制头部即可呀。
//
//如[5, 7]里共有三个数字，分别写出它们的二进制为：
//
//101　　110　　111
//
//相与后的结果为100，仔细观察我们可以得出，最后的数是该数字范围内所有的数的左边共同的部分（即m,n左边的共同部分），
// 如果上面那个例子不太明显，我们再来看一个范围[26, 30]，它们的二进制如下：
//
//11010　　11011　　11100　　11101　　11110
//
//也是前两位是11，后面3位在不同数字中一定会出现0和1、相与即为0了。

因为 只要有一个0，那么无论有多少个 1都是 0

比如：从 5到 7

5:0 1 0 1
6:0 1 1 0
7:0 1 1 1
-----------
  0 1 0 0
所以，代码如下：
```

```py
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        shift = 0   
        # 找到公共前缀
        while m < n:
            m = m >> 1
            n = n >> 1
            shift += 1
        return m << shift

？？？
当两个数位数不同时，中间一定会有一个1000...0 这样的进位数，这个数与比他小的数&操作都是0       
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while m < n:
            # 抹去最右边的 1
            n = n & (n - 1)
        return n


只要找到规律，那么暴力法依然给力，核心思想是：
如果m与n在二进制下的位数不一样，那么必须得0，
然后只算m,n在二进制位数一样的情况下，来个暴力解法，就可以通过，而且速度不慢额，代码如下：

class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        if len(bin(m))<len(bin(n)):
            return 0
        else:
            temp=m
            for each in range(m+1,n+1,1):
                temp&=each
            return temp
```


```scala

  object Solution {
    def rangeBitwiseAnd(m: Int, n: Int): Int = {
      var count = 0
      var m1 = m
      var n1 = n
      while (m1!=n1) {
        m1 >>= 1
        n1 >>=1
        count+=1
      }
      m1<<count
    }
  }

```

###  1.80. <a name='HappyNumber'></a>202. 快乐数 Happy Number

[官方](https://www.bilibili.com/video/BV1Ca4y1v7Qr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CA41187LQ?spm_id_from=333.999.0.0)

判断是否成环，和之前的链表的题目类似

```py
如果他不是快乐数，
那么他肯定在某些数存在不停循环的过程，

class Solution:
    def isHappy(self, n: int) -> bool:
        res = []
        while 1:
            n = sum([ int(i)**2 for i in str(n)])
            if n == 1:
                return True
            else:
                if n not in res:
                    res.append(n)
                else:
                    return False

class Solution:
    def isHappy(self, n: int) -> bool:  
        def getNext(number):
            sqSum = 0
            while number > 0:
                number, digit = divmod(number, 10)
                sqSum += digit ** 2
            return sqSum

        slow = n
        fast = getNext(n)
        while fast != 1 and slow != fast:
            slow = getNext(slow)
            fast = getNext(getNext(fast))
        return fast == 1
```

```py
class Solution:
    def isHappy(self, n: int) -> bool:
        def getNext(n):
            sqSum = 0
            while n > 0:
                n, digit = divmod(n, 10)
                sqSum += digit ** 2
            return sqSum

        visited = set()
        while n != 1 and n not in visited:
            visited.add(n)
            n = getNext(n)

        return n == 1

class Solution:
    def isHappy(self, n: int) -> bool:
        def getNext(number):
            sqSum = 0
            
            # 从个位开始依次取，平方求和
            while number:
                sqSum += (number % 10) ** 2
                number = number // 10
            return sqSum
        # 记录中间结果
        visited = set()

        while True:
            n = getNext(n)
            if n == 1:
                return True
            # 如果中间结果重复出现，说明陷入死循环了，该数不是快乐数
            if n in visited:
                return False
            else:
                visited.add(n)


```

```scala
object Solution {
    
    def getDigitSquaresSum(num: Int) = {
        num.toString.map(_.asDigit).map(x => x*x).foldLeft(0)(_ + _)
    }
    
    def isHappy(n: Int): Boolean = {
        var num = n
        var set = scala.collection.mutable.HashSet.empty[Int]
        var flag = true
        while(flag){
            if(num == 1){
                flag = false
            }else if(set.contains(num)){
                flag = false
            }else{
                set.add(num)
                num = getDigitSquaresSum(num)
            }
        }
        
        num == 1
    }
}

```

```scala

  object Solution {
    def isHappy(n: Int): Boolean = {
      def next(x:Int): Int ={
        x.toString().map(e=> (e-'0')*(e-'0')).sum
      }

      def solve(x:Int, m:Set[Int]): Boolean = x match {
        case 1 => return true
        case x if m.contains(x) =>return false
        case x =>solve(next(x), m+x)
      }
      solve(n, Set[Int]())
    }
  }

```

###  1.81. <a name='RemoveLinkedListElements'></a>203. Remove Linked List Elements

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7bf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Yi4y137WA?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Sz411b7zw?spm_id_from=333.999.0.0)

```py
首先处理特殊情况

然后开始双指针，一前一后，一起走

当后面的节点值等于val时，前面指针不动，后面指针继续走，直到节点的值!=val

此时把前面指针的next指向后面节点，即把中间这些值为val的节点删除了

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        if head == None:  #处理[]
            return head
        while head != None and head.val == val:  #处理[7,7,7,7,1]
            head = head.next
        if head == None:  #处理[7,7,7,7]
            return head

        slow, fast = head, head.next
        while fast != None:
            if fast.val == val:
                while fast != None and fast.val == val:
                    fast = fast.next
                slow.next = fast
            else:
                slow = slow.next
                fast = fast.next
        return head
```

```py
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        cur = head #操作对象是同一块内存 id(temp)=id(head)
        while cur:
            if cur.next and cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        if head and head.val == val: #头节点等于val的情况单独拿出来
            return head.next
        else:
            return head

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy = ListNode(next=head) #添加一个虚拟节点
        cur = dummy
        while(cur.next!=None):
            if(cur.next.val == val):
                cur.next = cur.next.next #删除cur.next节点
            else:
                cur = cur.next
        return dummy.next


class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy = ListNode(1)
        dummy.next = head
        cur = dummy
        while head:
            if head.val == val:
                cur.next = head.next
            else:
                cur = head
            head = head.next   
        return dummy.next
```

```scala
  object Solution {
    def removeElements(head: ListNode, `val`: Int): ListNode = {
      val dummy = ListNode(0)
      dummy.next = head
      var prev = dummy
      var cur = head
      while (cur!=null) {
        if (cur.x != `val`) {
          prev.next = cur
          prev = cur
        } else {
          prev.next = null
        }
        cur = cur.next
      }
      dummy.next
    }
  }
}

```

###  1.82. <a name='CountPrimes'></a>204-Count Primes

[哈哈哈](https://www.bilibili.com/video/BV167411w7Sf?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7cV?spm_id_from=333.999.0.0)

```py
# 埃氏筛代码重点理解一下j从i*i开始吧，

# 因为计算i*i之前就计算了i*2，i*3...,i*(i-1)。 

# 这题搜到一个非常牛逼的算法,叫做厄拉多塞筛法. 

# 比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,

# 然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,

# 然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,

# 再把5所有的倍数划去.以此类推.

# 代码的实现上用了非常好的技巧:

# 即i是从(2,int(n**0.5)+1)而非(2,n).这个技巧是可以验证的,

# 比如说求9以内的质数个数,那么只要划掉sqrt(9)以内的质数倍数,

# 剩下的即全为质数. 所以在划去倍数的时候也是从i*i开始划掉,而不是i+i.

class Solution:
    def countPrimes(self, n) -> int:
        if n < 3:
            return 0     
        else:
            # 首先生成了一个全部为1的列表
            isPrime = [1] * n
            # 因为0和1不是质数,所以列表的前两个位置赋值为0
            isPrime[0],isPrime[1] = 0,0
             # 此时从index = 2开始遍历,output[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引
             # 全部赋值为0. 此时output[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推.
            for i in range(2,int(n**0.5)+1): 
                if isPrime[i] == 1:
                    isPrime[i*i:n:i] = [0] * len(isPrime[i*i:n:i])
         # 最后output中的数字1表明该位置上的索引数为质数,然后求和即可.
        return sum(isPrime)

import math
from math import sqrt
class Solution(object):
    def countPrimes(self, n):
        isprime = [1]*n
        for i in range(2,int(sqrt(n))+1):
            if isprime[i]:
                for j in range(i*i,n,i):
                    isprime[j] = 0
        count = 0
        for i in range(2,n):
            if isprime[i]:count += 1
        return count

# 这个解法真是太赞了!又学到了很多~~~ 和大家分享一下
class Solution(object):
    def countPrimes(self, n):

        isPrime = [1 for i in range(n)]

        i = 2
        while i * i < n:
        	if isPrime[i]:
        		j = i * i 
        		while j < n :
        			isPrime[j] = 0
        			j += i
        	i += 1

        return sum(isPrime[2:])
```

```scala
object Solution {
    def countPrimes(n: Int): Int = {
        
        //Sieve of Eratosthenes
        
        var primeArray = Array.fill(n)(false)
        (2 until n).map(i => primeArray(i) = true)
        
        //We need to check for all numbers i, where i < sqrt(n)
        //To avoid doing sqrt operation again & again (since its expensive)
        //We can do i*i < n
        
        var i =2
        while(i*i < n){
            if(primeArray(i)){
                var j = i*i
                while(j < n){
                    primeArray(j) = false
                    j += i //because we are only checking multiple of i for each i in iteration
                }
            }
            i+=1
        }
        
        primeArray.filter(x => x).length
    }
}

```


###  1.83. <a name='isomorphicstrings'></a>205. isomorphic strings

[小梦想家](https://www.bilibili.com/video/BV1ab411H7ZS?spm_id_from=333.999.0.0)

```py
满足题目要求的同构字符串即两个字符串的字符之间是双射或者说一一对应的关系，假设s字符串对应的集合是S，t字符串对应的集合是T，则双射关系要求：

S的元素个数、T的元素个数、S与T之间的映射个数三者都相等，则只需要一行代码即可：

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) == len(set(zip(s,t)))

从评论区@StrayCamel 搬运更 Pythonic 的写法：

原回答：

补充一个python3

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) and len(set(s)) == len(set(zip(s, t)))
```

```py
例如字符串 adsds 和 opfpf

a 和 o 是映射关系 d 和 p 是映射关系 s 和 f 是映射关系 那么

adsds.index('a') ==  opfpf.index('o')
 adsds.index('d') ==  opfpf.index('p')
 adsds.index('s') ==  opfpf.index('f')

这三个是不是恒成立

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        n = len(s)
        for i in range(n):
            if s.index(s[i]) != t.index(t[i]):  # 两个字符在各自字符串中第一次出现的位置相同，表示可以重构
                return False
        else:
            return True
```

```py          
采用两个dict，互相指向，构成双射。发现了冲突，也就是一个字母可能对应了两个不同的字母，就说明两个字符串不是同构了。

class Solution(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False
        
        lookup1 = dict()
        lookup2 = dict()
        for c1,c2 in zip(s,t):
            if (c1 in lookup1 and lookup1[c1] != c2) or (c2 in lookup2 and lookup2[c2] != c1) :
                return False
            lookup1[c1] = c2
            lookup2[c2] = c1        
        return True


class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(t) != len(s):
            return False
        lookup1 = {}
        lookup2 = {}
        for i in range(len(s)):
            c1, c2 = s[i], t[i]
            if c1 not in lookup1:
                lookup1[c1] = c2
            if c2 not in lookup2:
                lookup2[c2] = c1
            if lookup1[c1] != c2 or lookup2[c2] != c1:
                return False
        return True 

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        lookup1 = {}
        lookup2 = {}
        for c1, c2 in zip(s, t):
            # 这个get默认值用的好，满足了还没有完成配对字符出现的None值的情况
            if lookup1.get(c1, c2) != c2 or lookup2.get(c2, c1) != c1:
                return False
            lookup1[c1] = c2
            lookup2[c2] = c1
        return True


class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t): return False

        dic = dict()
        for i in range(len(s)):
            if s[i] not in dic and t[i] not in dic.values():
                dic[s[i]]=t[i]
            elif s[i] in dic and dic[s[i]] == t[i]:
                pass
            else:return False
        return True
```

```scala
  object Solution {
    def isIsomorphic(s: String, t: String): Boolean = {
      val m:HashMap[Char,Char] = HashMap[Char,Char]()
      val n:HashMap[Char,Char] = HashMap[Char,Char]()

      s.indices.foreach(
        idx=>idx match {
          case idx if m.contains(s(idx)) && m(s(idx))!=t(idx) => return false
          case idx if n.contains(t(idx)) && n(t(idx))!=s(idx) => return false
          case idx =>{
            m(s(idx))=t(idx)
            n(t(idx))=s(idx)
          }
        }
      )
      true
    }
  }
```

###  1.84. <a name='ReverseLinkedList'></a>206-Reverse Linked List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7zr?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV16Q4y1M767?spm_id_from=333.999.0.0)

```py
前置条件：迭代指针：p = head、结果指针：res = none

以1->2->3->4->5为例：

过程：

res:None

第一层循环

res:1->2->3->4->5 res = p

res:1->None res.next = res

p:2->3->4->5 p = p.next

第二层循环

res:2->3->4->5 res = p

res:2->1->None res.next = res

p:3->4->5 p = p.next

第三层循环

res:3->4->5 res = p

res:3->2->1->None res.next = res

p:4->5 p = p.next

第四层循环

res:4->5 res = p

res:4->3->2->1->None res.next = res

p:5 p = p.next

第五层循环

res:5 res = p

res:5->4->3->2->1->None res.next = res

p:None p = p.next

end...

class Solution:
    def reverseList(self, head):
        pre, res = head, None
        while pre:
            res = pre
            res.next = res
            pre = pre.next
        return res
```

```py
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        """ 还有一种方法，不需要使用首元结点 
            1 -> 2 -> 3 -> 4    可以依次逆序每个指针
            1 <- 2 <- 3 <- 4    4变为了新的表头
            和头插法一样， 需要注意改变节点指针的时候，不能影响到 遍历下一个元素
        """
        # 1. 首先需要一个指针p顺序遍历节点， 还需要pre 和 cur 指针用于反转
        pre = None
        tmp = cur = head
        while tmp:
            # 1. 更新cur为当前节点
            cur = tmp
            # 2. p指针后移
            tmp = tmp.next
            # 3. 做反转
            cur.next = pre
            # 4. 更新pre为当前节点
            pre = cur

        # 5. 重新定义 head指向链表末尾
        head = cur
        return head
```


```py

递归解法， 先写出 while循环的迭代解法，再推导到 迭代写法。好像容易理解一些
# 还可以 以递归的形式解决问题
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        """ 
            迭代解法中，每一步都是 重新指向next指针， 可以分治法，使用递归求解。找到最小子问题及终止条件
            需要调用递归栈， 空间效率要低很多。
        """
        # 1. 首先需要一个指针p顺序遍历节点， 还需要pre 和 cur 指针用于反转
        def reverse(pre, cur):
            # 当cur为None了， 说明pre指向最后的节点，返回作为新的头结点
            if not cur: 
                return pre
            next = cur.next
            cur.next = pre
            return reverse(cur, next)
        

        head = reverse(None, head)
        return head


class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        
        def reverse(pre,cur):
            if not cur:
                return pre
                
            tmp = cur.next
            cur.next = pre

            return reverse(cur,tmp)
        
        return reverse(None,head)
```




```scala
object Solution {
    def reverseList(head: ListNode): ListNode = {
        if(head == null || head.next == null){
            head
        } else{
            var p = reverseList(head.next)
            head.next.next = head
            head.next = null
            p
        }
    }
}

```
```scala
/**
* time complexity: O(n)
* space complexity: O(1) 
*/
object Solution0 {
    def reverseList(head: ListNode): ListNode = {        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        prev
    }
}

 /**
 * time complexity: O(n)
 * space complexity: O(1)
 */
object Solution1 {
    def reverseList(head: ListNode): ListNode = {
        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        prev
    }
    
    def printNode(node: ListNode) {
        var n = node
        while(n != null) {
            print(s"${n.x} ")
            n = n.next
        }
    }
}


/** recursive version */

object Solution2 {
    def reverseList(head: ListNode): ListNode = {
        
        val curr:ListNode = null
        
        _reverseList(curr, head)
        
    }
    
    @annotation.tailrec
    def _reverseList(curr: ListNode, next: ListNode): ListNode = {
        if(next == null) {
            curr
        }else{
            val tmpNode = next.next
            next.next = curr
            _reverseList(next, tmpNode)
        }
    }
}

object Solution2-1 {
    def reverseList(head: ListNode): ListNode = {
        if(head == null) head
        else _reverseList(head)
        
    }
    
    def _reverseList(node: ListNode): ListNode = {
        if (node == null || node.next == null) {
            node
        }else {
            val newHead = _reverseList(node.next)
              // reversedHead 是返回原本的尾巴，若一開始輸入是 1 -> 2 -> 3 -> 4 -> 5  -> null , 那 reversedHead 就是 5
            // 每次 iteration 返回都是同一個 reversedHead 也就是 5
            node.next.next = node
            node.next = null
             // 每次迭代 改變的就是送進每個 function 的 listnode 的 next 與 next.next 指向
            newHead
        }
        
        
    }
}

```

###  1.85. <a name='-1'></a>207-课程表

[花花酱](https://www.bilibili.com/video/BV1Ut411a74a?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV19k4y1r76s?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jz411B7UJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xp4y1Y7FJ?spm_id_from=333.999.0.0)

```py
class Solution(object):

    # 这里使用逆邻接表

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return True
        # 深度优先遍历，判断结点是否访问过
        # 这里要设置 3 个状态
        # 0 就对应 False ，表示结点没有访问过
        # 1 就对应 True ，表示结点已经访问过，在深度优先遍历结束以后才置为 1
        # 2 表示当前正在遍历的结点，如果在深度优先遍历的过程中，
        # 有遇到状态为 2 的结点，就表示这个图中存在环
        visited = [0 for _ in range(numCourses)]
        print("visited:", visited)

        # 逆邻接表，存的是每个结点的前驱结点的集合
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 在前，0 在后
        inverse_adj = [set() for _ in range(numCourses)]
        print("inverse_adj:",inverse_adj)
        for second, first in prerequisites:
            print("[first]:",first)
            print("[second]:",second)
            inverse_adj[second].add(first)
            print("inverse_adj表示在学习第[",second,"]节课前，要先学习:",inverse_adj[second])

        for i in range(numCourses):
            # 在遍历的过程中，如果发现有环，则dfs返回true，就退出
            if self.__dfs(i, inverse_adj, visited,1): # visited 初始化为 0
                return False
        return True

    def __dfs(self, vertex, inverse_adj, visited,depth):
        """
        注意：这个递归方法的返回值是返回是否有环
        :param vertex: 结点的索引
        :param inverse_adj: 逆邻接表，记录的是当前结点的前驱结点的集合
        :param visited: 记录了结点是否被访问过，2 表示当前正在 DFS 这个结点
        :return: 是否有环
        """
        # 结束条件：
        # 2 表示这个结点正在访问
        # 2 表示当前正在遍历的结点，如果在深度优先遍历的过程中，
            # -------------🎨很重要🎨-------------
        if visited[vertex] == 2:
            # 表示遇到环
            # 有遇到状态为 2 的结点，就表示这个图中存在环
            return True
            # -------------🎨很重要🎨-------------
        if visited[vertex] == 1: # 1 表示结点已经访问过，在深度优先遍历结束以后才置为 1
            return False

        print("第1步vertex:",vertex,"visited:", visited," depth:",depth)
        visited[vertex] = 2
        print("第2步vertex:",vertex,"visited:", visited," depth:",depth)
        for precursor in inverse_adj[vertex]: # 是个set()
            # 如果有环，就返回 True 表示有环
            # -------------🎨很重要🎨-------------
            if self.__dfs(precursor, inverse_adj, visited,depth+1):
                return True 
            # -------------🎨很重要🎨-------------
        print("第3步vertex:",vertex,"visited:", visited," depth:",depth)

        # 1 表示访问结束
        visited[vertex] = 1
        print("第4步vertex:",vertex,"visited:", visited," depth:",depth)
        return False

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        visited = [0] * numCourses
        result = list()
        valid = True

        for info in prerequisites:
            edges[info[1]].append(info[0])
        
        def dfs(u: int):
            nonlocal valid
            visited[u] = 1
            for v in edges[u]:
                if visited[v] == 0:
                    dfs(v)
                    if not valid:
                        return
                elif visited[v] == 1:
                    valid = False
                    return
            visited[u] = 2
            result.append(u)
        
        for i in range(numCourses):
            if valid and not visited[i]:
                dfs(i)
        
        return valid

class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        def dfs(i, colors, prerequisites):
        	colors[i] = 'G'
        	#print i, colors
        	for front, tail in prerequisites:
        		if tail == i:
        			if colors[front] == 'G':
        				return False
        			elif colors[front] == 'B':
        				continue
        			elif dfs(front, colors, prerequisites) == False:
        				return False
        	colors[i] = 'B'
        	return True

        colors = ['W' for i in range(numCourses)]
        for i in range(numCourses):
        	if colors[i] == 'W':
        		if dfs(i, colors, prerequisites) == False:
        			return False
        return True
```

```py
# python
from collections import defaultdict 
class Solution:
    def canFinish(self, numCourses, prerequisites):
        inde = defaultdict(lambda:0)  # keep track of indegree of a course
        g = defaultdict(list)          # digraph of courses 
        for t,f in prerequisites:
            g[f].append(t)
            inde[t]+=1
        inde0 = []                   # inde0 holds courses whose indegree is 0
        for i in range(numCourses):
            if inde[i]==0:
                inde0.append(i)      # initialize inde0
        for i in inde0:
            for j in g[i]:
                inde[j]-=1
                if inde[j]==0:
                    inde0.append(j)
        return len(inde0)==numCourses

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        indeg = [0] * numCourses

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])
        visited = 0

        while q:
            visited += 1
            u = q.popleft()
            for v in edges[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)

        return visited == numCourses

class Solution(object):

    # 思想：该方法的每一步总是输出当前无前趋（即入度为零）的顶点

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return True
        # 入度数组，一开始全部为 0
        in_degrees = [0 for _ in range(numCourses)]
        # 邻接表
        adj = [set() for _ in range(numCourses)]

        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # [0,1] 表示 1 在先，0 在后
        # 注意：邻接表存放的是后继 successor 结点的集合
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)
        counter = 0
        while queue:
            top = queue.pop(0)
            counter += 1

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)

        return counter == numCourses
```

```scala

// new and apply
// Use the new keyword when you want to refer to a class's own constructor:
// 解法是 每个node(node)，1.它依赖的node个数(parent) 2.统计依赖它的node个数(son)，
// 一个node没有依赖其它节点，放入zeroInDegree
// 对zeroIndegree的node遍历，对每个依赖它的node都可以直接除去依赖


  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum == numCourses
    }
  }

  class Test extends BaseExtension {
    def init {
      val input = Array(Array(0,1),Array(1,2))
      println(Solution.canFinish(3,input) == true)
      //println(lru.get(1) == 1)
    }

    val name = "207 course schedule"
  }

```

###  1.86. <a name='ImplementTriePrefixTree'></a>208. Implement Trie (Prefix Tree)

[花花酱](https://www.bilibili.com/video/BV1Ut411a74P?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zz4y1R7j8?spm_id_from=333.999.0.0)

```py
from collections import  defaultdict
class TrieNode:
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.isWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.children[c]
        r.isWord = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r.children:
                return False
            r = r.children[c]
        return r.isWord

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r.children:
                return False
            r = r.children[c]
        return True
# 简单版：直接用字典

# char(key)->dict(value)

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.setdefault(c, {})
        r['#'] = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r: return False
            r = r[c]
        return r.get("#", False)

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r: return False
            r = r[c]
        return True
# 改成树了，不用类，哈希树实现 时间超过 98.94

class Trie:

    def __init__(self):
        self.root = {}


    def insert(self, word: str) -> None:
        cur_node = self.root
        for char in word:
            if not cur_node.get(char):
                cur_node[char] = {}
            cur_node = cur_node[char]
        cur_node['end'] = True


    def search(self, word: str) -> bool:
        cur_node = self.root
        for char in word:
            try:
                cur_node = cur_node[char]
            except:
                return False
        if cur_node.get('end'):
            return True
        else:
            return False


    def startsWith(self, prefix: str) -> bool:
        cur_node = self.root
        for char in prefix:
            try:
                cur_node = cur_node[char]
            except:
                return False
        return True
# Python, 写的时候忘了要写树
# 两个集合，一个存word，一个存前缀
# 插入word时倒序往prefixs集合中添加前缀，如果已经存在了，就说明后续都不用继续添加了
# 时间、空间 分别打败77%，91%
class Trie:

    def __init__(self):
        self.words = set()
        self.prefixs = set()

    def insert(self, word: str) -> None:
        try:
            self.words.add(word)
            for end_index in range(len(word)+1, 0, -1):
                prefix = word[:end_index]
                self.prefixs.add(prefix)
        except:
            return

    def search(self, word: str) -> bool:
        if word in self.words:
            return True
        else:
            return False


    def startsWith(self, prefix: str) -> bool:
        if prefix in self.prefixs:
            return True
        else:
            return False
```

```scala
/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

/**
* chosen solution
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie0() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}



/**
* my first commitment
*/
case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
}

class Trie1() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach { c =>

      val cIdx = c.asDigit - 'a'.asDigit
      if (node.childNode(cIdx) == null) {
        node.childNode(cIdx) = Node()
      }
      node = node(cIdx)
    }
    node.isWord = true

  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    val node = searchUtil(word)

    node != null && node.isWord

  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix) != null
  }


   private def searchUtil(s: String): Node = {
    var node = root
    var continue = true
    for {
      c <- s
      if continue
    } {
      val cIdx = c.asDigit - 'a'.asDigit
      if (node(cIdx) == null) {
        continue = false
      } 
      node = node(cIdx)
    }
    node
  }
}


/**
*  more elegant
*  Node with apply and update
*/

case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
  
  def update(idx: Int, node: Node): Unit = {
    childNode(idx) = node
  }

  def update(c: Char, node: Node): Unit = {
    this.update(c.asDigit - 'a'.asDigit, node)
  }
}
class Trie1-2() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach {
      case c if node(c) == null => 
        node(c) = Node()
        node = node(c)

      case c => node = node(c)
    }
    node.isWord = true
      
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }


  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach {
      case c if node(c) != null => node = node(c)
      case _ => return None
    }
    Some(node)
  }
  def traversal(): Unit = {
    val result = scala.collection.mutable.ListBuffer[String]()

    def _traversal(prefix: String, node: Node): Unit = {
      if (node.isWord) {
        result += prefix
      }
      node.childNode.zipWithIndex.foreach {
        case (n, idx) if n != null => _traversal(prefix + ('a' + idx).toChar, n)
        case _ =>
      }

    }

    _traversal("", root)
    result.foreach(s => println(s.mkString("")))

  }

}

/**
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie2() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}
```

###  1.87. <a name='-1'></a>209-长度最小的子数组

[哈哈哈](https://www.bilibili.com/video/BV1JZ4y1N7Rt?spm_id_from=333.999.0.0)

###  1.88. <a name='CourseScheduleII210-II'></a>210. Course Schedule II 210-课程表II

[花花酱](https://www.bilibili.com/video/BV1gW411y7Kb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ja4y147on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qt4y1X7oC?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kK411W7rL?spm_id_from=333.999.0.0)

```py
# 思路2：构建逆邻接表，实现深度优先遍历。思路其实也很简单，其实就是检测这个有向图中有没有环，只要存在环，课程就不能完成。

# 注意：这个深度优先遍历得通过逆邻接表实现，当访问一个结点的时候，应该递归访问它的前驱结点，直至前驱结点没有前驱结点为止。

# Python 代码：

class Solution(object):

    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return [i for i in range(numCourses)]

        # 逆邻接表
        inverse_adj = [set() for _ in range(numCourses)]
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 -> 0，这里要注意：不要弄反了
        for second, first in prerequisites:
            inverse_adj[second].add(first)

        visited = [0 for _ in range(numCourses)]
        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列

        res = []
        for i in range(numCourses):
            if self.__dfs(i,inverse_adj, visited, res,1):
                return []
        return res

    def __dfs(self, vertex, inverse_adj, visited, res,depth):
        """
        注意：这个递归方法的返回值是返回是否有环
        :param vertex: 结点的索引
        :param inverse_adj: 逆邻接表，记录的是当前结点的前驱结点的集合
        :param visited: 记录了结点是否被访问过，2 表示当前正在 DFS 这个结点
        :return: 是否有环
        """
        # 2 表示这个结点正在访问
        if visited[vertex] == 2:
            # DFS 的时候如果遇到一样的结点，就表示图中有环，课程任务便不能完成
            return True
        if visited[vertex] == 1:
            return False
        # 表示正在访问这个结点
        visited[vertex] = 2
        # 递归访问前驱结点
        for precursor in inverse_adj[vertex]:
            # 如果没有环，就返回 False，
            # 执行以后，逆拓扑序列就存在 res 中
            print(vertex,"的precursor:",precursor,"depth:",depth)
            if self.__dfs(precursor, inverse_adj, visited, res,depth+1):
                
                return True

        # 能走到这里，说明所有的前驱结点都访问完了，所以可以输出了
        # 并且将这个结点状态置为 1
        visited[vertex] = 1
        print("第4步vertex:",vertex,"visited:", visited," depth:",depth)
        # 先把 vertex 这个结点的所有前驱结点都输出之后，再输出自己
        res.append(vertex)
        print("visited置为1后,res才能append:",res,"depth:",depth)
        # 最后不要忘记返回 False 表示无环
        return False
```

```py
# 思路1：拓扑排序。构建的邻接表就是我们通常认识的邻接表，每一个结点存放的是后继结点的集合。

# 该方法的每一步总是输出当前无前趋（即入度为零）的顶点。

# 为避免每次选入度为 0 的顶点时扫描整个存储空间，可设置一个队列暂存所有入度为 0 的顶点。

# 具体做法如下：

# 1、在开始排序前，扫描对应的存储空间，将入度为 0 的顶点均入队列。

# 2、只要队列非空，就从队首取出入度为 0 的顶点，将这个顶点输出到结果集中，并且将这个顶点的所有邻接点的入度减 1，

# 在减 1 以后，发现这个邻接点的入度为 0 ，就继续入队。

# 最后检查结果集中的顶点个数是否和课程数相同即可。

# Python 代码：

class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return [i for i in range(numCourses)]
        # 入度数组，一开始全部为 0
        in_degrees = [0 for _ in range(numCourses)]
        # 邻接表
        adj = [set() for _ in range(numCourses)]
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 -> 0，这里要注意：不要弄反了
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)

        while queue:
            top = queue.pop(0)
            res.append(top)

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)
        if len(res) != numCourses:
            return []
        return res

# bfs 借助队列实现拓扑排序
from collections import deque
class Solution:
    def findOrder(self, numCourses, prerequisites):
        # 建图，以邻接表存储
        def buildGraph(numCourses, prerequisites):
            graph = []  # 邻接表
            indeg = [0] * numCourses  # 入度表

            for i in range(numCourses):  # 直接[[]]*numCourses建表有问题
                graph.append([])
            for side in prerequisites:
                a, b = side[1], side[0]  # 依赖关系b依赖a，就是a->b
                graph[a].append(b)
                indeg[b] += 1

            return graph, indeg

        graph, indeg = buildGraph(numCourses, prerequisites)
        res = []
        # print(graph)
        # print(indeg)
        
        # 将所有入度为 0 的节点放入队列中
        queue = deque()
        for i in range(numCourses):
            if indeg[i] == 0:
                queue.append(i)

        while queue:
            # 队首节点出队，放入答案中
            node = queue.popleft()
            res.append(node)
            # 将该节点相邻节点入度-1
            for neighbor in graph[node]:
                indeg[neighbor] -= 1
                # 相邻节点入度为 0 则入队
                if indeg[neighbor] == 0:
                    queue.append(neighbor)

        if len(res) != numCourses:  # 如果拓扑排序没排完，则说明有环，返回空
            return []
        return res

class Solution:
    def findOrder(self, numCourses, prerequisites):
        # 存储有向图
        edges = collections.defaultdict(list)
        # 存储每个节点的入度
        indeg = [0] * numCourses
        # 存储答案
        result = list()

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        # 将所有入度为 0 的节点放入队列中
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])

        while q:
            # 从队首取出一个节点
            u = q.popleft()
            # 放入答案中
            result.append(u)
            for v in edges[u]:
                indeg[v] -= 1
                # 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
                if indeg[v] == 0:
                    q.append(v)

        if len(result) != numCourses:
            result = list()
        return result

# 写了个python 3 ，广度优先的，加了每一句的注释，仅供参考

class Solution:
    def findOrder(self, numCourses, prerequisites):
        p = prerequisites
        # 所有课程没有先后顺序，这里我读题一开始没理解
        if p == []:
            return [i for i in range(numCourses)]

        from collections import defaultdict, deque
        go = defaultdict(list)
        # come=defaultdict(list) 逆向邻接表，本例不需要
        # 记录每个节点的入度
        rudu = defaultdict(int)
        # 记录所有prerequisites 出现的课程
        total = set()
        # 这个集合中存着所有需要前导课的课程号
        you = set()

        for i in p:

            a, base = i
            # 由基础课base 能够到达的a
            go[base].append(a)
            # come[a].append(base)  本例不需要
            # 进入并去重
            total.add(a)
            total.add(base)

            rudu[a] += 1
            # 只要有入度就是有前导课
            you.add(a)

        # 所有必须学习的课
        first = set([j for j in range(numCourses)])
        # 找到那些与其他课程无关的课，先学习了。ff 是集合
        ff = first - total
        ans = [g for g in ff]

        # 构建了邻接表，入度字典，下面开始拓扑排序
        #====================================
        # 找到入度为0 的课程，他们是其他课程的前导课，c 是一个集合
        c = total - you
        # 前导课加入deque
        q = deque(c)
        while q:

            # 入度为0，拿出来
            x = q.popleft()
            ans.append(x)
            # 遍历所有以x 为前导课的课
            xlist = go[x]
            for j in xlist:

                # 入度减去一
                rudu[j] -= 1
                # 发现入度==0 ，进入队列
                if rudu[j] == 0:
                    q.append(j)

        return ans if len(ans) == numCourses else []
       
class Solution:
    def findOrder(self, numCourses, prerequisites):
        ##创建入度的列表，索引对应节点编号，若索引不能对应节点编号，需要创建字典
        indegree = [0]*numCourses
        for i in range(len(prerequisites)):
            indegree[prerequisites[i][0]] += 1
        queue = [] ##存放入度为0的节点
        for i in range(numCourses):
            if indegree[i] == 0:
                queue.append(i)
        ret = [] ##按顺序存放节点
        while len(queue) != 0:
            cur = queue.pop(0) ##出队入度为0的节点
            ret.append(cur)
            for edge in prerequisites:
                if edge[1] == cur:
                    indegree[edge[0]] -= 1 ##更新节点的入度
                    if indegree[edge[0]] == 0:
                        queue.append(edge[0]) ##将入度为0的节点入队
        return ret if len(ret) == numCourses else [] #若结果列表个数不等于课程数，表示存在环
```

```py
# 拓扑排序khan算法的py/go/rs三语言实现

class Solution:
    def findOrder(self, numCourses, prerequisites):
        t = [0] * numCourses
        d = [[] for _ in range(numCourses)]
        for i, j in prerequisites:
            t[i] += 1
            d[j].append(i)
        ans = [i for i, j in enumerate(t) if not j]
        for i in ans:
            for j in d[i]:
                t[j] -= 1
                not t[j] and ans.append(j)
        return len(ans) == numCourses and ans or []
```

```scala

import scala.collection.mutable.ArrayBuffer
// 与lc207类似，不过要给出顺序

  object Solution {
    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      val ans = ArrayBuffer[Int]()
      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        ans += cur
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum match {
        case canFinshNum if canFinshNum == numCourses => ans.toArray
        case _ => Array()
      }
    }
  }

```

###  1.89. <a name='AddandSearchWord'></a>211 Add and Search Word

[小明](https://www.bilibili.com/video/BV1x5411a77S?spm_id_from=333.999.0.0)

###  1.90. <a name='WordSearchII'></a>212. Word Search II

[花花酱](https://www.bilibili.com/video/BV184411d7i9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1G7NQ?spm_id_from=333.999.0.0)

```py

如果把方向换成[[0,1], [1,0], [0,-1], [-1,0]]过不了：

[["a","b","e"],["b","c","d"]]
["abcdeb"]
先检索abc（b用[0,1]）会记录这个结果不符合，再检索abc（b用[1,0]）会直接判断不行, lru_cache没法处理visited的差异


class Solution:
    def findWords(self, board: [[str]], words: [str]) -> [str]:
        m, n = len(board), len(board[0])
        res = set()
        @lru_cache(None)
        def dfs(x, y, ans, mark=set()):
            mark.add((x, y))
          
            if ans in words:
                res.add(ans)
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                if 0 <= x + dx < m and 0 <= y + dy < n and (x + dx, y + dy) not in mark:
                    dfs(x + dx, y + dy, ans + board[x + dx][y + dy])
            mark.remove((x, y))
        for i in range(m):
            for j in range(n):
                dfs(i, j, board[i][j])
        return list(res)
```


```py
from collections import defaultdict


class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""

    def insert(self, word):
        cur = self
        for c in word:
            cur = cur.children[c]
        cur.is_word = True
        cur.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)

        def dfs(now, i1, j1):
            if board[i1][j1] not in now.children:
                return

            ch = board[i1][j1]

            now = now.children[ch]
            if now.word != "":
                ans.add(now.word)

            board[i1][j1] = "#"
            for i2, j2 in [(i1 + 1, j1), (i1 - 1, j1), (i1, j1 + 1), (i1, j1 - 1)]:
                if 0 <= i2 < m and 0 <= j2 < n:
                    dfs(now, i2, j2)
            board[i1][j1] = ch

        ans = set()
        m, n = len(board), len(board[0])

        for i in range(m):
            for j in range(n):
                dfs(trie, i, j)

        return list(ans)

from collections import defaultdict


class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""

    def insert(self, word):
        cur = self
        for c in word:
            cur = cur.children[c]
        cur.is_word = True
        cur.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)
		
        def dfs(now, i1, j1):
            if board[i1][j1] not in now.children:
                return

            ch = board[i1][j1]

            nxt = now.children[ch]
            if nxt.word != "":
                ans.append(nxt.word)
                nxt.word = ""

            if nxt.children:
                board[i1][j1] = "#"
                for i2, j2 in [(i1 + 1, j1), (i1 - 1, j1), (i1, j1 + 1), (i1, j1 - 1)]:
                    if 0 <= i2 < m and 0 <= j2 < n:
                        dfs(nxt, i2, j2)
                board[i1][j1] = ch

            if not nxt.children:
                now.children.pop(ch)

        ans = []
        m, n = len(board), len(board[0])

        for i in range(m):
            for j in range(n):
                dfs(trie, i, j)

        return ans
。
```



```scala

/**
* chosen solution
* tries + dfs + pruning
* memo
*   1. put all words into tries which is implemented by hashmap
*   2. DFS way searching all char in board composing a word and searching whether the word exists in tries
*   3. in dfs, we directly input the node from tries instead of tries itself 
*   4. pruning an edge after matching a word and its children couldn't represent a word
*/
import scala.collection.mutable
case class Node(next: mutable.Map[Char, Node] = mutable.Map.empty, var isWord: Boolean = false){
  def apply(char: Char): Option[Node] = next.get(char)
  def update(char: Char, node: Node): Unit = next(char) = node
}

class Tries(){
  val root = Node()
  def insert(word: String): Unit = {
    var node = root
    word.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined
  def search(word: String): Boolean =  searchUtil(word).exists(_.isWord)

  def searchUtil(s: String): Option[Node] = {
    var node = root
    s.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }
}


object Solution0 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
* tries + dfs + pruning
* memo
*   1. a seenBoard to record which position was visited 
* time complexity: 
* 
*/

object Solution1-1 {
  val result = scala.collection.mutable.Set[String]()

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for{
      row <- board.indices
      col <- board(0).indices
    }{
      _dfs(board, Array.ofDim[Boolean](board.length, board(0).length), tries, "", (row, col))
    }

    result.toList
  }

  private def _dfs(board: Array[Array[Char]], seenBoard:Array[Array[Boolean]], tries: Trie, currentPrefix: String, currentIdx: (Int, Int)) {
    val (row, col) = currentIdx
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    if(tries.startsWith(newPrefix)){
      seenBoard(row)(col) = true
      getNextPosition(currentIdx, seenBoard).foreach{idx =>
        _dfs(board, seenBoard.map(_.clone()), tries, newPrefix, idx)
      }
    }
  }

  private def getNextPosition(currentIdx: (Int, Int), seenBoard: Array[Array[Boolean]]): Array[(Int, Int)] = {

    def check(row: Int, col: Int): Boolean = {
      if(row >= seenBoard.length || row < 0 || col >= seenBoard(0).length || col < 0 || seenBoard(row)(col))  false
      else true
    }
    val (row, col) = currentIdx
    val result = scala.collection.mutable.ArrayBuffer[(Int, Int)]()

    for{
      i <- -1 to 1
      j <- -1 to 1
    }{
      if((math.abs(i) + math.abs(j) == 1) && check(row + i, col + j)) result.append((row + i, col + j))
    }
    result.toArray
  }
}

/**
* simplify : without seen matrix
*/

object Solution1-2 {

  val result = scala.collection.mutable.Set[String]()
  private val inBounds = (shape: (Int, Int)) => (coord: (Int, Int)) => coord._1 < shape._1 && coord._1 >= 0 && coord._2 < shape._2 && coord._2 >= 0
  private val getNeighbors = (coord: (Int, Int), filter: ((Int, Int)) => Boolean) => {
    List(
      (coord._1 + 1, coord._2),
      (coord._1, coord._2 + 1),
      (coord._1 - 1, coord._2),
      (coord._1, coord._2 - 1)
    ).filter(filter)
  }

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for {
      row <- board.indices
      col <- board(0).indices
    } {
      _dfs(board, tries, "", (row, col))
    }
    result.toList
  }

  private def _dfs(board: Array[Array[Char]], tries: Trie, currentPrefix: String, coord: (Int, Int)) {

    val (row, col) = coord
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    val c = board(row)(col)
    board(row)(col) = '#'
    if (tries.startsWith(newPrefix)) {

      getNeighbors(coord, inBounds((board.length, board.head.length))(_))
        .foreach {
          case (nr, nc) if board(nr)(nc) != '#' =>
            _dfs(board, tries, newPrefix, (nr, nc))
          case _ =>
        }
    }
    board(row)(col) = c
  }
}


object Solution1-3 {
  private val visitedLabel = '#'
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Trie()
    words.foreach(tries.insert)
    dfs(tries, board)
  }


  def dfs(tries: Trie, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int) ,prePrefix: String, board: Array[Array[Char]], ret: scala.collection.mutable.HashSet[String]): Unit = {
      val currentChar =  board(coord._1)(coord._2)
      val newPrefix = prePrefix + currentChar
      if(tries.search(newPrefix)) ret += newPrefix
      /* pruning */
      if(tries.startsWith(newPrefix)){
        board(coord._1)(coord._2) = visitedLabel
        getAvailableCoords(coord, (board.length, board(0).length)).foreach {
          case (r, c) if board(r)(c) != visitedLabel => _dfs((r, c), newPrefix, board, ret)
          case _ =>
        }
        board(coord._1)(coord._2) = currentChar
      }
    }

    val coords = for(i <- board.indices; j <- board(0).indices) yield (i, j)
    val ret = scala.collection.mutable.HashSet[String]()
    coords.foreach(coord => _dfs(coord, "", board, ret))
    ret.toList

  }

  private val getAvailableCoords = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row, col + 1),
      (row - 1, col),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 &&  0 <= c && c < shape._2}
  }
}




object Solution2 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


```

###  1.91. <a name='HouseRobberII213-II'></a>213. House Robber II 213-打家劫舍II

[18:13 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ea4y147oh?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1GD4y1d7DS?spm_id_from=333.999.0.0)

```py
# 核心原则就是：第一个和最后一个不能同时抢。 
# 所以：要么不抢第一个，要么不抢最后一个。 
# 注意，不抢第一个的时候，最后一个可抢可不抢；
# 另一种情况同理 取两种情况中的最大值

class Solution(object):
    def rob(self, nums):
        n = len(nums)
        if n == 0:
          return 0
        if n <= 2:
          return max(nums)
        # 不抢第一个
        dp1 = [0] * n
        dp1[0] = 0
        dp1[1] = nums[1]
        for i in range(2, n):
          dp1[i] = max(dp1[i-1],nums[i] + dp1[i-2])

        # 不抢最后一个
        dp2 = [0] * n
        dp2[0] = nums[0]
        dp2[1] = max(nums[0],nums[1])
        for i in range(2, n-1):
          dp2[i] = max(dp2[i-1],nums[i] + dp2[i-2])
        return max(dp1[n-1],dp2[n-2])



class Solution(object):
    def rob(self, nums):

        n = len(nums)
        if n == 0 : return 0
        if n == 1 : return nums[0]
        if n == 2 : return max(nums[0],nums[1])
        
        dp = [[0 for i in range(n)] for j in range(n)]

        for i in range(n):
            for j in range(i,n):
                if j == i:
                    dp[i][j] = nums[j]
                elif j == i + 1:
                    dp[i][j] = max(nums[i],nums[i+1])
                else:
                    dp[i][j] = max(dp[i][j-2] + nums[j], dp[i][j-1])

        # rob without n-1, or rob with  n-1
        val = max(dp[0][n-2], dp[1][n-3] + nums[n-1])

        return val
```

```py
class Solution(object):
    def rob(self, nums):

        def RobRange(start,end):
            #前1个，前2个
            dp1=0
            dp2=0
            for i in range(start, end + 1):
                maxdp = max(dp1, dp2 + nums[i])
                dp2 = dp1
                dp1 = maxdp
            return maxdp

        n = len(nums)
        if n == 1:
            return nums[0]
        return max(RobRange(0,n-2),RobRange(1,n-1))


class Solution:
    def rob(self, nums):
        def RobRange(start: int, end: int) -> int:
            dp1 = nums[start]
            dp2 = max(nums[start], nums[start + 1])
            for i in range(start + 2, end + 1):
                dp1, dp2 = dp2, max(dp1 + nums[i], dp2)
            return dp2
        
        n = len(nums)
        if n == 1:
            return nums[0]
        elif n == 2:
            return max(nums[0], nums[1])
        else:
            return max(RobRange(0, n - 2), RobRange(1, n - 1))
```

###  1.92. <a name='CombinationSumIII216-III'></a>216. Combination Sum III 216-组合总和 III

[花花酱](https://www.bilibili.com/video/BV14b411u7q8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1SC4y1a7Vy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gz4y1Z7CV?spm_id_from=333.999.0.0)

```py
# 枚举剪枝，dfs()!

class Solution(object):
    def combinationSum3(self, k, n):

        def dfs(startIndex, sum, path):
            if sum==0 and len(path)==k: res.append(path)
            if sum<=0: return
            
            for j in range(startIndex, 10):
                dfs(j, sum-j, path+[j])
        
        res = []
        dfs(1, n, [])
        return res

# 简单回溯

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []

        def dfs(startIndex, sum, path):
            if sum < 0:
                return

            if len(path) == k and sum == 0:
                res.append(path[:])
                return

            for i in range(startIndex, 10):
                path.append(i)
                dfs(i+1, sum - i, path)
                path.pop()
                    
        dfs(1, n, [])

        return res

class Solution(object):
    def combinationSum3(self, k, n):
        """
        :type k
        :type n
        :rtype: List[List[int]]
        """
        if not k or not n:
            return []
        
        res = []         
        def dfs(k, n, tmp, start):
            if n == 0 and k == 0:
                res.append(tmp[:])
                return
            if k <= 0 or n <= 0:
                return
            
            for i in range(start, 10):
                tmp.append(i)
                dfs(k - 1, n - i, tmp, i + 1)
                tmp.pop()
                    
        dfs(k, n, [], 1)       
        return res

from typing import List
class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        self.res = []
        cur = []
        def dfs(startI, k, n, path):
            if k == 0 and n == 0:
                self.res.append(path[:])
                return 
            elif n <= 0 or k == 0:
                return 
            for i in range(startI, 10):
                path.append(i)
                dfs(i+1, k-1, n-i, path)
                path.pop()
        dfs(1, k, n, cur)
        return self.res

# 闭包用的挺好，如果内层函数不止一处用到的话，不建议写成内层函数，我是这么认为的。
# 感觉大佬们写的代码都好长啊。

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        def dfs(startI:int,sums:int):
            nonlocal path
            if k == len(path):
                if sums == 0:
                    res.append(path[:])
                return
            
            if startI < 10 and sums > 0:
                #添加当前元素到组合序列
                path.append(startI)
                dfs(startI + 1,sums - startI)
                path.pop()
                dfs(startI + 1,sums)
        path, res = list(), list()
        dfs(1,n)
        return res
# 回溯的king

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []
        def dfs(path, startI):
            if len(path) == k and sum(path) == n:
                res.append(path)
                return
            for j in range(startI, 10):
                dfs(path+[j], j+1)
        dfs([], 1)
        return res

# 补一个python解法，击败98%，主要表现为剪枝

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        if n < 6: return []
        res = []
        def backtrack(num, path, k, n):
            if k == 0 and n == 0:
                res.append(path[:])
            if n < 0 or k < 0:
                return 
            for i in range(num, 10):
                if i > n:
                    break
                path.append(i)
                backtrack(i+1, path, k-1, n-i)
                path.pop()
            return 

        backtrack(1, [], k, n)
        return res

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []  #存放结果集
        path = []  #符合条件的结果
        def dfs(n,k,sums,startIndex):
            if sums > n: return  #剪枝操作
            if sums == n and len(path) == k:  #如果path.size() == k 但sum != n 直接返回
                return res.append(path[:])
            for i in range(startIndex,9-(k-len(path))+2):  #剪枝操作
                path.append(i)
                sums += i 
                dfs(n,k,sums,i+1)  #注意i+1调整startIndex
                sums -= i  #回溯
                path.pop()  #回溯
        
        dfs(n,k,0,1)
        return res

# 接近双百的逆向思维，先一次性总结512种所有的情况，之后筛选k和n符合的情况就行了，对于情况有限的直接枚举肯定最快

class Solution(object):
    def combinationSum3(self, k, n):
        def combine(n):
            if n==1:
                return [[1],[]]
            else:
                temp = combine(n-1)
                return [x+[n] for x in temp]+temp
        lookup = combine(9)
        res = combine(n)[]
        for path in lookup:
            if len(path)==k and sum(path)==n:
                res += [path]
        return res
```

###  1.93. <a name='ContainsDuplicate'></a>217. Contains Duplicate

[小梦想家](https://www.bilibili.com/video/BV1ab411H7Zw?spm_id_from=333.999.0.0)

```py
简单题。。。我觉得我又行了

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(nums) != len(set(nums))

人生苦短，我用Python

class Solution:
    def containsDuplicate(self, nums):
        return len(nums) - len(set(nums)) > 0

我竟然自己想出来了这种反人类的玩意儿 python：

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) < len(nums)
谁还不会一行呢

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return not (len(nums)==len(set(nums)))
```


```py
用哈希表存放元素，遍历nums

（1）如果数字不在哈希表中，说明该数字第一次出现，哈希表加入该数字

（2）如果数字存在哈希表中，说明该数字第二次出现，直接返回False

如果遍历完了，说明所有数字都只出现一次，那么返回True

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        numSet = set()
        for i in nums:
            if i in numSet:
                return True
            else:
                numSet.add(i)
        return False
```

```scala
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        var hashSet = scala.collection.mutable.HashSet.empty[Int]
        import scala.util.control.Breaks._
        var flag = false
        breakable{
            for(num <- nums){
                if(hashSet.contains(num)){
                        flag = true
                        break
                    }else{
                    hashSet.add(num)
                }
                }
            }
        flag
        }
    }
    
  
//Alternate (SCALA) solution
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        return nums.distinctBy(_.self).length != nums.length
    }
}

```

###  1.94. <a name='TheSkylineProblem'></a>218. The Skyline Problem

[花花酱](https://www.bilibili.com/video/BV1hb411c7Q4?spm_id_from=333.999.0.0)

###  1.95. <a name='ContainsDuplicateII'></a>219. Contains Duplicate II

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ga?spm_id_from=333.999.0.0)

###  1.96. <a name='ContainsDuplicateIII'></a>220 Contains Duplicate III

[小明](https://www.bilibili.com/video/BV19h41197iw?spm_id_from=333.999.0.0)

###  1.97. <a name='-1'></a>221-最大正方形

[哈哈哈](https://www.bilibili.com/video/BV1XT4y137Gq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16K411575r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1mA411q7Sw?spm_id_from=333.999.0.0)

```py
# 暴力卷积法

import numpy as np
from scipy.signal import convolve2d
class Solution:
    def maximalSquare(self, matrix):
        if not matrix: return 0
        matrix=np.array(matrix,int)
        for i in range(1,min(matrix.shape)+1):
            if convolve2d(matrix,np.ones((i,i),int),'valid').max()<i**2:
                return (i-1)**2
        return i**2
```

```py


# 回想了一下上次的思考，对于这个矩阵中需要构成square(len>1)，

# 右下角的坐标为(x, y) ，那么(x - 1, y - 1)一定需要是一个square，

# 并且该点的左边全为1，上边也为1，按照这个进行理解变长的增加。

class Solution:
    def maximalSquare(self, matrix):
        m, n = len(matrix), len(matrix[0])
        # initialze a (m, n) array
        dp = [[0] * n for _ in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1
                    res = max(dp[i][j], res)
        return res * res

# 用原数组存算出来的值，空间复杂度是不是就降到O(1)了

class Solution:
    def maximalSquare(self, matrix):
        maxEdge = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                if i and j:
                    if matrix[i][j]=="1":
                        matrix[i][j]=min(int(matrix[i-1][j-1]),int(matrix[i][j-1]),int(matrix[i-1][j]))+1
                    else:
                        matrix[i][j]=0
                maxEdge = max(maxEdge,int(matrix[i][j]))
        return maxEdge**2       
# 浑元形意太极门的人过来，集合了


```

###  1.98. <a name='CountCompleteTreeNodes'></a>222. Count Complete Tree Nodes

[花花酱](https://www.bilibili.com/video/BV1n44y1E73D?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qz411i7bh?spm_id_from=333.999.0.0)

两种递归

```py
class Solution(object):
    def countNodes(self, root):
        if root == None:
        	return 0
        if root.left == None and root.right == None:
        	return 1
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)

class Solution(object):
    def countNodes(self, root):
        if not root:
            return 0
        lh, rh = self.getHeight(root.left), self.getHeight(root.right)
        if lh == rh:  # 左右子树高度相同，说明左子树必满 则节点数=左子树节点 + root节点(=1) + 递归找右子树
            return (pow(2, lh) - 1) + 1 + self.countNodes(root.right)
        else:  # 左子树比右子树高，说明右子树必满 同理
            return (pow(2, rh) - 1) + 1 + self.countNodes(root.left)

    def getHeight(self, root):
        ret = 0
        while root:
            ret += 1
            root = root.left
        return ret
# 相对来说，递归法利用公式更容易理解：
# 既然说了是 complete binary tree，那么必然有特性可用，
# complete binary tree的特性是除了最后一层，之前的就是perfect tree.
```

```py
# 完全二叉树的性质{根节点的左右子树至少有一个是满二叉树}， 
# 首先从根节点开始计算左右子树的高度，如果相等则为满二叉树，直接返回 
# 否则递归计算左右子树 
# Note：乍一看时间复杂度为O(N*logN)，
# 但是根据完全二叉树的性质,其子树中至少有一个满二叉树，
# 所以只会有一个递归会正真的执行下去 
# 查找深度的时间复杂度为logN,递归的深度为O(logN)，
# 所以总的时间复杂度为O(logN * logN)

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        left = right = 0
        tmp1 = tmp2 =  root

        # 求出树的深度
        while tmp1:
            left += 1
            tmp1 = tmp1.left
        while tmp2:
            right += 1
            tmp2 = tmp2.right

        # 利用树的深度
        if left == right:
            return 2 ** left - 1
        else:
            return 1 + self.countNodes(root.left) + self.countNodes(root.right)  #根据完全二叉树的性质，这两地递归真正执行的只有一个


# 所以寻找左子树的最左边的高度和右子树的最右边的node高度，
# 如果相同就是perfect tree，高度2^h - 1， 否则递归的来看左子树和右子树

class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
        	return 0
        
        p, q = root,root

        leftHeight = 0
        rightHeight = 0

        while p:
        	p = p.left
        	leftHeight += 1

        while q:
        	q = q.right
        	rightHeight += 1

        if leftHeight == rightHeight:
        	return (int)(math.pow(2,leftHeight) - 1)
        else:
        	return 1 + self.countNodes(root.left) + self.countNodes(root.right)



# 我随便写了写，还准备修改，没想到一提交啪就通过了，很快啊！

class Solution(object):
    def countNodes(self, root):
        if not root: return 0
        depth=0
        
        def getDepth(root):
            nonlocal depth
            depth += 1
            if root.left:
                getDepth(root.left)
            else:
                return
            
        getDepth(root)
        ans=2**(depth-1)-1
        
        def dfs(node,path):
            nonlocal ans
            path.append(node)
            if node.left:
                dfs(node.left,path)
            if node.right:
                dfs(node.right,path)
            if not node.left and not node.right:
                if len(path)==depth:
                    ans+=1
            path.pop()
            
        dfs(root,[])
        return ans
```

###  1.99. <a name='RectangleArea'></a>223. Rectangle Area

[小梦想家](https://www.bilibili.com/video/BV1Ck4y1z7Hp?spm_id_from=333.999.0.0)

```py
class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        def overlapLength(a1, a2, b1, b2) -> int:
            return max(min(a2, b2) - max(a1, b1), 0)

        overlap = overlapLength(ax1, ax2, bx1, bx2) * overlapLength(ay1, ay2, by1, by2)

        areaA = (ax2 - ax1) * (ay2 - ay1)

        areaB = (bx2 - bx1) * (by2 - by1)

        return areaA + areaB - overlap
```

```py
class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        
        xx1 = max(ax1,bx1)
        yy1 = min(ay2,by2)
        xx2 = min(ax2,bx2)
        yy2 = max(ay1,by1)
        
        w = max(0,xx2- xx1)
        h = max(0,yy1 - yy2)

        area1 = (ax2- ax1) * (ay2- ay1)
        area2 = (bx2- bx1) * (by2- by1)
        return area1 + area2 -w * h

class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        area1 = (ax2 - ax1) * (ay2 - ay1)
        area2 = (bx2 - bx1) * (by2 - by1)
        overlapWidth = min(ax2, bx2) - max(ax1, bx1)
        overlapHeight = min(ay2, by2) - max(ay1, by1)
        overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0)
        return area1 + area2 - overlapArea
```

### 224

https://www.bilibili.com/video/BV1Nb4y1z7hG?from=search&seid=1882841343164929357&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.71qtf391s5w0.png" width="40%">

```py
class Solution:
    def calculate(self, s: str) -> int:
        stack = [1]
        sign = 1
        i = 0
        res = 0
        while i < len(s):
            if s[i].isdigit():
                n = 0
                while i<len(s) and s[i].isdigit():
                    n = 10*n + int(s[i])
                    i += 1
                res += sign*n
            else:
                if s[i]=='+':   sign=stack[-1]
                elif s[i]=='-': sign=-stack[-1]
                elif s[i]=='(': stack.append(sign)
                elif s[i]==')': stack.pop()
                i += 1
        return res
```

###  1.100. <a name='ImplementStackusingQueues'></a>225-Implement Stack using Queues

[哈哈哈](https://www.bilibili.com/video/BV1p741177pK?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ep4y1Y77j?spm_id_from=333.999.0.0)

```py
from collections import deque

class MyStack:

    def __init__(self):
        """
        Python普通的Queue或SimpleQueue没有类似于peek的功能
        也无法用索引访问，在实现top的时候较为困难。

        用list可以，但是在使用pop(0)的时候时间复杂度为O(n)
        因此这里使用双向队列，我们保证只执行popleft()和append()，因为deque可以用索引访问，可以实现和peek相似的功能

        in - 存所有数据
        out - 仅在pop的时候会用到
        """
        self.queue_in = deque()
        self.queue_out = deque()

    def push(self, x: int) -> None:
        """
        直接append即可
        """
        self.queue_in.append(x)


    def pop(self) -> int:
        """
        1. 首先确认不空
        2. 因为队列的特殊性，FIFO，所以我们只有在pop()的时候才会使用queue_out
        3. 先把queue_in中的所有元素（除了最后一个），依次出列放进queue_out
        4. 交换in和out，此时out里只有一个元素
        5. 把out中的pop出来，即是原队列的最后一个
        
        tip：这不能像栈实现队列一样，因为另一个queue也是FIFO，如果执行pop()它不能像
        stack一样从另一个pop()，所以干脆in只用来存数据，pop()的时候两个进行交换
        """
        if self.empty():
            return None

        for i in range(len(self.queue_in) - 1):
            self.queue_out.append(self.queue_in.popleft())
        
        self.queue_in, self.queue_out = self.queue_out, self.queue_in    # 交换in和out，这也是为啥in只用来存
        return self.queue_out.popleft()

    def top(self) -> int:
        """
        1. 首先确认不空
        2. 我们仅有in会存放数据，所以返回第一个即可
        """
        if self.empty():
            return None
        
        return self.queue_in[-1]


    def empty(self) -> bool:
        """
        因为只有in存了数据，只要判断in是不是有数即可
        """
        return len(self.queue_in) == 0


class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue1 = collections.deque()
        self.queue2 = collections.deque()


    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.queue2.append(x)
        while self.queue1:
            self.queue2.append(self.queue1.popleft())
        self.queue1, self.queue2 = self.queue2, self.queue1


    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue1.popleft()


    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue1[0]


    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue1


class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = collections.deque()


    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        n = len(self.queue)
        self.queue.append(x)
        for _ in range(n):
            self.queue.append(self.queue.popleft())


    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue.popleft()


    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[0]


    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue


```

```py
q2当作缓存队列

class MyStack:

    def __init__(self):
        # q1和q2是两个队列
        ## 保证q1当中永远有元素
        ## 保证q2当中永远没有元素
        self.q1 = deque([])
        self.q2 = deque([])

    def push(self, x: int) -> None:
        self.q1.append(x)
        
    def pop(self) -> int:
        while len(self.q1) > 1:
            self.q2.append(self.q1.popleft())
        t = self.q1
        self.q1 = self.q2
        self.q2 = t
        return self.q2.popleft()
        
        
    def top(self) -> int:
        while len(self.q1) > 1:
            self.q2.append(self.q1.popleft())
        res = self.q1.popleft()
        t = self.q1
        self.q1 = self.q2
        self.q2 = t
        self.q1.append(res)
        return res

    def empty(self) -> bool:
        return not self.q1
```

```scala
/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */


/**
* chosen solution
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack0() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}




 /**
 * my first commit
 * two queue version
 * time complexity: 
 *   push: O(1)
 *   pop: O(2n - 1)  n is the element in queue1
 *   top: O(2n - 1)
 */
class MyStack1() {

    /** Initialize your data structure here. */
    var queue1 = scala.collection.mutable.Queue[Int]()
    var queue2 = scala.collection.mutable.Queue[Int]()

    /** Push element x onto stack. */
    def push(x: Int) {
        queue1.enqueue(x)
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
       }
    
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        ret
        
    }

    /** Get the top element. */
    def top(): Int = {
        while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
        }
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        queue1.enqueue(ret)
        ret
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty && queue2.isEmpty
    }

}

/**
* two queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack2() {

   import scala.collection.mutable.Queue
    /** Initialize your data structure here. */
    var queue1 = Queue.empty[Int] 


    /** Push element x onto stack. */
    def push(x: Int) {
        val queue2 = Queue(x)
        queue2.enqueueAll(queue1.dequeueAll(_ => true))
        queue1 = queue2
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
        if(queue1.isEmpty) -1 else queue1.dequeue
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }
}

/**
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack3() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}

/**
* memo:
*   1. push entire old queue into a new queue without expanding all elements 
* time complexity:  
*     all operation are O(1) after being amortized
*   
* start  Queue()
* push1  Queue(1, Queue())
* push2  Queue(2, Queue(1, Queue()))
* push3  Queue(3, Queue(2, Queue(1, Queue())))
* push4  Queue(4, Queue(3, Queue(2, Queue(1, Queue()))))
* pop    Queue(3, Queue(2, Queue(1, Queue())))
* pop    Queue(2, Queue(1, Queue()))
*/

class MyStack4() {
  import scala.collection.mutable
  /** Initialize your data structure here. */
  var queue: mutable.Queue[Any] = mutable.Queue.empty[Any]

  /** Push element x onto stack. */
  def push(x: Int) {
    val queue2: mutable.Queue[Any] = mutable.Queue(x)
    queue2.enqueue(queue)
    queue = queue2

  }
  /** Removes the element on top of the stack and returns that element. */
  def pop(): Int = {

    if(queue.isEmpty) -1 else {
      val ret = queue.dequeue.asInstanceOf[Int]
      queue = queue.dequeue.asInstanceOf[mutable.Queue[Any]]
      ret
    }
  }
  /** Get the top element. */
  def top(): Int = {
    if(queue.isEmpty) -1 else queue.head.asInstanceOf[Int]
  }

  /** Returns whether the stack is empty. */
  def empty(): Boolean = {
    queue.size != 2
  }
}
```

###  1.101. <a name='-1'></a>226-翻转二叉树

[哈哈哈](https://www.bilibili.com/video/BV1Sh411R7B2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73E?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FK411p7Co?spm_id_from=333.999.0.0)

```py
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```

```py
用队列做，每次都弹出第一个节点，然后判断

如果节点为叶子节点，那就什么都不做

如果不是叶子节点，那就有三种情况：

1.左节点和右节点都存在，此时把两个节点交换，然后把左右节点都重新加入队列

2.只有左节点，此时交换两个节点，然后把右节点重新加入队列

3.只有右节点，此时交换两个节点，然后把左节点重新加入队列

### 代码

class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if root == None:
            return root
        Q = deque([root])
        while Q:
            r = Q.popleft()
            if r.left or r.right:
                r.left, r.right = r.right, r.left
                if r.left and r.right:
                    Q.append(r.left)
                    Q.append(r.right)
                elif r.right and not r.left:
                    Q.append(r.right)
                else:
                    Q.append(r.left)
        return root
```

###  1.102. <a name='BasicCalculatorII'></a>227 Basic Calculator II

[小明](https://www.bilibili.com/video/BV1Qy4y167Ax?spm_id_from=333.999.0.0)

https://www.bilibili.com/video/BV1t4411c7m6?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

https://www.bilibili.com/video/BV1v54y1a74b?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

```py
class Solution:
    def calculate(self, s: str) -> int:
        n = len(s)
        stack = []
        op = '+'
        num = 0
        for i in range(n):
            if s[i] != ' ' and s[i].isdigit():
                num = num * 10 + ord(s[i]) - ord('0')
            if i == n - 1 or s[i] in '+-*/':
                if op == '+':
                    stack.append(num)
                elif op == '-':
                    stack.append(-num)
                elif op == '*':
                    stack.append(stack.pop() * num)
                else:
                    stack.append(int(stack.pop() / num))
                op = s[i]
                num = 0
        return sum(stack)

class Solution:
    def calculate(self, s: str) -> int:
        stack = []
        num, op = 0, "+"
        for i, c in enumerate(s):
            if c.isdigit():
                num = 10*num + int(c)
            if c in "+-*/" or i==len(s)-1:
                if op == "+":
                    stack.append(num)
                elif op == "-":
                    stack.append(-num)
                elif op == "*":
                    stack.append(stack.pop()*num)
                elif op == "/":
                    stack.append(int(stack.pop()/float(num)))
                num, op = 0, c
        return sum(stack)

# python里 -3/2==-2
# -3//2=-2，就是个坑
import operator
class Solution(object):
    def calculate(self, s):
        res = []
        opMap = {
            "+": lambda e: res.append(e),
            "-": lambda e: res.append(-e),
            "*": lambda e: res.append(e * res.pop()),
            "/": lambda e: res.append(int((res.pop()/e)))
            # "/": lambda e: a.append(int(operator.truediv(a.pop(), e)))
        }
        op = "+"
        num = 0
        for char in s+"+":
            if char.isdigit():
                num = num * 10 + int(char)
            elif char != " ":
                opMap[op](num)
                op = char
                num = 0
        return sum(res)
```

```py
# 本题不含括号和符号位，所以将 '/' 替换为 '//' 就可以直接调用 eval 了。
class Solution(object):
    def calculate(self, s):
        return eval(s.replace('/', '//'))
```

###  1.103. <a name='SummaryRanges'></a>228 Summary Ranges

[小明](https://www.bilibili.com/video/BV1Et4y1i7YZ?spm_id_from=333.999.0.0)

###  1.104. <a name='MajorityElementII'></a>229. Majority Element II 

[哈哈哈](https://www.bilibili.com/video/BV12z411B7rS?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nK411P7qR?spm_id_from=333.999.0.0)

```py
# 哈希统计

class Solution:
    def majorityElement(self, nums):
        lookup = defaultdict(int)
        res = []
        for num in nums:
            lookup[num] += 1
            if lookup[num] > len(nums) // 3:
                res.append(num)
        return list(set(res))


class Solution:
    def majorityElement(self, nums):
        lookup = {}
        res = []

        for num in nums:
            if num in lookup:
                lookup[num] += 1
            else:
                lookup[num] = 1
        for item in lookup.keys():
            if lookup[item] > len(nums)//3:
                res.append(item)

        return res
```


###  1.105. <a name='KthSmallestElementinaB'></a>230 Kth Smallest Element in a B

[小明](https://www.bilibili.com/video/BV1ha4y1i7dZ?spm_id_from=333.999.0.0)

```py
# 用yield来波骚操作

class Solution:
    def kthSmallest(self, root, k):

        def gen(r):
            if r is not None:
                yield from gen(r.left)
                yield r.val
                yield from gen(r.right)
        
        it = gen(root)
        for _ in range(k):
            ans = next(it)
        return ans

# 收藏一波，博主大大威武
# yield真是迭代优化利器

# 6得飞起！~ 来化简下助涨楼主骚气
class Solution:
    def kthSmallest(self, root, k):
        from itertools import chain, islice
        def gen(x): yield from chain(gen(x.left), [x.val], gen(x.right)) if x else ()
        return next(islice(gen(root), k - 1, k))
```

```py
# InOrder排序，输出
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        stack = []
        while root or stack: # stack一般都有
            while root: # 找到最深的节点，root在最深处的时候就为none
                stack.append(root)
                root = root.left
            root = stack.pop() # stack弹出最深处的节点
            k -= 1
            if k == 0:
                return root.val
            root = root.right #去右孩子看看

class Solution:
    def kthSmallest(self, root, k: int) -> int:
        queue = deque([])

        def inOrder(root):
            
            if not root: return
            helper(root.left)
            queue.append(root.val)
            helper(root.right)
            return

        inOrder(root)
        return queue[k - 1]
```


```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

object Solution {
    def kthSmallest(root: TreeNode, k: Int): Int = {

      val stack = collection.mutable.Stack[TreeNode]()
      var node = root
      var counter = 0
      var ans = 0
      while ((counter <= k) && (node != null || stack.nonEmpty)) {
        while(node != null) {
          stack push node
          node = node.left
        }
        node = stack.pop
        
        counter += 1
        if (counter == 1 || counter <= k) {
          ans = node.value
        }
        
        node = node.right
        
      }
      ans
    }
}
/**
* my first commit
* inorder iterative template
* time complexity: O(H + K) => H is tree height, H + K = element in stack
*/

object Solution1 {
    def kthSmallest(root: TreeNode, k: Int): Int = {
        
        val stack = collection.mutable.Stack[TreeNode]()
        var node = root
        var counter = 0
        
        
        while(node != null || stack.nonEmpty) {
            while(node != null) {
                stack push node
                node = node.left
            }
            node = stack.pop
            counter += 1
            if(counter == k) return node.value
            else node = node.right
            
        }
        -1
    }
}

/**
* inorder traversal - recursive version
* time complexity: O(H + k)
*/

object Solution2-1 {
    import scala.collection.mutable
    def kthSmallest(root: TreeNode, k: Int): Int = {
        val ret = _kthSmallest(root, k, mutable.ListBuffer.empty)

        ret(k - 1)
    }
    
    def _kthSmallest(node: TreeNode, k:Int, l: mutable.ListBuffer[Int]): mutable.ListBuffer[Int]  = {
       if(node == null) l
       else {
           _kthSmallest(node.left, k, l)
           l += node.value
           if(l.size >= k) l  // shortcut
           else  _kthSmallest(node.right, k, l)  
       }
    }
}


/**
* a brilliant solution - inorder recursive traversal 
* memo:
*   1. using Either, right records numbers of visited node, left record the value when the condition is meet
* time complexity:
*      O(H + K) H is the height of the tree calculated by log(N) approximately
*/
object Solution2-2 {
  def go (node: TreeNode, k: Int) : Either[Int, Int] = {
     val r =for {
      numElementsLeft <- if (node.left == null) Right (0) else go(node.left, k)
      numElementsRight <- if (numElementsLeft + 1 == k) Left(node.value)
      else
        if (node.right == null) Right(0) else go(node.right, k - (numElementsLeft + 1))

    } yield numElementsLeft + numElementsRight + 1
      println(r)
      r

  }

  def kthSmallest(root: TreeNode, k: Int): Int = {
    go(root, k).left.get
  }
}

```



###  1.106. <a name='PowerofTwo'></a>231. Power of Two

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rV411r7AL?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0

class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return True if  n >0 and log2(n) == int(log2(n)) else False
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return bin(n).count('1') == 1 and n > 0

class Solution:
    def isPowerOfTwo(self, n):
        return n > 0 and not (n & (n - 1))

class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & -n) == n
```

```py
2147483648是整数范围内最大的2次幂，若n是2的幂，那么2147483648一定能整除它

class Solution(object):
    def isPowerOfTwo(self, n):
        return n > 0 and 2147483648 % n == 0

        
class Solution:

    BIG = 2**30

    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and Solution.BIG % n == 0
```

```scala
/**
* time complexity  O(1)
*/
object Solution {
    def isPowerOfTwo(n: Int): Boolean = {
        n > 0 && (n & (n - 1) ) == 0
    }
}
```

###  1.107. <a name='ImplementQueueusingStacks'></a>232-Implement Queue using Stacks

[哈哈哈](https://www.bilibili.com/video/BV1p741177pp?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Gf4y147Vj?spm_id_from=333.999.0.0)

```py
class MyQueue:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = []
        self.s2 = []
        self.front = None


    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        if not self.s1: self.front = x
        self.s1.append(x)
        


    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        if not self.s2:
            while self.s1:
                self.s2.append(self.s1.pop())
            self.front = None
        return self.s2.pop()

    def peek(self) -> int:
        """
        Get the front element.
        """
        if self.s2: 
            return self.s2[-1]
        return self.front


    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        if not self.s1 and not self.s2:
            return True
        return False
```

```py
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x):
        while self.s1:
            self.s2.append(self.s1.pop())
        self.s2.append(x)
        while self.s2:
            self.s1.append(self.s2.pop())

    def pop(self):
        return self.s1.pop() if self.s1 else None
        

    def peek(self):
        return self.s1[-1] if self.s1 else None

    def empty(self):
        return False if self.s1 else True
```

```scala
/**
* using two stack to implement
* one for push, the other for pop
* time complexity amortized O(1) per operation
* space complexity
*/

class MyQueue() {

  /** Initialize your data structure here. */
  private val inputStack = scala.collection.mutable.ArrayStack[Int]()
  private val outputStack = scala.collection.mutable.ArrayStack[Int]()


  /** Push element x to the back of queue. */
  def push(x: Int) {
    inputStack.push(x)

  }

  /** Removes the element from in front of queue and returns that element. */
  def pop(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.pop()

  }

  /** Get the front element. */
  def peek(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.head
  }

  /** Returns whether the queue is empty. */
  def empty(): Boolean = {
    outputStack.isEmpty && inputStack.isEmpty
  }

}

```

###  1.108. <a name='PalindromeLinkedList'></a>234. Palindrome Linked List

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ML?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        vals = []
        current_node = head
        while current_node is not None:
            vals.append(current_node.val)
            current_node = current_node.next
        return vals == vals[::-1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Solution:
    def isPalindrome(self, head: ListNode) -> bool:

        self.front_pointer = head

        def recursively_check(current_node=head):
            if current_node is not None:
                if not recursively_check(current_node.next):
                    return False
                if self.front_pointer.val != current_node.val:
                    return False
                self.front_pointer = self.front_pointer.next
            return True

        return recursively_check()

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
秒啊，就是有可能数字太大
可以理解成字符串(链表)转数字，如果是回文从前往后与从后往前得到的数字是一样的
虽然没有深入想，但是这个算法在经过证明之前，真心不敢用。有可能在特定测试例下失败
只有python 能做，只要用强制类型语言都会越界。
class Solution(object):

def isPalindrome(self, head):
    s1=0
    s2=0
    t=1

    while head!=None:
        s1=s1*10+head.val
        s2=s2+t*head.val
        t=t*10
        head=head.next
        
    return s1==s2
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
 
 /**
 * my first commitment
 *  using two pointer, one run 2 times faster than the other
 */
object Solution1 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null){
            true
        }else {
            var slowPre: ListNode = null
            var slow = head
            var fast = head

            while (fast != null && fast.next != null) {
                fast = fast.next.next

                val slowNext = slow.next
                slow.next = slowPre
                slowPre = slow
                slow = slowNext

            }

            fast match {
                case null => checkPalindrome(slowPre, slow)
                case _ => checkPalindrome(slowPre, slow.next)  // odd case
            }
            /**
                1 2 2 1 null
                s f
                    s   f  

                1 2 3 2 1 null
                s f   
                    s   f
            */
        }
       
                
    }
    def checkPalindrome(left: ListNode, right: ListNode): Boolean = {
        (left, right) match {
            case (null, null) => true
            case (l, r) if l != null && r != null && l.x == r.x => checkPalindrome(left.next, right.next)
            case _ => false   
        }
        
    }
    

    def printNode(node: ListNode) {
        var n = node
        
        while(n != null) {
            print(s"${n.x}\t")
            n = n.next
        }
    }
}


/**
* very brilliant solution
*/
object Solution2 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null) {
            return true
        }
        var p = head
        var result = true
        def go(node: ListNode): Unit = {
            if (node.next != null) {
                go(node.next)
            }
            if (p.x != node.x) {
                result = false
            }
            p = p.next
        }
        go(head)
        result
    }
}
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def isPalindrome(head: ListNode): Boolean = {
        var flag = true
        var rev = head
        var h = head
        def reverse(n: ListNode): Unit = {
            if(n == null){
                ()
            }else{
                reverse(n.next)
                val cond = n.x == h.x
                flag = flag && cond
                h = h.next
            }
        }
       
        reverse(rev)
        flag
    }
}

```

###  1.109. <a name='LowestCommonAncestorofaBinarySearchTree'></a>235. Lowest Common Ancestor of a Binary Search Tree

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7VY?spm_id_from=333.999.0.0)

```py
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        def getPath(root: TreeNode, target: TreeNode) -> List[TreeNode]:
            path = list()
            node = root
            while node != target:
                path.append(node)
                if target.val < node.val:
                    node = node.left
                else:
                    node = node.right
            path.append(node)
            return path
        
        path_p = getPath(root, p)
        path_q = getPath(root, q)
        ancestor = None
        for u, v in zip(path_p, path_q):
            if u == v:
                ancestor = u
            else:
                break
        
        return ancestor

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        ancestor = root
        while True:
            if p.val < ancestor.val and q.val < ancestor.val:
                ancestor = ancestor.left
            elif p.val > ancestor.val and q.val > ancestor.val:
                ancestor = ancestor.right
            else:
                break
        return ancestor

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python3 利用二叉搜索树的特点，如果p、q的值都小于root，

说明p q 肯定在root的左子树中；如果p q都大于root，

说明肯定在root的右子树中，如果一个在左一个在右 

则说明此时的root记为对应的最近公共祖先 //python3

太有道理了, 我竟然没当成搜索树来看待。

根据搜索树的特点，如果 p，q 值 都 < root 的值，就去左子树
根据搜索树的特点，如果 p，q 值 都 > root 的值，就去右子树
否则就是说分布在 root的左右子树中

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if p.val<root.val and q.val<root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        
        if p.val>root.val and q.val>root.val:
            
            return self.lowestCommonAncestor(root.right,p,q)
        
        return root
```

```py
递归法：

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root: return root  //中
        if root.val >p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left,p,q)  //左
        elif root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right,p,q)  //右
        else: return root

若p、q分别在某一节点的左右子树内，则该节点为最小公共祖先。

（对于二叉搜索树而言，即需满足该min(p,q)<=node.val<=max(p,q)）

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        r1=max(p.val,q.val)
        r2=min(p.val,q.val)
        while root :
            if root.val>=r2 and root.val<=r1:
                return root
            if root.val>r1:
                root=root.left
            else:
                root=root.right
        return root
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
* DFS 
* 
* exploit binary search three property:  right > parent value > left
* time complexity : O(N)
* space complexity: O(N)
*/
object Solution1 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }
  
  @annotation.tailrec
  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    (p, q) match {
      case (pp, qq) if p.value > node.value && q.value > node.value  && node != null => _lowestCommonAncestor(node.right, pp, qq)
      case (pp, qq) if p.value < node.value && q.value < node.value && node != null => _lowestCommonAncestor(node.left, pp, qq)
      case _ => node
    }
  }
}


/**
* iterative version
*/
object Solution1-2 {
    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
      if(root == null) return root
      var node = root
      
      var condition = true
      while(condition && node != null){
        if(q.value > node.value && p.value > node.value)
          node = node.right
        else if (node.value > q.value && node.value > p.value)
          node = node.left
        else 
          condition = false
      }
      node
    }
}
```

###  1.110. <a name='-1'></a>236-二叉树的最近公共祖先

[哈哈哈](https://www.bilibili.com/video/BV1ov411172r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411p7dr?spm_id_from=333.999.0.0)

```py
# 提供一个python3题解：

# 思路 ：这是我看过解释最清楚的youtube题解 需要听懂印度口音英语，但讲得非常好

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return 
        if root == p or root == q:
            return root 
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        if left and right:
            return root 
        elif left and not right:
            return left 
        elif right and not left:
            return right 

# Python 超越99%执行速度的解法：而且也简短

class Solution:
    def lowestCommonAncestor(self, root, p, q) -> 'TreeNode':

        if root in (None,p,q):
            return root 

        L = self.lowestCommonAncestor(root.left,p,q)
        R = self.lowestCommonAncestor(root.right,p,q)

        return R if None==L else L if None==R else root

# 左子树或自己含p 就返回p，右子树或自己含q就返回q，左右子树返回一p一q则返回自己，
# 如果某子树返回了答案（另一子树必然返回None），
# 则返回答案，剩下就是两个子树都返回空，则返回空。 
# 经过逻辑化简：

# 先分析自己，自己是p,q,None中的一者，自然返回自己。
# 然后分析左右子树的返回值，如果其中一个是None，则返回另一个，
# 作为传递，无论是传递最终的答案，还是传递p和q。
# 如果左右子树返回p和q，当然返回root。 Python中的None即C/C++/Java 中的Null/null

# //递归
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q: return root  
        # //找到了节点p或者q，或者遇到空节点
        left = self.lowestCommonAncestor(root.left,p,q)  
        # //左
        right = self.lowestCommonAncestor(root.right,p,q)  
        # //右
        if left and right: return root  
        # //中: left和right不为空，root就是最近公共节点
        elif left and not right: return left  
        # //目标节点是通过left返回的
        elif not left and right: return right  
        # //目标节点是通过right返回的
        else: return None  
        # //没找到
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
*  chosen solution
*  DFS with recursive
*  time complexity O(N), N is the number of node in the tree
*  space complexity O(N)
*/
object Solution0 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }

  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    if (node == null || node == p || node == q) return node
    /**
    *  1. if p and q are node 's child, return p q 's LCA 
    *  2.  if p and q are not node's child return null
    *  3. if p and q, only one of then ar node's child return that node (p or q)
    */
    val left = _lowestCommonAncestor(node.left, p, q)
    val right = _lowestCommonAncestor(node.right, p, q)

    (left, right) match {
      case (null, _) => right  // p and q are both not in left
      case (_, null) => left  // p and q are both not in right
      case (l, r) =>  node // only lowest common ancestor could return both non null node
      // p and q, one of then in left and the other one in right
    }
  }
}
```

###  1.111. <a name='DeleteNodeinaLinkedList'></a>237. Delete Node in a Linked List

[小梦想家](https://www.bilibili.com/video/BV1rv411h7Lv?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1ap4y1C7JP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vt4y1y7eM?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/shan-chu-lian-biao-zhong-de-jie-dian-by-x656s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getNext(node: ListNode): ListNode = {
        val nextNode = node.next
        if(nextNode == null)
            null
        else{
            node.x = nextNode.x
            node.next = getNext(nextNode)
            node
        }
    }
    
    def deleteNode(node: ListNode): Unit = {
        getNext(node)
    }
}

//The above solution can be simplified to:
object Solution {
    
    def deleteNode(node: ListNode): Unit = {
        node.x = node.next.x
        node.next = node.next.next //These 2 lines are effectively the same as doing the above recursion in scala
    }
}

```

###  1.112. <a name='ProductofArrayExceptSelf'></a>238 Product of Array Except Self

[小明](https://www.bilibili.com/video/BV1oT4y1G78Y?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16z4y197oQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def productExceptSelf(self, nums):
        n = len(nums)
        # 动态规划,开辟两类空间,分别存储索引i左边(右边)所有数的乘积,
        # 所以,output[i]即为i左边所有数的乘积*i右边所有数的乘积.
        # 为了满足O(1)空间复杂度要求(输出数组不被视作额外空间),
        # 首先,一类空间的dp数据(i右边所有数的乘积)用输出数组存储,
        # 二类空间的dp数据(i左边所有数的乘积)用两个变量存储,
        # 因为这两个变量会一直变化, 所以应该实时更新输出数组.
        dp_right = [1 for i in range(n)]
        pre_left = 1
        for i in range(n - 2, -1, -1):
            dp_right[i] = dp_right[i + 1] * nums[i + 1]
        for i in range(1, n):
            cur_left = pre_left * nums[i - 1]
            dp_right[i] = cur_left * dp_right[i]
            pre_left = cur_left
        return dp_right

# python 思想：前缀积，前缀积和前缀和差不多

class Solution:
    def productExceptSelf(self, nums):
        nums_len = len(nums)
        res = [1]*nums_len
        right = 1
        for i in range(1, nums_len):
            res[i] = res[i-1] * nums[i-1]
        for i in range(nums_len-1, -1, -1):
            res[i] = res[i]*right
            right = right * nums[i]
        # print(res)
        return res

# 用一个数组来存储每一个数的左边的数的乘积，那么 ans[i] = ans[i-1]*nums[i]， 
# 第一个数左边没有数，认为ans[0] = 1。
# 再用一个数 R 来存储右边的数的乘积，
# 从后往前循环，ans乘以R就是左右数缀的乘积，同时更新R。

class Solution:
    def productExceptSelf(self, nums):
        n = len(nums)
        ans = [0]*n
        
        ans[0] = 1
        for i in range(1, n):
            ans[i] = ans[i-1]*nums[i-1]

        R = 1
        for i in reversed(range(n)):
            ans[i] = ans[i] * R
            R *= nums[i]

        return ans

class Solution:
    def productExceptSelf(self, nums):
        n=len(nums)
        left=[1]*n
        right=[1]*n
        res=[]
        for i in range(1,n):
            left[i]=left[i-1]*nums[i-1]
        for i in range(n-2,-1,-1):
            right[i]=right[i+1]*nums[i+1]
        for i in range(n):
            res.append(left[i]*right[i])
        return res 

# 方法一：左右乘积列表

class Solution:
    def productExceptSelf(self, nums):
        length = len(nums)
        
        # L 和 R 分别表示左右两侧的乘积列表
        L, R, answer = [0]*length, [0]*length, [0]*length
        
        # L[i] 为索引 i 左侧所有元素的乘积
        # 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1
        L[0] = 1
        for i in range(1, length):
            L[i] = nums[i - 1] * L[i - 1]
        
        # R[i] 为索引 i 右侧所有元素的乘积
        # 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1
        R[length - 1] = 1
        for i in reversed(range(length - 1)):
            R[i] = nums[i + 1] * R[i + 1]

        # 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
        for i in range(length):
            answer[i] = L[i] * R[i]
        
        return answer

# 方法二：空间复杂度 O(1)O(1) 的方法
# 思路
# 尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。
# 由于输出数组不算在空间复杂度内，那么我们可以将 L 或 R 数组用输出数组来计算。
# 先把输出数组当作 L 数组来计算，然后再动态构造 R 数组得到结果。
# 让我们来看看基于这个思想的算法。


class Solution:
    def productExceptSelf(self, nums):
        length = len(nums)
        answer = [0]*length
        
        # answer[i] 表示索引 i 左侧所有元素的乘积
        # 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1
        answer[0] = 1
        for i in range(1, length):
            answer[i] = nums[i - 1] * answer[i - 1]
        
        # R 为右侧所有元素的乘积
        # 刚开始右边没有元素，所以 R = 1
        R = 1;
        for i in reversed(range(length)):
            # 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
            answer[i] = answer[i] * R
            # R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
            R *= nums[i]
        
        return answer
```

```scala
object Solution {

    //pre-compute prefix & suffix products in O(N) time and then multiply them
    def productExceptSelf(nums: Array[Int]): Array[Int] = {
        var prefix = Array.fill(nums.length)(1)
        var suffix = Array.fill(nums.length)(1)
        
        (1 until prefix.length).map(i => {
            prefix(i) = prefix(i-1)*nums(i-1)
        })
        
        (suffix.length-2 to 0 by -1).map(i => {
            suffix(i) = suffix(i+1)*nums(i+1)
        })
        
        (0 until nums.length).map(i => {
            nums(i) = prefix(i) * suffix(i)
        })
        nums
    }
}

```

###  1.113. <a name='SlidingWindowMaximum'></a>239. Sliding Window Maximum

[花花酱](https://www.bilibili.com/video/BV1WW411C763?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Bf4y1v758?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # 注意 Python 默认的优先队列是小根堆
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        ans = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:
                heapq.heappop(q)
            ans.append(-q[0][0])
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        q = collections.deque()
        for i in range(k):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)

        ans = [nums[q[0]]]
        for i in range(k, n):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
            while q[0] <= i - k:
                q.popleft()
            ans.append(nums[q[0]])
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        prefixMax, suffixMax = [0] * n, [0] * n
        for i in range(n):
            if i % k == 0:
                prefixMax[i] = nums[i]
            else:
                prefixMax[i] = max(prefixMax[i - 1], nums[i])
        for i in range(n - 1, -1, -1):
            if i == n - 1 or (i + 1) % k == 0:
                suffixMax[i] = nums[i]
            else:
                suffixMax[i] = max(suffixMax[i + 1], nums[i])

        ans = [max(suffixMax[i], prefixMax[i + k - 1]) for i in range(n - k + 1)]
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
思路：维护窗口，向右移动时左侧超出窗口的值弹出，

因为需要的是窗口内的最大值，所以只要保证窗口内的值是递减的即可，

小于新加入的值全部弹出。最左端即为窗口最大值 python解法：

class Solution(object):
    def maxSlidingWindow(self, nums, k):
        win, ret = [], []
        for i, v in enumerate(nums):
            if i >= k and win[0] <= i - k: win.pop(0)
            while win and nums[win[-1]] <= v: win.pop()
            win.append(i)
            if i >= k - 1: ret.append(nums[win[0]])
        return ret
```

```py
class MyQueue: #单调队列（从大到小
    def __init__(self):
        self.queue = [] #使用list来实现单调队列
    
    #每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
    #同时pop之前判断队列当前是否为空。
    def pop(self, value):
        if self.queue and value == self.queue[0]:
            self.queue.pop(0)#list.pop()时间复杂度为O(n),这里可以使用collections.deque()
            
    #如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
    #这样就保持了队列里的数值是单调从大到小的了。
    def push(self, value):
        while self.queue and value > self.queue[-1]:
            self.queue.pop()
        self.queue.append(value)
        
    #查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
    def front(self):
        return self.queue[0]
    
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        que = MyQueue()
        result = []
        for i in range(k): #先将前k的元素放进队列
            que.push(nums[i])
        result.append(que.front()) #result 记录前k的元素的最大值
        for i in range(k, len(nums)):
            que.pop(nums[i - k]) #滑动窗口移除最前面元素
            que.push(nums[i]) #滑动窗口前加入最后面的元素
            result.append(que.front()) #记录对应的最大值
        return result
```

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        Q = deque()
        res = []
        for i, n in enumerate(nums):
            while Q and nums[Q[-1]] < n:
                Q.pop()
            Q.append(i)
            if i - k == Q[0]:
                Q.popleft()
            if i >= k - 1:
                res.append(nums[Q[0]])
        return res
```

```scala

/**
* chosen solution 
* using  array deque (double side queue)  which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution0 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
        //you should always delete elements from right side
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* using max heap, may not AC
* pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)} : keep element's time complexity is O(K)
* time complexity: O(N log K)
*/

object Solution1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        var pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
        val rest = scala.collection.mutable.ArrayBuffer[Int]()
        
        nums.zipWithIndex.foreach{case (v: Int, idx: Int) => {
     
            pq += ((v, idx))
            
            /* keep the elements that is only larger than newest v and the nearest k */
            pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)}       

            if (idx + 1 >= k) {
                rest += pq.head._1
            }
          
        }}        
        rest.toArray
    }
}


/**
* may not AC
* fold left version, it is worst than for loop version
*/
object Solution1-2 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
  val (_, rest, _) = nums.zipWithIndex.foldLeft((pq, Array.empty[Int], k)){
    (B, v_id) =>
      val (_pq, rest: Array[Int], _k) = B
      var newPq = _pq
      newPq += v_id
      if(v_id._2 + 1 >= k) {
        newPq = newPq.filter{case (_v:Int, _idx: Int) => (_v >= v_id._1) && (_idx > v_id._2 - k) }
          
         (newPq, rest :+ newPq.head._1, _k)
      }else {
         (newPq, rest, _k)
      }
     
  }
  rest
        
    }
}


/**
* using scala vector, due to scala vector is immutable, any operation about add update remove is generate a new vector
* so it's not a proper substitute for deque
*/

object Solution2 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    var windows = Vector.empty[Int]
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.head <= index - k)
        windows = windows.drop(1)

      while (windows.nonEmpty && nums(windows.last) <= value){
        windows = windows.dropRight(1)
      }
      windows = windows :+ index
      if (index + 1 >= k) {
        ret += nums(windows.head)
      }
    }
    ret.toArray
  }
}

/**
* using java array deque (double side queue) version which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution3 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    import java.util
    val windows = new util.ArrayDeque[Int]  // record nums index
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.peekFirst() <= index - k) {
        // remove out of date element
        windows.removeFirst()
      }

      while (!windows.isEmpty && nums(windows.peekLast()) <= value) {
        // drop the element if  it is smaller than upcoming element
        windows.removeLast()
      }
      windows.add(index)
      if (index + 1 >= k) {
        ret += nums(windows.peekFirst())
      }
    }
    ret.toArray
  }
}

/**
* use scala build-in arrayDeque
*/
object Solution3-1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* brute force, not AC
*/
object Solution4 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        nums.sliding(k).map(_.max).toArray
    }
}
```

###  1.114. <a name='-1'></a>240. 二维数组的查找

[哈哈哈](https://www.bilibili.com/video/BV1dz411i7jC?spm_id_from=333.999.0.0)

```py
import bisect
class Solution:
    def searchMatrix(self, matrix, target):
        for row in matrix:
            idx = bisect.bisect_left(row, target)
            if idx < len(row) and row[idx] == target:
                return True
        return False
```

```py
class Solution(object):
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix:
            return False
        row = len(matrix)
        col = len(matrix[0]) if row else 0 
        m, n = 0, col - 1
        while m < row and n >= 0:
            if matrix[m][n] < target:
                m += 1
            elif matrix[m][n] > target:
                n -= 1
            else:
                return True
        return False

class Solution:
    def searchMatrix(self, matrix, target):
        for row in matrix:
            for element in row:
                if element == target:
                    return True
        return False

# 从右上角开始找，若目标小了就左移，目标大了就下移

class Solution:
    def searchMatrix(self, matrix, target):
        i,j=0,len(matrix[0])-1
        while i<len(matrix) and j>=0:
            if matrix[i][j]==target: return True
            if target<matrix[i][j]: j-=1
            elif target>matrix[i][j]: i+=1
        return False


class Solution:
    def searchMatrix(self, matrix, target):
        m,n=len(matrix),len(matrix[0])
        for i in range(m):
            for j in range(n):
                if matrix[i][j]<target:
                    continue
                elif matrix[i][j]==target:
                    return True 
                else:
                    if j==0:
                        return False 
                    else:
                        break
        return False
# （python）对每一行二分查找
# 分治法。

# 左下角的元素是这一行中最小的元素，同时又是这一列中最大的元素。比较左下角元素和目标：
# 若左下角元素等于目标，则找到
# 若左下角元素大于目标，则目标不可能存在于当前矩阵的最后一行，问题规模可以减小为在去掉最后一行的子矩阵中寻找目标
# 若左下角元素小于目标，则目标不可能存在于当前矩阵的第一列，问题规模可以减小为在去掉第一列的子矩阵中寻找目标
# 若最后矩阵减小为空，则说明不存在
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        if n == 0:
            return False

        i = m - 1
        j = 0
        while i >= 0 and j < n:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                j = j + 1
            else:
                i = i - 1
        return False
class Solution:
    def searchMatrix(self, matrix, target):
        row,col=len(matrix),len(matrix[0])
        for i in range(row):
            left,right=0,col-1
            while left<=right:
                mid=(left+right)//2
                if matrix[i][mid]==target:
                    return True
                elif matrix[i][mid]>target:
                    right=mid-1
                else:
                    left=mid+1
        return False 
```

###  1.115. <a name='ValidAnagram'></a>242. Valid Anagram 

[小梦想家](https://www.bilibili.com/video/BV1Db411s78v?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hV411i73u?spm_id_from=333.999.0.0)

```py
直接返回两个计数器是否相等即可

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)


class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        a = collections.Counter(s)
        b = collections.Counter(t)
        return True if a == b else False
```

```py
Python：

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        record = [0] * 26
        for i in range(len(s)):
            #并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[ord(s[i]) - ord("a")] += 1
        print(record)
        for i in range(len(t)):
            record[ord(t[i]) - ord("a")] -= 1
        for i in range(26):
            if record[i] != 0:
                #record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return False
        return True
Python写法二（没有使用数组作为哈希表，只是介绍defaultdict这样一种解题思路）：

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import defaultdict
        
        s_dict = defaultdict(int)
        t_dict = defaultdict(int)

        for x in s:
            s_dict[x] += 1
        
        for x in t:
            t_dict[x] += 1

        return s_dict == t_dict
```

```scala

/**
* chosen solution
* one line version
* time complexity: O(N)
*/

object Solution0 {
  def isAnagram(s: String, t: String): Boolean = {
   s.groupBy(identity).mapValues(_.length).toMap == t.groupBy(identity).mapValues(_.length).toMap  // toMap: transform MapView to Map

  }
}


/**
* my first commit
* time complexity: O(N)
*/

object Solution1 {
  def isAnagram(s: String, t: String): Boolean = {
    charCounter(s) equals charCounter(t)
  }
  private def charCounter(str: String): Map[Char, Int] = {
    str.foldLeft(collection.mutable.Map.empty[Char, Int]) {
      (map, s) =>
        map.get(s) match {
          case Some(e) =>
            map.update(s, e + 1)
            map
          case None =>
            map.update(s, 1)
            map
        }
    }.toMap
  }
}



```

```scala
//Time complexity( O(NlogN + N))
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        if(arr1.size != arr2.size){
            false
        } else{
            java.util.Arrays.sort(arr1)
            java.util.Arrays.sort(arr2)
            
            var flag = true
            import scala.util.control.Breaks._
            var index = 0
            breakable{
            while(index < arr1.size){
                if(arr1(index) != arr2(index)){
                    flag = false
                    break
                }
                index += 1
            }
            }
            flag
        }
    }
}

//Time complexity O(n)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        
        if(arr1.size != arr2.size){
            false
        } else{
            var map = scala.collection.mutable.Map.empty[Char, Int]
            for(elem <- arr1){
                map.get(elem) match{
                    case Some(count) => map += (elem -> (count+1))
                    case None => map += (elem -> 1)
                }
            }
            
            for(elem <- arr2){
                map.get(elem) match{
                    case Some(count) if count == 1 => map.remove(elem)
                    case Some(count) => map += (elem -> (count-1))
                    case None => ()
                }
            }
            
            if(map.keys.isEmpty) true else false
        }
    }
}

//One more: O(N)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        if(s.size != t.size){
            false
        }else{
        var arr = Array.fill(26)(0)
        for(elem <- s){
            arr(elem - 'a') += 1
        }
        
        import scala.util.control.Breaks._
        var flag = true
        breakable{
        for(elem <- t){
            arr(elem - 'a') -= 1
            if(arr(elem - 'a') < 0){
                flag = false
                break
            }
        }
        }
        flag
    }
    }
}

```

###  1.116. <a name='ShortestWordDistance'></a>243. Shortest Word Distance

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Ae?spm_id_from=333.999.0.0)

###  1.117. <a name='StrobogrammaticNumber'></a>246. Strobogrammatic Number

[小梦想家](https://www.bilibili.com/video/BV14b411g7zD?spm_id_from=333.999.0.0)

###  1.118. <a name='-1'></a>257-二叉树的所有路径

[哈哈哈](https://www.bilibili.com/video/BV1rf4y1X7He?spm_id_from=333.999.0.0)

```py
class Solution:
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        def construct_paths(root, path):
            if root:
                path += str(root.val)
                if not root.left and not root.right:  # 当前节点是叶子节点
                    paths.append(path)  # 把路径加入到答案中
                else:
                    path += '->'  # 当前节点不是叶子节点，继续递归遍历
                    construct_paths(root.left, path)
                    construct_paths(root.right, path)

        paths = []
        construct_paths(root, '')
        return paths

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        paths = list()
        if not root:
            return paths

        node_queue = collections.deque([root])
        path_queue = collections.deque([str(root.val)])

        while node_queue:
            node = node_queue.popleft()
            path = path_queue.popleft()

            if not node.left and not node.right:
                paths.append(path)
            else:
                if node.left:
                    node_queue.append(node.left)
                    path_queue.append(path + '->' + str(node.left.val))
                
                if node.right:
                    node_queue.append(node.right)
                    path_queue.append(path + '->' + str(node.right.val))
        return paths

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python3 最好理解的递归实现

class Solution:
            
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root:
            return []
        if not root.left and not root.right:
            return [str(root.val)]
        paths = []
        if root.left:
            for i in self.binaryTreePaths(root.left):
                paths.append(str(root.val) + '->' + i)
        if root.right:
            for i in self.binaryTreePaths(root.right):
                paths.append(str(root.val) + '->' + i)
        return paths  
paths 递归每调用一次要创建一个以便给上一层遍历（叠加）
调用self.binaryTreePaths(root.left)得到的是左子树的全部路径，加入左子树为[1,2,3],那么得到的结果是[1,2],[1,3]两组，然后还要和根节点进行拼接，所以要用循环。
```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//Given a binary tree, return all root-to-leaf paths.
//
//Note: A leaf is a node with no children.
//
//Example:
//
//Input:
//
//1
///   \
//2     3
//\
//5
//
//Output: ["1->2->5", "1->3"]
//
//Explanation: All root-to-leaf paths are: 1->2->5, 1->3

package lc0257 {

  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def binaryTreePaths(root: TreeNode): List[String] = {
      val tmp = ArrayBuffer[Int]()
      val ret =ArrayBuffer[ArrayBuffer[Int]]()
      helper(root, tmp, ret)
      ret.toList.map({
        x=>x.mkString("->")
      })
    }

    def helper(node:TreeNode,tmp:ArrayBuffer[Int],ret:ArrayBuffer[ArrayBuffer[Int]]): Unit = {
      if (node==null) {
        return
      }

      tmp += node.value

      if (node.left == null && node.right==null) {
          ret += tmp.clone()
      } else {
        helper(node.left, tmp, ret)
        helper(node.right, tmp, ret)
      }
      tmp.remove(tmp.length-1)
    }
  }

  class Test extends BaseExtension {
    def init {
      val t1 = Tree.build(IndexedSeq("1","2 3","5 N N N"))
      println(Solution.binaryTreePaths(t1))
    }
    val name = "257 binary tree path"
  }
}

```

###  1.119. <a name='AddDigits'></a>258. Add Digits

[小梦想家](https://www.bilibili.com/video/BV1ub41137cm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N54y1B7XU?spm_id_from=333.999.0.0)

```py
除了传统的单纯循环，还可以找规律。

假如一个三位数'abc'，其值大小为s1 = 100 * a + 10 * b + 1 * c，

经过一次各位相加后，变为s2 = a + b + c，减小的差值为(s1 -s2) = 99 * a + 9 * b，

差值可以被9整除，每一个循环都这样，缩小了9的倍数。

当num小于9，即只有一位时，直接返回num，

大于9时，如果能被9整除，则返回9

（因为不可能返回0也不可能返回两位数及以上的值），

如果不能被整除，就返回被9除的余数。

class Solution:
    def addDigits(self, num: int) -> int:
        if num > 9:
            num = num % 9
            if num == 0:
                return 9
        return num

class Solution:
    def addDigits(self, num: int) -> int:
        while num>9:
            num=sum([int(c) for c in str(num)])
        return num
```

```py
但对于Python来说，% 取余运算是对整体进行运算，结果是非负数，故 -10 % 9 = 8，所以上述逻辑在Python中有小瑕疵，需提前进行判断，代码如下：

class Solution:
    def addDigits(self, num: int) -> int:
        return (num - 1) % 9 + 1 if num >= 10 else num

class Solution:
    def addDigits(self, num: int) -> int:
        return num - int((num - 1) / 9) * 9
```

###  1.120. <a name='III-1'></a>260-只出现一次的数字 III

[哈哈哈](https://www.bilibili.com/video/BV15Z4y1H7Sw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK411J7dN?spm_id_from=333.999.0.0)

```py
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        freq = Counter(nums)
        return [num for num, occ in freq.items() if occ == 1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/single-number-iii/solution/zhi-chu-xian-yi-ci-de-shu-zi-iii-by-leet-4i8e/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        xorsum = 0
        for num in nums:
            xorsum ^= num
        
        lsb = xorsum & (-xorsum)
        type1 = type2 = 0
        for num in nums:
            if num & lsb:
                type1 ^= num
            else:
                type2 ^= num
        
        return [type1, type2]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/single-number-iii/solution/zhi-chu-xian-yi-ci-de-shu-zi-iii-by-leet-4i8e/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

思路, 先全部异或一次, 得到的结果, 考察其的某个非0位(比如最高非0位), 那么只出现一次的两个数中, 在这个位上一个为0, 一个为1, 由此可以将数组中的元素分成两部分,重新遍历, 求两个异或值

class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        acc = 0
        for i in nums:
            acc ^=i
        n = len(bin(acc))-3
        a,b=0,0
        for i in nums:
            if i>>n&1:
                a^=i
            else:
                b^=i
        return b,a

 为什么使用的是len(bin(acc))-3呢？在为负数的时候，应该如何理解呢？
 就是求二进制位不相同在哪一位: 如果是两个正数,就是最高位, 如果是两个负数,那么就是对应补码的最低数, 如果一正一负, 那么就是正数最高位+1.

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        return [k for k,v in collections.Counter(nums).items() if v == 1]    
```

###  1.121. <a name='UglyNumber'></a>263 Ugly Number

[花花酱](https://www.bilibili.com/video/BV11W411C7zd?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Mb41157Pa?spm_id_from=333.999.0.0)

```py
class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False

        factors = [2, 3, 5]
        for factor in factors:
            while n % factor == 0:
                n //= factor
        
        return n == 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/ugly-number/solution/chou-shu-by-leetcode-solution-fazd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
思路一：递归

class Solution:
    def isUgly(self, num: int) -> bool:
        if num == 0: return False
        if num == 1:return True
        if num % 2 == 0: return self.isUgly(num // 2)
        if num % 3 == 0: return self.isUgly(num // 3)
        if num % 5 == 0: return self.isUgly(num // 5)
        return False
思路二：迭代

class Solution:
    def isUgly(self, num: int) -> bool:
        for p in 2, 3, 5:
            while num % p == 0 < num:
                num //= p
        return num == 1

菜鸡想问问 num % p == 0 < num: 这里为啥要加一个<num呢？ 不加会超时，没搞懂原理😥
防止num为0时无限循环
```

###  1.122. <a name='UglyNumberII'></a>264. Ugly Number II

[花花酱](https://www.bilibili.com/video/BV1yW411C7Sm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vT4y1775u?spm_id_from=333.999.0.0)

```py
# python 实习面试这道题挂了，但我就不懂了，第一次见这题目谁能想到3指针的方法？

class Solution(object):
    def nthUglyNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        res = [1]
        idx2 = 0
        idx3 = 0
        idx5 = 0
        for i in range(n-1):
            res.append(min(res[idx2]*2,res[idx3]*3,res[idx5]*5))
            if res[-1] == res[idx2]*2:
                idx2 += 1
            if res[-1] == res[idx3]*3:
                idx3 += 1
            if res[-1] == res[idx5]*5:
                idx5 += 1
        return res[-1]

# 就这？好清晰，牛的牛的

class Solution(object):
    def nthUglyNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        a,b,c = 0,0,0
        dp = [0]*n
        dp[0] = 1
        for i in range(1,n):
            dp[i] = min(dp[a]*2,dp[b]*3,dp[c]*5)
            if dp[i] == dp[a]*2:
                a += 1
            if dp[i] == dp[b]*3:
                b += 1
            if dp[i] == dp[c]*5:
                c += 1
        return dp[n-1]

class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[1] = 1
        p2 = p3 = p5 = 1

        for i in range(2, n + 1):
            num2, num3, num5 = dp[p2] * 2, dp[p3] * 3, dp[p5] * 5
            dp[i] = min(num2, num3, num5)
            if dp[i] == num2:
                p2 += 1
            if dp[i] == num3:
                p3 += 1
            if dp[i] == num5:
                p5 += 1
        
        return dp[n]
# 还可以优化：
# 根据页面hint 来做的
class Solution(object):
    def nthUglyNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1
        else:
            import collections
            q2 = collections.deque()
            q3 = collections.deque()
            q5 = collections.deque()
            q2.append(2)
            q3.append(3)
            q5.append(5)
            while n > 1:
                    x = min(q2[0],q3[0],q5[0])
                    if x == q2[0]:
                            x = q2.popleft()
                            q2.append(2*x)
                            q3.append(3*x)
                            q5.append(5*x)
                    elif x == q3[0]:
                            x = q3.popleft()
                            q3.append(3*x)
                            q5.append(5*x)
                    else:
                            x = q5.popleft()
                            q5.append(5*x)
                    n -= 1
            return x
```

###  1.123. <a name='MissingNumber'></a>268 Missing Number

[小明](https://www.bilibili.com/video/BV1LU4y1p7n7?spm_id_from=333.999.0.0)

```py
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        nums.sort()
        for i, num in enumerate(nums):
            if num != i:
                return i
        return len(nums)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/missing-number/solution/diu-shi-de-shu-zi-by-leetcode-solution-naow/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        s = set(nums)
        for i in range(len(nums) + 1):
            if i not in s:
                return i

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/missing-number/solution/diu-shi-de-shu-zi-by-leetcode-solution-naow/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        xor = 0
        for i, num in enumerate(nums):
            xor ^= i ^ num
        return xor ^ len(nums)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/missing-number/solution/diu-shi-de-shu-zi-by-leetcode-solution-naow/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        total = n * (n + 1) // 2
        arrSum = sum(nums)
        return total - arrSum

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/missing-number/solution/diu-shi-de-shu-zi-by-leetcode-solution-naow/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

```py
（python）排序比较 O(n*logn)

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res=0
        nums.sort()
        n=len(nums)
        for i in range(n):
            if res==nums[i]:
                res+=1
            else:
                return res 
        return n 
（python）集合做差 O(n)

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        a=set(nums)
        b=set()
        for i in range(len(nums)+1):
            b.add(i)
        return list(b-a)[-1]

利用集合的方法时间复杂度更低一些，感谢提醒

开始不认真看题目以为求出所有，所以用两个集合求差集，然后发现结果只有一个数，就改了下

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        return list({i for i in range(0, len(nums)+1)} - set(nums))[0]

进阶解法 用可能出现的所有数的和 - 实际出现的数的和 = 未出现的数 res

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = len(nums)
        # 用可能出现的所有数(n + range(n))的和 - 实际出现的数 nums 的和 = 未出现的数 res
        for i, num in enumerate(nums) :
            res += i - num
        return res

如果直接求和的最大的和为 49995000 未超出 int 的范围 

(虽然 python 本来就不怎么考虑范围(手动狗头))， 

所以可以直接计算，注意让 n * (n+1) 计算后再 / 2 以避免奇数整除2后导致结果错误

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        return (len(nums) + 1) * len(nums) // 2 - sum(nums) 

Python 前n项和减去数组总和

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n=len(nums)
        return n*(n+1)//2-sum(nums)
```

```scala
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        val idealSum = (size * (size + 1))/2
        
        val arraySum = nums.foldLeft(0)(_ + _) // can also use nums.sum
        
        idealSum - arraySum
    }
}

//Removing foldLeft improved time
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        var idealSum = (size * (size + 1))/2
        
        for(num <- nums){
            idealSum -= num
        }

        idealSum
    }
}

```

###  1.124. <a name='ClosestBinarySearchTreeValue'></a>270. Closest Binary Search Tree Value

[哈哈哈](https://www.bilibili.com/video/BV1zy4y1a7mR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1fi4y1u7Sb?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.125. <a name='H-Index'></a>274 H-Index

[小明](https://www.bilibili.com/video/BV1ZV411z7Kx?spm_id_from=333.999.0.0)


###  1.126. <a name='FirstBadVersion'></a>278. First Bad Version

[小梦想家](https://www.bilibili.com/video/BV1rZ4y1P7YF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1cQ4y1N7dc?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        left = 1
        right = n
        while left < right:
            mid = left + (right - left) // 2
            if isBadVersion(mid) == True:
                right = mid
            else:
                left = mid + 1
        return right
```

```py
class Solution:
    def firstBadVersion(self, n):
        if isBadVersion(1) == True:
            return 1
        else:

            left = 1
            right = n
            while right - left > 1:
                k = int((left + right) / 2)
                if isBadVersion(k) == False:
                    left = k
                else:
                    right = k
            return right
```

```scala
/* The isBadVersion API is defined in the parent class VersionControl.
      def isBadVersion(version: Int): Boolean = {} */



/**
* my first commitment
* binary search recursive version
* time complexity
*   log(n)
*/
class Solution1 extends VersionControl {
    def firstBadVersion(n: Int): Int = {
        search(1, n)
    }
  
    def search(left: Int, right: Int): Int  = {
      if (left > right) return -1
       /**
      * it's bad version from mid to n, we could keep right side a bad version
      * the we return left side index as left index equals to right index
      */
      if (left == right) return left
      
      val mid = left + (right - left) / 2
      if (isBadVersion(mid))
     
        search(left, mid) 
      else
        search(mid + 1, right)
    }
}

```

###  1.127. <a name='PerfectSquares'></a>279 Perfect Squares

[小明](https://www.bilibili.com/video/BV1r5411Y7MH?spm_id_from=333.999.0.0)

```py
# 动态规划

# ```
# 1. 初始化 inf 从0开始，所以数组长度 n+1 
# 2. 考虑到是平方，意味着他的间隔可能是跳跃性的，所以 
#         n  =   (n-j*j)  + j*j
#         dp[i] = dp[i-1] + 1
# 3. 那么 min 就是未来找到最小值而存在的，因为需要遍历很多个平方， dp[i] 用户存储最小值
# 4. 返回 dp[-1] 的结果，也就是最终 n 的值
# ```

# ```python
class Solution(object):
    def numSquares(self, n) -> int:
        square_nums = [i**2 for i in range(1, int(n**0.5)+1)]
        dp = [float('inf')] * (n+1)
        dp[0] = 0
        for i in range(1, n+1):
            for square in square_nums:
                if i < square:
                    break
                # print("%s --- %s结果需要一次 --- %s结果需要%s次" % (i, square, i-square, dp[i-square]))
                dp[i] = min(dp[i], dp[i-square] + 1)
        return dp[-1]

# 我会背包了 我真牛逼！ 打开评论 我是s逼
# 超时，最后测试用例7217
class Solution:
    def numSquares(self, n) -> int:
        goods = []
        for i in range(1,101):
            goods.append(i * i)
        dp = [float('inf')] * (n + 1)
        dp[0] = 0
        for g in goods:
            for j in range(1,n+1):
                if j - g >= 0:
                    dp[j] = min(dp[j-g] + 1,dp[j])
        return dp[n]
# Python：

class Solution:
    def numSquares(self, n) -> int:
        '''版本一，先遍历背包, 再遍历物品'''
        # 初始化
        nums = [i**2 for i in range(1, n + 1) if i**2 <= n]
        dp = [10**4]*(n + 1)
        dp[0] = 0
        # 遍历背包
        for j in range(1, n + 1):
            # 遍历物品
            for num in nums:
                if j >= num:
                    dp[j] = min(dp[j], dp[j - num] + 1)
        return dp[n]
 class Solution:
    '''版本一，先遍历背包, 再遍历物品'''
    def numSquares(self, n) -> int:
        dp = [n] * (n + 1)
        dp[0] = 0
        # 遍历背包
        for j in range(1, n+1):
            for i in range(1, n):
                num = i ** 2
                if num > j: break
                # 遍历物品
                if j - num >= 0:
                    dp[j] = min(dp[j], dp[j - num] + 1)
        return dp[n]   
 class Solution:
    def numSquares1(self, n) -> int:
        '''版本二， 先遍历物品, 再遍历背包'''
        # 初始化
        nums = [i**2 for i in range(1, n + 1) if i**2 <= n]
        dp = [10**4]*(n + 1)
        dp[0] = 0
        # 遍历物品
        for num in nums:
            # 遍历背包
            for j in range(num, n + 1):
                dp[j] = min(dp[j], dp[j - num] + 1)
        return dp[n]
# 有没有python用动态规划超时的兄弟。
# 
class Solution:
    def numSquares(self, n) -> int:
        f = [float('inf')] * (n+1)
        f[0] = 0
        for  i in range(1,n+1):
            i_sqrt = i**0.5
            j = 1
            while j <= i_sqrt:
                f[i] = min(f[i],f[i-j**2]+1)
                j += 1
        return f[n]
class Solution:
    def numSquares(self, n) -> int:
        """
        完全背包问题： f[i][j]: 前i个物品，占据j空间最少可以放几个。
        f[i][j] = min(f[i - 1][j], f[i][j - v[i] + w[i], ..., f[i][j - k * v[i]] + k * w[i])
        = min(f[i-1][j], f[i][j - v[i] + w[i]])
        空间优化之后得到：
        f[i] = min(f[i], f[i- v[i] + w[i]])
        """
        f = [n] * (n + 1)
        f[0] = 0
        for i in range(1, n + 1):
            j = 1
            while j * j <= i:
                f[i] = min(f[i], f[i - j * j] + 1)
                j += 1
        return f[n]
```


```py
# 执行时间7256ms，在超时的边缘反复横跳
from math import ceil
class Solution:
    def numSquares(self, n) -> int:

        def f(n):
            if n <= 3:
                return n
            # if n is square itself
            if sqrt(n) % 1 == 0:
                return 1
            return min(
                (f(n - i**2) + 1 for i in reversed(range(1, ceil(sqrt(n)))))
            )

        return f(n)
```

```py
# 四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。 

# 推论：满足四数平方和定理的数n（四个整数的情况），必定满足 n=4^a(8b+7)

class Solution:
    def numSquares(self, n):
            """
            :type n
            :rtype
            """
            while n % 4 == 0: 
                n /= 4 
            if n % 8 == 7: 
                return 4 
            a = 0 
            while a**2 <= n: 
                b = int((n - a**2)**0.5) 
                if a**2 + b**2 == n: 
                    return (not not a) + (not not b) 
                a += 1 
            return 3
# 一个解题合集，欢迎小伙伴一起
```

###  1.128. <a name='ExpressionAddOperators'></a>282. Expression Add Operators

[花花酱](https://www.bilibili.com/video/BV15W411C727?spm_id_from=333.999.0.0)

###  1.129. <a name='MoveZeros'></a>283. Move Zeros

[小梦想家](https://www.bilibili.com/video/BV1m441187Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ba4y1t7eK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Wp4y1y7pT?spm_id_from=333.999.0.0)

```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        n = len(nums)
        left = right = 0
        while right < n:
            if nums[right] != 0:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
            right += 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

年轻人不讲五的~

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # way1: Time:19.38 Space:55.79
        n_zero = nums.count(0)  # O(n)
        while n_zero > 0:
            nums.remove(0)  # O(n)
            nums.append(0)  # O(1)
            n_zero -= 1

        # way2: Time:87.76 Space:28.35
        # key的值是bool，也就是只对0排序，非零的1，3，12不排序。
        # 用lambda x:x!=0 也一样。
        nums.sort(key=bool, reverse=True)

想到的第一个方法是用pop

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        j=0
        for i in range(len(nums)):
            if nums[j]==0:
                nums.pop(j)
                nums.append(0)
            else:
                j+=1
```

```py
直接遍历，后面补0，找到的0删除

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        i = 0
        while i < n:
            if nums[i] == 0:
                nums.append(0)
                del nums[i]
                i -=1
                n-=1
            i += 1

python3，三行搞定

时间复杂度分析 remove() ---> O(N) ，append() --> O(1) count()---> O(N)---- 整体= O(3N)

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        for i in range(nums.count(0)):
            nums.remove(0)
            nums.append(0)

Python 1行

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.sort(key=bool, reverse=True)

设置一个index，遇到不是0的数就和index位置的数交换，然后index加一，python：

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        index = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[index], nums[i] = nums[i], nums[index]
                index += 1

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0:
                nums[slow] = nums[fast]
                slow += 1
        for i in range(slow, len(nums)):
            nums[i] = 0
```

```scala
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        var p1 = 0
        var p2 = 0
        while(p1 < nums.size && p2 < nums.size){
            if(nums(p1) == 0 && nums(p2) != 0 && p1<p2){
                nums(p1) = nums(p2)
                nums(p2) = 0
                p1 += 1
                p2 += 1
            } else if(nums(p1) != 0 && nums(p2) != 0){
                p1 += 1
            }else{
                p2 += 1
            }
        }
    }
}

//Alternate solution: calculate the number of shifts 
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        
        var zeroCount = 0
        //count of zero is amount character is shifted to left
        //from first zero position traverse array left
        for(a <- 0 to nums.size-1){   
            //count zeroes and shift when not zero
            if(nums(a) == 0){
                zeroCount = zeroCount + 1
            }else if(zeroCount>0){
                //shift left if not 0 by zeroCount
                nums(a-zeroCount) = nums(a)
                nums(a) = 0
            }
        }
    }
}

```

```scala
package com.zhourui.leetcode

package lc0283_movezero {
  object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
//      nums.foldLeft(0) {
//        case (w,b) => {
//          if (b!=0) {
//            nums(w) = b
//
//            w+1
//          } else w
//        }
//      }

      nums.indices.foldLeft(0) {
        case (acc, e) => {
          if (nums(e)!=0) {
            val tmp = nums(e)
            nums(e) = nums(acc)
            nums(acc) = tmp
            acc+1
          } else acc
        }
      }
    }
  }
}

/*
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int w = 0;
        for (int i = 0; i< nums.size(); i++) {
            if (nums[i]!=0) {
                swap(nums[w++], nums[i]);
            }
        }
    }
};
 */

```

###  1.130. <a name='PeekingIterator'></a>284 Peeking Iterator

[小明](https://www.bilibili.com/video/BV1LN411R7U7?spm_id_from=333.999.0.0)

###  1.131. <a name='FindtheDuplicateNumber'></a>287 Find the Duplicate Number

[小明](https://www.bilibili.com/video/BV1Ug4y1v7mF?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pz4y1X7qR?spm_id_from=333.999.0.0)

```py
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        #数组只能读 所以不能排序,不能swap数组下标
        #时间复杂度小于 O(n^2) 不能暴力
        #空间复杂度 O(1) 不能额外开辟数组
        
        ''' 1、暴力不符合题意
        for i in nums:
            count = 0
            for num in nums:
                if num == i:
                    count += 1
            if count > 1:
                return i
        return -1
        '''
        
        '''2、小于O(n^2) 二分查找
        我们不要考虑数组,只需要考虑 数字都在 1 到 n 之间
        示例 1:
        arr = [1,3,4,2,2] 此时数字在 1 — 5 之间

        mid = (1 + 5) / 2 = 3 arr小于等于的3有4个(1,2,2,3)，1到3中肯定有重复的值
        mid = (1 + 3) / 2 = 2 arr小于等于的2有3个(1,2,2)，1到2中肯定有重复的值
        mid = (1 + 2) / 2 = 1 arr小于等于的1有1个(1)，2到2中肯定有重复的值
        所以重复的数是 2 
        '''
        left = 1
        right = len(nums)
        while left < right:
            mid = int(left + (right - left)/2)
            cnt = 0
            for num in nums:
                if num <= mid:
                   cnt += 1
            if cnt <= mid:
                left = mid + 1
            else:
                right = mid
        return right

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        low, high = 1, len(nums) - 1
        while low <= high:
            mid = (low + high) >> 1
            cnt = sum(x <= mid for x in nums)
            if cnt > mid:
                high = mid - 1
            else:
                low = mid + 1

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = {}
        # dic = dict()
        for n in nums:
            dic[n] = dic.get(n, 0) + 1
            print(dic)
            if dic[n] >= 2:
                return n
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        print(set(nums))
        return (sum(nums)-sum(set(nums)))//(len(nums) - len(set(nums)))
```

###  1.132. <a name='GameofLife'></a>289. Game of Life

[花花酱](https://www.bilibili.com/video/BV14W411d7ji?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hp4y1B7D5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vz4y1R7DJ?spm_id_from=333.999.0.0)

```py
# 生命在于调库

import numpy as np
from scipy import signal
class Solution:
    def gameOfLife(self, board):
        arr = np.array(board)
        mask = np.ones((3,3))
        mask[1, 1] = 0
        around = signal.convolve2d(arr, mask, mode='same')
        arr[around < 2] = 0
        arr[around == 3] = 1
        arr[around > 3] = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                board[i][j] = arr[i, j]

        return board

# 卷积法

from scipy.signal import convolve2d
import numpy as np
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """
        b=np.array(board)
        x=convolve2d(b,[[1,1,1],[1,10,1],[1,1,1]],'same')
        board[:]=b*(x//2==6)+(x==3)
        return board
```

```py
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """

        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        rows = len(board)
        cols = len(board[0])

        # 从原数组复制一份到 copy_board 中
        copy_board = [[board[row][col] for col in range(cols)] for row in range(rows)]

        # 遍历面板每一个格子里的细胞
        for row in range(rows):
            for col in range(cols):

                # 对于每一个细胞统计其八个相邻位置里的活细胞数量
                live_neighbors = 0
                for neighbor in neighbors:

                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # 查看相邻的细胞是否是活细胞
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and (copy_board[r][c] == 1):
                        live_neighbors += 1

                # 规则 1 或规则 3        
                if copy_board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    board[row][col] = 0
                # 规则 4
                if copy_board[row][col] == 0 and live_neighbors == 3:
                    board[row][col] = 1
        return board

class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """

        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        rows = len(board)
        cols = len(board[0])

        # 遍历面板每一个格子里的细胞
        for row in range(rows):
            for col in range(cols):

                # 对于每一个细胞统计其八个相邻位置里的活细胞数量
                live_neighbors = 0
                for neighbor in neighbors:

                    # 相邻位置的坐标
                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # 查看相邻的细胞是否是活细胞
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and abs(board[r][c]) == 1:
                        live_neighbors += 1

                # 规则 1 或规则 3 
                if board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    # -1 代表这个细胞过去是活的现在死了
                    board[row][col] = -1
                # 规则 4
                if board[row][col] == 0 and live_neighbors == 3:
                    # 2 代表这个细胞过去是死的现在活了
                    board[row][col] = 2

        # 遍历 board 得到一次更新后的状态
        for row in range(rows):
            for col in range(cols):
                if board[row][col] > 0:
                    board[row][col] = 1
                else:
                    board[row][col] = 0
        return board

class Solution(object):
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        row = len(board)
        col = len(board[0]) if row else 0

        dx = [-1,-1,-1,0,1,1,1,0]
        dy = [-1,0,1,1,1,0,-1,-1]
    
        for i in range(row):
            for j in range(col):
                cnt = 0
                for k in range(8):
                    x, y = i + dx[k], j + dy[k]
                    if x >=0 and x < row and y >=0 and y < col and (board[x][y] == 1  or board[x][y] == 2):
                        cnt += 1

                if board[i][j] and (cnt < 2 or cnt > 3):
                    board[i][j] = 2
                elif board[i][j] == 0 and cnt == 3:
                    board[i][j] = 3

        for i in range(row):
            for j in range(col):
                board[i][j] %= 2
        return board
```

###  1.133. <a name='WordPattern'></a>290. Word Pattern

[小梦想家](https://www.bilibili.com/video/BV1d4411V7mi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1N7wD?spm_id_from=333.999.0.0)

```py
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        word2ch = dict()
        ch2word = dict()
        words = s.split()
        if len(pattern) != len(words):
            return False
        
        for ch, word in zip(pattern, words):
            if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word):
                return False
            word2ch[word] = ch
            ch2word[ch] = word
    
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/word-pattern/solution/dan-ci-gui-lu-by-leetcode-solution-6vqv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

1.205题假设s与t长度相等，这道题需要处理pattern和s长度不一样的情况

2.本题需要将s分隔成单个单词

其它部分都一样，加两行代码即可，总共三行代码：

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        if len(pattern) != len(words): return False
        return len(set(pattern)) == len(set(words)) == len(set(zip(pattern,words)))

简答思路-->字典类型

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        d=dict()
        s=s.split()
        if len(pattern)!=len(s):return False

        for x in range(len(pattern)):
            if pattern[x] not in d and s[x] not in d.values():
                d[pattern[x]]=s[x]
            elif pattern[x] in d and  d[pattern[x]]==s[x]:
                pass
            else : return False
        return True
```


```py
两种思路： 思路一：哈希表双射，这个更快，就是两边的键按照顺序录入，但是值要进行交换，要是在对比过程中这个键出现过，但是值不同就为false

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s = s.split(' ')
        pi = {}; si = {}
        if len(pattern) != len(s): return False
        for i, j in zip(pattern, s):
            if (i in pi and pi[i] != j) or (j in si and si[j] != i): return False
            else: 
                pi[i] = j
                si[j] = i
        return True
思路二：这个思路是看评论区的，非常有意思，就是利用了index函数只返回第一个满足条件的索引的情况，然后进行比较

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s = s.split(' ')
        pi = [pattern.index(i) for i in pattern]
        si = [s.index(i) for i in s]
        return True if pi == si else False

python3中一种比较讨巧的解法：

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        pi = []
        si = []
        for v in pattern:
            pi.append(pattern.index(v))
            
        ss = s.split(' ')
        for v in ss:
            si.append(ss.index(v))

        if si == pi:
            return True
        else:
            return False

在大佬的基础上简化一下代码

class Solution:
    def wordPattern(pattern, s):
        if len(s.split(' ')) != len(pattern):
            return False
        ss = s.split(' ')
        listP,listS = [pattern.index(i) for i in pattern],[ss.index(j) for j in ss]
        return listP == listS
```


###  1.134. <a name='SerializeandDeserializeBinaryTree'></a>297. Serialize and Deserialize Binary Tree

[花花酱](https://www.bilibili.com/video/BV1Hb411c7cr?spm_id_from=333.999.0.0)

###  1.135. <a name='BullsandCows'></a>299. Bulls and Cows

[小梦想家](https://www.bilibili.com/video/BV1M64y1M7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1bh411R7n4?spm_id_from=333.999.0.0)

```py
from collections import defaultdict
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        n = len(secret)
        s, g = defaultdict(int), defaultdict(int)
        a, b = 0, 0
        for i in range(n) :
            l,r = secret[i], guess[i]
            if l == r :
                a += 1
            else :
                s[l] += 1
                g[r] += 1
        for k,v in s.items() :
            b += min(v, g[k])
        return str(a) + 'A' + str(b) + 'B'

# python
#  你这甚至不如sort之后再一个一个匹配，算两遍不麻烦嘛
#  sort之后一一匹配相等元素对么，那你如何知道bull个数？
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        secret_list = list(secret)
        guess_list = list(guess)

        # 先遍历一遍统计bull
        bull = 0
        for i in range(len(secret_list)):
            if secret_list[i] == guess_list[i]:
                bull += 1
        
        # 再遍历统计一共有多少个相等的元素对
        cow = 0
        for ch in secret_list:
            if ch in guess_list:
                cow += 1
                guess_list.remove(ch)

        # cow - bull 即为真正的 cow
        return str(bull) + 'A' + str(cow-bull) + 'B'

# 做了两次才做出来，需要注意：

# 调整位置时，位置只能用一次 比如1123 1011 输出的是1A1B而不是1A2B

# 先计算公牛（数字和位置都匹配），比如1122 1222 输出的是 3A0B而不是3A1B

class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        a = b = 0
        hashmap = collections.Counter(secret)
        for x, y in zip(secret, guess):
            if x == y:
                a += 1
                hashmap[x] -= 1
        for x, y in zip(secret, guess):
            if x != y:
                if y in hashmap:
                    if hashmap[y] > 0:
                        b += 1
                    hashmap[y] -= 1
        return f'{a}A{b}B'

from collections import Counter
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bull = sum(secret[i] == guess[i] for i in range(len(secret)))
        cow = sum((Counter(secret) & Counter(guess)).values()) - bull
        return f'{bull}A{cow}B'

# 都这么短。。。。。
# 我Python还是用的不行啊
import operator
class Solution(object):
    def getHint(self, secret, guess):
        """
        :type secret: str
        :type guess: str
        :rtype: str
        """
        bull = sum(map(operator.eq, secret, guess))
        sa = collections.Counter(secret)
        sb = collections.Counter(guess)
        cow = sum((sa & sb).values()) - bull
        return str(bull) + 'A' + str(cow) + 'B'
```

###  1.136. <a name='LongestIncreasingSubsequence'></a>300 Longest Increasing Subsequence 最长上升子序列

[花花酱](https://www.bilibili.com/video/BV1Wf4y1y7ou?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1rT4y1u7jV?spm_id_from=333.999.0.0)

```py
# 贪心 + 二分查找

class Solution:
    def lengthOfLIS(self, nums):
        d = []
        for n in nums:
            if not d or n > d[-1]:
                d.append(n)
            else:
                l, r = 0, len(d) - 1
                loc = r
                while l <= r:
                    mid = (l + r) // 2
                    if d[mid] >= n:
                        loc = mid
                        r = mid - 1
                    else:
                        l = mid + 1
                d[loc] = n
        return len(d)

class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        dp = [1 for i in range(len(nums))]
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[j]+1, dp[i])
        return max(dp)

class Solution:
    def lengthOfLIS(self, nums):
        if len(nums) <= 1:
            return len(nums)
        dp = [1] * len(nums)
        result = 0
        for i in range(1, len(nums)):
            for j in range(0, i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
            result = max(result, dp[i]) #取长的子序列
        return result

class Solution:
    def lengthOfLIS(self, nums):
        if not nums:
            return 0
        dp = []
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

```scala



/**
* chosen answer
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution0 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}

/**
* brute force : not Ac
* memo:
* 1. each position have two choice :
*    1. take current value if currentIdx value > previousIdx value 
*    2. do not take current value
* time complexity: O(2^n)
*/
object Solution1 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        lengthOfLIS(nums, 0, -1)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int): Int = {
      if (currentIdx >= nums.length) return 0
      
      val taken = if (previousIdx == -1  ||  (nums(currentIdx) > nums(previousIdx))) {
        lengthOfLIS(nums, currentIdx + 1, currentIdx) + 1
      } else {
        0
      } 
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx)
      taken max nonTaken
    }
}

/**
* with memorized: we just fill the nxn dimension memory array
* time complexity: O(n^2)
* space complexity: O(n^2)
*/
object Solution1-2 {
    def lengthOfLIS(nums: Array[Int]): Int = {
      val memory = Array.fill[Int](nums.length, nums.length)(-1)
      lengthOfLIS(nums, 0, -1, memory)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int, memory: Array[Array[Int]]): Int  = {
      // println(currentIdx, previousIdx)
      if (nums.length == currentIdx) return 0
      if (memory(currentIdx)(previousIdx + 1) != -1) return memory(currentIdx)(previousIdx + 1)
      
      val taken = if (previousIdx == -1 || nums(currentIdx) > nums(previousIdx)) {
        1 + lengthOfLIS(nums, currentIdx + 1, currentIdx, memory)
      } else {
        0
      }
      
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx, memory)
      
      memory(currentIdx)(previousIdx + 1) = taken max nonTaken
      
      memory(currentIdx)(previousIdx + 1) 
    }
  
  
}





/**
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution3 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        

        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}
```

###  1.137. <a name='RemoveInvalidParentheses'></a>301. Remove Invalid Parentheses

[花花酱](https://www.bilibili.com/video/BV1VW411y7Xd?spm_id_from=333.999.0.0)

###  1.138. <a name='-1'></a>303-区域和检索 - 数组不可变

[哈哈哈](https://www.bilibili.com/video/BV1RV411d76R?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV18441137fs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ho4y1U7wF?spm_id_from=333.999.0.0)

```py
class NumArray:

    def __init__(self, nums: List[int]):
        self.sums = [0]
        _sums = self.sums

        for num in nums:
            _sums.append(_sums[-1] + num)

    def sumRange(self, i: int, j: int) -> int:
        _sums = self.sums
        return _sums[j + 1] - _sums[i]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/range-sum-query-immutable/solution/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-l-px41/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

居然没超时 233333333

class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums


    def sumRange(self, i: int, j: int) -> int:
        return sum(self.nums[i:j+1])

```

```py
Python3

菜鸟心得。

题目强调了多次调用，果然就是一个大坑，第一次尝试很淡定的写了对数组区域求和函数，妥妥的超时了。很不爽准备睡觉，结果洗漱时候灵感闪现，把前i个数求和放在nums[i-1]位置，这样答案不就是nums[j]-nums[i-1]了吗？瞬间应对多次调用🕶️

class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums
        for i in range(len(self.nums)):
            if i > 0:
                self.nums[i] = self.nums[i]+self.nums[i-1]

    def sumRange(self, i: int, j: int) -> int:
        if i>0:
            return self.nums[j]-self.nums[i-1]
        else:
            return self.nums[j]
```

###  1.139. <a name='RangeSumQuery2D'></a>304. Range Sum Query 2D

[花花酱](https://www.bilibili.com/video/BV1Jb411k7LQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1R64y127jL?spm_id_from=333.999.0.0)

```py
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), (len(matrix[0]) if matrix else 0)
        self.sums = [[0] * (n + 1) for _ in range(m)]
        _sums = self.sums

        for i in range(m):
            for j in range(n):
                _sums[i][j + 1] = _sums[i][j] + matrix[i][j]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        _sums = self.sums

        total = sum(_sums[i][col2 + 1] - _sums[i][col1] for i in range(row1, row2 + 1))
        return total

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), (len(matrix[0]) if matrix else 0)
        self.sums = [[0] * (n + 1) for _ in range(m + 1)]
        _sums = self.sums

        for i in range(m):
            for j in range(n):
                _sums[i + 1][j + 1] = _sums[i][j + 1] + _sums[i + 1][j] - _sums[i][j] + matrix[i][j]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        _sums = self.sums

        return _sums[row2 + 1][col2 + 1] - _sums[row1][col2 + 1] - _sums[row2 + 1][col1] + _sums[row1][col1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

直接切片不香吗？

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.matrix = matrix
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        res = 0
        for i in range(row1,row2+1):
            res += sum(self.matrix[i][col1:col2+1])
        return res

效率比较低，空间没有省下来，每次调用时间复杂度都是O(mn)，其中m = row2 - row1, n = col2 - col1。
```

```py
初中生路过，发现这一题跟学校教的因式分解 (A-B)^2 = A^2 - 2AB + B^2 很像，当中：

row2 和 col2 就是 A ,

row2 - row1 和 col2 - col1 就是 B

当然 (A-B)^2 = A^2 - 2AB + B^2 只在 row1 == col1 && row2 == col2 的情况下可用，严格来说应该是：

(A-B)(C-D) = AC - AD - BC + BD

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        
        self.row = len(matrix)+1
        if self.row == 1: return
        self.col = len(matrix[0])+1
        
        self.matrix = [[0 for i in range(self.col)]] + [[0]+i for i in matrix]
        
        for i in range(1, self.row):
            for j in range(1, self.col):
                self.matrix[i][j] = self.matrix[i][j] + self.matrix[i-1][j] + self.matrix[i][j-1] - self.matrix[i-1][j-1]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        
        if self.row == 0: return 0
        
        # 重点：(A-B)(C-D) = AC - AD - BC + BD
        return self.matrix[row2+1][col2+1] - self.matrix[row1][col2+1] - self.matrix[row2+1][col1] + self.matrix[row1][col1]
```

###  1.140. <a name='BestTimetoBuyandSellStockwithCooldown309-'></a>309. Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期

[花花酱](https://www.bilibili.com/video/BV1qW411C7Xc?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Vy4y1z7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13D4y1U7iU?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        
        n = len(prices)
        # f[i][0]: 手上持有股票的最大收益
        # f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        # f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        f = [[-prices[0], 0, 0]] + [[0] * 3 for _ in range(n - 1)]
        for i in range(1, n):
            f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i])
            f[i][1] = f[i - 1][0] + prices[i]
            f[i][2] = max(f[i - 1][1], f[i - 1][2])
        
        return max(f[n - 1][1], f[n - 1][2])

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        
        n = len(prices)
        f0, f1, f2 = -prices[0], 0, 0
        for i in range(1, n):
            newf0 = max(f0, f2 - prices[i])
            newf1 = f0 + prices[i]
            newf2 = max(f1, f2)
            f0, f1, f2 = newf0, newf1, newf2
        
        return max(f1, f2)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
## 两个状态
## 未进行空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n <= 1 :
            return 0
        
        have = [0] * n
        no = [0] * n
        have[0] = - prices[0]
        no[0] = 0     
        have[1] = max(have[0], -prices[1])
        no[1] = max(no[0], have[0] + prices[1])
        for i in range(2, n) :
            no[i] = max(no[i - 1], have[i - 1] + prices[i])
            have[i] = max(have[i - 1], no[i - 2] - prices[i])
        
        return no[n - 1]

## 空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n <= 1 :
            return 0
        
        have = - prices[0] # 对have[0]初始化
        no = 0     
        temp = no # 当i=2时, 记录下第一个no[i-2]
        have = max(have, -prices[1]) # 对have[1]初始化
        no = max(no, have + prices[1])
        for i in range(2, n) :
            no_i2 = temp # 记录下no[i-2]
            temp = no    # 记录下no[i-1]
            no = max(no, have + prices[i])
            have = max(have, no_i2 - prices[i])
        return no

## 三个状态
## 未进行空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if len == 0:
            return 0
        have = [0] * length  # 表示第i天持有股票所得最多现金
        no = [0] * length    # 表示第i天不持有股票且不在冷冻期所得最多现金
        cold = [0] * length  # 表示第i天不持有股票且在冷冻期所得最多现金
        have[0] = -prices[0] # 此时的持有股票就一定是买入股票了
        no[0] = 0            # 不持有股票那么现金就是0
        cold[0] = 0
        for i in range(1, length):
            have[i] = max(have[i-1], no[i-1] - prices[i]); 
            no[i] = max(no[i-1], cold[i-1]);
            cold[i] = have[i-1] + prices[i];
        return max(cold[-1], no[-1])

## 空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if len == 0:
            return 0

        have = -prices[0] # 此时的持有股票就一定是买入股票了
        no = 0            # 不持有股票那么现金就是0
        cold = 0
        for i in range(1, length):
            have = max(have, no - prices[i]); 
            no = max(no, cold);
            cold = have + prices[i];
        return max(cold, no)

sell[i]表示截至第i天，最后一个操作是卖时的最大收益；
buy[i]表示截至第i天，最后一个操作是买时的最大收益；
cool[i]表示截至第i天，最后一个操作是冷冻期时的最大收益；
递推公式：
sell[i] = max(buy[i-1]+prices[i], sell[i-1]) (第一项表示第i天卖出，第二项表示第i天冷冻)
buy[i] = max(cool[i-1]-prices[i], buy[i-1]) （第一项表示第i天买进，第二项表示第i天冷冻）
cool[i] = max(sell[i-1], buy[i-1], cool[i-1])
python:

class Solution:
    def maxProfit(self, prices):
        n = len(prices)
        if n == 0:
            return 0     
        sell = [0 for _ in range(n)]
        buy = [0 for _ in range(n)]
        cool = [0 for _ in range(n)]
        buy[0] = -prices[0]
        for i in range(1,n):
            sell[i] = max(buy[i-1] + prices[i], sell[i-1])
            buy[i] = max(cool[i-1] - prices[i], buy[i-1])
            cool[i] = max(sell[i-1], buy[i-1],cool[i-1])
        return sell[-1]

Python：

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0:
            return 0
        dp = [[0] * 4 for _ in range(n)]
        dp[0][0] = -prices[0] #持股票
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][3], dp[i-1][1]) - prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][3])
            dp[i][2] = dp[i-1][0] + prices[i]
            dp[i][3] = dp[i-1][2]
        return max(dp[n-1][3], dp[n-1][1], dp[n-1][2])

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # dp0: 手上有股票   dp1: 手上没股票且当天卖出   dp2: 手上没股票且之前卖出
        dp0, dp1, dp2 = -prices[0], 0, 0
        for p in prices[1:]:
            dp0, dp1, dp2 = max(dp0, dp2-p), dp0+p, max(dp1, dp2)
        return max(dp1, dp2)
```

```scala

/**
* my first commitment
* dynamic programming
* memo
*   1. dp definition: dp[i][j] means the best profit we can have at i-th day in state j of without holding / holding / cooldown 
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        /*
        * state definition
        * 0: without holding
        * 1: holding one
        * 2: sold than cooldown
        */
        val dp = Array.tabulate(prices.length, 3){
            case (0, 0) => 0
            case (0, 1) => -prices(0)
            case (0, 2) => 0
            case _ => 0
        }
        
        for(i <- 1 until prices.length) {
            dp(i)(0) = dp(i - 1)(0) max dp(i - 1)(2) // 0 -> 0 or 2 -> 0
            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i)) // 1 -> 1 or  0 -> 1
            dp(i)(2) = dp(i - 1)(1) + prices(i) // 1 -> 2
        }
        
        dp.last.max
    }
}

/**
* dynamic programming
* memo
*    ok! lets reduce the dp array size without keep all i-th state
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-2 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        var withoutHold = 0
        var hold = Int.MinValue
        var coolDown = 0
        
        for(price <- prices) {
            val withoutHold_ = withoutHold  // keep value
            val hold_ = hold // keep value
            withoutHold = withoutHold max coolDown
            hold = hold max (withoutHold_ - price)
            coolDown = hold_ + price  
        }
        withoutHold max coolDown
    }
}

/**
* dynamic programming - function programming
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-3 {
    def maxProfit(prices: Array[Int]): Int = {
        val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) {
            case ((withoutHold, hold, cooldown), cost) => 
             (
                 withoutHold max cooldown,
                 hold max (withoutHold - cost),
                 hold + cost      
             )
        }
        withoutHold max cooldown
    }
}
```

###  1.141. <a name='MinimumHeightTrees'></a>310 Minimum Height Trees

[小明](https://www.bilibili.com/video/BV1eA411j7XQ?spm_id_from=333.999.0.0)

###  1.142. <a name='BurstBalloons'></a>312 Burst Balloons

[小明](https://www.bilibili.com/video/BV1Q64y1f7Vy?spm_id_from=333.999.0.0)

###  1.143. <a name='CountofSmallerNumbersAfterSelf'></a>315. Count of Smaller Numbers After Self

[花花酱](https://www.bilibili.com/video/BV1BW411C7TM?spm_id_from=333.999.0.0)

###  1.144. <a name='RemoveDuplicateLetters'></a>316 Remove Duplicate Letters

[小明](https://www.bilibili.com/video/BV1x54y1R7y7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Tz4y167pC?spm_id_from=333.999.0.0)

```py
# 思路是参考别人的，
# 如果数比栈顶小，而且栈顶在后面还有的话，
# 就弹出栈顶。
# python自带列表弹出和加入最后一个数都是很快的。
# 然后在前面加一个0，因为0比一切字母小，可以不用判空，方便很多

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        result = ["0"] # 初值不要为空，不然index为-1会报错
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            print("s[idx:]",s[idx:],"数量: ",s[idx:].count(result[-1]),"需要大于0,表示要把c删掉，必须后面还有c")
            if char not in result:
                while char < result[-1] and s[idx:].count(result[-1]) > 0:
                    result.pop(-1) # result 删除最后一位
                result.append(char)
        return "".join(result[1:])

# 递归贪心版本
class Solution(object):
    def removeDuplicateLetters(self, str):
        """
        :type s: str
        :rtype: str
        """
        print("-"*50)
        # 先按字典排序
        for char in sorted(set(str)):
            print("-"*20,char)
            suffix = str[str.index(char):]
            print(suffix)


            # 看余下的是否能组成所需的字母
            # if len(set(suffix)) == len(set(str)): 也可以
            if set(suffix) == set(str):
                return char + self.removeDuplicateLetters(suffix.replace(char, ''))
                # 逐步把char后面的char替换掉
        return ''

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = ''
        while s:
            print(list(map(s.rindex, set(s))))
            i = min(map(s.rindex, set(s)))
            c = min(s[:i+1])
            print(s[:i+1])
            result += c
            s = s[s.index(c):].replace(c, '')
            print(s)
        return result

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        rindex = {char: idx for idx, char in enumerate(s)}
        print("rindex",rindex)
        result = '' 
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            if char not in result:
                while char < result[-1:] and idx < rindex[result[-1:]]:
                    # 如果 char 比 最后一位result[-1:] 小
                    # result 删除最后一位
                    print("rindex[result[-1:]",rindex[result[-1:]])
                    result = result[:-1] 
                result += char
        return result

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        n = len(s)
        stack = [s[0]]
        for i in range(1,n):
            if s[i] not in stack and s[i]>stack[-1]:
                stack.append(s[i])
            elif s[i] not in stack:
                while stack and s[i]<stack[-1] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
        return "".join(stack)

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        n = len(s)
        for i in range(n):
            if s[i] in stack:
                continue
            else:
                while stack and stack[-1] > s[i] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
            
        return "".join(stack)

# 思路三：栈
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        from collections import Counter
        c = Counter(s)
        stack = []
        existed = set()
        for a in s:
            # print(stack)
            if a not in existed:
            	# 判断后面还有没有该字母
                while stack and stack[-1] > a and c[stack[-1]] > 0:
                    existed.remove(stack.pop())
                stack.append(a)
                existed.add(a)
            c[a] -= 1
        return "".join(stack)

# 思路二：迭代
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        res = ""
        while s:
            # 从右往左找，找到最小位置的索引号
            loc = min(map(s.rindex, s))
            # 找该索引前面最小的字母
            a = min(s[:loc + 1])
            res += a
            s = s[s.index(a):].replace(a, "")
        return res
```

### 319

```py
class Solution(object):
    def bulbSwitch(self, n):
        """
        :type n: int
        :rtype: int
        """
        bulb = [1] * n # 实际上是从第一轮后，开始算起的，刚好n=0的情况符合
        print("bulb: ",bulb)
        for interval in range(2,n+1):
            for x in range(interval-1, n, interval): # 从第interval开始，间隔interval个
                # ---------切换开关---------
                bulb[x] = 1 if bulb[x] == 0 else 0
                print("bulb: ",bulb)
                # ---------切换开关---------
        return bulb.count(1)
```

###  1.145. <a name='CreateMaximumNumber'></a>321. Create Maximum Number

[花花酱](https://www.bilibili.com/video/BV11W411U7NR?spm_id_from=333.999.0.0)

###  1.146. <a name='CoinChange'></a>322. Coin Change

[花花酱](https://www.bilibili.com/video/BV1SW411C7d1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1tz4y1d7XM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ty4y187dh?spm_id_from=333.999.0.0)

```py
# 方法一：记忆化搜索

class Solution:
    def coinChange(self, coins, amount):
        # @functools.lru_cache(amount)
        def dp(rem) -> int:
            if rem < 0: return -1
            if rem == 0: return 0
            mini = int(1e9)
            for coin in self.coins:
                res = dp(rem - coin)
                if res >= 0 and res < mini:
                    mini = res + 1
            return mini if mini < int(1e9) else -1

        self.coins = coins
        if amount < 1: return 0
        return dp(amount)

# 方法二：动态规划

class Solution:
    def coinChange(self, coins, amount):
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1 

# python 完全背包问题

class Solution:
    def coinChange(self, coins, amount):
        if coins == []: return -1
        dp = [amount+1] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount+1):
            for coin in coins:
                if i >= coin:
                    dp[i] = min(dp[i], dp[i-coin]+1)

        if dp[-1] == amount+1: 
            return -1
        else:
            return dp[amount] 

class Solution:
    def coinChange(self, coins, amount):
        '''版本一'''
        # 初始化
        dp = [amount + 1]*(amount + 1)
        dp[0] = 0
        # 遍历物品
        for coin in coins:
            # 遍历背包
            for j in range(coin, amount + 1):
                dp[j] = min(dp[j], dp[j - coin] + 1)
        return dp[amount] if dp[amount] < amount + 1 else -1

# BFS

class Solution:
    def coinChange(self, coins, amount):
        from collections import deque
        queue = deque([amount])
        step = 0
        visited = set()
        while queue:
            n = len(queue)
            for _ in range(n):
                tmp = queue.pop()
                if tmp == 0:
                    return step
                for coin in coins:
                    if tmp >= coin and tmp - coin not in visited:
                        visited.add(tmp - coin)
                        queue.appendleft(tmp - coin)
            step += 1
        return -1

# 宽度优先,速度飕飕的

class Solution:
    def coinChange(self, coins, amount):
        q = [[0, 0]]
        see = {0}
        while q:
            cur, cnt = q.pop(0)
            if cur == amount:
                return cnt
            for i in coins:
                t = cur + i
                if t <= amount and t not in see:
                    q.append([t, cnt + 1])
                    see.add(t)
        return -1
# 自顶向下

class Solution:
    def coinChange(self, coins, amount):
        import functools
        @functools.lru_cache(None)
        def helper(amount):
            if amount == 0:
                return 0
            return min(helper(amount - c) if amount - c >= 0 else float("inf") for c in coins) + 1
        res = helper(amount)
        return res if res != float("inf") else -1

# DFS

class Solution:
    def coinChange(self, coins, amount):
        coins.sort(reverse=True)
        self.res = float("inf")
        
        def dfs(i, num, amount):
            if amount == 0:
                self.res = min(self.res, num)
                return 
            for j in range(i, len(coins)):
                # 剩下的最大值都不够凑出来了
                if (self.res - num) * coins[j] < amount:
                    break
                if coins[j] > amount:
                    continue
                dfs(j, num + 1, amount - coins[j])
                
        for i in range(len(coins)):
            dfs(i, 0, amount)
            
        return self.res if self.res != float("inf") else -1
```

```scala
/**
* dynamic programming: bottom up
* time complexity: O(S * N), S is the amount, N is the coin denomination count
* space complexity: O(S)
*/

object Solution {
    def coinChange(coins: Array[Int], amount: Int): Int = {
         
        val dp = Array.fill[Int](amount + 1)(amount + 1) // record the minimum needed coins of each denominations

        dp(0) = 0
        for (i <- 1 to amount; denominations <- coins) {

            if(denominations <= i) {
                dp(i) = dp(i) min (dp(i - denominations) + 1)
            }        
        }
    
        if (dp.last > amount) -1 else dp.last
    }
}

```

### 324

```py
class Solution(object):
    def wiggleSort(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        nums.sort()
        half = len(nums[::2])
        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]
```

###  1.147. <a name='PowerofThree'></a>326. Power of Three

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7QC?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1h441137PM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sZ4y1F7Lr?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        while n and n % 3 == 0:
            n //= 3
        return n == 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode-solution-hnap/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and 1162261467 % n == 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode-solution-hnap/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        # 一种是利用对数
        # fmod 是float求余 在math下
        return n>0 and fmod(log10(n) / log10(3), 1) == 0
        # 另一种方法是，因为在 int 范围内 3 的最大次方是 3^19 = 1162261467，
        # 如果 n 是 3 的整数次方，那么 1162261467 除以 n 的余数一定是零。
        # return n > 0 and 1162261467 % n == 0
位运算 x*3 = x*(2+1) = x * 2 + x = (x<<1) + x

常规递归：

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n < 3:
            if n == 1: return True
            return False
        else:
            if n % 3 == 0:
                return self.isPowerOfThree(n//3)
            else:
                return False

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        b = 1
        while b < n:
            b = (b << 1) + b
        if b == n:
            return True
        return False
```

```py
？？？
这种在循环中递归的写法要怎么改呀？为何每次n=1然后return True之后n又变成了3开始递归，一直在无限循环

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        while n > 1 :
            if n % 3 != 0:
                return False
            else:
                self.isPowerOfThree(n//3)
        return True

你的else语句少了个return，而且判断条件也不太对，举个例子 n = 3 ，循环会进入else分支，但执行完 self.isPowerOfThree(n//3) （先不管执行结果）n没变化又进入下一轮循环，又进入else分支，这不就无限循环了？可以改成这样：

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n >= 1 :
            if n % 3 != 0:
                return n == 1
            else:
                return self.isPowerOfThree(n//3)
        return False
```

###  1.148. <a name='OddEvenLinkedList'></a>328. 奇偶链表 (Odd Even Linked List)

[洛阳](https://www.bilibili.com/video/BV1v64y1u7AH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ag4y1B78z?spm_id_from=333.999.0.0)

```py
# 都是奇偶俩个链表然后合并的，我怎么就没想到。。 我直接想的就是快慢指针然后只把奇数节点拿出来插到前面。。。

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        if not head.next:
            return head
        if not head.next.next:
            return head
        p = head
        fast,slow = head.next.next,head
        fast_pre = head.next
        while fast:
            # 把当前fast(奇数)节点放在slow后面，记录fast_pre保证复原
            fast_pre.next,slow.next,fast.next= fast.next,fast,slow.next
            slow = slow.next
            fast_pre = fast_pre.next
            if not fast_pre or not fast_pre.next :
                break
            fast = fast_pre.next
        return head

# 双指针分别对应奇偶链，最后串起来：https://github.com/Brycexxx/leetcode/blob/master/oddEvenList.py

# Definition for singly-linked list.
class ListNode:
   def __init__(self, x):
       self.val = x
       self.next = None


class Solution:
   def oddEvenList(self, head: ListNode) -> ListNode:
       if head == None: return head
       point1, point2 = head, head.next
       p1, p2 = point1, point2
       while p2 != None and p2.next:
           p1.next = p1.next.next
           p2.next = p2.next.next
           p1 = p1.next
           p2 = p2.next
       p1.next = point2
       return point1

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        '''
        slow: 上一个奇数节点
        fast: 下一个奇数节点
        pre: 下一个奇数节点的前缀节点
        post: 上一个奇数节点的后缀节点
        '''
        slow, pre, fast = head, head.next, head.next.next
        while slow and fast:
            q = fast.next.next if fast.next else None
            post = slow.next
            pre.next = fast.next
            fast.next = post
            slow.next = fast
            slow, pre, fast = fast, pre.next, q
        return head


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        # 奇节点在偶节点之前
        if head == None:
            return None
        dummy_head_1 = ListNode(-1)
        dummy_head_2 = ListNode(-1)
        p1 = dummy_head_1  # 奇节点
        p2 = dummy_head_2  # 偶节点
        i = 1  # 题目要求第一个节点是奇节点
        while head:
            if i % 2 == 0:
                p2.next = head
                p2 = p2.next
                head = head.next
            else:
                p1.next = head
                p1 = p1.next
                head = head.next
            i += 1
        p2.next = None
        p1.next = dummy_head_2.next
        return dummy_head_1.next

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        evenHead = head.next
        odd, even = head, evenHead
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = evenHead
        return head

class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None:
            return head

        # odd used to keep track of the tail of odd nodes
        odd = oddHead = head
        # record how many swaps happend
        even = evenHead = head.next
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next 
            even = even.next
        odd.next = evenHead
        return head 
```

###  1.149. <a name='LongestIncreasingPathinaMatrix'></a>329. Longest Increasing Path in a Matrix

[花花酱](https://www.bilibili.com/video/BV1mW411d7q8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK4y1K7SX?spm_id_from=333.999.0.0)

```py
class Solution:
    
    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        @lru_cache(None)
        def dfs(row: int, column: int) -> int:
            best = 1
            for dx, dy in Solution.DIRS:
                newRow, newColumn = row + dx, column + dy
                if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[row][column]:
                    best = max(best, dfs(newRow, newColumn) + 1)
            return best

        ans = 0
        rows, columns = len(matrix), len(matrix[0])
        for i in range(rows):
            for j in range(columns):
                ans = max(ans, dfs(i, j))
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:

    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        rows, columns = len(matrix), len(matrix[0])
        outdegrees = [[0] * columns for _ in range(rows)]
        queue = collections.deque()
        for i in range(rows):
            for j in range(columns):
                for dx, dy in Solution.DIRS:
                    newRow, newColumn = i + dx, j + dy
                    if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[i][j]:
                        outdegrees[i][j] += 1
                if outdegrees[i][j] == 0:
                    queue.append((i, j))

        ans = 0
        while queue:
            ans += 1
            size = len(queue)
            for _ in range(size):
                row, column = queue.popleft()
                for dx, dy in Solution.DIRS:
                    newRow, newColumn = row + dx, column + dy
                    if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] < matrix[row][column]:
                        outdegrees[newRow][newColumn] -= 1
                        if outdegrees[newRow][newColumn] == 0:
                            queue.append((newRow, newColumn))
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

先预处理，对矩阵的值按从小到大排序，按大小顺序才能保证依赖的子问题都求解过了

dp[i][j]表示以matrix[i][j]结尾的最长递增长度

初始dp[i][j]都等于1
若matrix[i][j]四个方向有任意小于它，则可以更新dp[i][j] = max(dp[i][j], 1 + dp[r][c])
class Solution(object):
    def longestIncreasingPath(self, matrix):
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        lst = []
        for i in range(m):
            for j in range(n):
                lst.append((matrix[i][j], i, j))
        lst.sort()
        dp = [[0 for _ in range(n)] for _ in range(m)]
        for num, i, j in lst:
            dp[i][j] = 1
            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                r, c = i + di, j + dj
                if 0 <= r < m and 0 <= c < n:
                    if matrix[i][j] > matrix[r][c]:
                        dp[i][j] = max(dp[i][j], 1 + dp[r][c])
        return max([dp[i][j] for i in range(m) for j in range(n)])

我用的是优先队列就省去sort啦~

之所以要先排序，我觉得很可能是因为倒数第二行dp[i][j]=max(dp[i][j],1+dp[r][c])。 

这里出现了dp[r][c]，所以我们在计算dp[i][j]之前，必须先把dp[r][c]计算出来。 

matrix(r,c)位置的值比matrix（i，j）位置的值小（从if语句看出来的）。

所以我们只要保证，先把matrix中值小的位置的dp先算出来，

再把值大的位置的dp算出来，倒数第二行的代码就有意义了。所以我们要先排序。

 想到了和你一样的dp数组，没想到这种dp数组的填充方式，非常巧妙呀！
```

```py
方法一：代码清晰

方法二：效率最高

方法三：代码简洁

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]: return 0

        row = len(matrix)
        col = len(matrix[0])
        lookup = [[0] * col for _ in range(row)]

        def dfs(i, j):
            if lookup[i][j] != 0:
                return lookup[i][j]
            # 方法一
            res = 1
            for x, y in [[-1, 0], [1, 0], [0, 1], [0, -1]]:
                tmp_i = x + i
                tmp_j = y + j
                if 0 <= tmp_i < row and 0 <= tmp_j < col and \
                        matrix[tmp_i][tmp_j] > matrix[i][j]:
                    res = max(res, 1 + dfs(tmp_i, tmp_j))
            lookup[i][j] = max(res, lookup[i][j])
            # 方法二
            # val = matrix[i][j]
            # lookup[i][j] = 1 + max(
            #     dfs(i + 1, j) if 0 <= i + 1 < row and 0 <= j < col and matrix[i + 1][j] > val else 0,
            #     dfs(i - 1, j) if 0 <= i - 1 < row and 0 <= j < col and matrix[i - 1][j] > val else 0,
            #     dfs(i, j + 1) if 0 <= i < row and 0 <= j + 1 < col and matrix[i][j + 1] > val else 0,
            #     dfs(i, j - 1) if 0 <= i < row and 0 <= j - 1 < col and matrix[i][j - 1] > val else 0,
            # )
            # 方法三
            # lookup[i][j] = 1 + max(
            #     [dfs(i + x, y + j) for x, y in [[-1, 0], [1, 0], [0, 1], [0, -1]] \
            #      if 0 <= (i + x) < row and 0 <= (j + y) < col and matrix[i + x][j + y] > matrix[i][j]] or [0]
            # )
            
            return lookup[i][j]

        return max(dfs(i, j) for i in range(row) for j in range(col))
```

###  1.150. <a name='ReconstructItinerary'></a>332 Reconstruct Itinerary

[小明](https://www.bilibili.com/video/BV1qa4y1h7Ti?spm_id_from=333.999.0.0)

###  1.151. <a name='IncreasingTripletSubseque'></a>334 Increasing Triplet Subseque

[小明](https://www.bilibili.com/video/BV1Kr4y1F7m9?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        # m - min, sm - second min
        m, sm = float('inf'), float('inf')

        for num in nums:
        	print (m, sm)
        	if m >= num:
        		m = num
        	elif sm >= num:
        		sm = num
        	else:
        		return True
        return False


class Solution:
    def increasingTriplet(self, nums):
        n = len(nums)
        if n < 3:
            return False
        small, mid = max(nums), max(nums)
        for i in range(n):
            if nums[i] <= small:
                small = nums[i]
            elif nums[i] <= mid:
                mid = nums[i]
            elif nums[i] > mid:
                return True
        return False

# 循环遍历数组，不断更新数组内出现的最小值与最大值，如果出现的一个大于最大值的数，则表示存在长度为 3 的递增子序列。

class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        length = len(nums)
        if length < 3:
            return False
        
        min_num = float('inf')
        max_num = float('inf')
        
        for n in nums:
            if n < min_num:
                min_num = n
            elif min_num < n and n <= max_num:
                max_num = n
            elif n > max_num:
                return True
        
        return False
```

###  1.152. <a name='HouseRobberIII'></a>337 House Robber III

[小明](https://www.bilibili.com/video/BV1WD4y1X7JQ?spm_id_from=333.999.0.0)

```py
# 补充一个Python的：

class Solution:
    def rob(self, root: TreeNode) -> int:
        def _rob(root):
            if not root: return 0, 0
            
            ls, ln = _rob(root.left)  # 前一项表示根节点偷，后一项表示根节点不偷
            rs, rn = _rob(root.right) # 前一项表示根节点偷，后一项表示根节点不偷
            
            return root.val + ln + rn, max(ls, ln) + max(rs, rn) # 前一项表示根节点偷，后一项表示根节点不偷

        return max(_rob(root))
# ls表示偷左子树能带来的最大收益，ln表示不偷左子树能带来的最大收益，rs、rn同理

# 这个解法好像有点厉害

# 从root开始抢起来，最大能抢到的两个可能： 抢root和不抢root

# - rob_root = max(rob_L + rob_R , no_rob_L + no_nob_R + root.val)
# - no_rob_root = rob_L + rob_R


# 这个递归写起来就很厉害了


# ```
class Solution(object):
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(root):
            if not root: return 0, 0
            rob_L, no_rob_L = dfs(root.left) # 前一项表示根节点偷，后一项表示根节点不偷
            rob_R, no_rob_R = dfs(root.right) # 前一项表示根节点偷，后一项表示根节点不偷
            return max(no_rob_R + no_rob_L + root.val , rob_L + rob_R), rob_L + rob_R # 前一项表示根节点偷，后一项表示根节点不偷
        return dfs(root)[0]

class Solution:
    def rob(self, root: TreeNode) -> int:
        result = self.rob_tree(root)
        return max(result[0], result[1])
    
    def rob_tree(self, node):
        if node is None:
            return (0, 0) # (偷当前节点金额，不偷当前节点金额)
        left = self.rob_tree(node.left)
        right = self.rob_tree(node.right)
        val1 = node.val + left[1] + right[1] # 偷当前节点，不能偷子节点
        val2 = max(left[0], left[1]) + max(right[0], right[1]) # 不偷当前节点，可偷可不偷子节点
        return (val1, val2)

class Solution:
    def rob(self, root: TreeNode) -> int:
        if root is None:
            return 0
        if root.left is None and root.right  is None:
            return root.val
        # 偷父节点
        val1 = root.val
        if root.left:
            val1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            val1 += self.rob(root.right.left) + self.rob(root.right.right)
        # 不偷父节点
        val2 = self.rob(root.left) + self.rob(root.right)
        return max(val1, val2)
```

###  1.153. <a name='CountingBits'></a>338 Counting Bits

[小明](https://www.bilibili.com/video/BV1VK411s7xi?spm_id_from=333.999.0.0)

```py
class Solution:
    def countBits(self, n: int) -> List[int]:
        def countOnes(x: int) -> int:
            ones = 0
            while x > 0:
                x &= (x - 1)
                ones += 1
            return ones
        
        bits = [countOnes(i) for i in range(n + 1)]
        return bits

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        highBit = 0
        for i in range(1, n + 1):
            if i & (i - 1) == 0:
                highBit = i
            bits.append(bits[i - highBit] + 1)
        return bits

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        for i in range(1, n + 1):
            bits.append(bits[i >> 1] + (i & 1))
        return bits

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        for i in range(1, n + 1):
            bits.append(bits[i & (i - 1)] + 1)
        return bits

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution(object):
    def countBits(self, num):
        """ 
        1: 0001     3:  0011      0: 0000
        2: 0010     6:  0110      1: 0001
        4: 0100     12: 1100      2: 0010 
        8: 1000     24: 11000     3: 0011
        16:10000    48: 110000    4: 0100
        32:100000   96: 1100000   5: 0101
        
        由上可见：
        1、如果 i 为偶数，那么f(i) = f(i/2) ,因为 i/2 本质上是i的二进制左移一位，低位补零，所以1的数量不变。
        2、如果 i 为奇数，那么f(i) = f(i - 1) + 1， 因为如果i为奇数，那么 i - 1必定为偶数，而偶数的二进制最低位一定是0，
        那么该偶数 +1 后最低位变为1且不会进位，所以奇数比它上一个偶数bit上多一个1，即 f(i) = f(i - 1) + 1。
        :type num: int
        :rtype: List[int]
        """
        ret = [0]
        for i in xrange(1, num + 1):
            if i % 2 == 0: # 偶数
                ret.append(ret[i/2])
            else: # 奇数
                ret.append(ret[i - 1] + 1)
        return ret

写得太好了，对二进制了解得很透彻

谢谢层主的题解。我在python3中使用下述代码可运行成功，系统提示xrange未定义，所以我用了range，另一方面i/2我改成i//2。

class Solution:
    def countBits(self, num: int) -> List[int]:
        res=[0]
        for i in range(1,num+1):
            if i%2==0:
                res.append(res[i//2])
            else:
                res.append(res[i-1]+1)
        return res

class Solution(object):
    def countBits(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        return [bin(i)[2:].count('1') for i in range(n+1)]
```


```scala

/**
* chosen solution
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution0 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}

object Solution1 {
    def countBits(num: Int): Array[Int] = {
        (0 to num).map(_counter).toArray
        
    }
    private def _counter(n: Int): Int = {
        var counter = 0
        var nn = n
        
        while(nn != 0) {
            counter += 1
            nn = nn & (nn - 1)
        }
        counter 
    }
}

/**
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution2 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}
```

###  1.154. <a name='PowerofFour'></a>342. Power of Four

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7D5?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1p5411a7h1?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n & 0xaaaaaaaa) == 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/power-of-four/solution/4de-mi-by-leetcode-solution-b3ya/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and n % 3 == 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/power-of-four/solution/4de-mi-by-leetcode-solution-b3ya/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and n & n - 1 == 0 and n & 0b1010101010101010101010101010101 == n

class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        d=[1,4,16,64,256,1024,4096,16384,65536,262144,1048576,4194304,16777216,67108864,268435456,1073741824]
        return n in d
```

```py
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        while n > 1: n = n / 4
        return False if n != 1 else True 
```

###  1.155. <a name='-1'></a>343-整数拆分

[哈哈哈](https://www.bilibili.com/video/BV1Dp4y1U79P?spm_id_from=333.999.0.0)

###  1.156. <a name='ReverseString'></a>344. Reverse String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7Ha?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nC4y1a7DR?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1nQ4y1R7nH?spm_id_from=333.999.0.0)

```py
class Solution: 
    def reverseString(self, s: List[str]) -> None:

    """
    Do not return anything, modify s in-place instead.
    """
    i, j = 0, len(s) - 1
    while i<j:
        s[i],s[j]=s[j],s[i]
        i+=1
        j-=1
    return s

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        
        # 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(right//2)更低
        # 推荐该写法，更加通俗易懂
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

```py
class Solution:
    def reverseString(self, s):
        s.reverse()
        # s[:] = s[::-1]
        '''
        j = len(s)-1
        for i in range(len(s)//2):
            s[i],s[j] = s[j],s[i]
            j -= 1
       '''
```

```scala
object Solution {
    def reverseString(s: Array[Char]): Unit = {
        var begin = 0
        var end = s.length - 1
        while(begin < end){
            var temp = s(begin)
            s(begin) = s(end)
            s(end) = temp
            
            begin += 1
            end -= 1
        }
    }
}

```

###  1.157. <a name='ReverseVowelsofaString'></a>345. Reverse Vowels of a String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7JH?spm_id_from=333.999.0.0)

###  1.158. <a name='MovingAveragefromDataStream'></a>346 Moving Average from Data Stream

[小明](https://www.bilibili.com/video/BV1xV411m73u?spm_id_from=333.999.0.0)

###  1.159. <a name='TopKFrequentElements'></a>347. Top K Frequent Elements 

[花花酱](https://www.bilibili.com/video/BV1Mt411371T?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sk4y1B7vj?spm_id_from=333.999.0.0)

```py
#时间复杂度：O(nlogk)
#空间复杂度：O(n)
import heapq
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #要统计元素出现频率
        map_ = {} #nums[i]:对应出现的次数
        for i in range(len(nums)):
            map_[nums[i]] = map_.get(nums[i], 0) + 1
        
        #对频率排序
        #定义一个小顶堆，大小为k
        pri_que = [] #小顶堆
        
        #用固定大小为k的小顶堆，扫面所有频率的数值
        for key, freq in map_.items():
            heapq.heappush(pri_que, (freq, key))
            if len(pri_que) > k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                heapq.heappop(pri_que)
        
        #找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组
        result = [0] * k
        for i in range(k-1, -1, -1):
            result[i] = heapq.heappop(pri_que)[1]
        return result
```

```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dic = {}
        for n in nums:
            if n in dic:
                dic[n] += 1
            else:
                dic[n] = 1
        return [k for k, v in sorted(dic.items(), key=lambda item:item[1],reverse=True)][0:k]

python写了一个本以为时间很长结果击败了97%的代码（一开始都没想到优先队列【捂脸】）

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        sort_nums=sorted(Counter(nums).items(),reverse=True,key=lambda item:item[1])[:k]
        return list(zip(*sort_nums))[0]

Python一行搞定：

from collections import Counter

class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        return [item[0] for item in Counter(nums).most_common(k)]
```

```scala
object Solution {
    def topKFrequent(nums: Array[Int], k: Int): Array[Int] = {
        var hm = scala.collection.mutable.Map.empty[Int, Int]
        for(elem <- nums){
            hm.get(elem) match{
                case Some(count) => hm += (elem -> (count+1))
                case None => hm += (elem -> 1)
            }
        }
        
        // hm.toList.sortBy(x => (x._2)*(-1)).take(k).map(_._1).toArray
        // The above is a sorting approach. We can use Heap/PriorityQueue to achieve better time complexity
        
        import scala.math.Ordering.Implicits._
        
        def orderByFrequency(tup: (Int, Int)) = tup._2
        
        val pq = new scala.collection.mutable.PriorityQueue[(Int, Int)]()(Ordering.by(orderByFrequency))
        
        for(entry <- hm){
            pq.enqueue(entry)
        }
        
        println(pq)
        (1 to k).map(_ => pq.dequeue).map(_._1).toArray
        
    }
}

```

###  1.160. <a name='IntersectionofTwoArrays'></a>349. Intersection of Two Arrays

[小梦想家](https://www.bilibili.com/video/BV1zx411o7i1?spm_id_from=333.999.0.0)

###  1.161. <a name='IntersectionofTwoArraysII'></a>350. Intersection of Two Arrays II 

[小梦想家](https://www.bilibili.com/video/BV1gx411X7q8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV165411879H?spm_id_from=333.999.0.0)

```py
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        if len(nums1) > len(nums2):
            return self.intersect(nums2, nums1)
        
        m = collections.Counter()
        for num in nums1:
            m[num] += 1
        
        intersection = list()
        for num in nums2:
            if (count := m.get(num, 0)) > 0:
                intersection.append(num)
                m[num] -= 1
                if m[num] == 0:
                    m.pop(num)
        
        return intersection

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()

        length1, length2 = len(nums1), len(nums2)
        intersection = list()
        index1 = index2 = 0
        while index1 < length1 and index2 < length2:
            if nums1[index1] < nums2[index2]:
                index1 += 1
            elif nums1[index1] > nums2[index2]:
                index2 += 1
            else:
                intersection.append(nums1[index1])
                index1 += 1
                index2 += 1
        
        return intersection

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python大法好啊

class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        num1 = collections.Counter(nums1)
        num2 = collections.Counter(nums2)
        num = num1 & num2
        return num.elements()
        最后是不是应该 return(list(num.elements())
         .elements()返回的是迭代器，应该加。
         我觉得也是， num.elements() 好像是个地址值
         大佬👍。学习了Counter的&用法。不过elements函数，key如果是负数，就不输出了。还好本题都>= 0

大佬，想问一下， & 操作什么意思
求两个Counter中key的并集
```

```py
class Solution(object):
    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        inter = set(nums1) & set(nums2)
        l = []
        for i in inter:
            l += [i] * min(nums1.count(i), nums2.count(i))  
        return l
        看似简单，实则时间复杂度提升到n方了，count()的时间复杂度就是n


"""
哈希表
"""
from collections import Counter
class Solution:
    def intersect(self, nums1, nums2):
        nums1 = Counter(nums1)
        res = []
        for i in nums2:
            if i in nums1 and nums1[i]:
                res.append(i)
                nums1[i] -= 1
        return res
"""
排序后，再使用双指针
"""
class Solution:
    def intersect(self, nums1, nums2):
        nums1, nums2 = sorted(nums1), sorted(nums2)
        l1, l2 = 0, 0
        res = []
        while l1 < len(nums1) and l2 < len(nums2):
            if nums1[l1] == nums2[l2]:
                res.append(nums1[l1])
                l1 += 1
                l2 += 1
            elif nums1[l1] < nums2[l2]:
                l1 += 1
            else:
                l2 += 1
        return res
"""
动态规划
"""
class Solution:
    def intersect(self, nums1, nums2):
        nums1 = sorted(nums1)
        nums2 = sorted(nums2)
        dp = [[[]] * (len(nums2)+1) for _ in range(len(nums1)+1)]
        for i in range(1, len(nums1)+1):
            for j in range(1, len(nums2)+1):
                if nums1[i-1] == nums2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + [nums1[i-1]]
                else:
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j], key=len).copy()
        return dp[-1][-1]
"""
暴力
"""
class Solution:
    def intersect(self, nums1, nums2):
        res = []
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                if nums1[i] == nums2[j]:
                    res.append(nums1[i])
                    nums2[j] = float("inf")
                    break
        return res

nums2[j] = float("inf")小白问这行代码什么作用

暴力解法，如果nums2的长度大于nums1的长度，就会缺数据，需要先找到最长的数组再进行遍历

这行代码很关键。

假设num1和num2的重复元素为x，个数分别为n1和n2，

由于返回的是nums1中的x，即返回n1个x，如果n1<n2，没有问题，

如果n1>n2，没有这行代码的话，就有问题了。

这行代码的作用就是删除nums2中x，这样nums1中多余的x在nums2中就没有匹配，

最后返回的x的个数就是min(n1, n2)。

一句话总结，这句话的作用就是，确保返回nums1和nums2中重复元素个数的较小值。

这里不一定是赋值 float('inf')，只要不在元素取值范围内即可，

0 <= nums1[i], nums2[i] <= 1000。PS: 写得好像挺啰嗦的~
```

```scala
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        
        val map1 = nums1.groupBy(identity).mapValues(_.length)
        val map2 = nums2.groupBy(identity).mapValues(_.length)
        
        val keys = map1.keySet intersect map2.keySet
        
        keys.map(key => {
            val count1 = map1.get(key).get
            val count2 = map2.get(key).get
            val count = if(count1 > count2) count2 else count1
            Array.fill(count)(key)
        }).toArray.flatten
    }
}


//Alternate solution to keep count in HashMap from 1st array & decrease from second array... whatever is left is intersection
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        var map = scala.collection.mutable.Map.empty[Int, Int]
        var output = List.empty[Int]
        for(item <- nums1){
            map.get(item) match{
                case Some(count) => map += (item -> (count + 1))
                case None => map += (item -> 1)
            }
        }
        
        for(item <- nums2){
            map.get(item) match{
                case Some(count) => {
                    output = output :+ item
                    if(count - 1 == 0) map.remove(item) else map += (item -> (count - 1))
                }
                case None => map.remove(item)
            }
        }
        
        output.toArray
    }
}

```

###  1.162. <a name='DesignTwitter'></a>355. 设计推特 Design Twitter

[官方](https://www.bilibili.com/video/BV1aQ4y1N72N?spm_id_from=333.999.0.0)

###  1.163. <a name='LoggerRateLimiter'></a>359 Logger Rate Limiter

[小明](https://www.bilibili.com/video/BV1k64y1F7dE?spm_id_from=333.999.0.0)

###  1.164. <a name='ValidPerfectSquare'></a>367. Valid Perfect Square

[小梦想家](https://www.bilibili.com/video/BV1Gx411X7Ke?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DT4y1377H?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return float.is_integer(pow(num, 0.5))

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        x = 1
        square = 1
        while square <= num:
            if square == num:
                return True
            x += 1
            square = x * x
        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 0, num
        while left <= right:
            mid = (left + right) // 2
            square = mid * mid
            if square < num:
                left = mid + 1
            elif square > num:
                right = mid - 1
            else:
                return True
        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        x0 = num
        while True:
            x1 = (x0 + num / x0) / 2
            if x0 - x1 < 1e-6:
                break
            x0 = x1
        x0 = int(x0)
        return x0 * x0 == num

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num**0.5 == int(num**0.5)

打表党大胜利

ans = [i**2 for i in range(46342)]
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num in ans

python版二分法

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        low=1
        high=num
        while high>=low:
            mid=(high+low)//2
            if mid*mid == num:
                return True
            elif mid*mid < num:
                low=mid+1
            elif mid*mid > num:
                high=mid-1
        return False
```

###  1.165. <a name='LargestDivisibleSubset'></a>368 Largest Divisible Subset

[小明](https://www.bilibili.com/video/BV15D4y1Q74b?spm_id_from=333.999.0.0)

###  1.166. <a name='FindKPairswithSmallestSumsk'></a>373. Find K Pairs with Smallest Sums查找和最小的k对数字

[图灵](https://www.bilibili.com/video/BV1Mv4y1Z79v?spm_id_from=333.999.0.0)

###  1.167. <a name='GuessNumberHigherorLower'></a>374. Guess Number Higher or Lower

[小梦想家](https://www.bilibili.com/video/BV1Hx41197ou?spm_id_from=333.999.0.0)

###  1.168. <a name='-1'></a>376-摆动序列

[哈哈哈](https://www.bilibili.com/video/BV1sk4y167wV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16X4y1376k?spm_id_from=333.999.0.0)

```py
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = [1] + [0] * (n - 1)
        down = [1] + [0] * (n - 1)
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up[i] = max(up[i - 1], down[i - 1] + 1)
                down[i] = down[i - 1]
            elif nums[i] < nums[i - 1]:
                up[i] = up[i - 1]
                down[i] = max(up[i - 1] + 1, down[i - 1])
            else:
                up[i] = up[i - 1]
                down[i] = down[i - 1]
        
        return max(up[n - 1], down[n - 1])

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = down = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up = max(up, down + 1)
            elif nums[i] < nums[i - 1]:
                down = max(up + 1, down)
        
        return max(up, down)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = down = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up = down + 1
            elif nums[i] < nums[i - 1]:
                down = up + 1
        
        return max(up, down)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        prevdiff = nums[1] - nums[0]
        ret = (2 if prevdiff != 0 else 1)
        for i in range(2, n):
            diff = nums[i] - nums[i - 1]
            if (diff > 0 and prevdiff <= 0) or (diff < 0 and prevdiff >= 0):
                ret += 1
                prevdiff = diff
        
        return ret

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
大佬的这个解法好强，利用摆动序列，波峰和波谷的差值最多为1的特点。一次遍历，常数空间。学不来学不来

class Solution:
    def wiggleMaxLength(self, nums):
        up ,down = 1,1
        if len(nums)<2:return len(nums)
        for i in range(1,len(nums)):
            if nums[i]>nums[i-1]:
                up = down+1
            if nums[i]<nums[i-1]:
                down = up+1
        return max(up,down)

Python：

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        preC,curC,res = 0,0,1  #题目里nums长度大于等于1，当长度为1时，其实到不了for循环里去，所以不用考虑nums长度
        for i in range(len(nums) - 1):
            curC = nums[i + 1] - nums[i]
            if curC * preC <= 0 and curC !=0:  #差值为0时，不算摆动
                res += 1
                preC = curC  #如果当前差值和上一个差值为一正一负时，才需要用当前差值替代上一个差值
        return res

单调子序列保留两个端点，重复子序列保留一个点，剩下的都是符合要求的

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        arr=[nums[0]]
        for x in nums:
            if x!=arr[-1]:
                arr.append(x)
        if len(arr)<2:
            return len(arr)
        res=2
        for i in range(1,len(arr)-1):
            if arr[i-1]>arr[i]<arr[i+1] or arr[i-1]<arr[i]>arr[i+1]:
                res+=1
        return res
```



###  1.169. <a name='CombinationSumIV'></a>377. Combination Sum IV

[花花酱](https://www.bilibili.com/video/BV1gW411y7uz?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1zA411L7nu?spm_id_from=333.999.0.0)

```py
# 我们需要一个一维数组dp，其中dp[i]表示目标数为i的解的个数，
# 然后我们从1遍历到target，对于每一个数i，遍历nums数组，
# 如果i>=x, dp[i] += dp[i - x]。这个也很好理解，
# 比如说对于[1,2,3] 4，这个例子，当我们在计算dp[3]的时候，3可以拆分为1+x，
# 而x即为dp[2]，3也可以拆分为2+x，此时x为dp[1]，3同样可以拆为3+x，
# 此时x为dp[0]，我们把所有的情况加起来就是组成3的所有情况了
class Solution(object):
    def combinationSum4(self, candidates, target):
        """
        :type candidates: List[int]
        :type target
        :rtype: List[List[int]]
        """
        dp = [0 for i in range(target+1)]

        dp[0] = 1

        for i in range(target+1):
            for candidate in candidates:
                if i >= candidate:
                    dp[i] += dp[i - candidate]
        return dp[-1]
class Solution:
    def combinationSum4(self, nums, target):
        dp = [0] * (target + 1)
        dp[0] = 1

        for i in range(1, target+1):
            for j in nums:
                if i >= j:
                    dp[i] += dp[i - j]

        return dp[-1]
class Solution:
    def combinationSum4(self, nums: List[int], target) -> int:
        dp = [0]*(target+1)
        dp[0] = 1 # i - num = 0 ----> i = num时，表示只取 i 一个数 就是一种，因此这里赋值为1。
        nums.sort()
        for i in range(1,target+1):
            for num in nums: 
                if i - num >= 0:
                    dp[i] += dp[i-num]
        return dp[target]
# 不需要sort吧，如果你sort的话，可以在 if i - num >= 0: 

# dp[i] += dp[i-num] 后面加一个 else： break 不然白白sort了
class Solution:
    def combinationSum4(self, nums: List[int], target) -> int:
        dp = [1] + [0] * target
        for i in range(1, target + 1):
            for num in nums:
                if num <= i:
                    dp[i] += dp[i - num]
        
        return dp[target]
```

###  1.170. <a name='K'></a>378-有序矩阵中第K小的元素

[哈哈哈](https://www.bilibili.com/video/BV1mT4y1w7u2?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Zy4y127qr?spm_id_from=333.999.0.0)

```py
# 无脑暴力法一行版

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        return sorted(sum(matrix,[]))[k-1]
# 暴力pq一行
import heapq
class Solution(object):
    def kthSmallest(self, matrix, k):
        return heapq.nsmallest(k,sum(matrix,[]))[-1]
#  heapq一行
class Solution(object):
    def kthSmallest(self, matrix, k):
        return list(heapq.merge(*matrix))[k-1]

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        rec = sorted(sum(matrix, []))
        return rec[k - 1]

# 无脑暴力法优化版
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        l=heapq.nlargest(len(lis)-k+1,lis)
        return l[-1]
# 无脑暴力法
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        lis.sort()
        return lis[k-1]
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        n = len(matrix)
        pq = [(matrix[i][0], i, 0) for i in range(n)]
        heapq.heapify(pq)

        ret = 0
        for i in range(k - 1):
            num, x, y = heapq.heappop(pq)
            if y != n - 1:
                heapq.heappush(pq, (matrix[x][y + 1], x, y + 1))
        
        return heapq.heappop(pq)[0]
# binary search
# ```python
import bisect
class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k
        :rtype
        """
        l, r = matrix[0][0], matrix[-1][-1]
        while l <= r:
            mid = l + ((r - l) >> 2)
            if sum(bisect.bisect_right(row, mid) for row in matrix) < k:
                l = mid + 1
            else:
                r = mid - 1
        return l
```


###  1.171. <a name='InsertDeleteGetRandomO1'></a>380 Insert Delete GetRandom O(1)

[小明](https://www.bilibili.com/video/BV1Fg4y1q7Ru?spm_id_from=333.999.0.0)

###  1.172. <a name='LinkedListRandomNode'></a>382 Linked List Random Node

[小明](https://www.bilibili.com/video/BV1xZ4y1G7ie?spm_id_from=333.999.0.0)

###  1.173. <a name='RansomNote'></a>383 Ransom Note

[小明](https://www.bilibili.com/video/BV1GQ4y1N7Q5?spm_id_from=333.999.0.0)

### 386

```py
class Solution:
    def lexicalOrder(self, n):
        def dfs(num):
            if num > n:
                return
            ans.append(num)
            for nxt in range(num * 10, num * 10 + 10):
                dfs(nxt)

        ans = []
        for num in range(1, 10):
            dfs(num)
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(i: int = 1) -> None:
            if i > n:
                return
            for j in range(i, min(n + 1, (10 if i < 10 else i + 10))):
                ans.append(j)
                dfs(j * 10)
        ans = []
        dfs()
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(rec, i, n):
            if i > n: return -1
            rec.append(i);
            child = i * 10
            for j in range(10):
                if dfs(rec, child+j, n) == -1:break
            return
        rec = []
        for i in range(1, 10):
            dfs(rec, i, n)
        return rec
```

```py
class Solution:
    def lexicalOrder(self, n):
        return sorted(list(range(1,n+1)),key=lambda x:str(x))

class Solution:
    def lexicalOrder(self, n):
        return [int(j) for j in sorted([str(i) for i in range(1, n + 1)])]

# 字符串排序

class Solution:
    def lexicalOrder(self, n):
        l = sorted([str(i) for i in range(1, n + 1)])
        return [int(i) for i in l]
```

```py
class Solution:
    def lexicalOrder(self, n):
        orders = []
        stack = [(1, 8)]
        while len(stack) > 0:
            orders.append(stack[-1][0])
            (last, step) = stack.pop()
            if last+1 <= n and step > 0:
                stack.append((last+1, step-1))
            if last*10 <= n:
                stack.append((last*10, 9))
        return orders

class Solution:
    def lexicalOrder(self, n):
        ans = []
        num = 1
        while len(ans) < n:
            while num <= n:  # 不断进入下一层
                ans.append(num)
                num *= 10
            while num % 10 == 9 or num > n:  # 不断返回上一层
                num //= 10
            num += 1  # 遍历该层下一个数
        return ans

class Solution(object):
    def lexicalOrder(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        res = []
        cur = 1
        for i in range(n):
            res.append(cur)
            if (cur * 10 <= n):
                cur *= 10
            elif cur + 1 <= n and (cur + 1) % 10 != 0:
                cur += 1
            else:
                while (cur/10) % 10 == 9:
                    cur /= 10
                cur = cur / 10 + 1
        return res
```

###  1.174. <a name='FirstUniqueCharacterinaString'></a>387. First Unique Character in a String

[小梦想家](https://www.bilibili.com/video/BV1y4411A7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1b541147WU?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstUniqChar(self, s: str) -> int:
        frequency = collections.Counter(s)
        for i, ch in enumerate(s):
            if frequency[ch] == 1:
                return i
        return -1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def firstUniqChar(self, s: str) -> int:
        position = dict()
        n = len(s)
        for i, ch in enumerate(s):
            if ch in position:
                position[ch] = -1
            else:
                position[ch] = i
        first = n
        for pos in position.values():
            if pos != -1 and pos < first:
                first = pos
        if first == n:
            first = -1
        return first
        遍历字符串，如果当前字符没出现过就用字典记录它在字符串中的位置，
        出现过了就把字典里的那条记录改成-1。然后找字典里位置最靠前的（而且不是-1的）那个字符。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def firstUniqChar(self, s: str) -> int:
        position = dict()
        q = collections.deque()
        n = len(s)
        for i, ch in enumerate(s):
            if ch not in position:
                position[ch] = i
                q.append((s[i], i))
            else:
                position[ch] = -1
                while q and position[q[0][0]] == -1:
                    q.popleft()
        return -1 if not q else q[0][1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
用一个哈希表存放字符中字符出现的次数

然后从头遍历，返回遇到的第一个出现次数为1的字符下标

如果遍历完都没有，就说明不存在，返回-1

from collections import Counter
class Solution:
    def firstUniqChar(self, s: str) -> int:
        sDict = Counter(s)
        for n in range(len(s)):
            if sDict[s[n]] == 1:
                return n
        return -1

python3行，第一次出现的位置和最后一次出现的位置相等

class Solution(object):
    def firstUniqChar(self, s): 
        for i in range(len(s)):
            if s.find(s[i])==s.rfind(s[i]):
                return i
        return -1

用字典记录已经查找过的字母
执行用时：44 ms, 在所有 Python3 提交中击败了99.25%的用户
class Solution:
    def firstUniqChar(self, s: str) -> int:
        d={}
        length=len(s)
        for i in range(length):
            if s[i] not in d:
                if s.find(s[i],i+1)==-1:return i
                d[s[i]]=None
        return -1

我的另外一种算法，执行用时：48 ms, 在所有 Python3 提交中击败了98.92%的用户

class Solution:
    def firstUniqChar(self, s: str) -> int:
        for k,v in collections.Counter(s).items():
            if v==1:
                return s.find(k)
        return -1
```

```scala
object Solution {
    def firstUniqChar(s: String): Int = {
        var map = scala.collection.mutable.Map.empty[Char, (Int, Int)]
        (0 to s.length-1).map(i =>
            map.get(s.charAt(i)) match{
                case Some(indexAndCount) => map += (s.charAt(i) -> (i, indexAndCount._2 + 1))
                case None => map += (s.charAt(i) -> (i, 1))
            }
        )
        map.toList.filter(x => x._2._2 == 1).map(_._2._1).sorted.headOption.getOrElse(-1)
    }
}

//Alternate/Better SCALA solution
object Solution {
    def firstUniqChar(s: String): Int = {
        val hmap =  s.toCharArray.groupBy(identity).mapValues(_.length)
        val uniqChar = s.toCharArray.zipWithIndex.find (p => hmap(p._1) == 1)
        if(uniqChar.nonEmpty) uniqChar.get._2 else -1 
    }
}

/**How the above solution works:
scala> val a = "akashs"
a: String = akashs

scala> a.toCharArray.groupBy(identity)
res0: scala.collection.immutable.Map[Char,Array[Char]] = Map(h -> Array(h), k -> Array(k), s -> Array(s, s), a -> Array(a, a))

scala> a.toCharArray.groupBy(identity).mapValues(_.length)
res1: scala.collection.immutable.Map[Char,Int] = Map(h -> 1, k -> 1, s -> 2, a -> 2)

scala> a.toCharArray.zipWithIndex
res2: Array[(Char, Int)] = Array((a,0), (k,1), (a,2), (s,3), (h,4), (s,5))

scala> a.toCharArray.zipWithIndex.find(x => res1(x._1) == 1)
res3: Option[(Char, Int)] = Some((k,1))
*/

```

###  1.175. <a name='FindtheDifference'></a>389. Find the Difference

[小梦想家](https://www.bilibili.com/video/BV1Et411K7jP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

```py
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        for c in t:
            if t.count(c)!=s.count(c):
                return c
        return ""

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return next(iter(Counter(t)-Counter(s)))

Python 1行 ASCII 和之差

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return chr(sum(map(ord, t)) - sum(map(ord, s)))

每一个字符都对应一个 ASCII 数字，那么那个不同的数字的 ASCII 码就等于 t 的所有字符码之和 - s 的
ord 函数将单个字符转换为 ASCII 码， chr相反

👆👆👆 py3 1行(列表生成器 and 生成器，这就是你py3写不到一行代码的差距 没说你)

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return [x for x in t if t.count(x)-s.count(x)==1][0]

Counter O(n)：

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return next((Counter(t)-Counter(s)).elements())
位运算 O(n)：

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return chr(reduce(xor, map(ord, s+t)))
```

```py
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return (collections.Counter(t) - collections.Counter(s)).popitem()[0]

python reduce+lambda 一行。ord()取字符对应ascii码,chr()返回ascii码对应字符

class Solution(object):
    def findTheDifference(self, s, t):
        return reduce(lambda x,y: chr(ord(x) ^ ord(y)),s+t)

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return [x for x in t if t.count(x)-s.count(x)==1][0]      

这应该是最简单的方法了吧

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        ret = 0
        for c in s + t:
            ret ^= ord(c)
        return chr(ret)

一行极简

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return [x for x in t if t.count(x)-s.count(x)==1][0]
```




###  1.176. <a name='PerfectRectangle'></a>391. Perfect Rectangle

[花花酱](https://www.bilibili.com/video/BV184411c7cs?spm_id_from=333.999.0.0)

###  1.177. <a name='IsSubsequence'></a>392. Is Subsequence

[小梦想家](https://www.bilibili.com/video/BV1fg4y1q7eT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Za4y1a73v?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19f4y197yS?spm_id_from=333.999.0.0)

```py
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        n, m = len(s), len(t)
        i = j = 0
        while i < n and j < m:
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == n

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/is-subsequence/solution/pan-duan-zi-xu-lie-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        n, m = len(s), len(t)
        f = [[0] * 26 for _ in range(m)]
        f.append([m] * 26)

        for i in range(m - 1, -1, -1):
            for j in range(26):
                f[i][j] = i if ord(t[i]) == j + ord('a') else f[i + 1][j]
        
        add = 0
        for i in range(n):
            if f[add][ord(s[i]) - ord('a')] == m:
                return False
            add = f[add][ord(s[i]) - ord('a')] + 1
        
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/is-subsequence/solution/pan-duan-zi-xu-lie-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


这题就是 公共最长子序列LCS的翻版。。代码一模一样，只需要最后判定 LCS长度是否等于短字符串长度即可，这样最好理解。。。

class Solution(object):
    def isSubsequence(self, s, t):
        m, n = len(s), len(t)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1, 1):
            for j in range(1, n + 1, 1):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return True if dp[m][n] == m else False
```

```py
dp挺难理解的,代码加了注释希望帮助理解吧

class Solution2:
    def isSubsequence(self, s: str, t: str) -> bool:
        '''动态规划,挺难理解的'''
        n, m = len(s), len(t)
        f = [[0] * 26 for _ in range(m)] # 初始化m个长度为26的列表记录字母a-z的位置
        f.append([m] * 26)

        for i in range(m - 1, -1, -1):
            for j in range(26):
                # 记录字母a-z在t[i:]中的位置,如果第i个字符等于字符[a-z][j],那么j在i的位置,
                #否则j在t[i+1:]范围,这里倒序遍历,如果j不存在那么f[i][j]的值就是m
                f[i][j] = i if ord(t[i]) == j + ord('a') else f[i + 1][j]

        add = 0
        for i in range(n):
            if f[add][ord(s[i]) - ord('a')] == m: # 从t的第0个字符开始,如果f[0][j]==m,
                # 也就是说字母j不在t内,返回false,[ord(s[i]) - ord('a')]表示j,也就是在f数组中
                #的位置
                return False
            add = f[add][ord(s[i]) - ord('a')] + 1

        return True



思路一：库函数

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool: 
        loc = -1
        for a in s:
            loc = t.find(a, loc + 1)
            if loc == -1:
                return False
        return True
思路二：生成迭代器

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        t = iter(t)
        return all(c in t for c in s)
思路三：双指针

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i = 0
        j = 0
        while i < len(s) and j < len(t):
            # print(i, j)
            if s[i] == t[j]:
                i += 1
                j += 1
            else:
                j += 1    
        return i == len(s)
思路四：二分法

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:  
        from collections import defaultdict
        import bisect
        lookup = defaultdict(list)
        for idx, val in enumerate(t):
            lookup[val].append(idx)
        # print(lookup)
        loc = -1
        for a in s:
            j = bisect.bisect_left(lookup[a], loc + 1)
            if j >= len(lookup[a]): return False
            loc = lookup[a][j]
        return True


```

```py

简单粗暴.

class Solution(object):
    def isSubsequence(self, s, t):
        """
        :type a: str
        :type b: str
        :rtype: bool
        """
        t = iter(t)
        return all(i in t for i in s) 


翻译了一下

class Solution(object):
    def isSubsequence(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        t = iter(t)
        res = []
        for c in s:
            if c in t:
                res.append(c)
            else:
                res.append(None)

        res = iter(res)
        return all(res)
```

###  1.178. <a name='UTF-8Validation'></a>393. UTF-8 Validation

[花花酱](https://www.bilibili.com/video/BV1SE411w7no?spm_id_from=333.999.0.0)

###  1.179. <a name='DecodeString'></a>394 Decode String

[小明](https://www.bilibili.com/video/BV145411V75E?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GZ4y1p7pE?spm_id_from=333.999.0.0)

```py
# 类似正则表达式
# 神仙神仙，看了半天才看明白，每次只匹配最里层的，
# 将匹配到的字符串自动分成数字和字母，然后用转换函数替换成新串，
# 替换完内层后再去替换外层，直到没有括号为止。函数式编程和正则表达式玩的好秀。
# 牛的，看了半天终于懂了，不过这里r的意思应该是取消python转义吧
import re

class Solution(object):
    def decodeString(self, s):
        """
        :type s: str
        :rtype: str
        """
        def f(m):
            print("m:",m)
            print("m.group(1):",m.group(1))
            print("m.group(2):",m.group(2))
            return int(m.group(1))* m.group(2)
        while '[' in s:
            s = re.sub(r'(\d+)\[([A-Za-z]*)\]', f, s)
        return s
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1a1r7x6jdqww.png" width="50%">

```py
# 当前的 context 有两个值，一个是当前打印的串，一个是重复的数量。

# 我写了个状态机来解这个题目：

class Solution:
    def decodeString(self, s: str) -> str:
        res = ''       # 当前打印串
        count = 0   # 下一个 pattern 的数量
        stack = []
        for c in s:
            if ord('a') <= ord(c) <= ord('z'):
                res += c
            elif ord('0') <= ord(c) <= ord('9'):
                count = count * 10 + int(c)
            elif c == '[':
                stack.append((res, count))
                res = ''
                count = 0
            elif c == ']':
                ctx_res, ctx_count = stack.pop()
                res = ctx_res + res * ctx_count
        return res
class Solution:
    def decodeString(self, s: str) -> str:
        stk = []
        for ch in s:
            if ch == ']':
                sub = ''
                while stk[-1] != '[':
                    sub = stk.pop() + sub
                stk.pop()
                n = ''
                while stk and stk[-1].isdigit():
                    n = stk.pop() + n
                stk.append(int(n) * sub)
            else:
                stk.append(ch)
        return ''.join(stk)
# Python3简洁代码

# 本题核心思路是在栈里面每次存储两个信息, (左括号前的字符串, 左括号前的数字), 
# 比如abc3[def], 当遇到第一个左括号的时候，压入栈中的是("abc", 3), 
# 然后遍历括号里面的字符串def, 当遇到右括号的时候, 从栈里面弹出一个元素(s1, n1), 
# 得到新的字符串为s1+n1*"def", 也就是abcdefdefdef。对于括号里面嵌套的情况也是同样处理方式。
# 凡是遇到左括号就进行压栈处理，遇到右括号就弹出栈，栈中记录的元素很重要。
### 代码

class Solution:
    def decodeString(self, s: str) -> str:
        stack = []  # (str, int) 记录左括号之前的字符串和左括号外的上一个数字
        num = 0
        res = ""  # 实时记录当前可以提取出来的字符串
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c)
            elif c == "[":
                stack.append((res, num))
                res, num = "", 0
            elif c == "]":
                top = stack.pop()
                res = top[0] + res * top[1]
            else:
                res += c
        return res
```

###  1.180. <a name='LongestSubstringwithAtLeastK'></a>395 Longest Substring with At Least K

[小明](https://www.bilibili.com/video/BV1hD4y1X7rq?spm_id_from=333.999.0.0)

###  1.181. <a name='EvaluateDivision'></a>399. Evaluate Division

[花花酱](https://www.bilibili.com/video/BV1iW41167Nb?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XU4y1s7Lk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ko4y1f7eK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rZ4y1N7CW?spm_id_from=333.999.0.0)

```py
这道题非常好,可以用的图的DFS 和 BFS来做.

首先,我们要把除法运算转化成图表示,比如a->b = 2.0 b->c = 3.0,a,b,c看出节点,相处所的值为权值.那么a/c = ?就是相当于,a->c <==> a->b->c = 2.0*3.0= 6,所以我们要把已知条件建图!

接下来,就是遍历方法,这里有两种方法,

一种是DFS,一种是BFS

这两种方法还是看代码一步一步理解较好!


# DFS
  def calcEquation(self, equations, values, queries):
        """
        :type equations: List[List[str]]
        :type values: List[float]
        :type queries: List[List[str]]
        :rtype: List[float]
        """
        from collections import defaultdict
        graph = defaultdict(set)
        weight = defaultdict()
        lookup = {}
        # 建图
        for idx, equ in enumerate(equations):
            graph[equ[0]].add(equ[1])
            graph[equ[1]].add(equ[0])
            weight[tuple(equ)] = values[idx]
            weight[(equ[1], equ[0])] = float(1 / values[idx])

        # 深度遍历(DFS)
        def dfs(start, end, vistied):
            # 当图中有此边,直接输出
            if (start, end) in weight:
                return weight[(start, end)]
            # 图中没有这个点
            if start not in graph or end not in graph:
                return 0
            # 已经访问过
            if start in vistied:
                return 0
            vistied.add(start)
            res = 0
            for tmp in graph[start]:
                res = (dfs(tmp, end, vistied) * weight[(start, tmp)])
                # 只要遍历到有一个不是0的解就跳出
                if res != 0:
                    # 添加此边,以后访问节省时间
                    weight[(start, end)] = res
                    break
            vistied.remove(start)
            return res

        res = []
        for que in queries:
            # 用集合记录是否已经访问节点
            tmp = dfs(que[0], que[1], set())
            if tmp == 0:
                tmp = -1.0
            res.append(tmp)
        return res
# BFS
    def calcEquation(self, equations, values, queries):
        from collections import defaultdict, deque
        graph = defaultdict(set)
        weight = defaultdict()
        lookup = {}
        # 建图
        for idx, equ in enumerate(equations):
            graph[equ[0]].add(equ[1])
            graph[equ[1]].add(equ[0])
            weight[tuple(equ)] = values[idx]
            weight[(equ[1], equ[0])] = float(1 / values[idx])
        res = []
        for start, end in queries:
            if (start, end) in weight:
                res.append(weight[(start, end)])
                continue
            if start not in graph or end not in graph:
                res.append(-1)
                continue
            if start == end:
                res.append(1.0)
                continue
            stack = deque()
            # 将从start点可以到达下一个节点压入栈内
            for tmp in graph[start]:
                stack.appendleft((tmp, weight[(start, tmp)]))
            # 记录访问节点
            visited = {start}
            # 为了跳出双循环
            flag = False
            while stack:
                c, w = stack.pop()
                if c == end:
                    flag = True
                    res.append(w)
                    break
                visited.add(c)
                for n in graph[c]:
                    if n not in visited:
                        weight[(start, n)] = w * weight[(c, n)]
                        stack.appendleft((n, w * weight[(c, n)]))
            if flag:
                continue
            res.append(-1.0)
        return res
```

```py
带权图上的广度优先搜索

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:

        """BFS
        1.将给定的条件存储成图的带权邻接表。给定a/b=2，存储成a:{b:2}和b:{a:0.5}
        2.给定查询x/y，使用广度优先遍历查询x到y的路径，结果res为路径上的权值乘积
        """
        self.graph = defaultdict(dict)
        def bfs(start, end):
            queue = deque()
            visited = set()
            queue.append([start, 1])
            visited.add(start)
            while queue:
                cur, weight = queue.pop()
                if cur == end:
                    return weight
                for key, val in self.graph[cur].items():
                    if key not in visited:
                        visited.add(key)
                        queue.append([key, val * weight])
            return -1
        for nodes, val in zip(equations, values):
            self.graph[nodes[0]][nodes[1]] = val
            self.graph[nodes[1]][nodes[0]] = 1 / val
        res = []
        for node1, node2 in queries:
            if node1 not in self.graph or node2 not in self.graph:
                res.append(-1)
            else:
                res.append(bfs(node1, node2))
        return res
```

```py
基于字典的Floyd算法，执行时间击败了98%

from collections import defaultdict

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        edges = defaultdict(dict)
        verts = set()

        for (a, b), c in zip(equations, values):
            verts.add(a)
            verts.add(b)

            edges[a][b] = c
            edges[b][a] = 1 / c

        for k in verts:
            ek = edges[k]
            for i in verts:
                if i == k:
                    continue

                ei = edges[i]
                for j in verts:
                    if k == j or i == j or j in ei:
                        continue
                
                    if k in ei and j in ek:
                        ei[j] = ei[k] * ek[j]

        rst = []
        for a, b in queries:
            if a in edges and b in edges[a]:
                rst.append(edges[a][b])
            elif a == b and a in verts and b in verts:
                rst.append(1)
            else:
                rst.append(-1)

        return rst
```

###  1.182. <a name='RemoveKDigits'></a>402 Remove K Digits

[小明](https://www.bilibili.com/video/BV1PV411C79X?spm_id_from=333.999.0.0)

###  1.183. <a name='SumofLeftLeaves'></a>404. Sum of Left Leaves

[小梦想家](https://www.bilibili.com/video/BV1Et411K7wa?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15a4y1779U?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        isLeafNode = lambda node: not node.left and not node.right

        def dfs(node: TreeNode) -> int:
            ans = 0
            if node.left:
                ans += node.left.val if isLeafNode(node.left) else dfs(node.left)
            if node.right and not isLeafNode(node.right):
                ans += dfs(node.right)
            return ans
        
        return dfs(root) if root else 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sum-of-left-leaves/solution/zuo-xie-zi-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        isLeafNode = lambda node: not node.left and not node.right
        q = collections.deque([root])
        ans = 0

        while q:
            node = q.popleft()
            if node.left:
                if isLeafNode(node.left):
                    ans += node.left.val
                else:
                    q.append(node.left)
            if node.right:
                if not isLeafNode(node.right):
                    q.append(node.right)
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sum-of-left-leaves/solution/zuo-xie-zi-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root==None:
            return 0
        if root.left and root.left.left==None and root.left.right==None:
            return root.left.val+self.sumOfLeftLeaves(root.right)
        else:
            return self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)

root.left 为null时，再调用self.sumOfLeftLeaves(root.left)是不是没有必要，虽然它返回0？

最后一个else不仅包括root.left为空的情况，还包括了有左子树但是左子树不是一个叶子的情况，所以那部分还是不能省掉吧。

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        self.res=0
        def dfs(root):
            if root.left:
                if not root.left.left and not root.left.right:
                    self.res+=root.left.val
                dfs(root.left)
            if root.right:
                dfs(root.right)
            return self.res
        return dfs(root)

dfs

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        def dfs(root, is_left):
            if not root: return 0
            if not root.left and not root.right and is_left: #leaf
                return root.val
            return dfs(root.left, 1) + dfs(root.right, 0)
        return dfs(root, 0)
bfs

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root: return 0
        Q,res = list(), 0
        Q.append((root,0))
        while len(Q)>0:
            node, is_left = Q.pop(0)
            if node.left:
                Q.append((node.left, 1))
            if node.right:
                Q.append((node.right, 0))
            if not node.left and not node.right and is_left:
                res+=node.val
        return res
```

###  1.184. <a name='ConvertaNumbertoHexadecimal'></a>405-Convert a Number to Hexadecimal

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7ds?spm_id_from=333.999.0.0)

```py
class Solution:
    def toHex(self, num):
        """
        :type num: int
        :rtype: str
        """
        if num<0:
            num = (1<<32)+num
        return format(num, '0x')

class Solution:
    def toHex(self, num):
        """
        :type num: int
        :rtype: str
        """
        if num == 0:
            return '0'
        if num < 0:
            num += 2 ** 32

        # --------核心代码，确实厉害--------
        ans = ''
        hexdigits = '0123456789abcdef'
        while num:
            ans += hexdigits[num % 16]
            num //= 16
        return ans[::-1]
        # --------核心代码，确实厉害--------

class Solution(object):
    def toHex(self, num):
        """
        :type num: int
        :rtype: str
        """
        if not num :
            return "0"

        result = []
        hexStr ="0123456789abcdef"
        while num and len(result) != 8:
            h = num & 15
            result.append(hexStr[h])
            # num >>= 4,等效
            num //= 16

        return ''.join(result[::-1])
```

###  1.185. <a name='QueueReconstructionbyHeight'></a>406. Queue Reconstruction by Height 

[小明](https://www.bilibili.com/video/BV1xC4y1a72W?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV144411R7ch?spm_id_from=333.999.0.0)

```py
# 代码很简单，思路还不太好想

class Solution(object):
    def reconstructQueue(self, people):
        people = sorted(people, key=lambda x: (-x[0], x[1]))
        result = []
        for each in people:
            result.insert(each[1], each)
        return result

class Solution:
    def reconstructQueue(self, people):
        q = []
        for item in sorted(people, key=lambda x: (-x[0], x[1])):
            q.insert(item[1], item)
        return q

class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x:(-x[0], x[1]))
        res = []
        for p in people:
            res.insert(p[1], p)
        return res

class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x: (-x[0], x[1]))
        n = len(people)
        ans = list()
        for person in people:
            ans[person[1]:person[1]] = [person]
        return ans
```

###  1.186. <a name='ValidWordAbbreviation'></a>408. Valid Word Abbreviation

[小梦想家](https://www.bilibili.com/video/BV1A4411q74A?spm_id_from=333.999.0.0)

###  1.187. <a name='LongestPalindrome'></a>409. Longest Palindrome

[小梦想家](https://www.bilibili.com/video/BV1B441127W2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19C4y1479a?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Lk4y1z7PG?spm_id_from=333.999.0.0)

```py
class Solution:
    def longestPalindrome(self, s: str) -> int:
        ans = 0
        count = collections.Counter(s)
        for v in count.values():
            ans += v // 2 * 2
            if ans % 2 == 0 and v % 2 == 1:
                ans += 1
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-palindrome/solution/zui-chang-hui-wen-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
找出出现次数为偶数的求和，再找出所有奇数减一求和。因为奇数是可以拆成偶数使用的

class Solution:
    def longestPalindrome(self, s: str) -> int:
        dic = {}
        for i in s:
            if i not in dic:
                dic[i] = 0
            dic[i] += 1
        nums1 = []; nums2 = []
        for i in dic.values():
            if i%2 == 0: nums1.append(i)
            else: nums2.append(i - 1)
        a = sum(nums1) if nums1 != [] else 0
        b = sum(nums2) + 1 if nums2 != [] else 0
        return a + b

扣友们好，扣友们再见

class Solution:
    def longestPalindrome(self, s: str) -> int:
        flag = False
        res = 0
        for i in Counter(s).values():
            res += i//2*2
            if i % 2 != 0:
                flag = True       
        return res+1 if flag else res


python代码贴一下，速度打败75%，内存打败92%

class Solution:
    def longestPalindrome(self, s: str) -> int:
        cnt = [0] * 58 # 大写和小写字母之间隔了6个ASCII码
        for i in s:
            cnt[ord(i)-ord('A')] += 1
        ans = 0
        for j in cnt:
            ans += (j // 2) * 2
        return ans + int(ans < len(s)) # 如果ans比原字符串短，就说明可以拿一个字符做中心


直接统计s，最后按照字符数除以2向下取整乘以2，如果某一个字符出现奇数次，组合的回文数加1；


class Solution:
    def longestPalindrome(self, s: str) -> int:
        from collections import Counter
        counter_s = Counter(s)
        ans = 0
        c = 0
        for key, value in counter_s.items():
            if value >= 2:
                ans += value // 2 * 2
            if value % 2 == 1:
                c = 1
        return ans + c
```



###  1.188. <a name='SplitArrayLargestSum'></a>410. Split Array Largest Sum

[花花酱](https://www.bilibili.com/video/BV14W411d7D4?spm_id_from=333.999.0.0)

###  1.189. <a name='FizzBuzz'></a>412. Fizz Buzz

[小梦想家](https://www.bilibili.com/video/BV1xE411R7yK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tD4y1m76j?spm_id_from=333.999.0.0)

```py
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        ans = []
        for i in range(1, n + 1):
            s = ""
            if i % 3 == 0:
                s += "Fizz"
            if i % 5 == 0:
                s += "Buzz"
            if s == "":
                s = str(i)
            ans.append(s)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/fizz-buzz/solution/fizz-buzz-by-leetcode-solution-s0s5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python 3.10的解法 可惜目前不支持

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        res = []
        for i in range(1, n+1):
            match (i % 3 == 0), (i % 5 == 0):
                case True, True: res.append("Fizzbuzz")
                case True, _: res.append("Fizz")
                case _, True: res.append("Buzz")
                case _: res.append(i)
        return res
```

```py
一行流

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        return ['Fizz'*(not i%3)+'Buzz'*(not i%5) or str(i) for i in range(1,n+1)]

一行python完事

class Solution(object):
    def fizzBuzz(self, n):
        return ["FizzBuzz" if i % 15 == 0 else "Fizz" if i % 3 == 0 else "Buzz" if i % 5 == 0 else str(i) for i in range(1, n + 1)]
```

```scala
object Solution {
    def fizzBuzz(n: Int): List[String] = {
        (1 to n).map(num => {
            if(num%15 == 0)
                "FizzBuzz"
            else if(num%5 == 0)
                "Buzz"
            else if(num%3 == 0)
                "Fizz"
            else
                num.toString
        }).toList
    }
}

```

###  1.190. <a name='-1'></a>413-等差数列划分

[哈哈哈](https://www.bilibili.com/video/BV13a4y1i7tR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13f4y167YZ?spm_id_from=333.999.0.0)

```py
# 双指针，不用递归不用动态规划，i代表数列起始位置，j代表数列终结位置，
# 如果不满足等差数列，就把i移动到j-1处，满足就计数（不是+1，而是＋j-i-1）

class Solution(object):
    def numberOfArithmeticSlices(self, nums):
        n=len(nums)
        if n<3:
            return 0
        i=0
        j=2
        c=0
        while(j<n):
            if j-i<2:
                j+=1
                continue
            if nums[j]-nums[j-1]==nums[j-1]-nums[j-2]:
                c+=j-i-1
                j+=1
            else:
                i=j-1
        return c

class Solution:
    def numberOfArithmeticSlices(self, nums):
        n = len(nums)
        dp = [0]*n
        for i in range(2,n):
            dp[i] = dp[i-1]+1 if nums[i]-nums[i-1]==nums[i-1]-nums[i-2] else 0
        return sum(dp)

class Solution:
    def numberOfArithmeticSlices(self, nums):
        if len(nums) < 3: return 0
        dp = [0] * len(nums)
        for i in range(2, len(nums)):
            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:
                # 如果能和前两位数字组成等差数列
                # 以i为结尾的数字可以和前两位组成新的等差数列（1个）
                # 以i-1位置数字为结尾的等差数列加上i位置的数字可以组成新的等差数列（dp[i-1]）
                # 因此以i位置数字结尾的等差数列为上面两种等差数列数量的和
                dp[i] = dp[i-1] + 1
        return sum(dp)

class Solution:
    def numberOfArithmeticSlices(self, nums):
        i, res = 0, 0
        while i <= len(nums)-3:
            j = i + 1
            differ = nums[j] - nums[i]
            while j + 1 < len(nums) and nums[j+1] - nums[j] == differ:
                j += 1
            
            res += (j - i) * (j - i - 1) // 2
            i = j

        return res

class Solution:
    def numberOfArithmeticSlices(self, nums):
        if len(nums)<3:return 0
        ans=0
        lenth=2
        nums[0]=nums[1]-nums[0]
        for i in range(2,len(nums)):
            nums[i-1]=nums[i]-nums[i-1]
            if nums[i-1]==nums[i-2]:
                lenth+=1
            elif lenth>2:
                ans+=(lenth-2)*(lenth-1)//2
                lenth=2
            else:
                lenth=2
        if lenth>2:
            return (lenth-2)*(lenth-1)//2+ans
        return ans
```

###  1.191. <a name='ThirdMaximumNumber'></a>414. Third Maximum Number

[小梦想家](https://www.bilibili.com/video/BV1UE411X7k1?spm_id_from=333.999.0.0)

###  1.192. <a name='AddStrings'></a>415-Add Strings

[哈哈哈](https://www.bilibili.com/video/BV18E411n7Cy?spm_id_from=333.999.0.0)

###  1.193. <a name='PartitionEqualSubsetSum'></a>416. Partition Equal Subset Sum

[花花酱](https://www.bilibili.com/video/BV1AW411y7So?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oZ4y1G7QY?spm_id_from=333.999.0.0)

```py
# python 一行：
from functools import reduce 
class Solution(object):
    def canPartition(self, s):
        return 1-sum(s)%2==reduce(lambda x,y:x|(x<<y), s, 1)>>sum(s)//2&1
# 思路很简单，就是每次循环拿一个数字，在和既有的求和结果组合。

# 但是能想到这个是真的厉害。牛逼。 我把字典换成集合，加了点注释

class Solution:
    # 讨论区看到的一种解法，很巧妙。
    def canPartition(self, nums: List[int]) -> bool:
        # 常规判定
        if len(nums) < 2:
            return  False

        ac = sum(nums)
        if ac % 2 == 1:
            return  False

        res_ = ac / 2
        # 利用集合记录各种组合下来的和
        d = set()
        #最开始，什么都不取。这也是为了后面，对应不取某个数字的操作
        d.add(0)
        # 顺次取数字
        for num in nums:
            # 和既有的和操作，key = 0时，说明不取这个数，
            for k in list(d):
                r = num + k
                # 每次判定是否达标
                if r == res_:
                    return True
                # 计算的和加入字典
                d.add(r)
        return False

class Solution(object):
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        if not nums or len(nums) == 0:
            return True
        if sum(nums) % 2 != 0: ## 总和必须为偶数，否则肯定无法取两个集合的sum相等
            return False
        half_sum = sum(nums)//2
        dp = [False] * (half_sum+1)
        dp[0] = True
        for i in range(len(nums)):
            for j in range(half_sum, nums[i]-1, -1):
                dp[j] = dp[j] or dp[j-nums[i]]
        print(dp)
        return dp[half_sum]

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        taraget = sum(nums)
        if taraget % 2 == 1: return False
        taraget //= 2
        dp = [0] * 10001
        for i in range(len(nums)):
            for j in range(taraget, nums[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
        return taraget == dp[taraget]
# 可以看成重量和价值都为nums的01背包问题

class Solution(object):
    def canPartition(self, nums):
        sums = sum(nums)
        if sums%2==1:
            return False
        sums= sums//2
        dp = [0 for i in range(sums+1)]
        for i in range(1,len(nums)+1):
            for j in range(sums,0,-1):
                if j>=nums[i-1]:
                    dp[j] = max(dp[j],dp[j-nums[i-1]]+nums[i-1])
        return dp[-1]==sums

# python递归...

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        # @lru_cache(None)
        def dp(i,N):                                #dp(i,N)返回nums[0...i]中且当前和为N的状态下，能否凑成和为target的结果
            if N>target or i<0:return False
            if N==target:return True
            return dp(i-1,N+nums[i]) or dp(i-1,N)   #每次可以选择将nums[i]加进N，或者不将nums[i]加进N

        if sum(nums)%2!=0:return False              #目标和为奇数时不能分割成两个元素相等的子集
        target=sum(nums)//2                         #原问题等价于将nums划分为元素和为nums一半的两个子集的划分方式是否存在
        return dp(len(nums)-1,0)
```

```py

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 2:
            return False
        
        total = sum(nums)
        if total % 2 != 0:
            return False
        
        target = total // 2
        dp = [True] + [False] * target
        for i, num in enumerate(nums):
            for j in range(target, num - 1, -1):
                dp[j] |= dp[j - num]
        
        return dp[target]
```

###  1.194. <a name='PacificAtlanticWaterFlow'></a>417. Pacific Atlantic Water Flow

[花花酱](https://www.bilibili.com/video/BV1Kb411K7ty?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1by4y1h7ab?spm_id_from=333.999.0.0)

```py
class Solution:
    def __init__(self):
        self.result_all = None
        # 分别表示上右下左
        self.directs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        self.m = 0
        self.n = 0
        # 表示能流到太平洋
        self.po = None
        # 表示能流到大西洋
        self.ao = None
        self.visited = None
    
    
    def pacificAtlantic(self, matrix) :
        # 初始化一些东西
        self.result_all = []
        self.m = len(matrix)
        if self.m == 0:
            return self.result_all
        self.n = len(matrix[0])
        self.ao = [[0] * self.n for _ in range(self.m)]
        self.po = [[0] * self.n for _ in range(self.m)]
        self.visited = [[0] * self.n for _  in range(self.m)]

        # 本题顺着流不太好做，我们用逆流的方式来思考
        # 从上面的太平洋逆流
        for i in range(0, 1):
            for j in range(self.n):
                self.dfs(matrix, i, j, True)
        # 从左边的太平洋逆流
        self.visited = [[0] * self.n for _  in range(self.m)]
        for i in range(self.m):
            for j in range(0, 1):
                self.dfs(matrix, i, j, True)
        # 下面的大西洋
        self.visited = [[0] * self.n for _  in range(self.m)]
        for i in range(self.m - 1, self.m):
            for j in range(self.n):
                self.dfs(matrix, i, j, False)
        # 右边的大西洋
        self.visited = [[0] * self.n for _  in range(self.m)]
        for i in range(self.m):
            for j in range(self.n -1, self.n):
                self.dfs(matrix, i, j, False)
        
        for i in range(self.m):
            for j in range(self.n):
                if self.po[i][j] == 1 and self.ao[i][j] == 1:
                    self.result_all.append((i, j))
        return self.result_all

    def dfs(self, matrix, x, y, flag):
        if self.visited[x][y] == 1:
            return
        self.visited[x][y] = 1
        if flag:
            # 表示是太平洋
            self.po[x][y] = 1
        else:
            # 表示是大西洋
            self.ao[x][y] = 1

        for i in range(4):
            newx = x + self.directs[i][0]
            newy = y + self.directs[i][1]
            if not self.in_area(newx, newy):
                continue
            if matrix[x][y] > matrix[newx][newy]:
                continue
            self.dfs(matrix, newx, newy, flag)
        return
    
    def in_area(self, x, y):
        return 0 <= x < self.m and 0 <= y < self.n


作者：jawhiow
链接：https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/shen-du-sou-suo-dfs-by-jawhiow/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def bfs(self, heights: List[List[int]], src: List[List[int]], cnt: List[List[int]]) -> None:
        direction = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        m, n = len(heights), len(heights[0])
        visited = [[False] * n for _ in range(m)]
        from collections import deque
        q = deque(src)
        while q:
            x, y = q.popleft()
            for i, j in direction:
                row, col = x + i, y + j
                if 0 <= row < m and 0 <= col < n and not visited[row][col] and \
                    (x in (-1, m) or y in (-1, n) or heights[row][col] >= heights[x][y]):
                    visited[row][col] = True
                    cnt[row][col] += 1
                    q.append((row, col))
    
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        cnt = [[0] * n for _ in range(m)]
        # 1. 从太平洋逆流而上
        self.bfs(heights, [(-1, col) for col in range(n)] + [(row, -1) for row in range(m)], cnt)

        # 2. 从大西洋逆流而上
        self.bfs(heights, [(m, col) for col in range(n)] + [(row, n) for row in range(m)], cnt)
        # 3. 筛选出 cnt[row][col] = 2 的坐标
        return [[row, col] for row in range(m) for col in range(n) if cnt[row][col] == 2]
```

```py
Python 版本逆流而上

class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        res = []
        if not matrix or len(matrix) == 0:
            return res

        directions = [[0,1], [0,-1], [1, 0], [-1,0]]

        m = len(matrix)
        n = len(matrix[0])

        canP = [[0] * n for _ in range(m)]
        canA = [[0] * n for _ in range(m)]

        def dfs(row, col, ocean):
            if not ocean[row][col]:
                ocean[row][col] = 1
                for direction in directions:
                    x = row + direction[0]
                    y = col + direction[1]
                    if x >= m or x < 0  or y >= n or y < 0 or matrix[x][y] < matrix[row][col]:
                        continue
                    dfs(x, y, ocean)

        for i in range(m):
            dfs(i, 0, canP)
            dfs(i, n-1, canA)

        for j in range(n):
            dfs(0, j, canP)
            dfs(m-1, j, canA)

        for i in range(m):
            for j in range(n):
                if canA[i][j] and canP[i][j]:
                    res.append([i,j])
        return res

python 简洁解法

class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        A, B = set(), set()
        def dfs(i, j, vis):
            vis.add((i, j))
            for ni, nj in ((i+1, j), (i-1, j), (i, j-1), (i, j+1)):
                if -1<ni<m and -1<nj<n and heights[ni][nj]>=heights[i][j]\
                    and (ni, nj) not in vis:
                    dfs(ni, nj, vis)
        
        for i in range(m): dfs(i, 0, A);dfs(i, n-1, B)
        for j in range(n): dfs(0, j, A);dfs(m-1, j, B)
        return [list(i) for i in A&B]

python 多源 bfs

从第一行和第一列开始遍历非递减格子，即可得到所有能流到“太平洋”的格子。 同理从最后一行和最后一列遍历，得到所有能流到“太西洋”的格子，求交集即可。

class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        def bfs(A):
            queue, vis = deque(A), set(A)
            while queue:
                i, j = queue.popleft()
                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                    if 0<=x<m and 0<=y<n and (x, y) not in vis and heights[x][y]>=heights[i][j]:
                        queue.append((x, y))
                        vis.add((x, y))
            return vis

        m, n = len(heights), len(heights[0])
        A = {(0, j) for j in range(n)} | {(i, 0) for i in range(m)}
        B = {(m-1, j) for j in range(n)} | {(i, n-1) for i in range(m)}
        return [[i, j] for i, j in bfs(A) & bfs(B)]
```

###  1.195. <a name='BattleshipsinaBoard'></a>419. Battleships in a Board 

[小梦想家](https://www.bilibili.com/video/BV1TJ411j7QZ?spm_id_from=333.999.0.0)

###  1.196. <a name='MaximumXORofTwoNumbersinanArray'></a>421 Maximum XOR of Two Numbers in an Array

[小明](https://www.bilibili.com/video/BV1s64y1F7Wm?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMaximumXOR(self, nums):
        # 最高位的二进制位编号为 30
        HIGH_BIT = 30

        x = 0
        for k in range(HIGH_BIT, -1, -1):
            seen = set()
            # 将所有的 pre^k(a_j) 放入哈希表中
            for num in nums:
                # 如果只想保留从最高位开始到第 k 个二进制位为止的部分
                # 只需将其右移 k 位
                seen.add(num >> k)

            # 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分
            # 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1
            x_next = x * 2 + 1
            found = False
            
            # 枚举 i
            for num in nums:
                if x_next ^ (num >> k) in seen:
                    found = True
                    break

            if found:
                x = x_next
            else:
                # 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0
                # 即为 x = x*2
                x = x_next - 1
        
        return x

class Solution(object):
    def findMaximumXOR(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        answer = 0
        for i in range(32)[::-1]:
            answer <<= 1
            prefixes = {num >> i for num in nums}
            answer += any(answer^1 ^ p in prefixes for p in prefixes)
        return answer
```

###  1.197. <a name='ReconstructOriginalDigitsfromEnglish'></a>423 Reconstruct Original Digits from English

[小明](https://www.bilibili.com/video/BV1554y1h73S?spm_id_from=333.999.0.0)

###  1.198. <a name='LongestRepeatingCharacterReplacem'></a>424. 替换后的最长重复字符 Longest Repeating Character Replacem

[官方](https://www.bilibili.com/video/BV14r4y1K7rN?spm_id_from=333.999.0.0)

###  1.199. <a name='N-aryTreeLevelOrderTraversal'></a>429. N-ary Tree Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1CE411Q7BQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Uv411K77M?spm_id_from=333.999.0.0)

```py
def levelOrder(self, root: 'Node') -> List[List[int]]:
    if root is None:
        return []
    result = []
    queue = collections.deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            queue.extend(node.children)
        result.append(level)
    return result

作者：LeetCode
链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def levelOrder(self, root: 'Node') -> List[List[int]]:
    if root is None:
        return []        

    result = []
    previous_layer = [root]

    while previous_layer:
        current_layer = []
        result.append([])
        for node in previous_layer:
            result[-1].append(node.val)
            current_layer.extend(node.children)
        previous_layer = current_layer
    return result

作者：LeetCode
链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def levelOrder(self, root: 'Node') -> List[List[int]]:

    def traverse_node(node, level):
        if len(result) == level:
            result.append([])
        result[level].append(node.val)
        for child in node.children:
            traverse_node(child, level + 1)

    result = []

    if root is not None:
        traverse_node(root, 0)
    return result

作者：LeetCode
链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
Python版

思路一：DFS

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        res = []

        def dfs(root, depth):
            if not root: return 
            if len(res) <= depth:
                res.append([])
            res[depth].append(root.val)
            for ch in root.children:
                dfs(ch, depth+1)
        
        dfs(root, 0)
        return res
思路二：BFS

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:return []
        res = []
        
        def bfs(root):
            queue = [root]
            while queue:
                nxt = []
                tmp = []
                for node in queue:
                    tmp.append(node.val)
                    for ch in node.children:
                        nxt.append(ch)
                res.append(tmp)
                queue = nxt
        
        bfs(root)
        return res
```

###  1.200. <a name='FlattenaMultilevelDoublyLinkedList'></a>430 Flatten a Multilevel Doubly Linked List

[小明](https://www.bilibili.com/video/BV1754y1q7Kb?spm_id_from=333.999.0.0)

###  1.201. <a name='AllOoneDataStructure'></a>432. All O`one Data Structure

[花花酱](https://www.bilibili.com/video/BV1XW411d7qR?spm_id_from=333.999.0.0)

###  1.202. <a name='Non-overlappingIntervals'></a>435-Non-overlapping Intervals

[哈哈哈](https://www.bilibili.com/video/BV1i7411p7pv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ak4y1U7f8?spm_id_from=333.999.0.0)

```py
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0:
            return 0
        intervals.sort(key = lambda x:x[1])
        res = 0
        current = intervals[0][1]
        for i in intervals[1:]:
            if i[0] >= current:
                current = i[1]
            else:
                current = min(i[1], current)
                res += 1
        return res

# 最难想通的其实是根据哪个边界排序，看了题解里大佬的理解，

# 想象成参加活动，影响你参加更多活动的是活动的结束时间，

# 只有上一个活动结束了，才能参加下一个，

# 即上一个活动的结束时间要小于下一个活动的开始时间。


class Solution(object):
    def eraseOverlapIntervals(self, intervals):
  
        if not intervals:
            return 0
        intervals.sort(key=lambda x:x[1])
        l=len(intervals)
        count=1
        end=intervals[0][1]
        for i in range(1,l):
            if intervals[i][0]>=end:
                count+=1
                end=intervals[i][1]
        return l-count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0: return 0
        intervals.sort(key=lambda x: x[1])
        count = 1 # 记录非交叉区间的个数
        end = intervals[0][1] # 记录区间分割点
        for i in range(1, len(intervals)):
            if end <= intervals[i][0]:
                count += 1
                end = intervals[i][1]
        return len(intervals) - count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        right = intervals[0][1]
        ans = 1

        for i in range(1, n):
            if intervals[i][0] >= right:
                ans += 1
                right = intervals[i][1]
        
        return n - ans

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort()
        n = len(intervals)
        f = [1]

        for i in range(1, n):
            f.append(max((f[j] for j in range(i) if intervals[j][1] <= intervals[i][0]), default=0) + 1)

        return n - max(f)
```


###  1.203. <a name='FindRightInterval'></a>436 Find Right Interval

[小明](https://www.bilibili.com/video/BV1YT4y1w7EP?spm_id_from=333.999.0.0)

###  1.204. <a name='PathSumIII'></a>437 Path Sum III

[小明](https://www.bilibili.com/video/BV1tZ4y1M7JR?spm_id_from=333.999.0.0)

###  1.205. <a name='FindAllAnagramsinaString'></a>438. Find All Anagrams in a String

[花花酱](https://www.bilibili.com/video/BV1iW411d7Nb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1254y1X7HV?spm_id_from=333.999.0.0)

```py
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        s_len, p_len = len(s), len(p)
        
        if s_len < p_len:
            return []

        ans = []
        s_count = [0] * 26
        p_count = [0] * 26
        for i in range(p_len):
            s_count[ord(s[i]) - 97] += 1
            p_count[ord(p[i]) - 97] += 1

        if s_count == p_count:
            ans.append(0)

        for i in range(s_len - p_len):
            s_count[ord(s[i]) - 97] -= 1
            s_count[ord(s[i + p_len]) - 97] += 1
            
            if s_count == p_count:
                ans.append(i + 1)

        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        s_len, p_len = len(s), len(p)

        if s_len < p_len:
            return []

        ans = []
        count = [0] * 26
        for i in range(p_len):
            count[ord(s[i]) - 97] += 1
            count[ord(p[i]) - 97] -= 1

        differ = [c != 0 for c in count].count(True)

        if differ == 0:
            ans.append(0)

        for i in range(s_len - p_len):
            if count[ord(s[i]) - 97] == 1:  # 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同
                differ -= 1
            elif count[ord(s[i]) - 97] == 0:  # 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同
                differ += 1
            count[ord(s[i]) - 97] -= 1

            if count[ord(s[i + p_len]) - 97] == -1:  # 窗口中字母 s[i+p_len] 的数量与字符串 p 中的数量从不同变得相同
                differ -= 1
            elif count[ord(s[i + p_len]) - 97] == 0:  # 窗口中字母 s[i+p_len] 的数量与字符串 p 中的数量从相同变得不同
                differ += 1
            count[ord(s[i + p_len]) - 97] += 1
            
            if differ == 0:
                ans.append(i + 1)

        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-xzin/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution(object):
    def findAnagrams(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: List[int]
        """
        if len(p) > len(s):
            return []
        p = sorted(p)
        
        res = []
        Map = {}
        for i in range(len(s)-len(p) + 1):
            s1 = s[i: i+len(p)]
            if s1 in Map:
                Map[s1] += 1
                res.append(i)
                continue
            if sorted(s1) == p:
                res.append(i)
                Map[s1] = 1
            
        return res
```

```scala
/**
* chosen solution
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/
object Solution0 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }
    ret.toList
  }
}

/**
* my first commit
* sliding window + hashMap within windows
* time complexity: O(NM): N: s.length, M: p.length
*/

object Solution1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap

     s.sliding(p.length).zipWithIndex.filter{ case (c, _) => pMap == c.groupBy(identity).mapValues(_.length).toMap}.map(_._2).toList
  }
}


/**
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/

object Solution2 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }

    ret.toList
  }
}

/**
* sliding window - two hashmap version
* using a mutable map storing current window's string element and amount
* time complexity: O(N)
* space complexity: O(2N) -> two hashMap
*/

object Solution2-1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap
    val sMap = scala.collection.mutable.Map[Char, Int]()
    val result = scala.collection.mutable.ListBuffer[Int]()

    for((char, right) <- s.zipWithIndex) {
      sMap.put(char, sMap.getOrElse(char, 0) + 1)

      if(right >= p.length) {
        val leftChar = s(right - p.length)
        sMap.get(leftChar) match {
          case Some(e) if e == 1 => sMap.remove(leftChar)
          case Some(e) => sMap.update(leftChar, e - 1)
          case _ =>
        }
      }
      if(pMap.equals(sMap)) result += (right - p.length + 1)
    }
    result.toList
  }
}

```

###  1.206. <a name='ArrangingCoins'></a>441 Arranging Coins

[小明](https://www.bilibili.com/video/BV1eV411k7rg?spm_id_from=333.999.0.0)

###  1.207. <a name='FindAllDuplicatesinanArray'></a>442 Find All Duplicates in an Array

[小明](https://www.bilibili.com/video/BV1Lh411d7AD?spm_id_from=333.999.0.0)

###  1.208. <a name='StringCompression'></a>443. String Compression

[小梦想家](https://www.bilibili.com/video/BV1rE411f7Ld?spm_id_from=333.999.0.0)

###  1.209. <a name='AddTwoNumbersII'></a>445-Add Two Numbers II

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7Qz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pt4y1m78o?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17a4y1s7BG?spm_id_from=333.999.0.0)

```py
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        s1, s2 = [], []
        while l1:
            s1.append(l1.val)
            l1 = l1.next
        while l2:
            s2.append(l2.val)
            l2 = l2.next
        ans = None
        carry = 0
        while s1 or s2 or carry != 0:
            a = 0 if not s1 else s1.pop()
            b = 0 if not s2 else s2.pop()
            cur = a + b + carry
            carry = cur // 10
            cur %= 10
            curnode = ListNode(cur)
            curnode.next = ans
            ans = curnode
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/add-two-numbers-ii/solution/liang-shu-xiang-jia-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

反正都是要遍历，直接遍历转成string取出来，相加完了再构造成链表即可。一遍过，代码很简洁。

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        num1, num2 = "", ""
        while l1:
            num1 += str(l1.val)
            l1 = l1.next
        while l2:
            num2 += str(l2.val)
            l2 = l2.next
        resNum = str(int(num1) + int(num2))
        root = ListNode(0)
        p = root
        for digit in resNum:
            p.next = ListNode(int(digit))
            p = p.next
        return root.next
```

```py
python不怕溢出

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        def f(node):
            num=0
            while node:
                num=num*10+node.val
                node=node.next
            return num
        class Node(ListNode):
            def __init__(self,y,x):
                super().__init__(x)
                self.next=y
        return functools.reduce(Node,map(int,reversed(str(f(l1)+f(l2)))),None)
```

###  1.210. <a name='NumberofBoomerangs'></a>447. Number of Boomerangs

[小梦想家](https://www.bilibili.com/video/BV1hE411o7V2?spm_id_from=333.999.0.0)

###  1.211. <a name='FindAllNumbersDisappearedinanArray'></a>448. Find All Numbers Disappeared in an Array

[小梦想家](https://www.bilibili.com/video/BV1SE411d7FM?spm_id_from=333.999.0.0)

###  1.212. <a name='SerializeandDeserializeBST'></a>449. Serialize and Deserialize BST

[花花酱](https://www.bilibili.com/video/BV1ab411c75V?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1r7FT?spm_id_from=333.999.0.0)

```py
class Codec:
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return ' '.join(map(str, postorder(root)))

    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [int(x) for x in data.split(' ') if x]
        return helper()

作者：LeetCode
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Codec:
    def postorder(self, root):
        return self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else []
        
    def int_to_str(self, x):
        """
        Encodes integer to bytes string.
        """
        bytes = [chr(x >> (i * 8) & 0xff) for i in range(4)]
        bytes.reverse()
        bytes_str = ''.join(bytes)
        return bytes_str
        
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        lst = self.postorder(root)
        lst = [self.int_to_str(x) for x in lst]
        return 'ç'.join(map(str, lst))
    
    def str_to_int(self, bytes_str):
        """
        Decodes bytes string to integer.
        """
        result = 0
        for ch in bytes_str:
            result = result * 256 + ord(ch)
        return result
        
    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [self.str_to_int(x) for x in data.split('ç') if x]
        return helper() 

作者：LeetCode
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Codec:
    def postorder(self, root):
        return self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else []
        
    def int_to_str(self, x):
        """
        Encodes integer to bytes string
        """
        bytes = [chr(x >> (i * 8) & 0xff) for i in range(4)]
        bytes.reverse()
        bytes_str = ''.join(bytes)
        return bytes_str
        
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        lst = [self.int_to_str(x) for x in self.postorder(root)]
        return ''.join(map(str, lst))
    
    def str_to_int(self, bytes_str):
        """
        Decodes bytes string to integer.
        """
        result = 0
        for ch in bytes_str:
            result = result * 256 + ord(ch)
        return result
        
    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        n = len(data)
        # split data string into chunks of 4 bytes
        # and convert each chunk to int
        data = [self.str_to_int(data[4 * i : 4 * i + 4]) for i in range(n // 4)]
        return helper() 

作者：LeetCode
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

直接将其用先序遍历序列化，因为是二叉搜索树，所以排序后就是中序遍历，因此反序列化就转换成了105题的从先序与中序构造二叉树的问题。 时间超过100%。

class Codec:
    def serialize(self, root):
        def preorder(root):
            out = []
            if root:
                out += [str(root.val)]
                out += preorder(root.left)
                out += preorder(root.right)
            return out
        return ','.join(preorder(root))
        
    def deserialize(self, data):
        if not data:
            return None
        def buildTree(pre_o, in_o):
            if not pre_o:
                return None
            mid = pre_o[0]
            i = in_o.index(mid)
            root = TreeNode(mid)
            root.left = buildTree(pre_o[1:i + 1], in_o[:i])
            root.right = buildTree(pre_o[i + 1:], in_o[i + 1:])
            return root
        pre_o = list(map(int, data.split(',')))
        in_o = sorted(pre_o)
        return buildTree(pre_o, in_o)


```

```py
**先序:**

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        
        def preorder(root):
            if not root:
                res.append("#")
                return 
            res.append(str(root.val))
            preorder(root.left)
            preorder(root.right)
        preorder(root)
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        d = iter(data.split(","))
        def helper():
            tmp = next(d)
            # print(tmp)
            if tmp == "#":return 
            node = TreeNode(int(tmp))
            node.left = helper()
            node.right = helper()
            return node
        return helper()
**层序**

from collections import deque
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        
        res = []
        queue = deque()
        if root: queue.appendleft(root)
        while queue:
            tmp = queue.pop()
            if tmp:
                res.append(tmp.val)
                queue.appendleft(tmp.left)
                queue.appendleft(tmp.right)
            else:
                res.append("#")
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        data = iter(data.split(","))
        root = TreeNode(next(data))
        queue = deque([root])
        while queue:
            tmp = queue.pop()
            left_val = next(data)
            if left_val != "#":
                tmp.left = TreeNode(int(left_val))
                queue.appendleft(tmp.left)
            right_val = next(data)
            if right_val != "#":
                tmp.right = TreeNode(int(right_val))
                queue.appendleft(tmp.right)
        return root
```

###  1.213. <a name='DeleteNodeinaBST'></a>450. Delete Node in a BST

[花花酱](https://www.bilibili.com/video/BV1XW411d7yU?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1YK4y1h7Mw?spm_id_from=333.999.0.0)

```py
# python 极简递归

class Solution(object):
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        if not root: return None;
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        else:
            if not root.left or not root.right: # 出口就是
                root = root.left if root.left else root.right # 出口就是，删除root
            else:
                cur = root.right # 找到右子树最小值
                while cur.left: cur = cur.left # 找到右子树最小值
                root.val = cur.val # 找到右子树最小值 的值
                root.right = self.deleteNode(root.right, cur.val)  # 删除最小值
            
        return root;

# 不考虑平衡的话可以简单粗暴一些。

# 假如要删除的不是根节点，转为递归子问题。

# 假如删除的是根节点且左子树为空，返回右子树即可。

# 假如删除的是根节点且左子树非空，找到左子树中最大的节点（其必然是没有右子树的），

# 将根节点的右子树作为其右子树即可。

def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
    if not root:
        return None
    if root.val > key:
        root.left = self.deleteNode(root.left, key)
    elif root.val < key:
        root.right = self.deleteNode(root.right, key)
    elif not root.left:
        root = root.right
    else:
        p = root.left
        while p.right:
            p = p.right
        p.right = root.right
        root = root.left
    return root
```

```py
# 分享一个最高128ms，20.66%的沙比方法，原理就是打印除了key以外的排序树，然后生成一个只有右子树的排序树输出

class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        a=[]
        def f(r):
            if not r:return
            f(r.left)
            if r.val!=key:
                a.append(r.val)
            f(r.right)
        f(root)
        n=len(a)
        if not a:
            return 
        r=TreeNode(a[0])
        ans=r
        for i in range(1,n):
            r.right=TreeNode(a[i])
            r=r.right
        return ans
# 但这个复杂度不满足要求啊，虽然这个思路挺有意思
# 这实际就没实现删除节点这个功能，只是把结果找到了
```

###  1.214. <a name='SortCharactersByFrequency'></a>451 Sort Characters By Frequency

[小明](https://www.bilibili.com/video/BV18v411z7iy?spm_id_from=333.999.0.0)

###  1.215. <a name='SumII'></a>454 4Sum II

[小明](https://www.bilibili.com/video/BV1ny4y1D7UL?spm_id_from=333.999.0.0)

###  1.216. <a name='MinimumNumberofArrowstoBurstBalloons'></a>452. Minimum Number of Arrows to Burst Balloons

[花花酱](https://www.bilibili.com/video/BV1bW411d77B?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1PZ4y1L7VM?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        
        points.sort(key=lambda balloon: balloon[1])
        pos = points[0][1]
        ans = 1
        for balloon in points:
            if balloon[0] > pos:
                pos = balloon[1]
                ans += 1
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python3，啪的一下就过了，很快啊

什么贪心我不懂，求交集就完事儿了

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort()
        i = 1
        while i < len(points):
            (al, ar), (bl, br) = points[i - 1], points[i]
            if bl <= ar:
                points[i - 1] = bl, min(ar, br)
                points.pop(i)
            else:
                i += 1
        return len(points)

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if len(points) == 0: return 0
        points.sort(key=lambda x: x[0])
        result = 1
        for i in range(1, len(points)):
            if points[i][0] > points[i - 1][1]: # 气球i和气球i-1不挨着，注意这里不是>=
                result += 1     
            else:
                points[i][1] = min(points[i - 1][1], points[i][1]) # 更新重叠气球最小右边界
        return result

贪心，每次射箭尽量找气球有重叠的点。排序后，记录重叠区间，下一个气球有重叠就进一步取交集，不重叠就结果+1

class Solution(object):
    def findMinArrowShots(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        if len(points) == 0: return 0
        points = sorted(points, key=lambda x: x[0])

        start = points[0][0]
        end = points[0][1]
        res = 0

        for point in points:
            if point[0] <= end:
                start = max(point[0], start)
                end = min(point[1], end)
            else:
                res += 1
                start = point[0]
                end = point[1]
        return res + 1
```

```py
贪心

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: [x[0], x[1]])
        # print(points)
        if not points: return 0
        interval = [points[0][0], points[0][1]]
        res = 1
        for start, end in points[1:]:
            if start <= interval[1]: # 有交集
                interval[0] = start
                interval[1] = min(interval[1], end)
            else:
                res += 1
                interval[0] = start
                interval[1] = end
        return res
```

###  1.217. <a name='AssignCookies'></a>455-Assign Cookies

[哈哈哈](https://www.bilibili.com/video/BV157411s7b9?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1YE411r7UN?spm_id_from=333.999.0.0)

```py
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        n, m = len(g), len(s)
        i = j = count = 0

        while i < n and j < m:
            while j < m and g[i] > s[j]:
                j += 1
            if j < m:
                count += 1
            i += 1
            j += 1
        
        return count

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        gg, ss, ans = 0, 0, 0
        while gg < len(g) and ss < len(s):
            if s[ss] >= g[gg]:
                ans += 1
                gg += 1
                ss += 1
            else:
                ss += 1
        return ans
```

```py
class Solution:
    # 思路1：优先考虑胃饼干
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        res = 0
        for i in range(len(s)):
            if res <len(g) and s[i] >= g[res]:  #小饼干先喂饱小胃口
                res += 1
        return res
class Solution:
    # 思路2：优先考虑胃口
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        start, count = len(s) - 1, 0
        for index in range(len(g) - 1, -1, -1): # 先喂饱大胃口
            if start >= 0 and g[index] <= s[start]: 
                start -= 1
                count += 1
        return count
```

###  1.218. <a name='Pattern'></a>456 132 Pattern

[小明](https://www.bilibili.com/video/BV18f4y1i734?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1SZ4y1x74J?spm_id_from=333.999.0.0)

```py
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        
        # 左侧最小值
        left_min = nums[0]
        # 右侧所有元素
        right_all = SortedList(nums[2:])
        
        for j in range(1, n - 1):
            if left_min < nums[j]:
                index = right_all.bisect_right(left_min)
                if index < len(right_all) and right_all[index] < nums[j]:
                    return True
            left_min = min(left_min, nums[j])
            right_all.remove(nums[j + 1])

        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        candidate_k = [nums[n - 1]]
        max_k = float("-inf")

        for i in range(n - 2, -1, -1):
            if nums[i] < max_k:
                return True
            while candidate_k and nums[i] > candidate_k[-1]:
                max_k = candidate_k[-1]
                candidate_k.pop()
            if nums[i] > max_k:
                candidate_k.append(nums[i])

        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        candidate_i, candidate_j = [-nums[0]], [-nums[0]]

        for v in nums[1:]:
            idx_i = bisect.bisect_right(candidate_i, -v)
            idx_j = bisect.bisect_left(candidate_j, -v)
            if idx_i < idx_j:
                return True

            if v < -candidate_i[-1]:
                candidate_i.append(-v)
                candidate_j.append(-v)
            elif v > -candidate_j[-1]:
                last_i = -candidate_i[-1]
                while candidate_j and v > -candidate_j[-1]:
                    candidate_i.pop()
                    candidate_j.pop()
                candidate_i.append(-last_i)
                candidate_j.append(-v)

        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        stack = []                   # top is number "3"
        mmax = float('-inf')         # number "2"
        for n in nums[::-1]:         # look for number "1"
            if n < mmax: return True
            while stack and n > stack[-1]:
                mmax = stack.pop()
            stack.append(n)
        return False

class Solution:
    def find132pattern(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        stack = []
        _MIN = float('-inf')
        
        for i in range(len(nums)-1, -1, -1):
            if nums[i] < _MIN:
                return True
            while stack and nums[i] > stack[-1]:
                _MIN = stack.pop()
            stack.append(nums[i])
            
        return False

栈里是当前最大的数，设为max，min是max右边最大的数。只需要nums[i] < min则存在132模式。 我想问一下，能不能改成 正向遍历呢
不能， 因为要保证递减栈pop出的_MIN在原数组中下标要是最大的，先压入栈的数下标要最大，这个_MIN其实就是题目描述中的ak
```

###  1.219. <a name='PoorPigs'></a>458 Poor Pigs

[小明](https://www.bilibili.com/video/BV1g5411576M?spm_id_from=333.999.0.0)

###  1.220. <a name='RepeatedSubstringPattern'></a>459 Repeated Substring Pattern

[小明](https://www.bilibili.com/video/BV1Yt4y1S7XZ?spm_id_from=333.999.0.0)

###  1.221. <a name='LFUCacheO1'></a>460. LFU Cache / O(1)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7PR?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1Xb411c7m7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kA41147t8?spm_id_from=333.999.0.0)

```py
官方方法二加了些注释
python代码中双向链表freqMap在后面插入tail.pre，删除在前面删head.nex，和题解说明相反

import collections
class Node:
	def __init__(self, key, val, pre=None, nex=None, freq=0):
		self.pre = pre
		self.nex = nex
		self.freq = freq			#当前节点使用频率
		self.val = val
		self.key = key
	
	#插入节点
	# self-> nex-> self.nex
	def insert(self, nex):
		nex.pre = self
		nex.nex = self.nex
		self.nex.pre = nex
		self.nex = nex

# 创建双向链表，包含值为0的head，tail
def create_linked_list():
	head = Node(0, 0)
	tail = Node(0, 0)
	head.nex = tail
	tail.pre = head
	return (head, tail)

class LFUCache:
	def __init__(self, capacity: int):
		self.capacity = capacity
		self.size = 0			#键值对总数
		self.minFreq = 0		#记录最小的频率，每次容量满了，删这个频率的head.nex
		self.freqMap = collections.defaultdict(create_linked_list)	#key是频率，值是一条双向链表的head, tail，最近操作的节点插入tail前面，则head.nex是最小使用频率的节点，删除时删head.nex
		self.keyMap = {}		#存储键值对，值是node 类型

	#双向链表中删除指定节点
	def delete(self, node):
		if node.pre:			#不是第一个节点，就需要删除，
			node.pre.nex = node.nex	#前后前接起来
			node.nex.pre = node.pre						
			if node.pre is self.freqMap[node.freq][0] and node.nex is self.freqMap[node.freq][-1]: #新的频率中已存在这个节点，且只有这个节点，那就直接把这个新频率删掉，方便后面插入最新数据
				self.freqMap.pop(node.freq)														   
		return node.key												
	
	#增加
	def increase(self, node):
		node.freq += 1			#当前节点频率+1
		self.delete(node)		#旧频率中，删除此节点
		self.freqMap[node.freq][-1].pre.insert(node)	#新频率中，tail节点前插入当前节点
		if node.freq == 1:		#出现频率为1的了，记录一下，下次容量满了先从这里删
			self.minFreq = 1
		elif self.minFreq == node.freq - 1:	#操作最小频率的节点时，从旧频率到新频率时需要检查下旧频率，只有head,tail就不可能从这里删数据了，那就需要把minFreq更新为新频率，下次从这里删
			head, tail = self.freqMap[node.freq - 1]
			if head.nex is tail:		#这个频率里没有实际节点，只有head,tail
				self.minFreq = node.freq#最小频率更新为节点当前频率

	def get(self, key: int) -> int:
		if key in self.keyMap:
			self.increase(self.keyMap[key])
			return self.keyMap[key].val
		return -1

	def put(self, key: int, value: int) -> None:
		if self.capacity != 0:
			if key in self.keyMap:		#有，更新value
				node = self.keyMap[key]
				node.val = value
			else:
				node = Node(key, value)	#没有，新建一个node
				self.keyMap[key] = node
				self.size += 1
			if self.size > self.capacity:	#大于容量
				self.size -= 1										
				deleted = self.delete(self.freqMap[self.minFreq][0].nex)#删除head.nex
				self.keyMap.pop(deleted)
			self.increase(node)





class Node:
    def __init__(self, key, val, pre=None, nex=None, freq=0):
        self.pre = pre
        self.nex = nex
        self.freq = freq
        self.val = val
        self.key = key
        
    def insert(self, nex):
        nex.pre = self
        nex.nex = self.nex
        self.nex.pre = nex
        self.nex = nex
    
def create_linked_list():
    head = Node(0, 0)
    tail = Node(0, 0)
    head.nex = tail
    tail.pre = head
    return (head, tail)

class LFUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.size = 0
        self.minFreq = 0
        self.freqMap = collections.defaultdict(create_linked_list)
        self.keyMap = {}

    def delete(self, node):
        if node.pre:
            node.pre.nex = node.nex
            node.nex.pre = node.pre
            if node.pre is self.freqMap[node.freq][0] and node.nex is self.freqMap[node.freq][-1]:
                self.freqMap.pop(node.freq)
        return node.key
        
    def increase(self, node):
        node.freq += 1
        self.delete(node)
        self.freqMap[node.freq][-1].pre.insert(node)
        if node.freq == 1:
            self.minFreq = 1
        elif self.minFreq == node.freq - 1:
            head, tail = self.freqMap[node.freq - 1]
            if head.nex is tail:
                self.minFreq = node.freq

    def get(self, key: int) -> int:
        if key in self.keyMap:
            self.increase(self.keyMap[key])
            return self.keyMap[key].val
        return -1

    def put(self, key: int, value: int) -> None:
        if self.capacity != 0:
            if key in self.keyMap:
                node = self.keyMap[key]
                node.val = value
            else:
                node = Node(key, value)
                self.keyMap[key] = node
                self.size += 1
            if self.size > self.capacity:
                self.size -= 1
                deleted = self.delete(self.freqMap[self.minFreq][0].nex)
                self.keyMap.pop(deleted)
            self.increase(node)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lfu-cache/solution/lfuhuan-cun-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

也是用双向链表做的，改了好几处空指针异常的地方。这个零可恶心到我了
```

```py

```

###  1.222. <a name='HammingDistance'></a>461 Hamming Distance

[小明](https://www.bilibili.com/video/BV1M5411Y79g?spm_id_from=333.999.0.0)

###  1.223. <a name='IslandPerimeter'></a>463 Island Perimeter

[小明](https://www.bilibili.com/video/BV16V41167bF?spm_id_from=333.999.0.0)

###  1.224. <a name='CanIWin'></a>464. Can I Win

[花花酱](https://www.bilibili.com/video/BV1KW411o7m2?spm_id_from=333.999.0.0)

###  1.225. <a name='CountTheRepetitions'></a>466. 统计重复个数 Count The Repetitions

[官方](https://www.bilibili.com/video/BV1Qk4y1678m?spm_id_from=333.999.0.0)

###  1.226. <a name='ValidateIPAddress'></a>468 Validate IP Address

[小明](https://www.bilibili.com/video/BV1tg4y1q7Kq?spm_id_from=333.999.0.0)

###  1.227. <a name='ImplementRand10UsingRand7'></a>470. Implement Rand10() Using Rand7()

[花花酱](https://www.bilibili.com/video/BV1Ut411Z7KX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AD4y1m7Qb?spm_id_from=333.999.0.0)

```py
class Solution:
    def rand10(self) -> int:
        while True:
            row = rand7()
            col = rand7()
            idx = (row - 1) * 7 + col
            if idx <= 40:
                return 1 + (idx - 1) % 10

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def rand10(self) -> int:
        while True:
            a = rand7()
            b = rand7()
            idx = (a - 1) * 7 + b
            if idx <= 40:
                return 1 + (idx - 1) % 10
            a = idx - 40
            b = rand7()
            # get uniform dist from 1 - 63
            idx = (a - 1) * 7 + b
            if idx <= 60:
                return 1 + (idx - 1) % 10
            a = idx - 60
            b = rand7()
            # get uniform dist from 1 - 21
            idx = (a - 1) * 7 + b
            if idx <= 20:
                return 1 + (idx - 1) % 10

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

最近刚在算法书看到这道题。。。。。。

class Solution:
    def rand10(self):
        while True:
            res = (rand7()-1)*7 + rand7()#构造1~49的均匀分布
            if res <= 40:#剔除大于40的值，1-40等概率出现。
                break
        return res%10+1#构造1-10的均匀分布

为什么res = (rand7()-1)*7 + rand7() 不写成res = (and7()* rand7(), 有什么区别吗
你想想6*7相乘，或者7*7相乘，能生成48吗，你说的这样只能生成乘法表那几个而不是1-49均匀的那几个
```

```py
class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        start=None
        while start==None:
            cur=rand7()
            if 1<=cur<=3:
                start=0
            if 4<=cur<=6:
                start=5
        while True:
            cur=rand7()
            if cur>5:
                continue
            else:
                return start+cur


感觉官方题解以及其他方法比较难以理解，看了其他人的思路后有所感悟。

我们可以先创造一个1-5的均匀分布，得到一个符合的结果x。

其次我们可以通过某种方法将这个1-5的均匀分布变为1-10的均匀分布。

方法如下所示：我们可以在生成一个数y，因为y是1-7的数字，

我们可以排除数字4，y为7继续生成一个数字，变为1-3以及5-7两个部分，

这样这两个部分只有3个数字，因为是等概率的，

如果在前部分， y = 0，如果为后部分y=5，因此可以创造出1-10的等概率分布。

class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        x = rand7()
        while x>5:
            x = rand7()
        y = rand7()
        while y == 4:
            y = rand7()
        if y < 4:
            y = 0
        else:
            y = 5
        return x+y
             
```

###  1.228. <a name='Heaters'></a>475. Heaters

[小梦想家](https://www.bilibili.com/video/BV1vJ41117VH?spm_id_from=333.999.0.0)

###  1.229. <a name='NumberComplement'></a>476. Number Complement

[花花酱](https://www.bilibili.com/video/BV1PW411y7mv?spm_id_from=333.999.0.0)

###  1.230. <a name='TotalHammingDistance'></a>477. Total Hamming Distance

[花花酱](https://www.bilibili.com/video/BV1SW411r78m?spm_id_from=333.999.0.0)

```py
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        s_nums = [bin(s)[2:].rjust(32, "0") for s in nums]
        res = 0
        for item in zip(*s_nums):
            res += item.count("1") * item.count("0")
        return res

# 第一想法就是暴力，直接超时
class Solution(object): # 此法超时
    def totalHammingDistance(self, nums):
        """
        :type nums: List[int]
        :rtype
        """
        res = 0
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                res += bin(nums[i]^nums[j]).count('1')
        return res
class Solution(object): # 此法超时
    def totalHammingDistance(self, nums):
        """
        :type nums: List[int]
        :rtype
        """
        return sum(b.count('0') * b.count('1') for b in zip(*map('{:032b}'.format, nums)))
```

```py
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        res, n = 0, len(nums)
        for i in range(32):
            cnt_1 = 0
            for j in range(n):
                cnt_1 += (nums[j] >> i) & 1
            res += (n - cnt_1) * cnt_1
        return res 

class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(30):
            c = sum(((val >> i) & 1) for val in nums)
            ans += c * (n - c)
        return ans

class Solution(object):
    def totalHammingDistance(self, nums):
        """
        :type nums: List[int]
        :rtype
        """
        # iterate thru "column" or bit position
        # Note: you could stop at 10^9 as stated in the problem if you want to optimize
        res = 0
        for i in range(32):
            mask = 1 << i
            count_ones, count_zeros = 0, 0
            for num in nums:
                if num & mask != 0:
                    count_ones += 1
                else:
                    count_zeros += 1
            res += count_ones * count_zeros
        return res

class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        c0,c1,sm=0,0,0
        for i in range(31):
            c0=c1=0
            for n in nums:
                if (n>>i)&1:
                    c1+=1
                else:
                    c0+=1
            sm+=c0*c1
        return sm
```


###  1.231. <a name='GenerateRandomPointinaCircle'></a>478 Generate Random Point in a Circle

[小明](https://www.bilibili.com/video/BV1Nz4y127a1?spm_id_from=333.999.0.0)

###  1.232. <a name='SlidingWindowMedian'></a>480. Sliding Window Median

[花花酱](https://www.bilibili.com/video/BV15W411C7iy?spm_id_from=333.999.0.0)

###  1.233. <a name='FindPermutation'></a>484 Find Permutation

[小明](https://www.bilibili.com/video/BV1NT4y1L76i?spm_id_from=333.999.0.0)

###  1.234. <a name='MaxConsecutiveOnes'></a>485. Max Consecutive Ones

[小梦想家](https://www.bilibili.com/video/BV1zJ411R7SJ?spm_id_from=333.999.0.0)

###  1.235. <a name='PredicttheWinner'></a>486. Predict the Winner

[花花酱](https://www.bilibili.com/video/BV1kW411d7R2?spm_id_from=333.999.0.0)

###  1.236. <a name='TheMaze'></a>490 The Maze

[小明](https://www.bilibili.com/video/BV1az4y1f7Hn?spm_id_from=333.999.0.0)

###  1.237. <a name='TargetSum'></a>494. Target Sum

[花花酱](https://www.bilibili.com/video/BV1WW411C7Mp?spm_id_from=333.999.0.0)

[花花酱 下](https://www.bilibili.com/video/BV1WW411C7Mr?spm_id_from=333.999.0.0)

```py
# 思路

# 每个数，只有取正、取负数，这两种处理。因此可以做深度优先遍历，为了避免重复计算，加上记忆法。

# DFS 到 nums[i] 时，取正数，则要求后面的数，处理后的 next_target = current_target - nums[i];
# 取负数的处理同上，后续要处理的 next_target = current_target + nums[i]；
# 用 python 语法糖简单演示下：

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        # @lru_cache(None)
        def dfs(startIdx, sum) -> int:
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return dfs(startIdx + 1, sum - nums[startIdx]) + dfs(startIdx + 1, sum + nums[startIdx])

        return dfs(0, target)

# @lru_cache(None) 好神奇，瞬间提高效率
# 如果不用@lru_cache(None)，用这种方式会超时，Java的就不会啊
# 同样的解法，Java 不超时是因为 Java 运行速度比 Python 快得多。
# 而 Python 如果不用 lru_cache 或者显式的记忆数组存储 dfs 的结果，
# 大量重复计算会导致超时，因为 Python 运行速度慢

# DFS

class Solution:
    def findTargetSumWays(self, nums: List[int], V) -> int:
        def dfs(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum==0 else 0
            res = 0
            res += dfs(sum-nums[startIdx], startIdx+1)
            res += dfs(sum+nums[startIdx], startIdx+1)
            return res
        return dfs(V, 0)


# 递归，findSum(s, start_idx) 函数的意思是从start_index开始向后的子集合能有几种得到s的方法

class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S
        :rtype
        """
        def findSum(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return findSum(sum+nums[startIdx], startIdx+1) + findSum(sum-nums[startIdx], startIdx+1)
        return findSum(S, 0)
# 但是这样会超时，所以用cache 记一下

# ```python
class Solution(object):
    def findTargetSumWays(self, nums, S):
        """
        :type nums: List[int]
        :type S
        :rtype
        """
        def findSum(s, start_idx):
            if start_idx == len(nums):
                return 1 if s == 0 else 0
            if (s, start_idx) not in cache:
                cache[(s, start_idx)] = findSum(s+nums[start_idx], start_idx+1) + findSum(s-nums[start_idx], start_idx+1)
            return cache[(s, start_idx)]
            
        cache = {}
        return findSum(S, 0)
```

```py
#  0-1背包

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        s = sum(nums)
        if (target+s)&1: return 0
        
        V = (target+s) >> 1
        f = [1] + [0]*V
        for n in nums:
            for i in range(V, n-1, -1):
                f[i] += f[i-n]
        return f[-1]

class Solution:
    def findTargetSumWays(self, nums, target) -> int:
        tmp=sum(nums)-target
        if tmp<0 or tmp&1:return 0
        neg=tmp>>1
        dp=[1]+[0]*neg
        for num in nums:
            for j in range(neg,num-1,-1):
                dp[j]+=dp[j-num]
        return dp[-1]
# 感觉用sum-target返回0会剪枝更多 速度稍微快那么一点点

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        sumValue = sum(nums)
        if target > sumValue or (sumValue + target) % 2 == 1: return 0
        bagSize = (sumValue + target) // 2
        dp = [0] * (bagSize + 1)
        dp[0] = 1
        for i in range(len(nums)):
            for j in range(bagSize, nums[i] - 1, -1):
                dp[j] += dp[j - nums[i]]
        return dp[bagSize]

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        if not nums or sum(nums) < target or (sum(nums) + target)%2 == 1:
            return 0

        s = (sum(nums)+target)//2 #只一个子集，使得子集和为s

        # 对于每一个数都有加入和不加入两种情况，因此可以使用背包问题的方法求解
        marp = [0 for _ in range(s+1)]
        marp[0] = 1 #当i - num =0也就是这个数加入/不加入正好可以满足要求时，解法为1（这个地方确实想了很久，看了题解）
        for num in nums:
            for i in range(s,num-1,-1):#参考背包问题的自顶向下
                marp[i] = marp[i]+marp[i - num]

        return marp[-1]

# 官方的动态规划
class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        total = sum(nums)
        neg = total - target
        if neg < 0 or neg % 2 == 1:
            return 0
        neg = neg // 2
        dp = [[0] * (neg + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            num = nums[i - 1]
            for j in range(neg + 1):
                dp[i][j] += dp[i - 1][j]
                if j >= num:
                    dp[i][j] += dp[i - 1][j - num]
        return dp[-1][-1]

# 二维数组的外层循环，一般不都是从0到nums.length-1吗，为什么这里是从1到nums.length+1，百思不得其解
class Solution(object):
    def findTargetSumWays(self, nums, target):
        """
        :type nums: List[int]
        :type target
        :rtype
        """
        su = sum(nums)

        """
        su_data - du_data = target
        su_data + du_data = su 
        2 * su_data = target + su 
        su_data = (target + su) / 2

        dp[i][j] 前i个数中（包含i），加和等于j
        """

        if (su + target) % 2 == 1 or su < target: return 0

        new_target = (su - target) // 2

        dp = [[0 for _ in  range(new_target + 1)] for _ in range(len(nums) + 1)] 
        dp[0][0] = 1

        for i in range(1, len(nums) + 1):
            u = nums[i-1]
            for j in range(0, new_target + 1):
                if j >= u:
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-u]
                else:
                    dp[i][j] = dp[i-1][j]

        return dp[len(nums)][new_target]
```

###  1.238. <a name='TeemoAttacking'></a>495 Teemo Attacking

[小明](https://www.bilibili.com/video/BV1LK4y1Y75e?spm_id_from=333.999.0.0)

###  1.239. <a name='INextGreaterElementI'></a>496. 下一个更大元素 I (Next Greater Element I)

[洛阳](https://www.bilibili.com/video/BV1Ce411W7pW?spm_id_from=333.999.0.0)

###  1.240. <a name='RandomPointinNon-overlapping'></a>497 Random Point in Non-overlapping

[小明](https://www.bilibili.com/video/BV12K4y1Y7r6?spm_id_from=333.999.0.0)

###  1.241. <a name='KeyboardRow'></a>500. Keyboard Row

[小梦想家](https://www.bilibili.com/video/BV1vJ411X7BR?spm_id_from=333.999.0.0)

###  1.242. <a name='NextGreaterElementII'></a>503-Next Greater Element II

[哈哈哈](https://www.bilibili.com/video/BV197411L77N?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1k5411t7Pa?spm_id_from=333.999.0.0)

```py
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ret = [-1] * n
        stk = list()

        for i in range(n * 2 - 1):
            while stk and nums[stk[-1]] < nums[i % n]:
                ret[stk.pop()] = nums[i % n]
            stk.append(i % n)
        
        return ret

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/next-greater-element-ii/solution/xia-yi-ge-geng-da-yuan-su-ii-by-leetcode-bwam/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
赞一个，一开始真没想到用两个数组，一直在想用双指针+单调栈能不能搞出来

用单调栈求解，此处栈内记录的是 nums 元素的下标

直接将 nums 复制两倍
判断栈顶元素和当前元素的大小
若栈顶元素 > 当前元素：当前元素入栈
若栈顶元素 < 当前元素：弹出栈顶元素，并记录栈顶元素的下一个更大元素为当前元素
class Solution(object):
    def nextGreaterElements(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        nums_length = len(nums)
        res_list = [-1 for _ in range(nums_length)]
        stack = list()
        
        double_nums = nums + nums
        for index, num in enumerate(double_nums):
            while stack and nums[stack[-1]] < num:
                res_list[stack[-1]] = num
                stack.pop()
            if index < nums_length:
                stack.append(index)
        return res_list

```

```py
Python:

class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        dp = [-1] * len(nums)
        stack = []
        for i in range(len(nums)*2):
            while(len(stack) != 0 and nums[i%len(nums)] > nums[stack[-1]]):
                    dp[stack[-1]] = nums[i%len(nums)]
                    stack.pop()
            stack.append(i%len(nums))
        return dp
```

###  1.243. <a name='Base7'></a>504-Base 7

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7o5?spm_id_from=333.999.0.0)

###  1.244. <a name='FibonacciNumber'></a>509. Fibonacci Number

[1:30 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15y4y147Re?spm_id_from=333.999.0.0)

```py
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        
        p, q, r = 0, 0, 1
        for i in range(2, n + 1):
            p, q = q, r
            r = p + q
        
        return r

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        
        q = [[1, 1], [1, 0]]
        res = self.matrix_pow(q, n - 1)
        return res[0][0]
    
    def matrix_pow(self, a: List[List[int]], n: int) -> List[List[int]]:
        ret = [[1, 0], [0, 1]]
        while n > 0:
            if n & 1:
                ret = self.matrix_multiply(ret, a)
            n >>= 1
            a = self.matrix_multiply(a, a)
        return ret

    def matrix_multiply(self, a: List[List[int]], b: List[List[int]]) -> List[List[int]]:
        c = [[0, 0], [0, 0]]
        for i in range(2):
            for j in range(2):
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]
        return c

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def fib(self, n: int) -> int:
        sqrt5 = 5**0.5
        fibN = ((1 + sqrt5) / 2) ** n - ((1 - sqrt5) / 2) ** n
        return round(fibN / sqrt5)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Python：

class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        a, b, c = 0, 1, 0
        for i in range(1, n):
            c = a + b
            a, b = b, c
        return c

class Solution:
    def fib(self, n: int) -> int:
        a, b = 0, 1
        for i in range(n): 
            a, b = b, a + b # py的单行更新值
    	return a
# 递归实现
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)
```

```py
通项公式了解一下

class Solution:
    def fib(self, N):
        """
        :type N: int
        :rtype: int
        """
        return int((5**0.5)*0.2*( ((1+5**0.5)/2)**N-((1-5**0.5)/2)**N))
```

```scala
/**
* chosen solution
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution0 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* iterative - bottom up with memorization
* time complexity O(N)
* space complexity O(N)
*/

object Solution1 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1
        (2 to N).foreach(n => cache(n) = cache(n -1) + cache(n -2))
        cache(N)
    }
}

/**
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution1-2 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* recursive - top-down with memorization
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution2 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1

        def _fib(n: Int):Int = {
            if(n <= 1) return n
            
            if(cache(n) != 0) cache(n)
            else {
                cache(n) = _fib(n-1) + _fib(n-2)
                cache(n)
            }
        }
        _fib(N)
        
    }
}



/**
* recursive version - bottom up
* time complexity: O(2^N）
* space complexity: O(N)
*/

object Solution3 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
           fib(N - 1) + fib(N - 2)
        }
    }
}


/**
* matrix operation with pow operation
* memo
*   n > 1
*   | fn   |    | 1  1  |^ (n -1)  | 1 |
*   | fn-1 |  = | 1  0  |          | 1 |
* time complexity: O(logN)
* space complexity: O(logN) due to stack size
*/
object Solution4 {
  def fib(N: Int): Int = {
    if (N <= 1) return N

    val matrix = Array.ofDim[Int](2, 2)
    matrix(0)(0) = 1
    matrix(0)(1) = 1
    matrix(1)(0) = 1
    matrix(1)(1) = 0

    val identityMatrix = Array.tabulate(2, 2) {
      case (i, j) if i == j => 1
      case _ => 0
    }
    val retMatrix = matrixPow(identityMatrix, matrix, N - 1)
    retMatrix(0)(0)
  }

  @annotation.tailrec
  def matrixPow(current: Array[Array[Int]], base: Array[Array[Int]], pow: Int): Array[Array[Int]] = {
    if (pow == 0) current
    else {
      if ((pow & 1) == 1) {
        val newCurrent = multiply(current, base)
        val newBase = multiply(base, base)

        matrixPow(newCurrent, newBase, pow / 2)
      } else {
        val newBase = multiply(base, base)
        matrixPow(current, newBase, pow / 2)
      }
    }

  }

  def multiply(a: Array[Array[Int]], b: Array[Array[Int]]): Array[Array[Int]] = {
    val a00 = a(0)(0) * b(0)(0) + a(0)(1) * b(1)(0)
    val a01 = a(0)(0) * b(0)(1) + a(0)(1) * b(1)(1)
    val a10 = a(1)(0) * b(0)(0) + a(1)(1) * b(1)(0)
    val a11 = a(1)(0) * b(0)(1) + a(1)(1) * b(1)(1)
    a(0)(0) = a00
    a(0)(1) = a01
    a(1)(0) = a10
    a(1)(1) = a11
    a
  }
}
```

###  1.245. <a name='LongestPalindromicSubsequence'></a>516. Longest Palindromic Subsequence

[花花酱](https://www.bilibili.com/video/BV18W411d7k2?spm_id_from=333.999.0.0)

###  1.246. <a name='CoinChange2'></a>518 Coin Change 2

[小明](https://www.bilibili.com/video/BV1jC4y1a7YT?spm_id_from=333.999.0.0)

###  1.247. <a name='DetectCapital'></a>520. Detect Capital

[小梦想家](https://www.bilibili.com/video/BV1NJ41197da?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xT4y1j7G4?spm_id_from=333.999.0.0)

```py
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        # 若第 1 个字母为小写，则需额外判断第 2 个字母是否为小写
        if len(word) >= 2 and word[0].islower() and word[1].isupper():
            return False
        
        # 无论第 1 个字母是否大写，其他字母必须与第 2 个字母的大小写相同
        return all(word[i].islower() == word[1].islower() for i in range(2, len(word)))

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/detect-capital/solution/jian-ce-da-xie-zi-mu-by-leetcode-solutio-449z/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python3: 如果只有一个字母，返回true；如果全是大写，返回true，否则返回除了首字母外的字母是不是全是小写。

class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if len(word) == 1:
            return True
        if word.isupper():
            return True
        else:
            return word[1:].islower()
```

```py
嘻嘻，这应该是目前为止最简单的一题了

class Solution(object):
    def detectCapitalUse(self, word):
        """
        :type word: str
        :rtype: bool
        """
        if word == word.upper() or word == word.lower() or word == word.title():
            return True
        else:
            return False


class Solution:
    def detectCapitalUse(self, word: str) -> bool:
            return word.islower() or word.isupper() or word.istitle()
```

###  1.248. <a name='ContiguousArray'></a>525. Contiguous Array

[花花酱](https://www.bilibili.com/video/BV14W411d7SD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV185411t7tu?spm_id_from=333.999.0.0)

```py
0变-1是精髓，sum_dct = {0:-1}是细节。

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        sum_dct = {0:-1}
        temp,res = 0,0
        for i in range(len(nums)):
            if nums[i] == 0:
                temp += -1
            else:
                temp += 1
            if temp not in sum_dct:
                sum_dct[temp] = i
            else:
                res = max(res,i-sum_dct[temp])
        return res
```

```py
说一下心路历程。

错误思路1：开始我以为是一个栈的思路，遇到0就push，1就pop，

然后什么时候stack空了就行了。 后来发现这个思路是错的，因为1）

如果1比0多久pop不出去了，2）这种思路只考虑到从第0位开始的子数组

错误思路2：因此我想到构建两个list，分别存1和0，比较什么时候上下两个数组len一样，

然后返回两个list长度总和，的这种方法只能解决上面提到的1）问题

正确思路： 转而我想到，竟然是栈的思维，何必用一个真的栈，

只要记录栈里面的元素数量即可（0push，1pop） 

因此我构建了一个记录栈长度数量的list，然后发现这玩意不说就是前缀和的思路嘛。 

然后我借鉴错误思路2的点，需要记录长度的话，

就是当栈里元素数量相等的时候，保留上下标（或者保留最大长度）， 最后找一下最大长度即可

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:        
        preSum = [0]
        presum_index = {0:[-1,-1]}
        for i in range(len(nums)):
            preSum.append(preSum[i]+1 if nums[i] == 1 else preSum[i]-1)
            presum_index[preSum[-1]] = presum_index.get(preSum[-1],[i,i])
            presum_index[preSum[-1]][1] = i
        res = 0
        for v in presum_index.values():
            res = max(v[1] - v[0],res)
        return res

然后，我去看了一下我的历史提交记录，发现这题我一年前解过，而且解法竟然比现在好。。。。。。这一年完全没有进步

一年前的代码:

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        front_hash = {}
        front_hash[0] = -1
        res = 0
        s = 0
        for i in range(len(nums)):
            s += 1 if nums[i] == 1 else -1
            if s in front_hash:
                res = max(res, i - front_hash[s])
            else:
                front_hash[s] = i
        return res

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        res = 0
        hmap = {0: -1}
        prefix = 0
        for index, num in enumerate(nums):
            if num == 0:
                prefix -= 1
            else:
                prefix += 1
            hmap[prefix] = hmap.get(prefix, index)
            res = max(res, index - hmap[prefix])
        return res
```


###  1.249. <a name='BeautifulArrangement'></a>526 Beautiful Arrangement

[小明](https://www.bilibili.com/video/BV1DK411M7QR?spm_id_from=333.999.0.0)

###  1.250. <a name='RandomPickwithWeight'></a>528 Random Pick with Weight

[小明](https://www.bilibili.com/video/BV1UV411r7MK?spm_id_from=333.999.0.0)

###  1.251. <a name='MinimumAbsoluteDifferenceinBST'></a>530. Minimum Absolute Difference in BST

[花花酱](https://www.bilibili.com/video/BV1fW411k7eT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1FJ41147BB?spm_id_from=333.999.0.0)

```py
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        inorder = []
        def dfs(root):
            nonlocal inorder
            if not root:
                return 
            dfs(root.left)
            inorder.append(root.val)
            dfs(root.right) 
        dfs(root)
        return min([inorder[i]-inorder[i-1] for i in range(1,len(inorder))])

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        
        def inorder(node):
            if node:
                yield from inorder(node.left)
                yield node.val
                yield from inorder(node.right)

        pre, cur = tee(inorder(root))
        next(cur, None)
        return min(b-a for a, b in zip(pre, cur))
```

```py
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        self.res = float('inf')
        self.tmp = -1
        def dfs(root):
            if not root:
                return
            dfs(root.left)
            if self.tmp == -1:
                self.tmp = root.val
            else:
                self.res = min(self.res, abs(root.val - self.tmp))
                self.tmp = root.val
            dfs(root.right)
        dfs(root)
        return self.res

递归

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        ret = inf
        pre = None
        def dfs(node):
            nonlocal ret, pre
            if not node: return   
            dfs(node.left)
            if pre != None: ret = min(node.val - pre, ret)             
            pre = node.val
            dfs(node.right)                
        dfs(root)       
        return ret

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        """解题思路：二叉搜索树的中序遍历是一个递增且无重复元素的序列"""
        path = []
        min_ = float('INF')  

        def traval(root):  # 中序遍历
            nonlocal path
            if not root: return

            traval(root.left)
            path.append(root.val)
            traval(root.right)

        
        traval(root)
        result = list(zip(path, path[1:]))   # 窗口大小为2，步长为1
        for i, j in result:
            if abs(j - i) < min_:
                min_ = abs(j - i)
        
        return min_
```

###  1.252. <a name='K-diffPairsinanArray'></a>532 K-diff Pairs in an Array

[小明](https://www.bilibili.com/video/BV1MV41127o1?spm_id_from=333.999.0.0)

###  1.253. <a name='EncodeandDecodeTinyURL'></a>535. Encode and Decode TinyURL

[小梦想家](https://www.bilibili.com/video/BV1hb411e7zp?spm_id_from=333.999.0.0)

###  1.254. <a name='ComplexNumberMultiplicatin'></a>537 Complex Number Multiplicatin

[小明](https://www.bilibili.com/video/BV1sP4y1p7Px?spm_id_from=333.999.0.0)

###  1.255. <a name='ConvertBSTtoGreaterTree'></a>538 Convert BST to Greater Tree

[小明](https://www.bilibili.com/video/BV1k541177bt?spm_id_from=333.999.0.0)

###  1.256. <a name='SingleElementinaSortedArray540-'></a>540. Single Element in a Sorted Array 540-有序数组中的单一元素

[花花酱](https://www.bilibili.com/video/BV1gW411y7N3?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1P64y1F7cd?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Tg4y1B7Va?spm_id_from=333.999.0.0)

```py
def singleNonDuplicate(self, nums: List[int]) -> int:
    for i in range(0, len(nums) - 2, 2):
        if nums[i] != nums[i + 1]:
            return nums[i]
    return nums[-1]

作者：LeetCode
链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def singleNonDuplicate(self, nums: List[int]) -> int:
    lo = 0
    hi = len(nums) - 1   
    while lo < hi:
        mid = lo + (hi - lo) // 2
        halves_are_even = (hi - mid) % 2 == 0
        if nums[mid + 1] == nums[mid]:
            if halves_are_even:
                lo = mid + 2
            else:
                hi = mid - 1
        elif nums[mid - 1] == nums[mid]:
            if halves_are_even:
                hi = mid - 2
            else:
                lo = mid + 1
        else:
            return nums[mid]
    return nums[lo]

作者：LeetCode
链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def singleNonDuplicate(self, nums: List[int]) -> int:
    lo = 0
    hi = len(nums) - 1
    while lo < hi:
        mid = lo + (hi - lo) // 2
        if mid % 2 == 1:
            mid -= 1
        if nums[mid] == nums[mid + 1]:
            lo = mid + 2
        else:
            hi = mid
    return nums[lo]

作者：LeetCode
链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

这题一看就是考异或嘛，数组直接全部取异或就行了

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        t = nums[0]
        for i in range(1,len(nums)):
            t ^= nums[i]
        return t

异或的时间复杂度不符合要求啊
```

```py
二分法

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l, r = 0, len(nums)-1
        while l < r:
            m = l+((r-l) >> 1)
            if m % 2 == 1:
                m -= 1
            if nums[m] == nums[m+1]:
                l = m+2
            else:
                r = m-1
        return nums[l]
```

###  1.257. <a name='Matrix'></a>542. 01 矩阵 01 Matrix 

[官方](https://www.bilibili.com/video/BV1cZ4y1s727?spm_id_from=333.999.0.0)

###  1.258. <a name='DiameterofBinaryTree'></a>543 Diameter of Binary Tree

[小明](https://www.bilibili.com/video/BV12K4y1r78T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qA411t7LR?spm_id_from=333.999.0.0)

```py
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 1
        def depth(node):
            # 访问到空节点了，返回0
            if not node:
                return 0
            # 左儿子为根的子树的深度
            L = depth(node.left)
            # 右儿子为根的子树的深度
            R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
            self.ans = max(self.ans, L + R + 1)
            # 返回该节点为根的子树的深度
            return max(L, R) + 1

        depth(root)
        return self.ans - 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_len = 0
        def recur_func(root):
            nonlocal max_len
            if not root: return 0
            l_len = recur_func(root.left)
            r_len = recur_func(root.right)
            max_len = max(max_len, l_len + r_len)
            return max(l_len, r_len) + 1  # 每次返回左子树和右子树中长度最长的路径长度
            # 无论从左孩子返回还是右孩子返回，长度都要加1

        recur_func(root)
        return max_len

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        self.res=0 #存储最长直径
        def dfs(root:TreeNode):# 记录每一个子树的深度
            if not root:
                return 0
            l= dfs(root.left)
            r= dfs(root.right)
            self.res=max(self.res,l+r)#存储当前节点与之前遍历节点的最长路径
            return max(l,r)+1 #返回当前子树的最长深度
        dfs(root)
        return self.res
```

```py
测试用例感觉有点问题,空树的路径定义为-1比较好

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
            def dfs(root):
                if not root:
                    return -1
                l,r=dfs(root.left),dfs(root.right)
                self.ans=max(self.ans,l+r+2)
                return max(l,r)+1
            self.ans=0
            dfs(root)
            return self.ans

类属性变量用的妙！
```

###  1.259. <a name='RemoveBoxes'></a>546 Remove Boxes

[花花酱](https://www.bilibili.com/video/BV11W411Z7jG?spm_id_from=333.999.0.0)

###  1.260. <a name='-1'></a>547-朋友圈

[哈哈哈](https://www.bilibili.com/video/BV1Ta411F7rk?spm_id_from=333.999.0.0)

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def dfs(i: int):
            for j in range(provinces):
                if isConnected[i][j] == 1 and j not in visited:
                    visited.add(j)
                    dfs(j)
        
        provinces = len(isConnected)
        visited = set()
        circles = 0

        for i in range(provinces):
            if i not in visited:
                dfs(i)
                circles += 1
        
        return circles

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-provinces/solution/sheng-fen-shu-liang-by-leetcode-solution-eyk0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        provinces = len(isConnected)
        visited = set()
        circles = 0
        
        for i in range(provinces):
            if i not in visited:
                Q = collections.deque([i])
                while Q:
                    j = Q.popleft()
                    visited.add(j)
                    for k in range(provinces):
                        if isConnected[j][k] == 1 and k not in visited:
                            Q.append(k)
                circles += 1
        
        return circles

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-provinces/solution/sheng-fen-shu-liang-by-leetcode-solution-eyk0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def find(index: int) -> int:
            if parent[index] != index:
                parent[index] = find(parent[index])
            return parent[index]
        
        def union(index1: int, index2: int):
            parent[find(index1)] = find(index2)
        
        provinces = len(isConnected)
        parent = list(range(provinces))
        
        for i in range(provinces):
            for j in range(i + 1, provinces):
                if isConnected[i][j] == 1:
                    union(i, j)
        
        circles = sum(parent[i] == i for i in range(provinces))
        return circles

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-provinces/solution/sheng-fen-shu-liang-by-leetcode-solution-eyk0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        ### 传说江湖中有各种门派 ###
        # 初始化 数组中存放每个城市i的上一级节点
        pre = [-1]*n

        ### 打架之前先自报家门 ###
        # 找每个省份的省会
        def find(root):
            son = root
            ### 我不认识掌门啊 让我师傅去问问？ ###
            # 让root一直向上查找直到找到省会
            while pre[root] >= 0:
                root = pre[root]
        
            ### 当徒孙多没意思 直接拜倒掌门门下 辈分高 有牌面儿 ### 
            # 路径压缩
            while son != root:
                # 让查找路径上的所有城市都直接连到省会
                tmp = pre[son]
                pre[son] = root
                son = tmp
            
            ### 说出我家掌门 吓你一跳 ###
            return root
        
        ### 弱肉强食 小门派终究还是要被大门派兼并 ###
        # 按秩归并 pre数组存放的是下面连接的城市数量
        def union(root1,root2):
            if pre[root2] < pre[root1]:
                pre[root2] += pre[root1]
                pre[root1] = root2
            else:
                pre[root1] += pre[root2]
                pre[root2] = root1

        # 因为是对称的 只需要遍历右上区域
        for i in range(n):
            for j in range(i+1,n):
                if isConnected[i][j] == 1:
                    ### 我师从名门 识相的就快点投降 ###
                    # 找到i和j的省会
                    root1 = find(i)
                    root2 = find(j)
                    ### 江湖规矩 我们不打自家人 ###
                    # 如果i和j不在一个省但是彼此相连 将他们连到同一个省会
                    if root1 != root2:
                        union(root1,root2)
        
        ### 腥风血雨过后门派所剩无几 这就是"江湖" ###
        # 统计省会个数
        cnt = 0
        for i in range(n):
            if pre[i] < 0:
                cnt += 1
        return cnt
```

```py
不用递归，可以实现双100%：

class Solution:
    def findCircleNum(self, M: List[List[int]]) -> int:
        candidates = set(range(1, len(M)))
        if not candidates:
            return 1
        count = 0
        peoples = [0]
        while candidates:
            while peoples:
                people = peoples.pop()
                friends = [i for i in candidates if M[people][i]]
                for i in friends:
                    peoples.append(i)
                    candidates.remove(i)
            count += 1
            if candidates:
                peoples = [list(candidates)[0]]
        return count
```

```scala


/**
* union & find: implement both union by rank and path compression
* time complexity : 
*   in union & find each op:
*           find: very very close to O(1) amortized
*           union: very very close to O(1) amortized
*   the entire ：
*       O(n + M), n is node size, M is the times we call Union operation which cause O(1) 
*       n (constructor) + M (call union times)
*/

object Solution1 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    unionFind.counter

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)
  var counter = M

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
    counter -= 1
  }
}

/**
* union & find: without counter in union&find to record current cluster
*       O(n + M + n), n is node size, M is the times we call Union operation which cause O(1) 
*       n (construct union & find ) + M (call union times)  + n (n time call findRoot)
*/
object Solution1-2 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    M.indices.map(unionFind.findRoot).distinct.size

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
  }
}


```

###  1.261. <a name='BrickWall'></a>554 Brick Wall

[小明](https://www.bilibili.com/video/BV1mo4y1f7wc?spm_id_from=333.999.0.0)

###  1.262. <a name='NextGreaterElementIII'></a>556 Next Greater Element III

[小明](https://www.bilibili.com/video/BV19t4y167yb?spm_id_from=333.999.0.0)

###  1.263. <a name='SubarraySumEqualsKK'></a>560. Subarray Sum Equals K 和为K的子数组

[花花酱](https://www.bilibili.com/video/BV1XW411d71i?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d54y127ri?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vK4y1k7ku?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV13t4y1y7ya?spm_id_from=333.999.0.0)

```py
方法2 的 hashmap 初始化一开始没想通为啥是 {0: 1}，写成下面的形式感觉就好理解了

其实就是考虑 pre[i] == k 的这种情况

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        counter = dict()
        pre, ans = 0, 0
        for num in nums:
            pre += num
            if pre == k:
                ans += 1
            ans += counter.get(pre - k, 0)
            counter[pre] = counter.get(pre, 0) + 1
        return ans
```

```py
前序和也超时了

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        prefixsum=[0]*(len(nums)+1)
        for i in range(len(nums)):
            prefixsum[i+1] = prefixsum[i] + nums[i]
        count = 0
        for i in range(len(nums)):
            for j in range(i,len(nums)):
                if prefixsum[j+1] - prefixsum[i] == k:
                    count +=1
        return count 

class Solution:
    def subarraySum(self, nums: 'List[int]', k: 'int') -> 'int':
        sum, res, cul = 0, 0, {}
        cul[0] = 1
        for i in range(len(nums)):
            sum += nums[i]
            if sum - k in cul:
                res += cul[sum - k]
            if sum not in cul:
                cul[sum] = 0
            cul[sum] += 1
        return res
```

###  1.264. <a name='BinaryTreeTilt'></a>563 Binary Tree Tilt

[小明](https://www.bilibili.com/video/BV1KV41117ho?spm_id_from=333.999.0.0)

###  1.265. <a name='PermutationinString567-'></a>567. Permutation in String 567-字符串的排列

[花花酱](https://www.bilibili.com/video/BV14W411d7g6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1z54y1C7qB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV175411E761?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1154y1X7qB?spm_id_from=333.999.0.0)

```py
觉得写的不错，Python的胸弟们点个赞支持一下，过了年就会有对象的~

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        '''
        思路：怎么判断s2的字串和s1的排列之一相等，假如排序的话，遍历s2的同时，每次都排序，总的时间复杂度太高了。
        因此，我们采用一个有序字典来比较，由于只包含小写字母，我们采用数组来模拟有序字典，
        这样判断s2的子串和s1的排列之一相等就很容易了。总的时间复杂度为O(n),n为s2的长度。
        空间复杂度为:O(26)*2 == O(1) 

        '''
        m1 = len(s1)
        m2 = len(s2)
        if m1 > m2:
            return False
        dic1 = [0]*26
        dic2 = [0]*26
        for i in range(m1):
            dic1[ord(s1[i])-ord('a')] += 1
            dic2[ord(s2[i])-ord('a')] += 1
        if dic1 == dic2:
            return True

        for i in range(m1,m2):
            dic2[ord(s2[i-m1])-ord('a')] -= 1
            dic2[ord(s2[i])-ord('a')] += 1
            if dic1 == dic2:
                return True
        return False
方法1：其实就是滑动窗口哈希表（更新边界法），对应上面的方法五
class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1) #s1的哈希表，实质是字典
        c2 = collections.Counter() #实例化一个counter类
        p = q = 0  #设定下标初始化为0，滑动窗口就是[p,q]
        #下面就是不断在s2上面进行滑动窗口，不断更新哈希表进行比较，这是采用的边界更新法哦，因此是方法五，而不是方法三
        #这里补充一下，为什么滑动窗口用while没用for，其实都是一样的，你也可以改成for
        #但是对于有些情况，就只能用while，比如在回溯算法里面，即循环变量需要频繁的加减，显然此题并不是
        #因此对于此题，用for也可以，整体来说while的应用场合更加广泛
        while q < l2:
            c2[s2[q]] += 1   #统计字典哈希表
            if c1 == c2:
                return True  #注意，这种结果性条件判断一定是写在前面
            q += 1           #s2滑动窗口，下标后移
            if q - p + 1 > l1:   #为什么有这个呢？因为第一个滑动窗口比较特殊，要先构造第一个完整的滑动窗口，后面才是更新边界
                c2[s2[p]] -= 1   #字典哈希表移除最前面的字符
                if c2[s2[p]] == 0:  #由于counter特性，如果value为0，就删除它
                #否则会出现s1的map没有a，但是s2的map的a为0，此时是成立的，但是导致了这两个map不相等，结果出错
                    del c2[s2[p]]
                p += 1     #最前面的下标右移动
        return False  #遍历所有滑动窗口过后，仍然没返回true，那就是不合题意
        
方法2：优化的滑动窗口（变量统计法），其实就是上面的方法六
class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1)
        c2 = collections.Counter()
        cnt = 0 #统计变量，全部26个字符，频率相同的个数，当cnt==s1字母的个数的时候，就是全部符合题意，返回真
        p = q = 0 #滑动窗口[p,q]
        while q < l2:
            c2[s2[q]] += 1
            if c1[s2[q]] == c2[s2[q]]: #对于遍历到的字母，如果出现次数相同
                cnt += 1               #统计变量+1
            if cnt == len(c1):         #判断结果写在前面，此时证明s2滑动窗口和s1全部字符相同，返回真
                return True
            q += 1                     #滑动窗口右移
            if q - p + 1 > l1:         #这是构造第一个滑动窗口的特殊判断，里面内容是维护边界滑动窗口
                if c1[s2[p]] == c2[s2[p]]:    #判断性的if写在前面，因为一旦频率变化，这个统计变量就减1
                    cnt -= 1
                c2[s2[p]] -= 1                #字典哈希表移除最前面的字符
                if c2[s2[p]] == 0:            #由于counter特性，如果value为0，必须删除它
                    del c2[s2[p]]
                p += 1                        #最前面的下标右移动
        return False

class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1)
        c2 = collections.Counter()
        cnt = 0 #统计变量，全部26个字符，频率相同的个数，当cnt==s1字母的个数的时候，就是全部符合题意，返回真
        p = q = 0 #滑动窗口[p,q]
        while q < l2:
            c2[s2[q]] += 1
            if c1[s2[q]] == c2[s2[q]]: #对于遍历到的字母，如果出现次数相同
                cnt += 1               #统计变量+1
            if cnt == len(c1):         #判断结果写在前面，此时证明s2滑动窗口和s1全部字符相同，返回真
                return True
            q += 1                     #滑动窗口右移
            if q - p + 1 > l1:         #这是构造第一个滑动窗口的特殊判断，里面内容是维护边界滑动窗口
                if c1[s2[p]] == c2[s2[p]]:    #判断性的if写在前面，因为一旦频率变化，这个统计变量就减1
                    cnt -= 1
                c2[s2[p]] -= 1                #字典哈希表移除最前面的字符
                if c2[s2[p]] == 0:            #由于counter特性，如果value为0，必须删除它
                    del c2[s2[p]]
                p += 1                        #最前面的下标右移动
        return False


```

```py

Python 92% 配注释。

思路为维护一个窗口，用mp2存放窗口内元素出现的次数。当mp2 == mp1，返回True；否则，返回False。

时间复杂度：O(n)

空间复杂度：O(2 * 26)渐进为O(1)，2 * 是因为两个字典。26是因为最多26个字母。

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        n = len(s2)
        mp1 = collections.Counter(s1)
        mp2 = collections.defaultdict(int)
        l = 0 # 左窗
        for r in range(n):
            ele = s2[r]
            if ele not in mp1: # 当r指向元素不在mp1里时，将mp2清空，重新下一轮记数。
                l = r + 1
                mp2 = collections.defaultdict(int) 
            else: # 如果r指向元素在mp1里，检查指向元素频率是否大于mp1内对应元素。如果是，一直移动窗口左侧。
                mp2[ele] += 1
                while mp2[ele] > mp1[ele]:
                    mp2[s2[l]] -= 1
                    l += 1
                if mp2 == mp1: return True
        return False
```

```scala


/**
* my first commitment: sliding window: hashcode with build-in sliding method
*/
object Solution1 {
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1Length = s1.length
      val s1Hash = s1.groupBy(identity).mapValues(_.length).toMap.hashCode

      s2.sliding(s1Length).exists(seq => seq.groupBy(identity).mapValues(_.length).toMap.hashCode == s1Hash)
    }
}


/**
* optimize from 1-1 : maintain sliding window and hashmap by my self
* time complexity: O(s1.length + s2.length)
* space complexity: O(s1.distinct.length)
*/
object Solution1-2 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1HashCode = s1.groupBy(identity).mapValues(_.length).toMap.hashCode
      val s2Map = mutable.Map.empty[Char, Int]
      
      (0 until s2.length).exists {
        case idx if idx < s1.length =>
          val char = s2(idx)
          mapIncrement(s2Map, char)
          s2Map.hashCode == s1HashCode
        case idx => 
          val rightChar = s2(idx)
          val leftChar = s2(idx - s1.length)
          mapIncrement(s2Map, rightChar)
          mapDecrement(s2Map, leftChar) 
          s2Map.hashCode == s1HashCode
      }
    }
    def mapIncrement(map: mutable.Map[Char, Int], char: Char): Unit = {
      map.get(char) match {
            case Some(v) => map.update(char, v + 1)
            case None => map.update(char, 1)
      }
    }
    def mapDecrement(map: mutable.Map[Char, Int], char: Char) = map.get(char) match {
      case Some(v) if v == 1 => map.remove(char)
      case Some(v) => map.update(char, v - 1)
      case None =>
    }
}

/**
* sliding windows: using only 1 map to record differential
* 1. if diff map is empty, s2 contains the permutation of s1
* 2. initial map with foreach instead of groupBy witch is time consuming
* time complexity (l1 + l2)
*/
object Solution1-3 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val diffMap = mutable.Map.empty[Char, Int]
      s1.foreach(mapUpdate(diffMap, _, 1))
      
      (0 until s2.length).exists {case idx =>
        if (idx >= s1.length) {
          val leftChar = s2(idx - s1.length)
          mapUpdate(diffMap, leftChar, 1)
        }
        val rightChar = s2(idx)
        mapUpdate(diffMap, rightChar, -1)
        diffMap.isEmpty
      }
    }
    def mapUpdate(map: mutable.Map[Char, Int], char: Char, value: Int): Unit = {
      map.get(char) match {
            case Some(v) if v + value == 0 => map.remove(char)
            case Some(v) => map.update(char, v + value)
            case None => map.update(char, value)
      }
    }
}
```

###  1.266. <a name='-1'></a>572-另一个树的子树

[哈哈哈](https://www.bilibili.com/video/BV1cA411t7zD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1wt4y197aB?spm_id_from=333.999.0.0)

```py
这题不可能是简单题

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        def dfs(A,B): # 函数的功能要明确，用来判断当前子树是否一致
            if not B and not A: # 如果同时为空，则子树一致
                return True
            if not A and B: # 一个为空，另一个不为空，则子树不一致
                return False
            if not B and A:
                return False
            if A.val != B.val: # 如果当前节点的值不相等，显然不一致
                return False
            return dfs(A.left, B.left) and dfs(A.right, B.right) # 递归去对照两个子树的左子树和右子树
        
        if not root or not subRoot:
            return False
        if root.val == subRoot.val:
            if dfs(root, subRoot):
                return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
```

```py
python

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        if not root or not subRoot: return False
        l = self.isSubtree(root.left, subRoot)
        r = self.isSubtree(root.right, subRoot)    
        def equal(root1, root2):
            if not root1 and not root2: return True
            elif not root1 or not root2: return False
            elif root1.val != root2.val: return False
            else: return equal(root1.left, root2.left) and equal(root1.right, root2.right)
        return equal(root, subRoot) or l or r
学习一下速度最快那几种方法之一:序列化（元组化）+字符串比较-----打败96%

class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        def toTup(t):#这个函数把树序列化为一个元组
            return (t.val,toTup(t.left),toTup(t.right)) if t else None
        return str(toTup(t)) in str(toTup(s))#把元组转化为字符串以方便比较
```

###  1.267. <a name='DistributeCandies'></a>575 Distribute Candies

[小明](https://www.bilibili.com/video/BV11i4y1T7Pr?spm_id_from=333.999.0.0)

###  1.268. <a name='OutofBoundaryPaths'></a>576. Out of Boundary Paths

[花花酱](https://www.bilibili.com/video/BV18W411d7Cf?spm_id_from=333.999.0.0)

###  1.269. <a name='ShortestUnsortedContinuousSuba'></a>581 Shortest Unsorted Continuous Suba

[小明](https://www.bilibili.com/video/BV1Y54y1h7Xa?spm_id_from=333.999.0.0)

###  1.270. <a name='N-aryTreePreorderTraversal'></a>589 N-ary Tree Preorder Traversal

[小明](https://www.bilibili.com/video/BV1io4y1f7qT?spm_id_from=333.999.0.0)

###  1.271. <a name='ValidSquare'></a>593 Valid Square

[小明](https://www.bilibili.com/video/BV1j5411V73U?spm_id_from=333.999.0.0)

###  1.272. <a name='LongestHarmoniousSubsequence'></a>594 Longest Harmonious Subsequence

[小明](https://www.bilibili.com/video/BV1Pp4y1p7ss?spm_id_from=333.999.0.0)

###  1.273. <a name='CanPlaceFlowers'></a>605 Can Place Flowers

[小明](https://www.bilibili.com/video/BV1Uz4y1k7xU?spm_id_from=333.999.0.0)

### 611

```py
# 双指针

class Solution:
    # 双指针
    def triangleNumber(self, nums):
        nums.sort()
        n = len(nums)
        count = 0
        for c in range(2, n):
            a, b = 0, c-1
            while a < b:
                if nums[a] + nums[b] <= nums[c]:
                    a += 1
                else:
                    count += b - a 
                    b -= 1
        return count

class Solution(object):
    def triangleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)[::-1]
        res = 0
        for i in range(len(nums)-2):
            j, k = i + 1, len(nums) - 1
            while j < k:
                if nums[k] + nums[j] > nums[i]:
                    res += k - j
                    j += 1                
                else:
                    k -= 1
        return res

class Solution:
    def triangleNumber(self, nums):
        nums.sort()
        res = 0
        # 从大到小遍历
        for i in range(len(nums) - 1, 1, -1):
            l, r = 0, i -1
            while l < r:
                # 只要较小的两个值之和大于最大的值，则一定可组成三角形
                if nums[l] + nums[r] > nums[i]:
                    #i, r 和从l到r-1都可组成三角形，个数为 (r-1) - l + 1 = r - l
                    res += (r-1) - l + 1
                    r -= 1
                else: l += 1
        return res

class Solution:
    def triangleNumber(self, nums):
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n):
            k = i
            for j in range(i + 1, n):
                while k + 1 < n and nums[k + 1] < nums[i] + nums[j]:
                    k += 1
                ans += max(k - j, 0)
        return ans

class Solution:
    def triangleNumber(self, nums):
        nums.sort()
        res = 0
        for k in range(len(nums)):
            i, j = 0, k - 1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    res += j - i
                    j -= 1
                else:
                    i += 1
        return res
```

###  1.274. <a name='TaskScheduler'></a>621. Task Scheduler

[花花酱](https://www.bilibili.com/video/BV1Wt411Y7Y9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1LZ4y1M7Bg?spm_id_from=333.999.0.0)

```py
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = collections.Counter(tasks)

        # 任务总数
        m = len(freq)
        nextValid = [1] * m
        rest = list(freq.values())

        time = 0
        for i in range(len(tasks)):
            time += 1
            minNextValid = min(nextValid[j] for j in range(m) if rest[j] > 0)
            time = max(time, minNextValid)
            
            best = -1
            for j in range(m):
                if rest[j] and nextValid[j] <= time:
                    if best == -1 or rest[j] > rest[best]:
                        best = j
            
            nextValid[best] = time + n + 1
            rest[best] -= 1

        return time

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = collections.Counter(tasks)

        # 最多的执行次数
        maxExec = max(freq.values())
        # 具有最多执行次数的任务数量
        maxCount = sum(1 for v in freq.values() if v == maxExec)

        return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

最容易想明白的方法，每次都统计所有任务的数量然后降序排序，每次循环刷n+1个任务，即相应数组位置-1。再排序，再刷。直到第一个位置变成1就不这么操作。加上剩下为1的位置数目就大功告成

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        if n==0:
            return(len(tasks))
        timee = 0
        appearence = sorted(collections.Counter(tasks).values(), reverse=True)
        while appearence[0]>1:
            for i in range(n+1):
                if i < len(appearence):
                    appearence[i] = appearence[i]-1
            appearence = sorted(appearence,reverse = True)
            timee = timee+n+1
        print(appearence)
        last = collections.Counter(appearence)[1]
        return(timee+last)
        
妙！虽然桶思想容易理解且代码很简洁，但事先不容易想到，

这种排序思想是很容易想到的，但是排序思想编码不太容易，楼主代码写的很精妙简洁，

各种情况都包含在代码里了，牛逼！找不到一句废话，

唯一可以修改的地方是last= appearence.count(1)😝
```

```py
还是离不开Counter。简单解释一下：取次数最多的字母，两两之间加上n个间隔。

但是，如果有次数一样多的，还需要加1，加1不超过n次。再跟任务的总长度比较，取大的值就可以了。

from collections import Counter
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        l = len(tasks)
        if n == 0:
            return l
        c = Counter(tasks)
        m = c.most_common()
        ret = m[0][1] * (n + 1) - n
        for i in range(1, min(len(m), n)):
            if m[i][1] < m[0][1]:
                break
            ret += 1
        return max(ret, l)
```

###  1.275. <a name='DesignCircularQueue'></a>622 Design Circular Queue

[小明](https://www.bilibili.com/video/BV1kV411n7Uk?spm_id_from=333.999.0.0)

###  1.276. <a name='AddOneRowtoTree'></a>623 Add One Row to Tree

[小明](https://www.bilibili.com/video/BV1AK4y1U7ud?spm_id_from=333.999.0.0)

###  1.277. <a name='SumofSquareNumbers'></a>633-Sum of Square Numbers

[哈哈哈](https://www.bilibili.com/video/BV1a7411h7on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qh411i7Yh?spm_id_from=333.999.0.0)

```py
又是Python不拥有姓名的一天

class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        if not c:
            return True
        # (a - b) ^ 2 + (a + b) ^ 2 = 2 (a ^ 2 + b ^ 2) = 2 * c
        while c % 2 == 0:
            c //= 2
        # 费马平方和定理
        if c % 4 == 3:
            return False
        sqrt = int(math.sqrt(c))
        for i in range(3, sqrt + 1, 4):
            count = 0
            while c % i == 0:
                c //= i
                count += 1
            if count % 2 != 0:
                return False
        return True
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        # 双指针解法
        i, j = 0, int(math.sqrt(c))
        while i <= j:
            res = i * i + j * j
            if res == c:
                return True
            elif res < c:
                i += 1
            else:
                j -= 1
        return False
```

```py
双指针

i 从 0 开始
j 从可取的最大数 int(math.sqrt(c)) 开始
total = i * i + j * j
total > c: j = j - 1，将 total 值减小
total < c: i = i + 1，将 total 值增大
total == c：返回 True
import math

class Solution(object):
    def judgeSquareSum(self, c):
        """
        :type c: int
        :rtype: bool
        """
        j = int(math.sqrt(c))
        i = 0
        while i <= j:
            total = i * i + j * j
            if total > c:
                j = j - 1
            elif total < c:
                i = i + 1
            else:
                return True
        return False
最大值应该是Math.sqrt(c/2)
最大值就是Math.sqrt(c)，c = a^2 + b^2，在b=0的时候，a就是Math.sqrt(c)，取Math.sqrt(c/2)会出错。
```

###  1.278. <a name='ExclusiveTimeofFunctions'></a>636. Exclusive Time of Functions

[花花酱](https://www.bilibili.com/video/BV1PW411o7Bh?spm_id_from=333.999.0.0)

###  1.279. <a name='AverageofLevelsinBinaryTree'></a>637 Average of Levels in Binary Tree

[小明](https://www.bilibili.com/video/BV1eb4y1976M?spm_id_from=333.999.0.0)

###  1.280. <a name='DecodeWaysII'></a>639. Decode Ways II

[花花酱](https://www.bilibili.com/video/BV1YW411r75q?spm_id_from=333.999.0.0)

###  1.281. <a name='MaximumAverageSubarrayI'></a>643. Maximum Average Subarray I

[小梦想家](https://www.bilibili.com/video/BV1dV411k7i6?spm_id_from=333.999.0.0)

###  1.282. <a name='-1'></a>645-错误的集合

[哈哈哈](https://www.bilibili.com/video/BV1az411e7zU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1479j?spm_id_from=333.999.0.0)

```py
数学解题

class Solution:
    def findErrorNums(self, nums):
        ln, total = len(nums), sum(set(nums))
        return [sum(nums) - total, (1 + ln) * ln // 2 - total]
循环数组解题

class Solution:
    def findErrorNums(self, nums):
        ln = len(nums)
        repeat = lose = -1
        nums.sort()
        if nums[0] != 1:
            lose = 1
        elif nums[-1] != ln:
            lose = ln
        for i in range(1, ln):
            if nums[i] == nums[i - 1]:
                repeat = nums[i]
            if nums[i] - nums[i - 1] == 2:
                lose = nums[i] - 1
        return [repeat, lose]
哈希表解题

from collections import Counter

class Solution:
    def findErrorNums(self, nums):
        ln = len(nums)
        dic = Counter(nums)
        repeat = lose = -1
        for i in range(1, ln + 1):
            tmp = dic.get(i, 0)
            if tmp == 0:
                lose = i
            elif tmp == 2:
                repeat = i
        return [repeat, lose]
```

```py
在英文站抄的，很有意思

将1，n的bool初始为None

出现一次，变化为True

出现两次，变化为False

出现零次，仍为None

第一个['']是垫了一个，因为不是从零开始的

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        flag = [''] + [None] * len(nums)
        for each in nums:
            flag[each] = not flag[each]
        return [flag.index(False),flag.index(None)]



数学方法，求1+2...+N的和，nums唯一set()的和，和nums的和对应做减法直接得到结果

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        S = sum(set(nums))
        return [sum(nums)-S ,len(nums)*(len(nums)+1)//2-S]
        # len(nums)*(len(nums)+1)//2表示1+2+...+n = n*(n+1)/2, 减去 除了丢失数的和就是第二个结果
这题给我整抑郁了。。。。死磕遍历的方法不太行。。。

那就直接无脑算吧：

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        dup = sum(nums) - sum(set(nums))
        err = abs(sum(range(len(nums)+1)) - (sum(nums) - dup))
        return [dup, err]
```

###  1.283. <a name='-1'></a>646-最长数对链

[哈哈哈](https://www.bilibili.com/video/BV1rz411q7pZ?spm_id_from=333.999.0.0)

```py
# python3 贪心

class Solution:
    def findLongestChain(self, pairs):
        length = len(pairs)
        if length<=1:
            return length
        pairs = sorted(pairs, key=lambda x:x[1])
        pre = -1
        res = 0
        for i in range(length):
            if pre == -1:
                pre = i
                res += 1
            elif pairs[i][0] > pairs[pre][1]:
                pre = i
                res += 1
        return res

# python3, 贪心思想，具体参看附加上的归类的两道题的思路：

class Solution:
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x: (x[1], x[0]))
        count = 0
        end = -float('inf')
        for i, p in enumerate(pairs):
            if p[0] > end:
                count += 1
                end = p[1]
        return count 

class Solution(object):
    def findLongestChain(self, pairs):
        """
        :type pairs: List[List[int]]
        :rtype: int
        """
        if not pairs or len(pairs) == 0:
            return 0
        pairs = sorted(pairs, key=lambda x:x[0])
        dp = [1] * len(pairs)
        for i in range(1, len(pairs)):
            for j in range(i):
                dp[i] = max(dp[i], dp[j] + 1 if pairs[i][0] > pairs[j][1] else dp[j])
        return dp[-1]

class Solution(object):
    def findLongestChain(self, pairs):
        """
        :type pairs: List[List[int]]
        :rtype: int
        """
        if not pairs or len(pairs) == 0:
            return 0
        cur, res = float('-inf'), 0
        for p in sorted(pairs, key=lambda x: x[1]):
            if cur < p[0]: cur, res = p[1], res + 1
        return res
# 条件反射python3

class Solution:
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x:x[0])
        dp = []
        for i in range(len(pairs)):
            dp.append(1)
            for j in range(i):
                if pairs[i][0] > pairs[j][1]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return dp[-1]

import operator
class Solution(object):
    def findLongestChain(self, pairs):
        cur, ans = float('-inf'), 0
        for x, y in sorted(pairs, key = operator.itemgetter(1)):
            if cur < x:
                cur = y
                ans += 1
        return ans
```

###  1.284. <a name='PalindromicSubstrings'></a>647 Palindromic Substrings

[小明](https://www.bilibili.com/video/BV1g54y1h7uv?spm_id_from=333.999.0.0)

```py
# python无敌啊！！！有没有天理啊，手动滑稽😏😏😏😏！一行解法：
# ```python
import os
class Solution(object):
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype
        """
        return sum(len(os.path.commonprefix((s[:i][::-1], s[i:]))) 
                   + len(os.path.commonprefix((s[:i][::-1], s[i + 1:]))) + 1 
                        for i in range(len(s)))
# ```
# 解释下为啥要加两次，因为回文串有以下两种形式：
# - ‘abcba’
# - 'abba'

# 那为啥要加那个1呢，上面解释过了，单个字符也算是一个回文子串呀，嘻嘻😁

class Solution(object):
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype
        """
        '''
        双指针太暴力了吧
        '''
        cnt = 0
        for i in range(0,len(s)):
            for j in range(i+1,len(s)+1):
                # print(s[i:j])
                if s[i:j] == s[i:j][::-1]:
                    cnt += 1
        return cnt
```

```py
# 我傻了，看到范围1000，直接上On方 的解法了。
# 应对笔试不考虑空间复杂度，就直接dp动态规划了，
# 按照最长回文子串的思路，怎么写得快，怎么来。。。

class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[True] * n for _ in range(n)]
        ans = 0
        for d in range(n):
            for x in range(n):
                y = x + d
                if y >= n:
                    break
                if d == 0:
                    dp[x][y] = True
                elif d == 1:
                    dp[x][y] = (s[x] == s[y])
                else:
                    dp[x][y] = dp[x+1][y-1] and (s[x] == s[y])
                if dp[x][y]:
                    ans += 1
        return ans
```

```py
# 动态规划：

class Solution:
    def countSubstrings(self, s: str) -> int:
        dp = [[False] * len(s) for _ in range(len(s))]
        result = 0
        for i in range(len(s)-1, -1, -1): #注意遍历顺序
            for j in range(i, len(s)):
                if s[i] == s[j]:
                    if j - i <= 1: #情况一 和 情况二
                        result += 1
                        dp[i][j] = True
                    elif dp[i+1][j-1]: #情况三
                        result += 1
                        dp[i][j] = True
        return result

# 动态规划：简洁版

class Solution:
    def countSubstrings(self, s: str) -> int:
        dp = [[False] * len(s) for _ in range(len(s))]
        result = 0
        for i in range(len(s)-1, -1, -1): #注意遍历顺序
            for j in range(i, len(s)):
                if s[i] == s[j] and (j - i <= 1 or dp[i+1][j-1]): 
                    result += 1
                    dp[i][j] = True
        return result

class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        res = 0
        for i in range(n):
            for j in range(i, -1, -1):
                if s[i] == s[j] and (i - j + 1 <= 2 or dp[i - 1][j + 1]):
                    #print(i,j)
                    dp[i][j] = 1
                if dp[i][j]:res += 1
        return res
class Solution:
    def countSubstrings(self, s: str) -> int:
        n=len(s)
        dp = [[0]*n for i in range(n)]
        for i in range(n):
            dp[i][i]=1
        ans = n
        for i in range(n):
            for j in range(i-1,-1,-1):
                if s[j]==s[i] and dp[j+1][i-1]==i-j-1:
                    dp[j][i] = dp[j+1][i-1]+2
                    ans+=1
        return ans
```


```py
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        self.res = 0

        def helper(i, j):
            while i >= 0 and j < n and s[i] == s[j]:
                self.res += 1
                i -= 1
                j += 1

        for i in range(n):
            helper(i, i)
            helper(i, i + 1)
        return self.res
# 暴力，中心扩展

class Solution:
    def countSubstrings(self, s: str) -> int:
        length = len(s)
        if length == 0:return 0
        count = 0
        def centerExpand(left,right):
            cnt = 0
            while left >= 0 and right < length:
                if s[left] == s[right]:
                    cnt += 1
                    left -= 1
                    right += 1
                else:
                    return cnt
            return cnt
        for i in range(length):
            count += centerExpand(i,i)
            count += centerExpand(i,i+1)
        return count
# 双指针法：

class Solution:
    def countSubstrings(self, s: str) -> int:
        result = 0
        for i in range(len(s)):
            result += self.extend(s, i, i, len(s)) #以i为中心
            result += self.extend(s, i, i+1, len(s)) #以i和i+1为中心
        return result
    
    def extend(self, s, i, j, n):
        res = 0
        while i >= 0 and j < n and s[i] == s[j]:
            i -= 1
            j += 1
            res += 1
        return res
# python 每个位置向两端搜索

class Solution:
    def countSubstrings(self, s: str) -> int:
        def extend(i, j, s):
            count = 0
            while i >= 0 and j < len(s) and s[i] == s[j]:
                count += 1
                i -= 1
                j += 1
            return count

        count = 0
        m = len(s)
        for i in range(m):
            count += extend(i, i, s)
            count += extend(i, i+1, s)
        return count
# Python3中心扩展法非常简洁代码

# 直接利用中心扩展法, 依次计数找到的所有的回文子串即可；
# 无需在字符串中插入特殊字符, center中心位置从0到最后一个元素移动,

# 每次移动0.5, 表示移动到当前元素与下一个元素中间作为中心。
### 代码
from math import floor,ceil
class Solution:
    def countSubstrings(self, s: str) -> int:
        center = ans = 0
        while center < len(s):
            low, high = floor(center), ceil(center)
            while low >=0 and high < len(s) and s[low] == s[high]:
                low, high, ans = low-1, high+1, ans+1
            center += 0.5
        return ans
```

###  1.285. <a name='-1'></a>650-只有两个键的键盘

[哈哈哈](https://www.bilibili.com/video/BV1254y1z7ze?spm_id_from=333.999.0.0)

###  1.286. <a name='FindDuplicateSubtrees'></a>652. Find Duplicate Subtrees

[花花酱](https://www.bilibili.com/video/BV1cW411y7d1?spm_id_from=333.999.0.0)

###  1.287. <a name='TwoSumIV'></a>653. Two Sum IV

[小梦想家](https://www.bilibili.com/video/BV1Qz4y197h1?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AQ4y117mc?spm_id_from=333.999.0.0)

```py
看了官方题解，写的很好，我补充python 3 中序遍历中，直接向外传值的一个解法。

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        a=set()
        find=0
        def dfs(r):
            nonlocal find
            if r:
                dfs(r.left)
                if k-r.val in a:find=1
                a.add(r.val)
                dfs(r.right)
        dfs(root)
        return True if find else False

优化，及时停止递归，

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        a=set()
        def dfs(r):
            if r is None:return False
            
            if k-r.val in a:
                return True
            a.add(r.val)
            return dfs(r.left) or dfs(r.right)

        return dfs(root)
层层递归返回值与 直接返回值，再次服了大神的代码

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root: return False
        bfs, s = [root], set()
        for i in bfs:
            v=i.val
            l=i.left
            r=i.right
            if k - v in s: return True
            s.add(v)
            if l: bfs.append(l)
            if r: bfs.append(r)
        return False
```

```py
DFS

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        def dfs(root, k):
            nonlocal ans
            if not root:
                return False
            if k - root.val in ans:
                return True
            ans.add(root.val)
            return dfs(root.left, k) or dfs(root.right, k)
        
        ans = set()
        return dfs(root, k) 
BFS

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        ans = set()
        if not root:
            return False
        queue = [root]
        while queue:
            temp = queue.pop(0)
            if k - temp.val in ans:
                return True
            ans.add(temp.val)
            if temp.left:
                queue.append(temp.left)
            if temp.right:
                queue.append(temp.right)
        return False
```

###  1.288. <a name='MaximumWidthofBinaryTree'></a>662. Maximum Width of Binary Tree

[花花酱](https://www.bilibili.com/video/BV1cv411q7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16a4y1h7fG?spm_id_from=333.999.0.0)

```py
def widthOfBinaryTree(self, root):
    queue = [(root, 0, 0)]
    cur_depth = left = ans = 0
    for node, depth, pos in queue:
        if node:
            queue.append((node.left, depth+1, pos*2))
            queue.append((node.right, depth+1, pos*2 + 1))
            if cur_depth != depth:
                cur_depth = depth
                left = pos
            ans = max(pos - left + 1, ans)

    return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

对第一种方法的改进：queue中无须记录层数信息

class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        queue = [(root,0)]
        res = 0
        while queue:
            arr = []
            for _ in range(len(queue)):
                node,pos = queue.pop(0)
                arr.append(pos)
                if node.left:
                    queue.append((node.left,pos*2))
                if node.right:
                    queue.append((node.right,pos*2+1))
            
            res = max(res,1+arr[-1]-arr[0])
        
        return res

不完善，没必要用arr装入节点序号。BFS 建议用双端队列。

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        from collections import deque
        if not root: return 0  # 孤儿树
        q = deque([(root, 1)])
        res = 0
        while q:
            res = max(res, q[-1][-1] - q[0][-1] + 1)  # 只能写在这里！否则不存在
            for _ in range(len(q)):
                node, val = q.popleft()
                if node.left:
                    q.append((node.left, val * 2))
                if node.right:
                    q.append((node.right, val * 2 + 1))
        return res

class Solution(object):
    def widthOfBinaryTree(self, root):
        self.ans = 0
        left = {}
        def dfs(node, depth = 0, pos = 0):
            if node:
                left.setdefault(depth, pos)
                self.ans = max(self.ans, pos - left[depth] + 1)
                dfs(node.left, depth + 1, pos * 2)
                dfs(node.right, depth + 1, pos * 2 + 1)

        dfs(root)
        return self.ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        max_width = 0
        queue = collections.deque([(root, 1)])
        while queue:
            max_width = max(max_width, queue[-1][1] - queue[0][1] + 1)
            for _ in range(len(queue)):
                node, idx = queue.popleft()

                if node.left:  queue.append((node.left,  idx * 2))
                if node.right: queue.append((node.right, idx * 2 + 1))

        return max_width
```

###  1.289. <a name='BeautifulArrangementII'></a>667 Beautiful Arrangement II

[小明](https://www.bilibili.com/video/BV1j54y1b7Br?spm_id_from=333.999.0.0)

###  1.290. <a name='KthSmallestNumberinMultiplicationTable'></a>668. Kth Smallest Number in Multiplication Table

[花花酱](https://www.bilibili.com/video/BV17W411C7ai?spm_id_from=333.999.0.0)

###  1.291. <a name='TrimaBinarySearchTree'></a>669 Trim a Binary Search Tree

[小明](https://www.bilibili.com/video/BV19y4y1J7fu?spm_id_from=333.999.0.0)

###  1.292. <a name='NumberofLongestIncreasingSubse'></a>673 Number of Longest Increasing Subse

[小明](https://www.bilibili.com/video/BV1gT4y1F7y3?spm_id_from=333.999.0.0)

###  1.293. <a name='ValidParenthesisString'></a>678 Valid Parenthesis String

[小明](https://www.bilibili.com/video/BV1ap4y1X7nu?spm_id_from=333.999.0.0)

###  1.294. <a name='ValidPalindromeII'></a>680-Valid Palindrome II

[哈哈哈](https://www.bilibili.com/video/BV167411h7x1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y147xn?spm_id_from=333.999.0.0)

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def checkPalindrome(low, high):
            i, j = low, high
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        low, high = 0, len(s) - 1
        while low < high:
            if s[low] == s[high]: 
                low += 1
                high -= 1
            else:
                return checkPalindrome(low + 1, high) or checkPalindrome(low, high - 1)
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-palindrome-ii/solution/yan-zheng-hui-wen-zi-fu-chuan-ii-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def validPalindrome(self, s: str, flag=False) -> bool:
        if s == s[::-1]:
            return True 
        start, end = 0, len(s) - 1
        while start < end:
            if s[start] == s[end]:
                start, end = start+1, end-1
            elif not flag:
                return self.validPalindrome(s[start+1:end+1], True) or self.validPalindrome(s[start:end], True)
            else:
                return False
        return True

class Solution:
    def validPalindrome(self, s):
        if s == s[::-1]:
            return True
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] == s[r]:
                l, r = l + 1, r - 1
            else:
                a = s[l + 1 : r + 1]
                b = s[l:r]
                return a == a[::-1] or b==b[::-1]
```

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        n = len(s)
        i = next((i for i in range(n>>1) if s[i] != s[~i]), -1)
        return i == -1 or s[i+1:n-i] == s[i+1:n-i][::-1] or s[i:n-i-1] == s[i:n-i-1][::-1]
```

###  1.295. <a name='KEmptySlots'></a>683. K Empty Slots

[花花酱](https://www.bilibili.com/video/BV1Jb411k7Yu?spm_id_from=333.999.0.0)

###  1.296. <a name='RedundantConnection684-'></a>684. Redundant Connection 684-冗余连接

[花花酱](https://www.bilibili.com/video/BV1mt411J79j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1oe411p7qF?spm_id_from=333.999.0.0)

```py
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = list(range(n + 1))

        def find(index: int) -> int:
            if parent[index] != index:
                parent[index] = find(parent[index])
            return parent[index]
        
        def union(index1: int, index2: int):
            parent[find(index1)] = find(index2)

        for node1, node2 in edges:
            if find(node1) != find(node2):
                union(node1, node2)
            else:
                return [node1, node2]
        
        return []

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/redundant-connection/solution/rong-yu-lian-jie-by-leetcode-solution-pks2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
1，并查集思想解题
并查集的初始化就是每个点只属于自己标记的集合，即p[x]=x。
遍历边，如果两个点集合不同，那就合并进同一个集合，这里用了递归修改集合。
如果遍历边的过程中，发现两个点已经加进过之前的集合了，那就说明成环了，这时就可以输出了。
这就是传统并查集的做法。
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        p = [i for i in range(len(edges) + 1)]
        p = [*range(len(edges) + 1)]      #并查集元素初始化
        def f(x):
            if p[x] != x:       #递归修改所属集合,看上面dsu定义
                p[x] = f(p[x])  #如果结点是它自己的父结点，我们将其称为连接结点的领导者，保证p[x]=x这就是求领导节点的函数
            return p[x]
        for x, y in edges:      #遍历边
            px, py = f(x), f(y)
            if px != py:        #检查集合，领导节点是否相同，如果集合不同就合并
                p[py] = px
            else:
                return [x, y]   #集合相同就返回答案

利用py集合特性也可以做并查集，本质上没有区别，不过不用递归了，其实就是靠字典实现的并查集
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        p = {i: {i} for i in range(1, len(edges) + 1)}  #并查集初始化，{1: {1}, 2: {2}, 3: {3}, 4: {4}}
        for x, y in edges:
            if p[x] is not p[y]:    #如果两个集合地址不一样
                p[x] |= p[y]        #合并集合
                for z in p[y]:
                    p[z] = p[x]     #修改元素集合标记的指针地址
            else:
                return [x, y]

2，拓扑排序
利用数组degree记录各顶点的度。
利用数组neighbor记录各顶点的邻接顶点。
从度为1的节点出发进行拓扑排序，剩余边中在edges中排最后的那条即为答案。
拓扑排序步骤：
1.寻找出最开始的结点（因为是有向图，可以按箭头方向。无向图可任意）。
2.记住，记录一个点后，与这个点有关的所有边全部删除。如：记录点A后，那么A->B、A->C、A->D之间的边全部删除。
3.再一次寻找新的开始结点。。。重复以上步骤。。。。。。。。。。。。
直接看代码

# 并查集
class Solution1:
    def findRedundantConnection(self, edges):
        p = [i for i in range(len(edges) + 1)]
        p = [*range(len(edges) + 1)]      #并查集元素初始化
        def f(x):
            if p[x] != x:       #递归修改所属集合,看上面dsu定义
                p[x] = f(p[x])  #如果结点是它自己的父结点，我们将其称为连接结点的领导者，保证p[x]=x这就是求领导节点的函数
            return p[x]
        for x, y in edges:      #遍历边
            px, py = f(x), f(y)
            if px != py:        #检查集合，领导节点是否相同，如果集合不同就合并
                p[py] = px
            else:
                return [x, y]   #集合相同就返回答案



class Solution:

    def __init__(self):
        """
        初始化
        """
        self.n = 1005
        self.father = [i for i in range(self.n)]


    def find(self, u):
        """
        并查集里寻根的过程
        """
        if u == self.father[u]:
            return u
        self.father[u] = self.find(self.father[u])
        return self.father[u]

    def join(self, u, v):
        """
        将v->u 这条边加入并查集
        """
        u = self.find(u)
        v = self.find(v)
        if u == v : return
        self.father[v] = u
        pass


    def same(self, u, v ):
        """
        判断 u 和 v是否找到同一个根，本题用不上
        """
        u = self.find(u)
        v = self.find(v)
        return u == v

    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        for i in range(len(edges)):
            if self.same(edges[i][0], edges[i][1]) :
                return edges[i]
            else :
                self.join(edges[i][0], edges[i][1])
        return []
```

###  1.297. <a name='RedundantConnectionII'></a>685. Redundant Connection II

[花花酱](https://www.bilibili.com/video/BV1St411J7Ur?spm_id_from=333.999.0.0)

###  1.298. <a name='LongestUnivaluePath'></a>687. Longest Univalue Path

[花花酱](https://www.bilibili.com/video/BV1wt411r7Pr?spm_id_from=333.999.0.0)

###  1.299. <a name='KnightProbabilityinChessboard'></a>688. Knight Probability in Chessboard

[花花酱](https://www.bilibili.com/video/BV1Hb411c7mu?spm_id_from=333.999.0.0)

###  1.300. <a name='EmployeeImportance'></a>690. Employee Importance

[花花酱](https://www.bilibili.com/video/BV1Ut411J7uC?spm_id_from=333.999.0.0)

###  1.301. <a name='TopKFrequentWords'></a>692. Top K Frequent Words

[花花酱](https://www.bilibili.com/video/BV1Mt41137eL?spm_id_from=333.999.0.0)

### 693

```py
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while n:
            prenum = (n//2) & 1 # 背一背，和16进制差不多
            nownum = n%2
            if prenum == nownum:
                return False
            n>>=1
        return True

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while n:
            x = n & 1 # 如果两个相应位都为1,则该位的结果为1
            n>>=1 # 把">>"左边的运算数的各二进位全部右移1位
            y = n & 1
            if x==y:
                return False
        return True

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        tmp = str(bin(n))[2:]
        res = [tmp[i] != tmp[i-1] for i in range(1, len(tmp))]
        return all(res)

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        return not ('11' in str(bin(n)) or '00' in str(bin(n)))

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        return not('11' in bin(n) or '00' in bin(n))

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        n = str(bin(n))[2:]
        for i in range(0, len(n)-1):
            if n[i] == n[i+1]:
                return False
        return True

# bin()本身返回的就是字符串

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        b = n >> 1
        res = bin(b^n)[2:]
        if '0' in res:
            return False
        else:
            return True
```

###  1.302. <a name='-1'></a>695-岛屿的最大面积

[哈哈哈](https://www.bilibili.com/video/BV1s54y1B77k?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wz4y1R7e6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1k64y1c798?spm_id_from=333.999.0.0)

```py
class Solution:
    def dfs(self, grid, cur_i, cur_j) -> int:
        if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
            return 0
        grid[cur_i][cur_j] = 0
        ans = 1
        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            next_i, next_j = cur_i + di, cur_j + dj
            ans += self.dfs(grid, next_i, next_j)
        return ans

    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                ans = max(self.dfs(grid, i, j), ans)
        return ans


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                cur = 0
                stack = [(i, j)]
                while stack:
                    cur_i, cur_j = stack.pop()
                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
                        continue
                    cur += 1
                    grid[cur_i][cur_j] = 0
                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        next_i, next_j = cur_i + di, cur_j + dj
                        stack.append((next_i, next_j))
                ans = max(ans, cur)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                cur = 0
                q = collections.deque([(i, j)])
                while q:
                    cur_i, cur_j = q.popleft()
                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
                        continue
                    cur += 1
                    grid[cur_i][cur_j] = 0
                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        next_i, next_j = cur_i + di, cur_j + dj
                        q.append((next_i, next_j))
                ans = max(ans, cur)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python dfs 和 union find dfs

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        
        def dfs(i, j):
            grid[i][j] = 0
            ans = 1
            for r, c in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= r < m and 0 <= c < n and grid[r][c] == 1:
                    ans += dfs(r, c)
            return ans
        
        res = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    res = max(res, dfs(i, j))
        return res
union find 首先将grid中的每一个点都当作一个set， 如果这个点的元素为1， 则set的大小为1， 如果这个点的元素为0， 则set的大小为0； 遍历grid中的每一个点v，如果v的元素为1， 则判断v右边的点v_r和下面的v_d点是否为1， 如果是， 则将v_r/v_d点放进点v的set中， 同时用num来更新这个set的大小。

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        
        def find(v):
            if parent[v] != v:
                return find(parent[v])
            return parent[v]
        
        def union(v1, v2):
            r1 = find(v1)
            r2 = find(v2)
            if r1 != r2:
                parent[r2] = r1
                num[r1] += num[r2]
        
        m, n = len(grid), len(grid[0])
        parent = [i*n+j for i in range(m) for j in range(n)]
        num = [0] * (m * n)
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    v = i*n+j
                    num[v] = 1
                    if 0 <= i + 1 < m and grid[i + 1][j]:
                        num[v+n] = 1
                        union(v, v+n)
                    if 0 <= j + 1 < n and grid[i][j + 1]:
                        num[v+1] = 1
                        union(v, v+1)
        return max(num)
```

```py
最开始用两层递归，一层找岛屿，一层计算面积，时间直接爆炸 后来直接用两个for循环遍历列表来找岛屿，再用递归计算面积，速度非常快

执行用时：56 ms, 在所有 Python3 提交中击败了94.56%的用户
内存消耗：16.7 MB, 在所有 Python3 提交中击败了67.66%的用户
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        self.grid = grid
        self.ans = 0
        self.ans2 = 0
        self.height = len(grid)
        self.width  = len(grid[0])

        for i in range(self.height):  #直接for循环遍历即可，不用递归
            for j in range(self.width):
                if self.grid[i][j] == 1:
                    self.grid[i][j] = 0
                    self.dfs(i, j)
                    self.ans = max(self.ans, self.ans2)
                    self.ans2 = 0    
                    
        return self.ans        


    def dfs(self, i, j):  #从一个点开始找附近的所有岛屿，并且把找到的岛屿标记为海水
        self.grid[i][j] = 0
        self.ans2 += 1
        if j+1 < self.width and self.grid[i][j+1] == 1: #往右
            self.dfs(i, j+1)
        if j-1 >= 0 and self.grid[i][j-1] == 1:   #往左
            self.dfs(i, j-1)
        if i+1 < self.height and self.grid[i+1][j] == 1:   #往上
            self.dfs(i+1, j)
        if i-1 >= 0 and self.grid[i-1][j] == 1:   #往下
            self.dfs(i-1, j)
```

###  1.303. <a name='CountBinarySubstrings'></a>696 Count Binary Substrings

[小明](https://www.bilibili.com/video/BV14p4y1b7nV?spm_id_from=333.999.0.0)

###  1.304. <a name='FallingSquares'></a>699. Falling Squares

[花花酱](https://www.bilibili.com/video/BV1Lt41137EM?spm_id_from=333.999.0.0)

###  1.305. <a name='SearchinaBinarySearchTree'></a>700 Search in a Binary Search Tree

[小明](https://www.bilibili.com/video/BV14z411e76U?spm_id_from=333.999.0.0)

###  1.306. <a name='InsertintoaBinarySearchTree'></a>701 Insert into a Binary Search Tree

[小明](https://www.bilibili.com/video/BV1q54y1k76s?spm_id_from=333.999.0.0)

###  1.307. <a name='KthLargestElementinaStreamK'></a>703.Kth Largest Element in a Stream数据流中的第K大元素

[图灵](https://www.bilibili.com/video/BV1g5411w7o8?spm_id_from=333.999.0.0)

```py
方法一：直接降序排序，然后取第k个元素返回，add时每次都再排序一次，这样时间复杂度为O(k*logk)

# 1.直接排序
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.nums = nums
        self.k = k
        self.nums.sort(reverse = True)
        while len(self.nums) > k:
            self.nums.pop()

    def add(self, val: int) -> int:
        self.nums.append(val)
        self.nums.sort(reverse = True)
        if len(self.nums) > self.k:
            self.nums.pop()
        return self.nums[-1]
方法二：使用小顶堆实现的优先队列，Python 中标准库 heapq 就是小顶堆，时间复杂度降低为O(k)

# 2.小顶堆
import heapq
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.pool = nums
        heapq.heapify(self.pool)
        self.k = k
        while len(self.pool) > k:
            heapq.heappop(self.pool)

    def add(self, val: int) -> int:
        if len(self.pool) < self.k:
            heapq.heappush(self.pool, val)
        elif val > self.pool[0]:
            heapq.heapreplace(self.pool, val)
        return self.pool[0]
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.queue = []
        for n in nums: self.add(n)

    def add(self, val: int) -> int:
        if len(self.queue) < self.k:
            heapq.heappush(self.queue, val)
        elif val > self.queue[0]:
            heapq.heapreplace(self.queue, val)
        return self.queue[0]



python 3
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.nums = nums
        heapq.heapify(self.nums)
        self.k = k


    def add(self, val: int) -> int:
        heapq.heappush(self.nums, val)
        while len(self.nums) > self.k:
            heapq.heappop(self.nums)
        return self.nums[0]
```

```py
一顿操作猛如虎，一看击败百分五

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        t = sorted(nums)
        t = t[::-1]
        self.arr = t[:k]

    def add(self, val: int) -> int:
        for i in range(min(self.k, len(self.arr))):
            if self.arr[i] < val:
                self.arr.insert(i, val)
                break
        else:
            self.arr.append(val)
        return self.arr[self.k - 1]
```

```scala
/**
* using min heap
*/
class KthLargest(_k: Int, _nums: Array[Int]) {
    private val pq = scala.collection.mutable.PriorityQueue.empty[Int](Ordering[Int].reverse)
    val k = _k
    _nums.foreach(add)


    def add(`val`: Int): Int = {
        if (pq.size < k)
            /* if only add one element at once, += is more effective than enqueue op */
            pq += `val`
            // pq.enqueue(`val`)
        else if(pq.head < `val`){
            pq.dequeue
            pq += `val`
            // pq.enqueue(`val`)
        }
        // println(pq.clone.dequeueAll)
        pq.head
               
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(`val`)
 */
```

###  1.308. <a name='BinarySearch'></a>704.Binary Search二分查找

[图灵](https://www.bilibili.com/video/BV1Dh411v7yT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qa4y157E4?spm_id_from=333.999.0.0)

```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low, high = 0, len(nums) - 1
        while low <= high:
            mid = (high - low) // 2 + low
            num = nums[mid]
            if num == target:
                return mid
            elif num > target:
                high = mid - 1
            else:
                low = mid + 1
        return -1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
对不起没忍住

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target in nums :
            return nums.index(target)
        else:
            return -1
（版本一）左闭右闭区间

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            middle = (left + right) // 2

            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle - 1
            else:
                return middle
        return -1
（版本二）左闭右开区间

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left,right  =0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid+1
            elif nums[mid] > target:
                right = mid
            else:
                return mid
        return -1
```

```scala
object Solution {
    def search(nums: Array[Int], target: Int): Int = {
        nums.lastIndexOf(target)
    }
}

/**
* my first commitment:
* time complexity: O(logn)
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        println(left, right)
        val mid: Int = left  + (right - left) / 2
        if(nums(mid) == target){
          ans = mid
        } else if(target > nums(mid)) {
          left = mid + 1
        } else {
          right = mid - 1
        }
 
      }
      ans
    }
}

/**
* recursive version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
        search(nums, target, 0, nums.length - 1)
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      
      val mid = left + (right - left) / 2
      if (nums(mid) == target) 
        mid
      else if (target > nums(mid))
        search(nums, target, mid + 1, right)
      else 
        search(nums, target, left, right - 1)
      
    }
}
```

###  1.309. <a name='DesignHashSet'></a>705 Design HashSet

[小明](https://www.bilibili.com/video/BV1hV411z73p?spm_id_from=333.999.0.0)

###  1.310. <a name='DesignHashMap'></a>706. Design HashMap设计哈希映射

[图灵](https://www.bilibili.com/video/BV1Ho4y1Q7cr?spm_id_from=333.999.0.0)

###  1.311. <a name='DesignLinkedList'></a>707. Design Linked List

[花花酱](https://www.bilibili.com/video/BV1yW411Z7dV?spm_id_from=333.999.0.0)

###  1.312. <a name='MinimumASCIIDeleteSumforTwoStrings'></a>712. Minimum ASCII Delete Sum for Two Strings

[花花酱](https://www.bilibili.com/video/BV17W411d7m2?spm_id_from=333.999.0.0)

###  1.313. <a name='SubarrayProductLessThanK'></a>713 Subarray Product Less Than K

[小明](https://www.bilibili.com/video/BV1T5411j7tC?spm_id_from=333.999.0.0)

###  1.314. <a name='-1'></a>714-买卖股票的最佳时机含手续费

[哈哈哈](https://www.bilibili.com/video/BV1WK4y1E7mP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1t54y187Qy?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        dp = [[0, -prices[0]]] + [[0, 0] for _ in range(n - 1)]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee)
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        return dp[n - 1][0]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        sell, buy = 0, -prices[0]
        for i in range(1, n):
            sell, buy = max(sell, buy + prices[i] - fee), max(buy, sell - prices[i])
        return sell

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        buy = prices[0] + fee
        profit = 0
        for i in range(1, n):
            if prices[i] + fee < buy:
                buy = prices[i] + fee
            elif prices[i] > buy:
                profit += prices[i] - buy
                buy = prices[i]
        return profit

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
Python：

class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n)]
        dp[0][0] = -prices[0] #持股票
        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee)
        return max(dp[-1][0], dp[-1][1])


Python：

class Solution: # 贪心思路
    def maxProfit(self, prices: List[int], fee: int) -> int:
        result = 0
        minPrice = prices[0]
        for i in range(1, len(prices)):
            if prices[i] < minPrice:
                minPrice = prices[i]
            elif prices[i] >= minPrice and prices[i] <= minPrice + fee: 
                continue
            else: 
                result += prices[i] - minPrice - fee
                minPrice = prices[i] - fee
        return result
可以这样形象理解： 涨了能赚钱就抛掉。

然后，发现跌破了基准线(最高点-费用)，就庆幸自己抛掉了，并更新最低点；

如果没有跌破，但却找到新的高点，就找证券公司说我要反悔，之前抛掉的不算，并更新基准线。 

之前的贪心算法则是：遇到高点不急着抛掉，建立基准线；一旦跌破基准线则穿越回到之前的高点抛掉。

遇到新的高点，则更新基准线。 两者本质上完全一样的，就是反悔的时间点不一样。

Python3. Greedy is good.

假设此次交易利润：B - A - fee， 下次交易利润：D - C - fee， 

两次交易利润之和为 B - A + D - C - fee * 2， 

而只进行一次交易的利润为：D - A - fee， 只有当两次交易利润之和大于只进行一次交易的利润，

才会进行两次交易，因此：B - A + D - C - fee * 2 > D - A - fee，化简得 B - fee > C，

即下次交易的买入额要小于这次交易的卖出额-fee，才会获得更高总利润。 

这里设定minimum为此次交易卖出额-fee， 如果下一次股票价格比minimum小，

说明值得买入（重新赋值minimum）；

 如果大于minimum + fee，则按照minimum来计算交易利润，
 
 计算结果等价于上一次交易不卖出，这次卖出（即公式里的D - A - fee）； 

 而其他情况不值得交易（得不偿失或者根本没利润）。

class Solution:
    def maxProfit(self, prices, fee):
        """
        :type prices: List[int]
        :type fee: int
        :rtype: int
        """
        n = len(prices)
        if n < 2:
             return 0
        ans = 0
        minimum = prices[0]
        for i in range(1, n):
            if prices[i] < minimum:
                minimum = prices[i]
            elif prices[i] > minimum + fee:
                ans += prices[i]-fee-minimum
                minimum = prices[i]-fee
        return ans
## 未进行空间优化
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        length = len(prices)
        if len == 0:
            return 0
        have = [0] * length  # 表示第i天持有股票所得最多现金
        no = [0] * length    # 表示第i天不持有股票所得最多现金
        have[0] = -prices[0] # 此时的持有股票就一定是买入股票了
        no[0] = 0            # 不持有股票那么现金就是0
        for i in range(1, length):
            have[i] = max(have[i-1], no[i-1] - prices[i]) 
            no[i] = max(no[i-1], prices[i] + have[i-1] - fee)# 唯一不同之处
        return no[-1]  # 不持有股票状态所得金钱一定比持有股票状态得到的多

## 空间优化
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        length = len(prices)
        if len == 0:
            return 0
        have = -prices[0] # 此时的持有股票就一定是买入股票了
        no = 0            # 不持有股票那么现金就是0
        for i in range(1, length):
            have = max(have, no - prices[i]) 
            no = max(no, prices[i] + have - fee) # 唯一不同之处
        return no  # 不持有股票状态所得金钱一定比持有股票状态得到的多

fee一笔交易只收一次，买的时候收和卖的时候收没差的
dp1[i]表示第i天手上有股票，dp2[i]表示第i天手上没有股票，递归方程：

dp1[i] = max(dp1[i-1], dp2[i-1] - prices[i]) （第二项表示在第i天买入股票）
dp2[i] = max(dp2[i-1], dp1[i-1] + prices[i] - fee) （第二项表示在第i天将股票卖出，需扣除手续费）
python:
class Solution:
    def maxProfit(self, prices, fee):
        n = len(prices)
        if n < 2:
            return 0
        dp1 = [0 for _ in range(n)]#第i天手上有股票时的最大收益
        dp2 = [0 for _ in range(n)]#第i天手上无股票时的最大收益
        dp1[0] = -prices[0]
        for i in range(1,n):
            dp1[i] = max(dp1[i-1], dp2[i-1] - prices[i])
            dp2[i] = max(dp2[i-1], dp1[i-1] + prices[i] - fee)
        return dp2[n-1]
```

```scala
/**
* my first commitment
* dynamic programming
*     dp(i)(j) means the best profit we can have at i-th day in different state un-holding stock or holding a share of stock.
* 
*  memo:
*    this problem is similar to problem no 122
*  time complexity: O(N)
*  space complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        if(prices == null || prices.isEmpty) return 0
        
        /*
        *  0 for un-holding any stack
        *  1 for holding a share of stock
        */
        val dp = Array.tabulate(prices.length, 2) {
            case (0, 0) => 0
            case (0, 1) => -prices(0)
            case _ => 0
        }
        
        // 0: without holding, 1 holding
        for(i <- 1 until prices.length) {
            /** only pay the transition fee in selling a share of stock */
            dp(i)(0) = dp(i - 1)(0) max (dp(i - 1)(1) + prices(i) - fee)
            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i))
        }
        dp.last(0) // last time's state 0
        
    }
}

/**
* dynamic programming: only create an array keeping holding and un-holding
* time complexity: O(N)
* space complexity:  O(1)
*/
object Solution1-1 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        if(prices == null || prices.isEmpty) return 0
        val dp = Array.ofDim[Int](2)
        dp(0) = 0
        dp(1) = -prices(0)
        // 0 un-holding, 1 holding
        for(i <- 1 until prices.length){
        /*
        * it may causes a problem here, because we overwrite the previous dp(0) by new state i value and dp(1) would utilizes dp(0) which was overwritten 
        */
            dp(0) = dp(0) max (dp(1) + prices(i) - fee)
            dp(1) = dp(1) max (dp(0) - prices(i))
        }
        dp(0)
    }
}

/**
* dynamic programming 
* function programming
*/
object Solution2 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        val (unholding, holding) = prices.foldLeft((0, Int.MinValue)){
            case ((unholding, holding), price) =>
            (
            // avoiding overflow
                if((price - fee) > 0) unholding max (holding + price - fee) else unholding,
                holding max (unholding - price)
            )
        }
        unholding
    }
}
```

###  1.315. <a name='RangeModule'></a>715. Range Module

[花花酱](https://www.bilibili.com/video/BV1jt411379W?spm_id_from=333.999.0.0)

###  1.316. <a name='FindK-thSmallestPairDistance'></a>719. Find K-th Smallest Pair Distance

[花花酱](https://www.bilibili.com/video/BV1zb411u7iP?spm_id_from=333.999.0.0)

###  1.317. <a name='LongestWordinDictionary'></a>720. Longest Word in Dictionary

[花花酱](https://www.bilibili.com/video/BV1vW411r75D?spm_id_from=333.999.0.0)

###  1.318. <a name='FindPivotIndex'></a>724. Find Pivot Index

[花花酱](https://www.bilibili.com/video/BV1KW411S7nG?spm_id_from=333.999.0.0)

###  1.319. <a name='SplitLinkedListinParts'></a>725. Split Linked List in Parts

[花花酱](https://www.bilibili.com/video/BV1KW411S7ti?spm_id_from=333.999.0.0)

###  1.320. <a name='NumberofAtoms'></a>726. Number of Atoms

[花花酱](https://www.bilibili.com/video/BV11W411U7KT?spm_id_from=333.999.0.0)

###  1.321. <a name='CountDifferentPalindromicSubsequences'></a>730. Count Different Palindromic Subsequences

[花花酱](https://www.bilibili.com/video/BV12W41167vQ?spm_id_from=333.999.0.0)

###  1.322. <a name='MyCalendarIII'></a>732. My Calendar III

[花花酱](https://www.bilibili.com/video/BV1fW411k75b?spm_id_from=333.999.0.0)

###  1.323. <a name='FloodFill'></a>733. 图像渲染 Flood Fill

[花花酱](https://www.bilibili.com/video/BV1yW41167S4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fp4y1v7Pn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1p7vH?spm_id_from=333.999.0.0)

```py
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        currColor = image[sr][sc]
        if currColor == newColor:
            return image
        
        n, m = len(image), len(image[0])
        que = collections.deque([(sr, sc)])
        image[sr][sc] = newColor
        while que:
            x, y = que.popleft()
            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:
                    que.append((mx, my))
                    image[mx][my] = newColor
        
        return image

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        n, m = len(image), len(image[0])
        currColor = image[sr][sc]

        def dfs(x: int, y: int):
            if image[x][y] == currColor:
                image[x][y] = newColor
                for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                    if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:
                        dfs(mx, my)

        if currColor != newColor:
            dfs(sr, sc)
        return image

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python :深度优先搜索+递归；注意测试里面有一组比较恶心，就是初始位置的颜色如果和newcolor 一样，就不对image进行操作，直接反回image

class Solution(object):
    def floodFill(self, image, sr, sc, newColor):
        """
        :type image: List[List[int]]
        :type sr: int
        :type sc: int
        :type newColor: int
        :rtype: List[List[int]]
        """
        #up\down\left\right = u\p\l\r
        color = image[sr][sc]
        row = len(image) #行数
        col = len(image[0]) #列数
        if color == newColor:
            #测试试例比较恶心：image = [[0,0,0],[0,1,1]]; sr=1;sc=1;newColor=1
            return image 

        def DFS(r,c):#深度优先搜索函数，用于递归
            if image[r][c] == color:
                image[r][c] = newColor
                if r-1>=0 :
                    DFS(r-1,c)
                if r+1<row:
                    DFS(r+1,c)
                if c-1>=0:
                    DFS(r,c-1)
                if c+1<col:
                    DFS(r,c+1)
        
        DFS(sr,sc)
        return image
```

###  1.324. <a name='AsteroidCollision'></a>735 Asteroid Collision

[小明](https://www.bilibili.com/video/BV1jT4y1F76n?spm_id_from=333.999.0.0)

###  1.325. <a name='SentenceSimilarityII'></a>737. Sentence Similarity II

[花花酱](https://www.bilibili.com/video/BV1qW41167iB?spm_id_from=333.999.0.0)

###  1.326. <a name='DailyTemperatures'></a>739-Daily Temperatures

[哈哈哈](https://www.bilibili.com/video/BV1Q7411L7w8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ov411z7rM?spm_id_from=333.999.0.0)

```py
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        ans, nxt, big = [0] * n, dict(), 10**9
        for i in range(n - 1, -1, -1):
            warmer_index = min(nxt.get(t, big) for t in range(temperatures[i] + 1, 102))
            if warmer_index != big:
                ans[i] = warmer_index - i
            nxt[temperatures[i]] = i
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        length = len(temperatures)
        ans = [0] * length
        stack = []
        for i in range(length):
            temperature = temperatures[i]
            while stack and temperature > temperatures[stack[-1]]:
                prev_index = stack.pop()
                ans[prev_index] = i - prev_index
            stack.append(i)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

这种题我始终更喜欢KMP，空间复杂度更低哟

时间复杂度O(n)

空间复杂度O(1)

该思路由KMP中失配数组的构造演变而来。假设ans[i]记录了i位置上的答案（向右找多少个比自己大），则求ans[i]时，我先看一眼i+1位置，如果T[i+1]比我大，那得了，答案就是它了。

否则我要找的位置至少是比T[i+1]大，那么当然我就看一看ans[i+1]

class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        n=len(T)
        ans=[0]*n
        for i in range(n-2,-1,-1):
            now=i+1
            while T[now]<=T[i]:
                if ans[now]:
                    now+=ans[now]
                else:
                    break
            else:
                ans[i]=now-i
        return ans
```

```py
维护递减栈，后入栈的元素总比栈顶元素小。

比对当前元素与栈顶元素的大小
若当前元素 < 栈顶元素：入栈
若当前元素 > 栈顶元素：弹出栈顶元素，记录两者下标差值即为所求天数
这里用栈记录的是 T 的下标。

class Solution(object):
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        stack = list()
        t_length = len(T)
        res_list = [0 for _ in range(t_length)]
        
        for key, value in enumerate(T):     
            if stack:
                while stack and T[stack[-1]] < value:
                    res_list[stack[-1]] = key - stack[-1]
                    stack.pop()
            stack.append(key)
        return res_list

Python：

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        answer = [0]*len(temperatures)
        stack = [0]
        for i in range(1,len(temperatures)):
            # 情况一和情况二
            if temperatures[i]<=temperatures[stack[-1]]:
                stack.append(i)
            # 情况三
            else:
                while len(stack) != 0 and temperatures[i]>temperatures[stack[-1]]:
                    answer[stack[-1]]=i-stack[-1]
                    stack.pop()
                stack.append(i)
            
        return answer
```

###  1.327. <a name='DeleteandEarn'></a>740. Delete and Earn

[24:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1xW41167b5?spm_id_from=333.999.0.0)

```py
# 动态规划。
from collections import Counter
class Solution:
    def deleteAndEarn(self, nums):
        # 统计每个数字出现的次数、去重、排序
        dic = Counter(nums)
        nums = list(set(nums))
        nums.sort()
        
        # dp[i][0]: nums[0：i+1]中，不删除nums[i]所能获得的最大点数
        # dp[i][1]: 删除nums[i]所能获得的最大点数和
        dp = [[0 for i in range(2)] for _ in range(len(nums))]
        dp[0][0] = 0
        dp[0][1] = nums[0] * dic[nums[0]]

        for i in range(1, len(dp)):
            if nums[i] - nums[i-1] == 1:
                # 与上一元素相差1，则删除nums[i]的情况dp[i][1]，依赖于不删除nums[i-1]的情况，即dp[i-1][0]。
                dp[i][1] = dp[i-1][0] + nums[i] * dic[nums[i]]
            else:
                # 上一元素是否删除，与当前状态无关，选取前一状态获得的最大点数。
                dp[i][1] = max(dp[i-1][0],dp[i-1][1]) + nums[i] * dic[nums[i]]
            # 不删除当前元素，直接取前一状态的最大值。
            dp[i][0] = max(dp[i-1][0],dp[i-1][1])
        
        return max(dp[-1])

# 次数统计 + 动态规划
from collections import Counter
class Solution:
    def deleteAndEarn(self, nums):
        count = Counter(nums)
        tmp = sorted(count)
        n = len(tmp)
        dp = [0]*(1+n) # dp[i] 表示的是在[tmp[0],...tmp[i-1]]能获得的最大点数
        dp[1] = tmp[0] * count[tmp[0]]

        for i in range(2, 1+n):
            dp[i] = max(dp[i-1], dp[i-2] + tmp[i-1] * count[tmp[i-1]])
            if tmp[i-1] - tmp[i-2] > 1:
                dp[i] = max(dp[i], dp[i-1] + tmp[i-1] * count[tmp[i-1]])
        
        return dp[-1]

# 先排序，后 DP

class Solution:
    def deleteAndEarn(self, nums):
        nums.sort()
        # dp[0] 表示当前数不选，dp[1] 表示当前数选。从第一个数向后辗转递推
        dp = [0, nums[0]]
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                # 如果当前数和前一个数相等，则在前一个被选择的条件下，再选当前数。
                dp[1] += nums[i]
            elif nums[i] == nums[i - 1] + 1:
                # 如果当前数和前一个数相差 1，则一种情况是前一个数没选的条件下，选择当前数；
                # 或者在前一个数被选择的条件下，舍弃掉当前数
                temp = dp[0]
                dp[0] = max(dp)  # 舍弃掉当前数
                dp[1] = temp + nums[i]  # 选择当前数
            else:
                # 如果当前数和前一个数相差大于 1，则一种情况是前一个数已选的条件下，舍弃当前数
                # 第二种情况是，前一个数已选的条件下，选择当前数；
                # 第三种情况是，前一个数未选的条件下，选择当前数；（该情况必然非最大，不用考虑）
                # 第四种情况是，前一个数未选的条件下，舍弃当前数；（同上，非最大，不用考虑）
                dp[0] = max(dp)
                dp[1] = dp[0] + nums[i]
        return max(dp)

# 让我们一起来帮助撬家人，然后用获得的点数去超商买些好吃的

class Solution:
    def deleteAndEarn(self, nums):
        max_num = max(nums)
        table = [0]*(max_num+1)
        for i in nums:
            table[i] += 1

        # dp[i][0]和dp[i][1]分别表示第i个数不选和选的最大所得
        # dp = [[0]*2 for _ in range(max_num+1)]

        # for i in range(1,max_num+1):
        #     dp[i][0] = max(dp[i-1][0],dp[i-1][1])
        #     # 选择第i个数 第i-1个数一定不选而且可以选走所有的i  
        #     dp[i][1] = dp[i-1][0] + i*table[i]

        # 优化一下空间
        dp_0,dp_1 = 0,0
        for i in range(1,max_num+1):
            dp_0,dp_1 = max(dp_0,dp_1),dp_0+i*table[i]
            
        return max(dp_0,dp_1)

class Solution(object):
    def deleteAndEarn(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [0] * 10001
        for num in nums:
            dp[num] += num
        for i in range(2, 10001):
            dp[i] = max(dp[i]+dp[i-2], dp[i-1])
        return dp[-1]
```

###  1.328. <a name='CherryPickup'></a>741. Cherry Pickup

[花花酱](https://www.bilibili.com/video/BV1tW41167jy?spm_id_from=333.999.0.0)

###  1.329. <a name='NetworkDelayTime'></a>743. Network Delay Time

[花花酱](https://www.bilibili.com/video/BV1UW411r7S8?spm_id_from=333.999.0.0)

###  1.330. <a name='PrefixandSuffixSearch'></a>745. Prefix and Suffix Search

[花花酱](https://www.bilibili.com/video/BV1TW411k7PY?spm_id_from=333.999.0.0)

###  1.331. <a name='MinCostClimbingStairs'></a>746. Min Cost Climbing Stairs

[7:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1VW411y7Dq?spm_id_from=333.999.0.0)

```py
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp = [0] * (n + 1)
        for i in range(2, n + 1):
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        return dp[n]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        prev = curr = 0
        for i in range(2, n + 1):
            nxt = min(curr + cost[i - 1], prev + cost[i - 2])
            prev, curr = curr, nxt
        return curr

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

直接在原数组上修改就可以了

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        for i in range(2, len(cost)):
            cost[i] += min(cost[i-1], cost[i-2])
        return min(cost[-1], cost[-2])
```

```py

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost))
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, len(cost)):
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
        return min(dp[len(cost) - 1], dp[len(cost) - 2])
```

###  1.332. <a name='ShortestCompletingWord'></a>748. Shortest Completing Word

[花花酱](https://www.bilibili.com/video/BV15W411y7sJ?spm_id_from=333.999.0.0)

###  1.333. <a name='OpentheLock'></a>752. Open the Lock

[花花酱](https://www.bilibili.com/video/BV1NW411y74z?spm_id_from=333.999.0.0)

###  1.334. <a name='PartitionLabels'></a>763 Partition Labels

[小明](https://www.bilibili.com/video/BV1Ca4y177LW?spm_id_from=333.999.0.0)

###  1.335. <a name='CouplesHoldingHands'></a>765. 情侣牵手 Couples Holding Hands

[官方](https://www.bilibili.com/video/BV1pv411Y7wX?spm_id_from=333.999.0.0)

###  1.336. <a name='MaxChunksToMakeSorted'></a>769. Max Chunks To Make Sorted

[花花酱](https://www.bilibili.com/video/BV1LW411C7nD?spm_id_from=333.999.0.0)

###  1.337. <a name='JewelsandStones'></a>771 Jewels and Stones

[小明](https://www.bilibili.com/video/BV1RC4y1W7yH?spm_id_from=333.999.0.0)

###  1.338. <a name='SlidingPuzzle'></a>773. Sliding Puzzle

[花花酱](https://www.bilibili.com/video/BV1PW411o7g4?spm_id_from=333.999.0.0)

###  1.339. <a name='GlobalandLocalInversions'></a>775. Global and Local Inversions

[花花酱](https://www.bilibili.com/video/BV1JW411d75t?spm_id_from=333.999.0.0)

### 777

```py
# LR不能互相穿过
# R只能右移
# L只能左移
class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        # -----------去掉X,两个字符串应该相等-----------
        s = start.replace('X','')
        if s != end.replace('X',''):
            return False
        # -----------去掉X,两个字符串应该相等-----------

        # start中R的索引要小于等于end的
        # start中L的索引要大于等于end的
        d1 = [index for index,char in enumerate(start) if char !='X']
        d2 = [index for index,char in enumerate(end) if char !='X']


        for index,char in enumerate(s):
            # R 则start大于end的都是False
            if char == 'R' and d1[index] > d2[index]:
                return False
            if char == 'L' and d1[index] < d2[index]:
                return False

        return True

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        start = [(index, char) for index, char in enumerate(start) if char in ["L", "R"]]
        end = [(index, char) for index, char in enumerate(end) if char in ["L", "R"]]
        return len(start) == len(end) and all(c1 == c2 == "L" and i1 >= i2 or c1 == c2 == "R" and i1 <= i2 for (i1, c1), (i2, c2) in zip(start, end))

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        start_id = []
        print("enumerate: ", list(enumerate(start)))
        for i, c in enumerate(start):
            if c in ['L', 'R']:
                start_id.append((i, c))
                
        end_id = []
        for i, c in enumerate(end):
            if c in ['L', 'R']:
                end_id.append((i, c))
                
        if len(start_id) != len(end_id):
            return False
        
        for (i1, c1), (i2, c2) in zip(start_id, end_id):
            print("list(zipped): ",list(zip(start_id, end_id)))
            if c1 != c2:
                return False
            if c1 == c2 == 'L' and i1 < i2:
                return False
            if c1 == c2 == 'R' and i1 > i2:
                return False
        return True

class Solution:
    def canTransform(self, start, end):
        judge = lambda idxStart,idxEnd,f : len(idxStart)==len(idxEnd) and all(f(x,y) for x,y in zip(idxStart,idxEnd)) # f(x,y)是 lambda x,y
        # start和end 长度相等，且不能有 false
        # 如果满足if条件，则返回i
        gen = lambda string,char : [i for i in string if i in char] # char是'LR'
        # 如果满足if条件，则返回i
        genIdx = lambda string,char : [i for i in range(len(string)) if string[i] in char] # char是'L'或者 'R'
        return len(start)==len(end) and\
               gen(start,'LR')==gen(end,'LR') and \
               judge(genIdx(start,'L'),genIdx(end,'L'),lambda x,y:x>=y) and\
               judge(genIdx(start,'R'),genIdx(end,'R'),lambda x,y:x<=y)
```

###  1.340. <a name='SwiminRisingWater'></a>778. Swim in Rising Water

[花花酱](https://www.bilibili.com/video/BV1ab411k7TH?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kv4y1f7to?spm_id_from=333.999.0.0)

```py
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        #两点的边长为两点中最大的高度。建立一个边长集合，升序排序。
        n=len(grid)
        edges=[]
        for i in range(n):
            for j in range(n):
                p = i*n+j
                if i<n-1:
                    edges.append([max(grid[i][j],grid[i+1][j]),p,p+n])
                if j<n-1:
                    edges.append([max(grid[i][j],grid[i][j+1]),p,p+1])
        edges.sort()
        
        #并查集初始化
        father={i:i for i in range(n*n)}
        def find(x):
            if x!=father[x]:
                father[x]=find(father[x])
            return father[x]
        def union(x,y):
            a=find(x)
            b=find(y)
            father[a]=b
        
        #从小到大遍历加入每一条边，如果加入一条边后，首尾联通，那么返回加入的边长
        for edge in edges:
            union(edge[1],edge[2])
            if find(0)==find((n*n)-1):
                return edge[0]
        
        return 0
```

```py
可以说和昨天的一模一样

class Solution:
    def init_tree(self, n):
        self.fa = [i for i in range(n)]
    
    def find(self, x):
        r = x
        while self.fa[r] != r:
            r = self.fa[r]
        while self.fa[x] != x:
            temp = self.fa[x]
            self.fa[x] = r
            x = temp
        return r

    def union(self, x1, x2):
        r1 = self.find(x1)
        r2 = self.find(x2)
        if r1 == r2: return False
        self.fa[r1] = r2
        return True

    def swimInWater(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        self.init_tree(m * n)
        
        edges = []
        for i in range(m):
            for j in range(n):
                id = i*n + j
                if i > 0:
                    edges.append((id - n, id, max(grid[i - 1][j], grid[i][j])))
                if j > 0:
                    edges.append((id - 1, id, max(grid[i][j - 1], grid[i][j])))
        
        edges.sort(key=lambda x:x[2], reverse=False)

        for a, b, level in edges:
            self.union(a, b)
            if self.find(0) == self.find(m*n - 1):
                return level
```

###  1.341. <a name='LetterCasePermutation'></a>784. Letter Case Permutation

[花花酱](https://www.bilibili.com/video/BV1wW411o7WK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sv411a7Gx?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def letterCasePermutation(self, S):
        ans = [[]]

        for char in S:
            n = len(ans)
            if char.isalpha():
                for i in xrange(n):
                    ans.append(ans[i][:])
                    ans[i].append(char.lower())
                    ans[n+i].append(char.upper())
            else:
                for i in xrange(n):
                    ans[i].append(char)

        return map("".join, ans)

作者：LeetCode
链接：https://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def letterCasePermutation(self, S):
        B = sum(letter.isalpha() for letter in S)
        ans = []

        for bits in xrange(1 << B):
            b = 0
            word = []
            for letter in S:
                if letter.isalpha():
                    if (bits >> b) & 1:
                        word.append(letter.lower())
                    else:
                        word.append(letter.upper())

                    b += 1
                else:
                    word.append(letter)

            ans.append("".join(word))
        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

from typing import List
from itertools import product

# S 的长度不超过12。


class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        available = [set([char.lower(), char.upper()]) for char in s]
        return [''.join(t) for t in product(*available)]
class Solution(object):
    def letterCasePermutation(self, S):
        f = lambda x: (x.lower(), x.upper()) if x.isalpha() else x
        return map("".join, itertools.product(*map(f, S)))

作者：LeetCode
链接：https://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

BitMap Bitmap法，字符串S的长度为l， 则总共会有 2** l种结果，换成二进制就是0 ~ 2 **l - 1个数，
对于每个数，如果某个位上是0， 就放小写；是1， 就放大写。

class Solution(object):
    def letterCasePermutation(self, S):
        l = len(S)
        n = 2 ** l
        res = list()
        if l == 0:
            res.append("")
        for i in range(0, n): #得到0 ~ 2 ** l 的每个数
            temp = ""

            for j in range(0, l):
                if ((2 ** j) &i) == 0:#当前位是0， 放小写
                    temp += S[j].lower()
                else: #放大写
                    temp += S[j].upper()
            if temp not in res:
                res.append(temp)
        return res

以前竟然还没写出来，今天随机到这一题，报仇雪恨了，其实很简单啊，不信你看，击败98%

class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        res = ['']
        for c in s:
            if c in 'abcdefghijkmlnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
                res = [r+c.lower() for r in res] + [r+c.upper() for r in res]
            else:
                res = [r+c for r in res]
        return res

这不比官方的好懂

def letterCasePermutation(s):
    result = [s]
    for i in range(len(s)):
        if s[i]>='a' and s[i]<='z':  
            length = len(result)  # 遍历到length，就是上一个字符串对应的长度
            for j in range(length):
                result.append(result[j][0:i]+s[i].upper()+result[j][i+1:])
        elif s[i]>='A' and s[i]<='Z':
            length = len(result)
            for j in range(length):
                result.append(result[j][0:i]+s[i].lower()+result[j][i+1:])
    return result
```

```py

```

###  1.342. <a name='-1'></a>785-判断二分图

[哈哈哈](https://www.bilibili.com/video/BV1KQ4y1N72Z?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11r4y1P7Wr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1254y1i7Ut?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        UNCOLORED, RED, GREEN = 0, 1, 2
        color = [UNCOLORED] * n
        valid = True

        def dfs(node: int, c: int):
            nonlocal valid
            color[node] = c
            cNei = (GREEN if c == RED else RED)
            for neighbor in graph[node]:
                if color[neighbor] == UNCOLORED:
                    dfs(neighbor, cNei)
                    if not valid:
                        return
                elif color[neighbor] != cNei:
                    valid = False
                    return

        for i in range(n):
            if color[i] == UNCOLORED:
                dfs(i, RED)
                if not valid:
                    break
        
        return valid


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        UNCOLORED, RED, GREEN = 0, 1, 2
        color = [UNCOLORED] * n
        
        for i in range(n):
            if color[i] == UNCOLORED:
                q = collections.deque([i])
                color[i] = RED
                while q:
                    node = q.popleft()
                    cNei = (GREEN if color[node] == RED else RED)
                    for neighbor in graph[node]:
                        if color[neighbor] == UNCOLORED:
                            q.append(neighbor)
                            color[neighbor] = cNei
                        elif color[neighbor] != cNei:
                            return False

        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
visited -1没访问过 0 1代表color

DFS版本

class Solution(object):
    def isBipartite(self, graph):
        """
        :type graph: List[List[int]]
        :rtype: bool
        """
        n = len(graph)
        visited = [-1] * n
        for i in range(n):
            if visited[i] == -1:
                if not self.dfs(graph, i, 0, visited):
                    return False
        return True

    def dfs(self, graph, v, color, visited):
        visited[v] = color
        for i in graph[v]:
            if visited[i] == -1:
                if not self.dfs(graph, i, 1 - color, visited):
                    return False
            elif visited[i] == color:
                return False
        return True
BFS版本

class Solution(object):
    def isBipartite(self, graph):
        n = len(graph)
        visited = [-1] * n
        for i in range(n):
            if visited[i] == -1:
                if not self.bfs(graph, i, 0, visited):
                    return False
        return True

    def bfs(self, graph, v, color, visited):
        visited[v], queue = color, [v]
        while queue:
            node = queue.pop(0)
            for i in graph[node]:
                if visited[i] == -1:
                    visited[i] = 1 - visited[node]
                    queue.append(i)
                elif visited[i] == visited[node]:
                    return False
        return True
```

###  1.343. <a name='K-thSmallestPrimeFraction'></a>786. K-th Smallest Prime Fraction

[花花酱](https://www.bilibili.com/video/BV1AW411o7oi?spm_id_from=333.999.0.0)

###  1.344. <a name='CheapestFlightsWithinKStops'></a>787. Cheapest Flights Within K Stops

[花花酱](https://www.bilibili.com/video/BV13W411o7wc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DZ4y1H7oH?spm_id_from=333.999.0.0)

```py
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        f = [[float("inf")] * n for _ in range(k + 2)]
        f[0][src] = 0
        for t in range(1, k + 2):
            for j, i, cost in flights:
                f[t][i] = min(f[t][i], f[t - 1][j] + cost)
        
        ans = min(f[t][dst] for t in range(1, k + 2))
        return -1 if ans == float("inf") else ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/solution/k-zhan-zhong-zhuan-nei-zui-bian-yi-de-ha-abzi/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        f = [float("inf")] * n
        f[src] = 0
        ans = float("inf")
        for t in range(1, k + 2):
            g = [float("inf")] * n
            for j, i, cost in flights:
                g[i] = min(g[i], f[j] + cost)
            f = g
            ans = min(ans, f[dst])
        
        return -1 if ans == float("inf") else ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/solution/k-zhan-zhong-zhuan-nei-zui-bian-yi-de-ha-abzi/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
py 动态规划

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        dp = [float('inf') for _ in range(n)]
        dp[src] = 0
        for i in range(K+1):
            tmp = dp[:]
            for u, v, w in flights:
                dp[v] = min(dp[v],tmp[u]+w)
        return dp[dst] if dp[dst] != float('inf') else -1
堆

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        if src == dst: return 0
        graph = collections.defaultdict(dict)
        for start,end,cost in flights:
            graph[start][end] = cost

        queue = [(0,0,src)]
        while queue:
            cost, k, end = heapq.heappop(queue)
            if k > K+1 : continue
            if end == dst: return cost
            for key, val in graph[end].items():
                heapq.heappush(queue,(cost+val,k+1,key))
        return -1

class Solution:
    # Dijkstra+剪枝
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        if src == dst:
            return 0
        graph = collections.defaultdict(list)
        for f, t, p in flights:
            graph[f].append((t, p))
        dist = {src: 0}
        queue = [(0, src, 0)]
        while queue:
            price, vertex, interval = queue.pop(0)
            if interval > k:
                break
            for node, p in graph[vertex]:
                if price + p < dist.get(node, float("inf")):
                    dist[node] = price + p
                    queue.append((price + p, node, interval + 1))
        return -1 if dist.get(dst, float("inf")) == float("inf") else dist[dst]

作者：loyair
链接：https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/solution/787-k-zhan-zhong-zhuan-nei-zui-bian-yi-d-4q8e/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


###  1.345. <a name='DominoandTrominoTiling'></a>790. Domino and Tromino Tiling

[花花酱](https://www.bilibili.com/video/BV13W411o7AW?spm_id_from=333.999.0.0)

###  1.346. <a name='NumberofMatchingSubsequences'></a>792. Number of Matching Subsequences

[花花酱](https://www.bilibili.com/video/BV13W411o7Af?spm_id_from=333.999.0.0)

###  1.347. <a name='AllPathsFromSourcetoTarget'></a>797 All Paths From Source to Target

[小明](https://www.bilibili.com/video/BV1qa4y1E7sg?spm_id_from=333.999.0.0)

###  1.348. <a name='ChampagneTower'></a>799 Champagne Tower

[小明](https://www.bilibili.com/video/BV1Da411A7u5?spm_id_from=333.999.0.0)

###  1.349. <a name='MinimumSwapsToMakeSequencesIncreasing'></a>801. Minimum Swaps To Make Sequences Increasing

[花花酱](https://www.bilibili.com/video/BV1FW411o7tL?spm_id_from=333.999.0.0) 

###  1.350. <a name='BricksFallingWhenHit'></a>803. Bricks Falling When Hit 

[花花酱](https://www.bilibili.com/video/BV13W411o7kA?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xv411W74B?spm_id_from=333.999.0.0)

```py
class Solution:
    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:
        def getSit2Idx(n, x, y):
            return x * n + y

        m, n = len(grid), len(grid[0])
        size = m * n
        u = self.UnionFind(size + 1)
        tmp = copy.deepcopy(grid)

        for x, y in hits:
            tmp[x][y] = 0

        for column in range(n):
            if tmp[0][column] == 1:
                u.union(column, size)
        
        for row in range(1, m):
            for column in range(n):
                if tmp[row][column] == 1:
                    if row - 1 >= 0 and tmp[row - 1][column] == 1:
                        u.union(getSit2Idx(n, row - 1, column), getSit2Idx(n, row, column))
                    if column - 1 >= 0 and tmp[row][column - 1] == 1:
                        u.union(getSit2Idx(n, row, column - 1), getSit2Idx(n, row, column))

        dx, dy, ans = [0, 0, -1, 1], [-1, 1, 0, 0], []
        for x, y in hits[::-1]:
            if grid[x][y] == 0: 
                ans.insert(0, 0)
                continue
            original = u.getSize(size)
            if x == 0: u.union(y, size)
            for i in range(4):
                offsetX, offsetY = x + dx[i], y + dy[i]
                if 0 <= offsetX < m and 0 <= offsetY < n and tmp[offsetX][offsetY]:
                    a, b = getSit2Idx(n, x, y), getSit2Idx(n, offsetX, offsetY)
                    u.union(a, b)
            current = u.getSize(size)
            ans.insert(0, max(0, current - original - 1))
            tmp[x][y] = 1
        return ans

    class UnionFind:
        def __init__(self, n):
            self.parents = {}
            self.total = [1 for _ in range(n)]
            for i in range(n):
                self.parents[i] = i

        
        def find(self, x):
            original = self.parents[x]
            if original != x:
                original = self.find(original)
                self.parents[x] = original
            return original


        def union(self, x, y):
            rootX, rootY = self.find(x), self.find(y)
            if rootX != rootY:
                self.parents[rootX] = self.parents[rootY]
                self.total[rootY] += self.total[rootX]

        
        def getSize(self, idx):
            return self.total[self.find(idx)]
```

```py

```

###  1.351. <a name='UniqueMorseCodeWords'></a>804 Unique Morse Code Words

[小明](https://www.bilibili.com/video/BV1RD4y1Q7AM?spm_id_from=333.999.0.0)

###  1.352. <a name='LargestSumofAverages'></a>813. Largest Sum of Averages

[花花酱](https://www.bilibili.com/video/BV1XW411d7RB?spm_id_from=333.999.0.0)

###  1.353. <a name='BusRoutes'></a>815. Bus Routes

[花花酱](https://www.bilibili.com/video/BV1QW411d794?spm_id_from=333.999.0.0)

###  1.354. <a name='LinkedListComponents'></a>817. Linked List Components

[花花酱](https://www.bilibili.com/video/BV1cW411o7Eu?spm_id_from=333.999.0.0)

###  1.355. <a name='RaceCar'></a>818. Race Car (上)

[花花酱](https://www.bilibili.com/video/BV1cW411o7Tb?spm_id_from=333.999.0.0)

###  1.356. <a name='ShortestDistancetoaCharacter'></a>821 Shortest Distance to a Character

[小明](https://www.bilibili.com/video/BV1gy4y1Y784?spm_id_from=333.999.0.0)

###  1.357. <a name='BinaryTreesWithFactors'></a>823. Binary Trees With Factors

[花花酱](https://www.bilibili.com/video/BV1CW411d7RX?spm_id_from=333.999.0.0)

###  1.358. <a name='GoatLatin'></a>824 Goat Latin

[小明](https://www.bilibili.com/video/BV1Th411o782?spm_id_from=333.999.0.0)

###  1.359. <a name='MakingALargeIsland'></a>827. Making A Large Island

[花花酱](https://www.bilibili.com/video/BV1mW411d7rc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Cg4117727?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def largestIsland(self, grid):
        N = len(grid)

        def check(r, c):
            seen = {(r, c)}
            stack = [(r, c)]
            while stack:
                r, c = stack.pop()
                for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):
                    if (nr, nc) not in seen and 0 <= nr < N and 0 <= nc < N and grid[nr][nc]:
                        stack.append((nr, nc))
                        seen.add((nr, nc))
            return len(seen)

        ans = 0
        has_zero = False
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == 0:
                    has_zero = True
                    grid[r][c] = 1
                    ans = max(ans, check(r, c))
                    grid[r][c] = 0

        return ans if has_zero else N*N

作者：LeetCode
链接：https://leetcode-cn.com/problems/making-a-large-island/solution/zui-da-ren-gong-dao-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def largestIsland(self, grid):
        N = len(grid)

        def neighbors(r, c):
            for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if 0 <= nr < N and 0 <= nc < N:
                    yield nr, nc

        def dfs(r, c, index):
            ans = 1
            grid[r][c] = index
            for nr, nc in neighbors(r, c):
                if grid[nr][nc] == 1:
                    ans += dfs(nr, nc, index)
            return ans

        area = {}
        index = 2
        for r in xrange(N):
            for c in xrange(N):
                if grid[r][c] == 1:
                    area[index] = dfs(r, c, index)
                    index += 1

        ans = max(area.values() or [0])
        for r in xrange(N):
            for c in xrange(N):
                if grid[r][c] == 0:
                    seen = {grid[nr][nc] for nr, nc in neighbors(r, c) if grid[nr][nc] > 1}
                    ans = max(ans, 1 + sum(area[i] for i in seen))
        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/making-a-large-island/solution/zui-da-ren-gong-dao-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py

```

###  1.360. <a name='FlippinganImage'></a>832 Flipping an Image

[小明](https://www.bilibili.com/video/BV1q54y1r7f3?spm_id_from=333.999.0.0)

###  1.361. <a name='ImageOverlap'></a>835 Image Overlap

[小明](https://www.bilibili.com/video/BV1NK4y1a7Yf?spm_id_from=333.999.0.0)

###  1.362. <a name='New21Game'></a>837. 新 21 点 New 21 Game

[官方](https://www.bilibili.com/video/BV1Sz4y197cA?spm_id_from=333.999.0.0)

###  1.363. <a name='KeysandRooms'></a>841 Keys and Rooms

[小明](https://www.bilibili.com/video/BV1Wb4y1Q7hE?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1HK411F7JQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        def dfs(x: int):
            vis.add(x)
            nonlocal num
            num += 1
            for it in rooms[x]:
                if it not in vis:
                    dfs(it)
        
        n = len(rooms)
        num = 0
        vis = set()
        dfs(0)
        return num == n

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        num = 0
        vis = {0}
        que = collections.deque([0])

        while que:
            x = que.popleft()
            num += 1
            for it in rooms[x]:
                if it not in vis:
                    vis.add(it)
                    que.append(it)
        
        return num == n

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

DFS可以用栈实现。

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        cnt = len(rooms)
        seen = [False] * cnt
        stack = [0, ]
        while stack:
            nxt = stack.pop()
            if not seen[nxt]:
                seen[nxt] = True
                cnt -= 1
                stack.extend(rooms[nxt])
        return cnt == 0
```

```py
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        vis = [False] * n
        def dfs(st):
            vis[st] = True
            for ano in rooms[st]:
                if not vis[ano]:
                    dfs(ano)
        dfs(0)
        return all(vis)
dfs

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        vst = set()
        def f(key):
            vst.add(key)
            [f(k) for k in rooms[key] if k not in vst]
        return f(0) or len(vst) == len(rooms)
bfs

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        que, vst = [0], {0}
        for key in que:
            for k in filter(lambda k: k not in vst, rooms[key]):
                que += [k]
                vst |= {k}
        return len(vst) == len(rooms)
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        keys = [0]*len(rooms)
        def dfs(i):
            keys[i] = 1
            [dfs(key) for key in rooms[i] if keys[key]==0]
        dfs(0)
        return all(i==1 for i in keys)


class Solution:

    def dfs(self, key: int, rooms: List[List[int]]  , visited : List[bool] ) :
        if visited[key] :
            return

        visited[key] = True
        keys = rooms[key]
        for i in range(len(keys)) :
            # 深度优先搜索遍历
            self.dfs(keys[i], rooms, visited)

    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = [False for i in range(len(rooms))]

        self.dfs(0, rooms, visited)

        # 检查是否都访问到了
        for i in range(len(visited)):
            if not visited[i] :
                return False
        return True

dfs 不需要那个 计数呀

class Solution:
    def canVisitAllRooms(self, rooms):
        def dfs(x: int):
            vis.add(x)
            for it in rooms[x]:
                if it not in vis:
                    dfs(it)
        
        n = len(rooms)
        vis = set()
        dfs(0)
        return len(vis) == n
```

###  1.364. <a name='SplitArrayintoFibonacciSequence'></a>842. Split Array into Fibonacci Sequence

[花花酱](https://www.bilibili.com/video/BV1ZJ411H7t4?spm_id_from=333.999.0.0)

###  1.365. <a name='BackspaceStringCompare'></a>844 Backspace String Compare

[小明](https://www.bilibili.com/video/BV1aC4y1s7LK?spm_id_from=333.999.0.0)

###  1.366. <a name='LongestMountaininArray'></a>845 Longest Mountain in Array

[小明](https://www.bilibili.com/video/BV1zi4y1L7yV?spm_id_from=333.999.0.0)

###  1.367. <a name='ShortestPathVisitingAllNodes'></a>847 Shortest Path Visiting All Nodes

[花花酱](https://www.bilibili.com/video/BV1hW411d7MU?spm_id_from=333.999.0.0)

###  1.368. <a name='MaximizeDistancetoClosestPerson'></a>849 Maximize Distance to Closest Person

[小明](https://www.bilibili.com/video/BV1ZZ4y1G7iT?spm_id_from=333.999.0.0)

###  1.369. <a name='ScoreofParentheses'></a>856. Score of Parentheses

[花花酱](https://www.bilibili.com/video/BV1bW411d7gp?spm_id_from=333.999.0.0)

###  1.370. <a name='MirrorReflection'></a>858 Mirror Reflection

[小明](https://www.bilibili.com/video/BV1av411r7MW?spm_id_from=333.999.0.0)

###  1.371. <a name='BuddyStrings'></a>859 Buddy Strings

[小明](https://www.bilibili.com/video/BV1nz4y1o7Wo?spm_id_from=333.999.0.0)

###  1.372. <a name='AllNodesDistanceKinBinaryTree'></a>863. All Nodes Distance K in Binary Tree

[花花酱](https://www.bilibili.com/video/BV14W411d7mz?spm_id_from=333.999.0.0)

###  1.373. <a name='ShortestPathtoGetAllKeys'></a>864. Shortest Path to Get All Keys

[花花酱](https://www.bilibili.com/video/BV1LW411d7th?spm_id_from=333.999.0.0)

###  1.374. <a name='ReorderedPowerof2'></a>869 Reordered Power of 2

[小明](https://www.bilibili.com/video/BV1M64y1D78v?spm_id_from=333.999.0.0)

###  1.375. <a name='SmallestSubtreewithalltheDeepestNodes'></a>865. Smallest Subtree with all the Deepest Nodes

[花花酱](https://www.bilibili.com/video/BV14W411d7ZR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CV41187ZA?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def subtreeWithAllDeepest(self, root):
        # Tag each node with it's depth.
        depth = {None: -1}
        def dfs(node, parent = None):
            if node:
                depth[node] = depth[parent] + 1
                dfs(node.left, node)
                dfs(node.right, node)
        dfs(root)

        max_depth = max(depth.itervalues())

        def answer(node):
            # Return the answer for the subtree at node.
            if not node or depth.get(node, None) == max_depth:
                return node
            L, R = answer(node.left), answer(node.right)
            return node if L and R else L or R

        return answer(root)

作者：LeetCode
链接：https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/solution/ju-you-suo-you-zui-shen-jie-dian-de-zui-xiao-zi-sh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def subtreeWithAllDeepest(self, root):
        # The result of a subtree is:
        # Result.node: the largest depth node that is equal to or
        #              an ancestor of all the deepest nodes of this subtree.
        # Result.dist: the number of nodes in the path from the root
        #              of this subtree, to the deepest node in this subtree.
        Result = collections.namedtuple("Result", ("node", "dist"))
        def dfs(node):
            # Return the result of the subtree at this node.
            if not node: return Result(None, 0)
            L, R = dfs(node.left), dfs(node.right)
            if L.dist > R.dist: return Result(L.node, L.dist + 1)
            if L.dist < R.dist: return Result(R.node, R.dist + 1)
            return Result(node, L.dist + 1)

        return dfs(root).node

作者：LeetCode
链接：https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/solution/ju-you-suo-you-zui-shen-jie-dian-de-zui-xiao-zi-sh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
一趟dfs

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        def f(t):
            if not t:
                return t, 0
            else:
                x, m = f(t.left)
                y, n = f(t.right)
                if m > n:
                    return x, m + 1
                elif m < n:
                    return y, n + 1
                else:
                    return t, n + 1
        return f(root)[0]
单次dfs

class Solution:
    def dfs(self, root, level):
        if not root: return None, level
        left, llevel = self.dfs(root.left, level+1)
        right, rlevel = self.dfs(root.right, level+1)
        if llevel == rlevel:
            return root, llevel
        if llevel > rlevel:
            return left, llevel
        if llevel < rlevel:
            return right, rlevel


    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        if not root: return None
        ret, level = self.dfs(root, 0)
        return ret
python 比较直观的实现方法，判断节点的左右子树深度是否相同，相同的则为所求的字数：

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        if not root: return root
        def dfs(root):
            if not root: return root
            l = self.max_depth(root.left)
            r = self.max_depth(root.right)
            if l == r: return root
            elif l > r: return dfs(root.left)
            else: return dfs(root.right)
        return dfs(root)
    def max_depth(self, root, layer=1):
        if not root: return layer-1
        return max(self.max_depth(root.left,layer+1), self.max_depth(root.right, layer+1))
```

###  1.376. <a name='MinimumNumberofRefuelingStops'></a>871. Minimum Number of Refueling Stops

[花花酱](https://www.bilibili.com/video/BV1JW411d7VK?spm_id_from=333.999.0.0)

###  1.377. <a name='LengthofLongestFibonacciSubsequence'></a>873. Length of Longest Fibonacci Subsequence

[花花酱](https://www.bilibili.com/video/BV1jW411d79H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ab411i7wx?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def lenLongestFibSubseq(self, A):
        S = set(A)
        ans = 0
        for i in xrange(len(A)):
            for j in xrange(i+1, len(A)):
                """
                With the starting pair (A[i], A[j]),
                y represents the future expected value in
                the fibonacci subsequence, and x represents
                the most current value found.
                """
                x, y = A[j], A[i] + A[j]
                length = 2
                while y in S:
                    x, y = y, x + y
                    length += 1
                ans = max(ans, length)
        return ans if ans >= 3 else 0

作者：LeetCode
链接：https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-chang-du-by/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def lenLongestFibSubseq(self, A):
        index = {x: i for i, x in enumerate(A)}
        longest = collections.defaultdict(lambda: 2)

        ans = 0
        for k, z in enumerate(A):
            for j in xrange(k):
                i = index.get(z - A[j], None)
                if i is not None and i < j:
                    cand = longest[j, k] = longest[i, j] + 1
                    ans = max(ans, cand)

        return ans if ans >= 3 else 0

作者：LeetCode
链接：https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-chang-du-by/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
def lenLongestFibSubseq(self, A):
    """
    :type A: List[int]
    :rtype: int
    """
    dic = {num:[] for num in A}
    head = [(2,num) for num in A]
    size = len(A)
    cnt = 0
    for i,num in enumerate(A):
        cur = dic[num]
        for l,last in head[:i]+cur:
            if l+size-i+1 <= cnt:
                continue
            new = last+num
            if new in dic:
                dic[new].append((l+1,num))
                cnt = max(cnt,l+1)
    return cnt if cnt > 2 else 0
思路：a[i][j]用于记录A[?]+A[i]是否能得到A[j]，如果从来都不行，然后第一次可以，就为3；否则则为a[i][j]+1

class Solution:
    def lenLongestFibSubseq(self, A: List[int]) -> int:
        n, res = len(A), 0
        a = [[0] * n for i in range(n)]
        for i in range(n):
            lo, hi, v = 0, i - 1, A[i]
            while lo < hi:
                if A[lo] + A[hi] < v:
                    lo += 1
                elif A[lo] + A[hi] > v:
                    hi -= 1
                else:
                    if a[lo][hi]:
                        a[hi][i] = a[lo][hi] + 1
                    else:
                        a[hi][i] = 3
                    res = max(a[hi][i], res)
                    lo += 1
                    hi -= 1
        return res
```

###  1.378. <a name='KokoEatingBananas'></a>875.Koko Eating Bananas科科吃香蕉

[图灵](https://www.bilibili.com/video/BV1iV411s7eU?spm_id_from=333.999.0.0)

###  1.379. <a name='MiddleoftheLinkedList'></a>876.Middle of the Linked List 链表的中间结点

[图灵](https://www.bilibili.com/video/BV1Kv411p7vf?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Pz41187WS?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK411T74X?spm_id_from=333.999.0.0)

```py
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        A = [head]
        while A[-1].next:
            A.append(A[-1].next)
        return A[len(A) // 2]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        n, cur = 0, head
        while cur:
            n += 1
            cur = cur.next
        k, cur = 0, head
        while k < n // 2:
            k += 1
            cur = cur.next
        return cur

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python 快慢双指针

class Solution(object):
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow


```

```py
第一种先计数再找中点，第二种快慢指针

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        first = head
        count = 0
        while first != None:
            first = first.next
            count += 1
        second = head
        count = count//2
        while count > 0:
            second = second.next
            count -= 1
        return second
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        first = second = head
        while first != None and first.next != None:
            first = first.next.next
            second = second.next
        return second
```

###  1.380. <a name='StoneGame'></a>877 Stone Game

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Hr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xq4y1Q7uL?spm_id_from=333.999.0.0)

```py
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        length = len(piles)
        dp = [[0] * length for _ in range(length)]
        for i, pile in enumerate(piles):
            dp[i][i] = pile
        for i in range(length - 2, -1, -1):
            for j in range(i + 1, length):
                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])
        return dp[0][length - 1] > 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        length = len(piles)
        dp = [0] * length
        for i, pile in enumerate(piles):
            dp[i] = pile
        for i in range(length - 2, -1, -1):
            for j in range(i + 1, length):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[length - 1] > 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

记忆化递归

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        @cache
        def helper(i, j):
            if i==j: return piles[i]
            return max(piles[i]-helper(i+1, j),
                       piles[j]-helper(i, j-1))
        return helper(0, len(piles)-1)>=0
区间DP

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        N = len(piles)
        f = [[0]*(N+1) for _ in range(N+1)] # 防止出界
        for l in range(N):
            for i in range(N-l):
                j = i+l
                f[i][j] = max(piles[i]-f[i+1][j],
                              piles[j]-f[i][j-1])
        return f[0][N-1]>0
```

```py
反正暴力解过了就行了。

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        @cache
        def max_points(piles, start, end):
            if end - start == 1:
                return max(piles)
            op1 = piles[start] + max_points(piles, start + 2, end)
            op2 = piles[start] + max_points(piles, start + 1, end - 1)
            op3 = piles[end] + max_points(piles, start + 1, end - 1)
            op4 = piles[end] + max_points(piles, start, end - 2)
            return max(op1, op2, op3, op4)
        
        return max_points(tuple(piles), 0, len(piles) - 1) > (sum(piles) / 2)
```

###  1.381. <a name='ProfitableSchemes'></a>879. Profitable Schemes

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Jt?spm_id_from=333.999.0.0)

###  1.382. <a name='DecodedStringatIndex'></a>880 Decoded String at Index

[小明](https://www.bilibili.com/video/BV1Tt4y1k7GJ?spm_id_from=333.999.0.0)

###  1.383. <a name='BoatstoSavePeople'></a>881 Boats to Save People

[小明](https://www.bilibili.com/video/BV1MT4y1K7yq?spm_id_from=333.999.0.0)

###  1.384. <a name='ReachableNodesInSubdividedGraph'></a>882. Reachable Nodes In Subdivided Graph

[花花酱](https://www.bilibili.com/video/BV11W411Z71N?spm_id_from=333.999.0.0)

###  1.385. <a name='PossibleBipartition'></a>886. Possible Bipartition

[花花酱](https://www.bilibili.com/video/BV1DW411Z7G6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FT4y1g77u?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def possibleBipartition(self, N, dislikes):
        graph = collections.defaultdict(list)
        for u, v in dislikes:
            graph[u].append(v)
            graph[v].append(u)

        color = {}
        def dfs(node, c = 0):
            if node in color:
                return color[node] == c
            color[node] = c
            return all(dfs(nei, c ^ 1) for nei in graph[node])

        return all(dfs(node)
                   for node in range(1, N+1)
                   if node not in color)

作者：LeetCode
链接：https://leetcode-cn.com/problems/possible-bipartition/solution/ke-neng-de-er-fen-fa-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
DFS

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        color = [0] * n
        
        def dfs(node, c):
            if color[node] == -c: return False
            if color[node] == c: return True
            color[node] = c
            for neighbor in graph[node]:
                if not dfs(neighbor, -c):
                    return False
            return True
        
        for i in range(n):
            if color[i] == 0 and not dfs(i, 1):
                return False
        return True
BFS

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        teams = [0] * (n + 1)
        graph = collections.defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)

        for i in range(1, n+1):
            if teams[i] == 0:
                teams[i] = 1
                Q = collections.deque([i])
                while Q:
                    p = Q.popleft()
                    for neighbor in graph[p]:
                        if teams[neighbor] == teams[p]: return False
                        elif teams[neighbor] == 0:
                            teams[neighbor] = -teams[p]
                            Q.append(neighbor)
        return True
并查集

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        teams = [0] * (n + 1)
        graph = collections.defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
        parent = list(range(n+1))

        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            parent[find(x)] = parent[find(y)]

        for i in range(1, n+1):
            for j in graph[i]:
                if find(i) == find(j): return False
                union(j, graph[i][0])
        return True
python, 二刷, 图+dfs搜索, 缓存搜索中的分组号, 降低时间复杂度

class Solution:
    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:
        graph = collections.defaultdict(list)   # 刻画a, b两人的关系图, 无向图
        for s, e in dislikes:
            graph[s].append(e)
            graph[e].append(s)
        
        group = dict()

        @functools.lru_cache(None)               # 缓存dfs搜索中间结果, 下次i相同就相当于表查询, 时间复杂度为O(n)
        def dfs(i, g=1):
            if i in group:
                return group[i] == g            # i的组划分,已经判定在了group当中, 所以判断是否矛盾
            group[i] = g                        # 不矛盾的话, 判定给组g
            for con in graph[i]:                # 如果i的邻接节点,都能不矛盾地"安排", 返回true
                if not dfs(con, -1 * g):
                    return False
            return True
        
        for i in range(1, N + 1):
            if i not in group and not dfs(i):   # 此处必须强调i不在group, 因为前面搜索中可能将
                return False                    # i判定给了-1, 但是此时如果再次dfs搜索, 将其默认为1,会矛盾
        return True
```

###  1.386. <a name='SuperEggDrop'></a>887. Super Egg Drop

[花花酱](https://www.bilibili.com/video/BV1Tv411i7cP?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ri4y1t78d?spm_id_from=333.999.0.0)

```py
class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        memo = {}
        def dp(k, n):
            if (k, n) not in memo:
                if n == 0:
                    ans = 0
                elif k == 1:
                    ans = n
                else:
                    lo, hi = 1, n
                    # keep a gap of 2 x values to manually check later
                    while lo + 1 < hi:
                        x = (lo + hi) // 2
                        t1 = dp(k - 1, x - 1)
                        t2 = dp(k, n - x)

                        if t1 < t2:
                            lo = x
                        elif t1 > t2:
                            hi = x
                        else:
                            lo = hi = x

                    ans = 1 + min(max(dp(k - 1, x - 1), dp(k, n - x))
                                  for x in (lo, hi))

                memo[k, n] = ans
            return memo[k, n]

        return dp(k, n)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        # Right now, dp[i] represents dp(1, i)
        dp = list(range(n + 1))
        dp2 = [0] * (n + 1)
        for k in range(2, k + 1):
            # Now, we will develop dp2[i] = dp(j, i)
            x = 1
            for m in range(1, n + 1):
                # Let's find dp2[m] = dp(j, m)
                # Increase our optimal x while we can make our answer better.
                # Notice max(dp[x-1], dp2[m-x]) > max(dp[x], dp2[m-x-1])
                # is simply max(T1(x-1), T2(x-1)) > max(T1(x), T2(x)).
                while x < m and max(dp[x - 1], dp2[m - x]) >= max(dp[x], dp2[m - x - 1]):
                    x += 1

                # The final answer happens at this x.
                dp2[m] = 1 + max(dp[x - 1], dp2[m - x])

            dp = dp2[:]

        return dp[-1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        if n == 1:
            return 1
        f = [[0] * (k + 1) for _ in range(n + 1)]
        for i in range(1, k + 1):
            f[1][i] = 1
        ans = -1
        for i in range(2, n + 1):
            for j in range(1, k + 1):
                f[i][j] = 1 + f[i - 1][j - 1] + f[i - 1][j]
            if f[i][k] >= n:
                ans = i
                break
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


```

```py
dp[k][m] 的含义是k个鸡蛋 移动m次最多能够确定多少楼层
这个角度思考
dp[k][m] 最多能够确定的楼层数为L
那么我选定第一个扔的楼层之后，我要么碎，要么不碎
这就是把L分成3段
左边是碎的那段 长度是dp[k][m - 1]
右边是没碎的那段 长度是dp[k-1][m - 1] 因为已经碎了一个了
中间是我选定扔的楼层 是1
所以递推公式是
dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1
根据递推公式 如果采用k倒着从大到小计算 就可以只存一行的dp[k] 直接原地更新dp[k] 不影响后续计算 只需要O(K)空间复杂度 O(KlogN) 鸡蛋完全够用的时候 就是走LogN步 最差情况是1个鸡蛋走N步 O(KN)

def superEggDrop(self, K: int, N: int) -> int:
        dp = [0] * (K + 1)
        m = 0
        while dp[K] < N:
            m += 1
            for k in range(K, 0, -1):
                # print(m, k)
                dp[k] = dp[k - 1] + dp[k] + 1
        return m
```

###  1.387. <a name='ConstructBinaryTreefromPreorderandPostorder'></a>889. Construct Binary Tree from Preorder and Postorder

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Qi?spm_id_from=333.999.0.0)

###  1.388. <a name='SumofSubsequenceWidths'></a>891. Sum of Subsequence Widths

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Yv?spm_id_from=333.999.0.0)

###  1.389. <a name='AllPossibleFullBinaryTrees'></a>894. All Possible Full Binary Trees

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Sb?spm_id_from=333.999.0.0)

###  1.390. <a name='MaximumFrequencyStack'></a>895. Maximum Frequency Stack

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Hp?spm_id_from=333.999.0.0)

###  1.391. <a name='BitwiseORsofSubarrays'></a>898. Bitwise ORs of Subarrays

[花花酱](https://www.bilibili.com/video/BV1kW411Z7HV?spm_id_from=333.999.0.0)

###  1.392. <a name='OnlineStockSpan'></a>901. Online Stock Span

[花花酱](https://www.bilibili.com/video/BV1kW411k77K?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Jg4y1B74H?spm_id_from=333.999.0.0)

```py
class StockSpanner(object):
    def __init__(self):
        self.stack = []

    def next(self, price):
        weight = 1
        while self.stack and self.stack[-1][0] <= price:
            weight += self.stack.pop()[1]
        self.stack.append((price, weight))
        return weight

作者：LeetCode
链接：https://leetcode-cn.com/problems/online-stock-span/solution/gu-piao-jie-ge-kua-du-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class StockSpanner:

    def __init__(self):
        self.stack = [] # (price, span)

    def next(self, price: int) -> int:
        span = 1
        while self.stack and self.stack[-1][0] <= price:
            span += self.stack.pop()[1]
        self.stack.append((price, span))
        return span
```

```py
class StockSpanner:
    """
    用一个栈来存储过去股票的价格和对应的跨度，
    如果当天的股票价格大于栈顶的股票价格，则出栈，
    将对应的跨度加到今日股票价格的跨度上．
    直到栈顶的股票价格大于当日股票价格，然后将当日股票价格和对应的跨度入栈
    """
    def __init__(self):
        self.his_prices = [(-999, 0)]

    def next(self, price: int) -> int:
        span = 1
        while self.his_prices:
            if self.his_prices[-1][0] <= price:
                span += self.his_prices.pop()[1]
            else:
                break
        self.his_prices.append((price, span))
        return span
```

###  1.393. <a name='NumbersAtMostNGivenDigitSet'></a>902 Numbers At Most N Given Digit Set

[小明](https://www.bilibili.com/video/BV19A411j7Wf?spm_id_from=333.999.0.0)

###  1.394. <a name='-1'></a>904-水果成篮

[哈哈哈](https://www.bilibili.com/video/BV19i4y1M7Xn?spm_id_from=333.999.0.0)

###  1.395. <a name='SortArrayByParity'></a>905 Sort Array By Parity

[小明](https://www.bilibili.com/video/BV1Xk4y117rK?spm_id_from=333.999.0.0)

###  1.396. <a name='SuperPalindromes'></a>906 Super Palindromes

[小明](https://www.bilibili.com/video/BV1LA41157Wf?spm_id_from=333.999.0.0)

###  1.397. <a name='SnakesandLadders'></a>909. Snakes and Ladders

[小梦想家](https://www.bilibili.com/video/BV1cy4y1W7u9?spm_id_from=333.999.0.0)

###  1.398. <a name='SmallestRangeII'></a>910 Smallest Range II

[小明](https://www.bilibili.com/video/BV1p5411H7mS?spm_id_from=333.999.0.0)

###  1.399. <a name='WordSubsetse'></a>916 Word Subsetse

[小明](https://www.bilibili.com/video/BV1vh411S7r3?spm_id_from=333.999.0.0)

###  1.400. <a name='MaximumSumCircularSub'></a>918 Maximum Sum Circular Sub

[小明](https://www.bilibili.com/video/BV1c5411s7jZ?spm_id_from=333.999.0.0)

###  1.401. <a name='SumWithMultiplicity'></a>923. 3Sum With Multiplicity 

[花花酱](https://www.bilibili.com/video/BV14t411o7QT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pv41187sq?spm_id_from=333.999.0.0)

```py
def solve(A, target):
    # Assume A already sorted
    i, j = 0, len(A) - 1
    ans = 0
    while i < j:
        if A[i] + A[j] < target:
            i += 1
        elif A[i] + A[j] > target:
            j -= 1
        else:
            ans += 1
            i += 1
            j -= 1
    return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        ans = 0
        A.sort()

        for i, x in enumerate(A):
            # We'll try to find the number of i < j < k
            # with A[j] + A[k] == T, where T = target - A[i].

            # The below is a "two sum with multiplicity".
            T = target - A[i]
            j, k = i+1, len(A) - 1

            while j < k:
                # These steps proceed as in a typical two-sum.
                if A[j] + A[k] < T:
                    j += 1
                elif A[j] + A[k] > T:
                    k -= 1
                # These steps differ:
                elif A[j] != A[k]: # We have A[j] + A[k] == T.
                    # Let's count "left": the number of A[j] == A[j+1] == A[j+2] == ...
                    # And similarly for "right".
                    left = right = 1
                    while j + 1 < k and A[j] == A[j+1]:
                        left += 1
                        j += 1
                    while k - 1 > j and A[k] == A[k-1]:
                        right += 1
                        k -= 1

                    # We contributed left * right many pairs.
                    ans += left * right
                    ans %= MOD
                    j += 1
                    k -= 1

                else:
                    # M = k - j + 1
                    # We contributed M * (M-1) / 2 pairs.
                    ans += (k-j+1) * (k-j) / 2
                    ans %= MOD
                    break

        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        count = [0] * 101
        for x in A:
            count[x] += 1

        ans = 0

        # All different
        for x in xrange(101):
            for y in xrange(x+1, 101):
                z = target - x - y
                if y < z <= 100:
                    ans += count[x] * count[y] * count[z]
                    ans %= MOD

        # x == y
        for x in xrange(101):
            z = target - 2*x
            if x < z <= 100:
                ans += count[x] * (count[x] - 1) / 2 * count[z]
                ans %= MOD

        # y == z
        for x in xrange(101):
            if (target - x) % 2 == 0:
                y = (target - x) / 2
                if x < y <= 100:
                    ans += count[x] * count[y] * (count[y] - 1) / 2
                    ans %= MOD

        # x == y == z
        if target % 3 == 0:
            x = target / 3
            if 0 <= x <= 100:
                ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6
                ans %= MOD

        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

嗯……数学大法好

from collections import defaultdict
class Solution(object):
    def threeSumMulti(self, A, target):
        """
        :type A: List[int]
        :type target: int
        :rtype: int
        """
        mod = 1000000007
        
        counter = defaultdict(int)
        for n in A:
            counter[n] += 1
        
        ans = 0
        # x != y != z
        for x in xrange(101):
            for y in xrange(x+1, 101):
                z = target - x - y
                if z <= y:
                    continue
                ans += counter[x] * counter[y] * counter[z]
                ans %= mod 
                        
        # x == y != z
        for x in xrange(101):
            z = target - 2*x
            if z == x:
                continue
            ans += counter[x] * (counter[x]-1) * counter[z] / 2
            ans %= mod
            
        if target % 3 == 0:
            x = target / 3
            ans += counter[x] * (counter[x]-1) * (counter[x]-2) / 6
            ans %= mod
            
        return ans
python，数学方法，先把数组储存成字典，如果3个数相同，那么就是Cm3（m是该值的个数，数学里面的排列，不知道怎么调格式），如果有两个数一样，那么就是Cm2*Cn1，如果三个数均不同，那么就是Cm1*Cn1*Ck1


class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        count = collections.Counter(A)
        keys = sorted(count)

        ans = 0

        # Now, let's do a 3sum on "keys", for i <= j <= k.
        # We will use count to add the correct contribution to ans.
        for i, x in enumerate(keys):
            T = target - x
            j, k = i, len(keys) - 1
            while j <= k:
                y, z = keys[j], keys[k]
                if y + z < T:
                    j += 1
                elif y + z > T:
                    k -= 1
                else: # x+y+z == T, now calculate the size of the contribution
                    if i < j < k:
                        ans += count[x] * count[y] * count[z]
                    elif i == j < k:
                        ans += count[x] * (count[x] - 1) / 2 * count[z]
                    elif i < j == k:
                        ans += count[x] * count[y] * (count[y] - 1) / 2
                    else:  # i == j == k
                        ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6

                    j += 1
                    k -= 1

        return ans % MOD

作者：LeetCode
链接：https://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution:
    def threeSumMulti(self, A: List[int], target: int) -> int:
        ans = dict()  #数组转换成字典
        for i,num in enumerate(A):
            ans[num] = ans.get(num,0) + 1
        res = []  #target的可能分解结果
        for i in range(0,target//3+1):
            for j in range(i,target//2+1):
                k = target - i - j
                if k >= j:
                    res.append([i,j,k]) 
        total = 0
        for i,j,k in res:
            if i in ans and j in ans and k in ans:
                if i == j==k:
                    total += ans[i]*(ans[i]-1)*(ans[i]-2)//6
                elif i == j:
                    total += ans[i]*(ans[i]-1)*(ans[k])//2
                elif j == k:
                    total += ans[i]*(ans[j]-1)*ans[j]//2
                else:
                    total += ans[i]*ans[j]*ans[k]
        return total % (10**9+7)
```

###  1.402. <a name='FlipStringtoMonotoneIncreasing'></a>926. Flip String to Monotone Increasing

[花花酱](https://www.bilibili.com/video/BV1ft411R7qv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Vh411i7Wg?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def minFlipsMonoIncr(self, S):
        P = [0]
        for x in S:
            P.append(P[-1] + int(x))

        return min(P[j] + len(S)-j-(P[-1]-P[j])
                   for j in xrange(len(P)))

作者：LeetCode
链接：https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/solution/jiang-zi-fu-chuan-fan-zhuan-dao-dan-diao-di-zeng-b/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python3容易理解版本

class Solution:
    def minFlipsMonoIncr(self, S: str) -> int:
        n = len(S)
        #标记该位置之后由多少个1需要翻转为0
        flag0 = [0]*(n+1)
        #标记该位置之前由多少个0需要翻转为1
        flag1 = [0]*(n+1)
    
        for i in range(n):
            flag0[n-1-i] = flag0[n-i]
            flag1[i+1] = flag1[i]
            if S[n-1-i] == "0":
                flag0[n-1-i] += 1
            if S[i] == "1":
                flag1[i+1] += 1
        
        """查找从哪个位置开始，将这个位置前全部置为0，之后全部置为1总代价最小
           对于用例 010110
           flag0 = [3, 2, 2, 1, 1, 1, 0]
           flag1 = [0, 0, 1, 1, 2, 3, 3]"""
        return min(x[0]+x[1] for x in zip(flag0, flag1))


class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        # dp[i][j] 表示 在 i 位置的时候，其为 j 状态的时候，保持单调的最小翻转的次数
        dp = [[0,0] for i in range(n+1)]

        for i in range(n):
            if s[i] == '0':
                dp[i+1][0] = dp[i][0]
                dp[i+1][1] = min(dp[i][0], dp[i][1]) + 1
            else:
                dp[i+1][1] = min(dp[i][0], dp[i][1])
                dp[i+1][0] = dp[i][0] + 1
            
        return min(dp[n])
```

```py
class Solution(object):
    def minFlipsMonoIncr(self, S):
        """
        :type S: str
        :rtype: int
        """
        cnt=0                 #这道题使用了评论中大佬 Peter 的思路。设置一个光标从最左侧开始移动，左侧全为0，右侧全为1，统计左右改完之后要多少步
        cntlast=0
        znt=0
        for i in S:
            if i == '1':
                cnt+=1
            else:
                znt+=1        #统计字符串中0的个数，即将光标移动到最左边的时候，右边全为1要多少步
                cnt-=1
            if cnt < cntlast:
                cntlast=cnt
        return znt+cntlast


思路比较清晰，题目要求的最终字符串形式要么全是0，要么全是1，要么是前面一段连续0加上后面一段连续1字符串；
所以只需要考虑全0，全1，在每个位置进行划分得到两部分0,1字符串得到的操作中所需的最小的即可。
首先统计每个位置上前面有多少个0,1，后面有多少个0,1可以由总的0,1数量得到，然后在位置i上进行划分需要的翻转数为ones[i]+(n0-zeros[i]) (前面1转为0，后面0转为1)，最后取最小的即可。
class Solution:
    def minFlipsMonoIncr(self, S: str) -> int:
        n = len(S)
        ones, zeros = [0] * n, [0] * n
        for i, v in enumerate(S):
            ones[i], zeros[i] = ones[i-1], zeros[i-1]
            if v == "0":
                zeros[i] += 1
            else:
                ones[i] += 1
        n0, n1 = zeros[-1], ones[-1]
        ans = min(n0, n1)
        for i in range(n):
            ans = min(ans, ones[i]+(n0-zeros[i]))

        return ans
    
讨论一下即可。

class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        zero, one = 0, 0
        for i, x in enumerate(s, 1):
            # 改成 0 的花费是前面改成 0 的花费 + 当前位置改成 0 的花费
            # 改成 1 的花费是前面改成 0（此时做第一个 1） 或 1 的最小花费 + 当前位置改成 1 的花费
            zero, one = (zero + int(x != '0'), min(zero, one) + int(x != '1'))
        return min(zero, one)
#遍历字符串，找到一个分界点，使得该分界点之前1的个数和分界点之后0的个数之和最小，把分界点之前的1变成0，之后的0变成1
class Solution(object):
    def minFlipsMonoIncr(self, S):
        """
        :type S: str
        :rtype: int
        """
        m=S.count('0')   #分界点为0之前，统计之后的0
        res=[m]
        for x in S:
            if x=='1':   #如果是1，分界点之前1的个数+1，分界点之后0的个数不变
                m+=1
            else:       #如果是0，分界点之前1的个数不变，分界点之后0的个数减1
                m-=1
            res.append(m)        
        return min(res)
```

###  1.403. <a name='-1'></a>930-和相同的二元子数组(滑动窗口+前缀和)

[哈哈哈](https://www.bilibili.com/video/BV1iy4y1T7M3?spm_id_from=333.999.0.0)

###  1.404. <a name='NumberofRecentCalls'></a>933 Number of Recent Calls

[小明](https://www.bilibili.com/video/BV1gA41177jm?spm_id_from=333.999.0.0)

###  1.405. <a name='ShortestBridge'></a>934. Shortest Bridge

[花花酱](https://www.bilibili.com/video/BV19t411y7rL?spm_id_from=333.999.0.0)

###  1.406. <a name='StampingTheSequence'></a>936 Stamping The Sequence

[小明](https://www.bilibili.com/video/BV1d64y1D7fq?spm_id_from=333.999.0.0)

###  1.407. <a name='RangeSumofBST'></a>938 Range Sum of BST

[小明](https://www.bilibili.com/video/BV1WV411a7VR?spm_id_from=333.999.0.0)

###  1.408. <a name='ValidMountainArray'></a>941 Valid Mountain Array

[小明](https://www.bilibili.com/video/BV1n5411G7qs?spm_id_from=333.999.0.0)

###  1.409. <a name='FindtheShortestSuperstring'></a>943. Find the Shortest Superstring

[花花酱](https://www.bilibili.com/video/BV1yt411171k?spm_id_from=333.999.0.0)

###  1.410. <a name='Python-'></a>946-Python-栈的压入、弹出序列

[哈哈哈](https://www.bilibili.com/video/BV1JD4y1o7ZD?spm_id_from=333.999.0.0)

###  1.411. <a name='ValidateStackSequences'></a>946 Validate Stack Sequences

[小明](https://www.bilibili.com/video/BV1fz4y1y7rS?spm_id_from=333.999.0.0)

###  1.412. <a name='MostStonesRemovedwithSame'></a>947. 移除最多的同行或同列石头 Most Stones Removed with Same

[官方](https://www.bilibili.com/video/BV1Nr4y1K7Gj?spm_id_from=333.999.0.0)

###  1.413. <a name='BagofTokens'></a>948 Bag of Tokens

[小明](https://www.bilibili.com/video/BV1MK411P7K6?spm_id_from=333.999.0.0)

###  1.414. <a name='LargestTimeforGivenDigits'></a>949 Largest Time for Given Digits

[小明](https://www.bilibili.com/video/BV13v41117QS?spm_id_from=333.999.0.0)

###  1.415. <a name='LargestComponentSizebyCommo'></a>952 Largest Component Size by Commo

[小明](https://www.bilibili.com/video/BV1oK4y1h7Jt?spm_id_from=333.999.0.0)

###  1.416. <a name='VerifyinganAlienDictionary'></a>953 Verifying an Alien Dictionary

[小明](https://www.bilibili.com/video/BV1C64y1S7tT?spm_id_from=333.999.0.0)

###  1.417. <a name='ArrayofDoubledPairs'></a>954 Array of Doubled Pairs

[小明](https://www.bilibili.com/video/BV1Hq4y1S7xR?spm_id_from=333.999.0.0)

###  1.418. <a name='RegionsCutBySlashes'></a>959. 由斜杠划分区域 Regions Cut By Slashes

[官方](https://www.bilibili.com/video/BV1Ry4y117HD?spm_id_from=333.999.0.0)

###  1.419. <a name='LeastOperatorstoExpressNumber'></a>964. Least Operators to Express Number

[花花酱](https://www.bilibili.com/video/BV1Pt411k7qn?spm_id_from=333.999.0.0)

###  1.420. <a name='VowelSpellchecker'></a>966 Vowel Spellchecker

[小明](https://www.bilibili.com/video/BV1oK4y1T7kR?spm_id_from=333.999.0.0)

###  1.421. <a name='NumbersWithSameConsecutiveDifferences'></a>967. Numbers With Same Consecutive Differences

[花花酱](https://www.bilibili.com/video/BV1gt411B7oG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def numsSameConsecDiff(self, N, K):
        ans = {x for x in range(1, 10)}
        for _ in xrange(N-1):
            ans2 = set()
            for x in ans:
                d = x % 10
                if d - K >= 0:
                    ans2.add(10*x + d-K)
                if d + K <= 9:
                    ans2.add(10*x + d+K)
            ans = ans2

        if N == 1:
            ans.add(0)

        return list(ans)

作者：LeetCode
链接：https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences/solution/lian-xu-chai-xiang-tong-de-shu-zi-by-leetcode-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def numsSameConsecDiff(self, n: int, k: int):
        def temp_class(ret,N,K):
            temp = []
            #返回条件
            if N == 0:
                return [ret]
            #
            if ret%10 + K < 10:
                temp += temp_class(ret*10+ret%10+k,N-1,K)
            if ret%10 - K > -1 and K != 0:
                temp += temp_class(ret*10+ret%10-k,N-1,K)
            return temp
        #
        ret = []
        for i in range(1,10,1):
            if i + k < 10 or k - i < 10:
                ret += temp_class(i,n-1,k)
        return ret

def numsSameConsecDiff(self, N, K):
        """
        :type N: int
        :type K: int
        :rtype: List[int]
        """
        dp = set(range(10))
        for i in range(1, N):
            prev_dp = dp
            dp = set()
            for num in prev_dp:
                if num == 0:
                    continue
                left = num % 10
                if left >= K:
                    dp.add(num*10+left-K)
                if left + K <= 9:
                    dp.add(num*10+left+K)
        return sorted(list(dp))
```

```py

```

###  1.422. <a name='BinaryTreeCameras'></a>968 Binary Tree Cameras

[小明](https://www.bilibili.com/video/BV1Q5411u72B?spm_id_from=333.999.0.0)

###  1.423. <a name='PancakeSorting'></a>969 Pancake Sorting

[小明](https://www.bilibili.com/video/BV1hk4y127yJ?spm_id_from=333.999.0.0)

###  1.424. <a name='FlipBinaryTreeToMatchPreorder'></a>971 Flip Binary Tree To Match Preorder

[小明](https://www.bilibili.com/video/BV1NB4y1P7qL?spm_id_from=333.999.0.0)

###  1.425. <a name='KClosestPointstoOrigin'></a>973 K Closest Points to Origin

[小明](https://www.bilibili.com/video/BV1Vf4y1278J?spm_id_from=333.999.0.0)

###  1.426. <a name='KSubarraySumsDivisiblebyK'></a>974. 和可被 K 整除的子数组 Subarray Sums Divisible by K 

[官方](https://www.bilibili.com/video/BV19z4y1X79a?spm_id_from=333.999.0.0)

###  1.427. <a name='OddEvenJump'></a>975. Odd Even Jump

[花花酱](https://www.bilibili.com/video/BV1pt411p7M4?spm_id_from=333.999.0.0)

###  1.428. <a name='MiddleoftheLinkedList-1'></a>976 Middle of the Linked List

[小明](https://www.bilibili.com/video/BV1N5411t7Xm?spm_id_from=333.999.0.0)

###  1.429. <a name='SquaresofaSortedArray'></a>977 Squares of a Sorted Array

[小明](https://www.bilibili.com/video/BV1EX4y1u7Mb?spm_id_from=333.999.0.0)

###  1.430. <a name='LongestTurbulentSubarray'></a>978. 最长湍流子数组 Longest Turbulent Subarray 

[官方](https://www.bilibili.com/video/BV1PV411i73Y?spm_id_from=333.999.0.0)

###  1.431. <a name='UniquePathsIII'></a>980. Unique Paths III 

[花花酱](https://www.bilibili.com/video/BV1yt41187Si?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oK4y1a7Qp?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.432. <a name='MinimumCostForTickets'></a>983 Minimum Cost For Tickets

[小明](https://www.bilibili.com/video/BV1Wz4y1f7hG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1WK4y1t7pP?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.433. <a name='IntervalListIntersections'></a>986 Interval List Intersections

[小明](https://www.bilibili.com/video/BV1wg4y1z7Xz?spm_id_from=333.999.0.0)

###  1.434. <a name='VerticalOrderTraversalofaBinary'></a>987 Vertical Order Traversal of a Binary

[小明](https://www.bilibili.com/video/BV1yZ4y1M7CL?spm_id_from=333.999.0.0)

###  1.435. <a name='SatisfiabilityofEqualityEquations'></a>990. 等式方程的可满足性 Satisfiability of Equality Equations 

[官方](https://www.bilibili.com/video/BV1gz411i7kD?spm_id_from=333.999.0.0)

###  1.436. <a name='K-1'></a>992-K 个不同整数的子数组

[哈哈哈](https://www.bilibili.com/video/BV1t44y1q7th?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xy4y1Y7GL?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.437. <a name='-1'></a>993. 二叉树的堂兄弟节点

[小明](https://www.bilibili.com/video/BV17t4y11725?spm_id_from=333.999.0.0)

###  1.438. <a name='-1'></a>994-腐烂的橘子

[哈哈哈](https://www.bilibili.com/video/BV1Yp4y1D7Kg?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1bB4y1A7tG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qk4y1m7fz?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.439. <a name='-1'></a>993, 994, 995, 996

[花花酱](https://www.bilibili.com/video/BV1bb41117PB?spm_id_from=333.999.0.0)

###  1.440. <a name='FindtheTownJudge'></a>997 Find the Town Judge

[小明](https://www.bilibili.com/video/BV1Ka4y1i7Qt?spm_id_from=333.999.0.0)

###  1.441. <a name='MinimumCosttoMergeStones'></a>1000. Minimum Cost to Merge Stones

[花花酱](https://www.bilibili.com/video/BV1db411v7DG?spm_id_from=333.999.0.0)

###  1.442. <a name='GridIllumination'></a>1001 Grid Illumination

[小明](https://www.bilibili.com/video/BV1NT4y1V7Vk?spm_id_from=333.999.0.0)

###  1.443. <a name='III-1'></a>1004-最大连续1的个数 III

[哈哈哈](https://www.bilibili.com/video/BV1Zg411L7Qu?spm_id_from=333.999.0.0)

###  1.444. <a name='MinimumDominoRotationsForEq'></a>1007 Minimum Domino Rotations For Eq

[小明](https://www.bilibili.com/video/BV1br4y1w7TM?spm_id_from=333.999.0.0)

###  1.445. <a name='ConstructBinarySearchTreefrom'></a>1008 Construct Binary Search Tree from

[小明](https://www.bilibili.com/video/BV1yk4y1R7oF?spm_id_from=333.999.0.0)

###  1.446. <a name='ComplementofBase10Integer'></a>1009 Complement of Base 10 Integer

[小明](https://www.bilibili.com/video/BV1oK4y187ZM?spm_id_from=333.999.0.0)

###  1.447. <a name='PairsofSongsWithTotalDurations'></a>1010 Pairs of Songs With Total Durations 

[小明](https://www.bilibili.com/video/BV1t64y1f7hc?spm_id_from=333.999.0.0)

###  1.448. <a name='PartitionArrayIntoThreePartsWithEqu'></a>1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ

[官方](https://www.bilibili.com/video/BV1ZK4y1t7Sf?spm_id_from=333.999.0.0)

###  1.449. <a name='SmallestIntegerDivisiblebyK'></a>1015 Smallest Integer Divisible by K

[小明](https://www.bilibili.com/video/BV1PZ4y1G7iU?spm_id_from=333.999.0.0)

###  1.450. <a name='NextGreaterNodeInLinkedList'></a>1019. Next Greater Node In Linked List

[花花酱](https://www.bilibili.com/video/BV12b411s77J?spm_id_from=333.999.0.0)

###  1.451. <a name='SumofRootToLeafBinaryNumbers'></a>1022 Sum of Root To Leaf Binary Numbers

[小明](https://www.bilibili.com/video/BV11A411E7AN?spm_id_from=333.999.0.0)

###  1.452. <a name='-1'></a>1025,1026,1027,1028

[花花酱](https://www.bilibili.com/video/BV1Nb411j7qr?spm_id_from=333.999.0.0)

###  1.453. <a name='VideoStitching'></a>1024. Video Stitching

[花花酱](https://www.bilibili.com/video/BV1kb411u7Qk?spm_id_from=333.999.0.0)

###  1.454. <a name='MaximumDifferenceBetweenNod'></a>1026 Maximum Difference Between Nod

[小明](https://www.bilibili.com/video/BV1fi4y157ZS?spm_id_from=333.999.0.0)

###  1.455. <a name='TwoCityScheduling'></a>1029 Two City Scheduling

[小明](https://www.bilibili.com/video/BV1t54y1Q7G8?spm_id_from=333.999.0.0)

###  1.456. <a name='StreamofCharacters'></a>1032 Stream of Characters

[小明](https://www.bilibili.com/video/BV15T4y1L7RG?spm_id_from=333.999.0.0)

###  1.457. <a name='UncrossedLines'></a>1035 Uncrossed Lines

[小明](https://www.bilibili.com/video/BV1si4y1s79e?spm_id_from=333.999.0.0)

###  1.458. <a name='RobotBoundedInCircle'></a>1041 Robot Bounded In Circle

[小明](https://www.bilibili.com/video/BV1dk4y1y7RH?spm_id_from=333.999.0.0)

###  1.459. <a name='PartitionArrayforMaximumSum'></a>1043. Partition Array for Maximum Sum

[花花酱](https://www.bilibili.com/video/BV154411J7so?spm_id_from=333.999.0.0)

###  1.460. <a name='LongestDuplicateSubstring'></a>1044 Longest Duplicate Substring

[小明](https://www.bilibili.com/video/BV1Kv411B7a3?spm_id_from=333.999.0.0)

###  1.461. <a name='LastStoneWeight'></a>1046 Last Stone Weight

[小明](https://www.bilibili.com/video/BV1w54y197Ln?spm_id_from=333.999.0.0)

###  1.462. <a name='LongestStringChain'></a>1048 Longest String Chain

[小明](https://www.bilibili.com/video/BV17K4y1G7et?spm_id_from=333.999.0.0)



###  1.463. <a name='ShortestWaytoFormString'></a>1055.Shortest Way to Form String 形成字符串的最短路径

[图灵](https://www.bilibili.com/video/BV1SZ4y1G7WX?spm_id_from=333.999.0.0)

###  1.464. <a name='-1'></a>1091-二进制矩阵中的最短路径

[哈哈哈](https://www.bilibili.com/video/BV17k4y1r7EP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ro4y197kU?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.465. <a name='CarPooling'></a>1094 Car Pooling

[小明](https://www.bilibili.com/video/BV1Xk4y1k7UX?spm_id_from=333.999.0.0)

###  1.466. <a name='FindinMountainArray'></a>1095. Find in Mountain Array

[花花酱](https://www.bilibili.com/video/BV1m5411V7x7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK4115778?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.467. <a name='FillingBookcaseShelves'></a>1105. Filling Bookcase Shelves

[花花酱](https://www.bilibili.com/video/BV1Mx411X7Ks?spm_id_from=333.999.0.0)

###  1.468. <a name='ParsingABooleanExpression'></a>1106. Parsing A Boolean Expression

[花花酱](https://www.bilibili.com/video/BV1Cx411X7aF?spm_id_from=333.999.0.0)

###  1.469. <a name='DeleteNodesAndReturnForest'></a>1110. Delete Nodes And Return Forest

[花花酱](https://www.bilibili.com/video/BV1u4411977H?spm_id_from=333.999.0.0)

###  1.470. <a name='MaximumNestingDepthofTwoValidParentheses'></a>1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses

[官方](https://www.bilibili.com/video/BV11a4y1v7Bb?spm_id_from=333.999.0.0)

###  1.471. <a name='threading'></a>1114 - 1115 - 1116 - 多线程 threading

[花花酱](https://www.bilibili.com/video/BV12t411P79a?spm_id_from=333.999.0.0)

###  1.472. <a name='LowestCommonAncestorofDeepestLeaves'></a>1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖

[小明](https://www.bilibili.com/video/BV16f4y1q7eA?spm_id_from=333.999.0.0)

###  1.473. <a name='LongestWell-PerformingInterval'></a>1124. Longest Well-Performing Interval

[花花酱](https://www.bilibili.com/video/BV1Et41157Jw?spm_id_from=333.999.0.0)

###  1.474. <a name='SmallestSufficientTeam'></a>1125. Smallest Sufficient Team

[花花酱](https://www.bilibili.com/video/BV14t411G7WL?spm_id_from=333.999.0.0)

###  1.475. <a name='NumberofEquivalentDominoPairs'></a>1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs

[官方](https://www.bilibili.com/video/BV1fV411q7ZY?spm_id_from=333.999.0.0)

###  1.476. <a name='ShortestPathwithAlternatingColors'></a>1129. Shortest Path with Alternating Colors

[花花酱](https://www.bilibili.com/video/BV1Et411J7Dh?spm_id_from=333.999.0.0)

###  1.477. <a name='N-thTribonacciNumber'></a>1137. N-th Tribonacci Number

[3:55 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

###  1.478. <a name='StoneGameII'></a>1140. Stone Game II

[花花酱](https://www.bilibili.com/video/BV1Gt411c7hM?spm_id_from=333.999.0.0)

###  1.479. <a name='LongestCommonSubsequence'></a>1143 Longest Common Subsequence

[小明](https://www.bilibili.com/video/BV19Z4y1W7Xi?spm_id_from=333.999.0.0)

```py

```

```py

```

```scala
package com.zhourui.leetcode
import com.zhourui.codech.BaseExtension

//问题转化为dp[0...i][0..j]是否存在公共字串
//1.text1[i]==text2[j] && dp[i-1][j-1]存在公共字串
//2.否则从已有的dp中选择最大值 max(dp[i-1][j], dp[i][j-1]);
package lc1143{



  object Solution {
    def longestCommonSubsequence(text1: String, text2: String): Int = {
      val m = text1.length
      val n = text2.length
      //val dp = Array.ofDim[Int](1001,1001)
      val dp = Array.fill(1001,1001)(0)
      for (i<- 1 to m) { // must have space?
        for (j<- 1 to n) {
          dp(i)(j) = if (text1(i-1)== text2(j-1)) dp(i-1)(j-1)+1 else Math.max(dp(i-1)(j),dp(i)(j-1))
        }
      }
      dp(m)(n)
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.longestCommonSubsequence("abcde", "ace") == 3)
    }
    val name = "1143 Longest common sequence"
  }
}

```

###  1.480. <a name='BinaryTreeColoringGame'></a>1145. Binary Tree Coloring Game

[花花酱](https://www.bilibili.com/video/BV1ft411K7Gf?spm_id_from=333.999.0.0)

###  1.481. <a name='NumberofDiceRollsWithTargetSum'></a>1155. Number of Dice Rolls With Target Sum

[花花酱](https://www.bilibili.com/video/BV1t4411Q7JN?spm_id_from=333.999.0.0)

###  1.482. <a name='FindWordsThatCanBeFormedbyCharacters'></a>1160. 拼写单词 Find Words That Can Be Formed by Characters 

[官方](https://www.bilibili.com/video/BV1Lt4y1Q7Yx?spm_id_from=333.999.0.0)

###  1.483. <a name='DinnerPlateStacks'></a>1172. Dinner Plate Stacks

[花花酱](https://www.bilibili.com/video/BV1E4411z7xb?spm_id_from=333.999.0.0)

###  1.484. <a name='NumberofValidWordsforEachPuzzle'></a>1178. Number of Valid Words for Each Puzzle

[花花酱](https://www.bilibili.com/video/BV1x441117vz?spm_id_from=333.999.0.0)

###  1.485. <a name='MakeArrayStrictlyIncreasing'></a>1187. Make Array Strictly Increasing

[花花酱](https://www.bilibili.com/video/BV1sJ411N7jD?spm_id_from=333.999.0.0)

###  1.486. <a name='K-ConcatenationMaximumSum'></a>1191. K-Concatenation Maximum Sum

[花花酱](https://www.bilibili.com/video/BV1AJ411w756?spm_id_from=333.999.0.0)

###  1.487. <a name='UglyNumberIII'></a>1201. Ugly Number III

[花花酱](https://www.bilibili.com/video/BV1QJ411M7Jx?spm_id_from=333.999.0.0)

###  1.488. <a name='SmallestStringWithSwaps'></a>1202. Smallest String With Swaps

[花花酱](https://www.bilibili.com/video/BV1PJ411T7Wq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Yh41127VH?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.489. <a name='SortItemsbyGroupsRespectingDependencies'></a>1203. 项目管理 Sort Items by Groups Respecting Dependencies

[官方](https://www.bilibili.com/video/BV1iy4y1m7ye?spm_id_from=333.999.0.0)

###  1.490. <a name='DesignSkiplist'></a>1206. Design Skiplist 

[花花酱](https://www.bilibili.com/video/BV1kT4y1F7Nr?spm_id_from=333.999.0.0)

###  1.491. <a name='RemoveAllAdjacentDuplicatesin'></a>1209 Remove All Adjacent Duplicates in 

[小明](https://www.bilibili.com/video/BV1qA411L7z9?spm_id_from=333.999.0.0)

###  1.492. <a name='MinimumCosttoMoveChips'></a>1217 Minimum Cost to Move Chips

[小明](https://www.bilibili.com/video/BV1zt4y1e7fK?spm_id_from=333.999.0.0)

###  1.493. <a name='LongestArithmeticSubsequenceofGivenDifference'></a>1218. Longest Arithmetic Subsequence of Given Difference

[花花酱](https://www.bilibili.com/video/BV1tE411f73y?spm_id_from=333.999.0.0)

###  1.494. <a name='CountVowelsPermutation'></a>1220. Count Vowels Permutation

[花花酱](https://www.bilibili.com/video/BV1FJ411c7pT?spm_id_from=333.999.0.0)

###  1.495. <a name='DiceRollSimulation'></a>1223 Dice Roll Simulation

[花花酱](https://www.bilibili.com/video/BV17E411k7PR?spm_id_from=333.999.0.0)

###  1.496. <a name='TilingaRectanglewiththeFewestSquares'></a>1240 Tiling a Rectangle with the Fewest Squares

[花花酱](https://www.bilibili.com/video/BV1UE411t7Gb?spm_id_from=333.999.0.0)

###  1.497. <a name='-1'></a>1248-统计「优美子数组」

[哈哈哈](https://www.bilibili.com/video/BV1FU4y1H76T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wk4y1r7t7?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.498. <a name='MinimumRemovetoMakeValidPare'></a>1249 Minimum Remove to Make Valid Pare

[小明](https://www.bilibili.com/video/BV1wK4y1X7G7?spm_id_from=333.999.0.0)

###  1.499. <a name='-1'></a>1252 1253 1254 1255

[花花酱](https://www.bilibili.com/video/BV1kE411Y7rg?spm_id_from=333.999.0.0)

###  1.500. <a name='MinimumMovestoMoveaBoxtoTheirTarget'></a>1263. Minimum Moves to Move a Box to Their Target

[花花酱](https://www.bilibili.com/video/BV1AJ411Q7B6?spm_id_from=333.999.0.0)

###  1.501. <a name='-1'></a>1277-统计全为1的正方形子矩阵

[哈哈哈](https://www.bilibili.com/video/BV1nk4y1k7vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Kp4y1X7n4?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.502. <a name='PalindromePartitioningIII'></a>1278. Palindrome Partitioning III

[花花酱](https://www.bilibili.com/video/BV1HJ411q7nc?spm_id_from=333.999.0.0)

###  1.503. <a name='FindtheSmallestDivisorGivena'></a>1283 Find the Smallest Divisor Given a

[小明](https://www.bilibili.com/video/BV1Fv411r7Nw?spm_id_from=333.999.0.0)

###  1.504. <a name='MinimumNumberofFlipstoConvertBinaryMatrix'></a>1284. Minimum Number of Flips to Convert Binary Matrix

[花花酱](https://www.bilibili.com/video/BV1nJ411y7m1?spm_id_from=333.999.0.0)

###  1.505. <a name='ConvertBinaryNumberinaLinkedList'></a>1290. 二进制链表转整数 (Convert Binary Number in a Linked List

[洛阳](https://www.bilibili.com/video/BV1kc411h7Rs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nD4y1R7QH?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.506. <a name='SequentialDigits'></a>1291 Sequential Digits

[小明](https://www.bilibili.com/video/BV11v411C7so?spm_id_from=333.999.0.0)

###  1.507. <a name='ShortestPathinaGridwithObstaclesElimination'></a>1293. Shortest Path in a Grid with Obstacles Elimination

[花花酱](https://www.bilibili.com/video/BV1VJ411k72A?spm_id_from=333.999.0.0)

###  1.508. <a name='DivideArrayinSetsofKConsecutiveNumbers'></a>1296. Divide Array in Sets of K Consecutive Numbers

[花花酱](https://www.bilibili.com/video/BV1gJ411e7cS?spm_id_from=333.999.0.0)

###  1.509. <a name='NumberofPathswithMaxScore'></a>1301. Number of Paths with Max Score

[花花酱](https://www.bilibili.com/video/BV1pJ411a7ry?spm_id_from=333.999.0.0)

###  1.510. <a name='DeepestLeavesSum'></a>1302 Deepest Leaves Sum

[小明](https://www.bilibili.com/video/BV1Bb4y1D7Cp?spm_id_from=333.999.0.0)

###  1.511. <a name='AllElementsinTwoBinarySearch'></a>1305 All Elements in Two Binary Search

[小明](https://www.bilibili.com/video/BV1kK411N7az?spm_id_from=333.999.0.0)

###  1.512. <a name='JumpGameIII'></a>1306 Jump Game III

[小明](https://www.bilibili.com/video/BV13y4y1q7Gi?spm_id_from=333.999.0.0)

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0:
            return True

        n = len(arr)
        used = {start}
        q = collections.deque([start])

        while len(q) > 0:
            u = q.popleft()
            for v in [u + arr[u], u - arr[u]]:
                if 0 <= v < n and v not in used:
                    if arr[v] == 0:
                        return True
                    q.append(v)
                    used.add(v)
        
        return False

```

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(site, n):
            if flag[0]:
                return
            if arr[site] == 0:
                flag[0] = True
                return
            see[site] = True
            for next_site in (site+arr[site], site-arr[site]):
                if 0 <= next_site < n and see[next_site] == False:
                    dfs(next_site, n)
        n = len(arr)
        flag = [False]
        see = [False] * n
        dfs(start, n)
        return flag[0]
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()

        def dfs(index):
            if index in seen:
                return False

            seen.add(index)
            if index < 0 or index >= len(arr):
                return False

            if arr[index] == 0:
                return True

            return dfs(index + arr[index]) or dfs(index - arr[index])

        return dfs(start)
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()
        queue = [(start, 0)]

        while queue:
            index, step = queue.pop(0)

            if index in seen:
                continue

            seen.add(index)

            if index < 0 or index >= len(arr):
                continue

            if arr[index] == 0:
                return True

            queue.extend([(index + arr[index], step+1), (index - arr[index], step+1)])

        return False

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(index,d):
            if index<0 or index>=len(arr) or len(d)!=len(set(d)):return False
            if arr[index]==0:return True
            return dfs(index+arr[index],d+[index+arr[index]]) or  dfs(index-arr[index],d+[index-arr[index]])
        return dfs(start,[start])

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start]==0:return True
        q=collections.deque([start])
        visited={start}
        while q:
            node=q.popleft()
            for n in [node+arr[node],node-arr[node]]:
                if 0<=n<len(arr) and n not in visited:
                    if arr[n]==0:return True
                    q.append(n)
                    visited.add(n)
        return False

bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        q, v, n = [start], {start}, len(arr)
        while q:
            p = []
            for i in q:
                if not arr[i]:
                    return True
                for j in i - arr[i], i + arr[i]:
                    if 0 <= j < n and j not in v:
                        p.append(j)
                        v.add(j)
            q = p
        return False
dfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        n, v = len(arr), set()
        def f(i):
            if not arr[i]:
                return True
            elif i not in v:
                v.add(i)
                return 0 <= i - arr[i] < n and f(i - arr[i]) or 0 <= i + arr[i] < n and f(i + arr[i])
        return f(start)

python bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        l, mark, queue= len(arr), [1 for i in range(len(arr))], [start]
        while len(queue)!=0:
            n = len(queue)
            for i in range(n):
                tmp = queue.pop()
                if arr[tmp]==0:
                    return True
                mark[tmp] = 0
                for cur in tmp+arr[tmp], tmp-arr[tmp]:
                    if 0<=cur<l and mark[cur]:
                        queue.insert(0, cur)
        return False
```

###  1.513. <a name='XORQueriesofaSubarray'></a>1310. XOR Queries of a Subarray

[花花酱](https://www.bilibili.com/video/BV1oJ411L78Y?spm_id_from=333.999.0.0)

###  1.514. <a name='MinimumInsertionStepstoMakeaStringPalindrom'></a>1312. Minimum Insertion Steps to Make a String Palindrom

[花花酱](https://www.bilibili.com/video/BV1HJ411L7b2?spm_id_from=333.999.0.0)

###  1.515. <a name='MinimumDistancetoTypeaWordUsingTwoFinger'></a>1320. Minimum Distance to Type a Word Using Two Finger

[花花酱](https://www.bilibili.com/video/BV11J411n7fN?spm_id_from=333.999.0.0)

###  1.516. <a name='SorttheMatrixDiagonally'></a>1329 Sort the Matrix Diagonally

[小明](https://www.bilibili.com/video/BV1hU4y147b1?spm_id_from=333.999.0.0)

###  1.517. <a name='RemovePalindromicSubsequences'></a>1332 Remove Palindromic Subsequences

[小明](https://www.bilibili.com/video/BV1tK4y1D7aV?spm_id_from=333.999.0.0)

###  1.518. <a name='FindtheCityWithSmallestNumberofNeighbors'></a>1334. Find the City With Smallest Number of Neighbors

[花花酱](https://www.bilibili.com/video/BV1b7411z7Tb?spm_id_from=333.999.0.0)

###  1.519. <a name='MinimumDifficultyofaJobSchedule'></a>1335. Minimum Difficulty of a Job Schedule

[花花酱](https://www.bilibili.com/video/BV1K7411r7xj?spm_id_from=333.999.0.0)

###  1.520. <a name='TheKWeakestRowsinaMatrix'></a>1337 The K Weakest Rows in a Matrix

[小明](https://www.bilibili.com/video/BV1bX4y157ju?spm_id_from=333.999.0.0)

###  1.521. <a name='MaximumProductofSplitt'></a>1339 Maximum Product of Splitt

[小明](https://www.bilibili.com/video/BV1Ch411i7yS?spm_id_from=333.999.0.0)

###  1.522. <a name='JumpGameV'></a>1340. Jump Game V

[花花酱](https://www.bilibili.com/video/BV1h7411W7wS?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        pathdic = defaultdict(list)
        n = len(arr)
        if n<=1: return n
        indegrees = [0]*n
        for i in range(n):
            for j in range(i+1,n):
                if arr[j]<arr[i] and j-i<=d:
                    pathdic[i].append(j)
                    indegrees[j] += 1
                else:
                    break
            for j in range(i-1, -1, -1):
                if arr[j]<arr[i] and i-j<=d:
                    pathdic[i].append(j)
                    indegrees[j] += 1
                else:
                    break
        # 拓扑排序
        queue = Deque()
        for i,degree in enumerate(indegrees):
            if degree == 0:
                queue.append((i,1))
        ans = 1
        while queue:
            node, level = queue.popleft()
            for nx_node in pathdic[node]:
                ans = max(ans, level+1)
                indegrees[nx_node] -= 1
                if indegrees[nx_node] == 0:
                    queue.append((nx_node, level+1))
        return ans

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        D = {}
        l = len(arr)
        def P(n):
            if n in D:
                return D[n]
            t = 1
            for i in range(1, d + 1):
                if n + i >= l or arr[n] <= arr[n + i]:
                    break
                t = max(t, 1 + P(n + i))
            for i in range(1, d + 1):
                if n - i < 0 or arr[n] <= arr[n - i]:
                    break
                t = max(t, 1 + P(n - i))
            D[n] = t
            return t
        return max(P(i) for i in range(l))
```

```py
记忆化 DFS

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        n = len(arr)
        @lru_cache(None)
        def helper(i):
            res = 0
            for j in range(i + 1, i + d + 1):
                if j >= n or arr[j] >= arr[i]:
                    break
                res = max(res, helper(j))
            for j in range(i - 1, i - d - 1, -1):
                if j < 0 or arr[j] >= arr[i]:
                    break
                res = max(res, helper(j))
            return res + 1
        return max(helper(i) for i in range(n))
```

```py
排序之后对向两边进行拓展

#python3
class Solution:
	def maxJumps(self,arr,d):
		fans=1
		size=len(arr)
		has,dp=[[0]*size for _ in range(2)]
		for i in sorted(range(size),key=arr.__getitem__):
			tans=has[i]=1
			for j in range(i+1,min(size,i+d+1)):
				if not has[j] or arr[j]==arr[i]:
					break
				tans=max(tans,dp[j]+1)
			for j in range(i-1,max(-1,i-d-1),-1):
				if not has[j] or arr[j]==arr[i]:
					break
				tans=max(tans,dp[j]+1)
			dp[i]=tans
			fans=max(fans,tans)
		return fans

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        # 不能往比自己的高的跳
        # 能跳的区间内不能有比自己高的
        # dp[i]从 i开始的最大跳跃
        n = len(arr)
        height = [(jump,i) for i, jump in enumerate(arr)]
        height = sorted(height, key=lambda x: x[0])
        dp = [1 for _ in range(n)]
        #print(idx)
        #idx1 = map(lambda x: x[1], idx)
        for jump, i in height:
            cur = 1
            for j in range(i-1, max(-1, i - d) - 1, -1): # 向左跳
                if arr[j] >= jump: break
                cur = max(dp[j] + 1,cur)

            for j in range(i + 1, min(n, i + d + 1)):
                if arr[j] >= jump: break
                cur = max(dp[j] + 1, cur)
            dp[i] = cur
        return max(dp)

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        seen = dict()

        def dfs(pos):
            if pos in seen:
                return
            seen[pos] = 1

            i = pos - 1
            while i >= 0 and pos - i <= d and arr[pos] > arr[i]:
                dfs(i)
                seen[pos] = max(seen[pos], seen[i] + 1)
                i -= 1
            i = pos + 1
            while i < len(arr) and i - pos <= d and arr[pos] > arr[i]:
                dfs(i)
                seen[pos] = max(seen[pos], seen[i] + 1)
                i += 1

        for i in range(len(arr)):
            dfs(i)
        print(seen)
        return max(seen.values())

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/jump-game-v/solution/tiao-yue-you-xi-v-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  1.523. <a name='MaximumStudentsTakingExam'></a>1349. Maximum Students Taking Exam

[花花酱](https://www.bilibili.com/video/BV1w7411V7eC?spm_id_from=333.999.0.0)

###  1.524. <a name='MaximumNumberofEventsThatCanBeAttended'></a>1353. Maximum Number of Events That Can Be Attended 

[花花酱](https://www.bilibili.com/video/BV1C7411j7YJ?spm_id_from=333.999.0.0)

###  1.525. <a name='ConstructTargetArrayWithMultipleSums'></a>1354. Construct Target Array With Multiple Sums

[花花酱](https://www.bilibili.com/video/BV1g7411c793?spm_id_from=333.999.0.0)

###  1.526. <a name='MinimumCosttoMakeatLeastOneValidPath'></a>1368. Minimum Cost to Make at Least One Valid Path

[花花酱](https://www.bilibili.com/video/BV1oE411E74t?spm_id_from=333.999.0.0)

###  1.527. <a name='FindtheLongestSubstringContainingVowelsinEve'></a>1371. Find the Longest Substring Containing Vowels in Eve

[花花酱](https://www.bilibili.com/video/BV1CE411K7hb?spm_id_from=333.999.0.0)

###  1.528. <a name='MaximumSumBSTinBinaryTree'></a>1373. Maximum Sum BST in Binary Tree

[花花酱](https://www.bilibili.com/video/BV17E411u797?spm_id_from=333.999.0.0)

###  1.529. <a name='FrogPositionAfterTSeconds'></a>1377. Frog Position After T Seconds

[花花酱](https://www.bilibili.com/video/BV1mE411K7vc?spm_id_from=333.999.0.0)

###  1.530. <a name='FindCorrespondingNodeofBinaryTreeinaClone'></a>1379 Find Corresponding Node of Binary Tree in a Clone

[小明](https://www.bilibili.com/video/BV1A54y147HN?spm_id_from=333.999.0.0)

###  1.531. <a name='BalanceaBinarySearchTree'></a>1382. Balance a Binary Search Tree

[花花酱](https://www.bilibili.com/video/BV1y7411f7v2?spm_id_from=333.999.0.0)

###  1.532. <a name='CountNumberofTeams'></a>1395. Count Number of Teams

[花花酱](https://www.bilibili.com/video/BV1cc411h73E?spm_id_from=333.999.0.0)

###  1.533. <a name='DesignUndergroundSystem'></a>1396 Design Underground System

[小明](https://www.bilibili.com/video/BV1uA411N7q6?spm_id_from=333.999.0.0)

###  1.534. <a name='StoneGameIII'></a>1406. Stone Game III

[花花酱](https://www.bilibili.com/video/BV1zT4y1G7Tb?spm_id_from=333.999.0.0)

###  1.535. <a name='QueriesonaPermutationWithKey'></a>1409. Queries on a Permutation With Key

[花花酱](https://www.bilibili.com/video/BV1mz411b7Uw?spm_id_from=333.999.0.0)

###  1.536. <a name='RestoreTheArray'></a>1416. Restore The Array

[花花酱](https://www.bilibili.com/video/BV1gK4y1k7Rv?spm_id_from=333.999.0.0)

###  1.537. <a name='DiagonalTraverseII'></a>1424. Diagonal Traverse II

[花花酱](https://www.bilibili.com/video/BV1r5411x7Tm?spm_id_from=333.999.0.0)

###  1.538. <a name='ConstrainedSubsetSum'></a>1425. Constrained Subset Sum

[花花酱](https://www.bilibili.com/video/BV13t4y1m7fD?spm_id_from=333.999.0.0)

###  1.539. <a name='CountingElements'></a>1426  Counting Elements

[小明](https://www.bilibili.com/video/BV1Eg4y187vx?spm_id_from=333.999.0.0)

###  1.540. <a name='KidsWiththeGreatestNumberofCandie'></a>1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie

[官方](https://www.bilibili.com/video/BV1vD4y1D7yo?spm_id_from=333.999.0.0)

###  1.541. <a name='CheckIfAll1sAreatLeastLength'></a>1437 Check If All 1's Are at Least Length

[小明](https://www.bilibili.com/video/BV1Yo4y1R78P?spm_id_from=333.999.0.0)

###  1.542. <a name='LongestContinuousSubarrayWithAbsolute'></a>1438. Longest Continuous Subarray With Absolute

[花花酱](https://www.bilibili.com/video/BV1Cf4y1m7aN?spm_id_from=333.999.0.0)

###  1.543. <a name='BuildanArrayWithStackOperations'></a>1441 Build an Array With Stack Operations

[小明](https://www.bilibili.com/video/BV1Gg4y167ZD?spm_id_from=333.999.0.0)

###  1.544. <a name='CountTripletsThatCanFormTwoArraysofEqual'></a>1442. Count Triplets That Can Form Two Arrays of Equal

[花花酱](https://www.bilibili.com/video/BV17g4y1B7yo?spm_id_from=333.999.0.0)

###  1.545. <a name='MinimumTimetoCollectAllApplesinaTree'></a>1443. Minimum Time to Collect All Apples in a Tree

[花花酱](https://www.bilibili.com/video/BV1e541147oZ?spm_id_from=333.999.0.0)

###  1.546. <a name='NumberofWaysofCuttingaPizza'></a>1444. Number of Ways of Cutting a Pizza

[花花酱](https://www.bilibili.com/video/BV1CK411W7nR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gg4y1B7zS?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.547. <a name='ConsecutiveCharacters'></a>1446 Consecutive Characters

[小明](https://www.bilibili.com/video/BV1QA411j7Qt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pp4y1Q7Rh?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.548. <a name='CountGoodNodesinBinaryTree'></a>1448 Count Good Nodes in Binary Tree

[小明](https://www.bilibili.com/video/BV1Zg4y1q7kc?spm_id_from=333.999.0.0)

###  1.549. <a name='FormLargestIntegerWithDigitsThatAdd'></a>1449. Form Largest Integer With Digits That Add

[花花酱](https://www.bilibili.com/video/BV19Q4y1A7Rf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1j54y1D7vf?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.550. <a name='RearrangeWordsinaSentence'></a>1451 Rearrange Words in a Sentence

[小明](https://www.bilibili.com/video/BV1UA411t7Eg?spm_id_from=333.999.0.0)

###  1.551. <a name='MaximumNumberofDartsInsideofaCircularDartb'></a>1453 Maximum Number of Darts Inside of a Circular Dartb

[小明](https://www.bilibili.com/video/BV1Ut4y117jp?spm_id_from=333.999.0.0)

###  1.552. <a name='Pseudo-PalindromicPathsinaBin'></a>1457 Pseudo-Palindromic Paths in a Bin

[小明](https://www.bilibili.com/video/BV1t54y1t7KK?spm_id_from=333.999.0.0)

###  1.553. <a name='CheckIfaStringContainsAllBinar'></a>1461 Check If a String Contains All Binar

[小明](https://www.bilibili.com/video/BV13Z4y1w7K9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oU4y1p7Tr?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.554. <a name='CherryPickupII'></a>1463 Cherry Pickup II

[小明](https://www.bilibili.com/video/BV1AA411s7Tc?spm_id_from=333.999.0.0)

###  1.555. <a name='PaintHouseIII'></a>1473. Paint House III

[花花酱](https://www.bilibili.com/video/BV15K411p7nT?spm_id_from=333.999.0.0)

###  1.556. <a name='FinalPricesWithaSpecialDiscountinaSho'></a>1475. Final Prices With a Special Discount in a Sho

[花花酱](https://www.bilibili.com/video/BV1na4y1Y7VU?spm_id_from=333.999.0.0)

###  1.557. <a name='KthAncestorofaTreeNode'></a>1483. Kth Ancestor of a Tree Node

[花花酱](https://www.bilibili.com/video/BV1kt4y1X7fk?spm_id_from=333.999.0.0)

###  1.558. <a name='AvoidFloodinTheCity'></a>1488. Avoid Flood in The City

[花花酱](https://www.bilibili.com/video/BV1af4y1y7uW?spm_id_from=333.999.0.0)

###  1.559. <a name='FindCriticalandPseudo-CriticalEdgesin'></a>1489. Find Critical and Pseudo-Critical Edges in

[花花酱](https://www.bilibili.com/video/BV1cV41167oi?spm_id_from=333.999.0.0)

###  1.560. <a name='ThekthFactorofn'></a>1492 The kth Factor of n

[小明](https://www.bilibili.com/video/BV1ha4y1H7vz?spm_id_from=333.999.0.0)

###  1.561. <a name='LongestSubarrayof1sAfterDeletingOne'></a>1493. Longest Subarray of 1's After Deleting One

[花花酱](https://www.bilibili.com/video/BV1rC4y18751?spm_id_from=333.999.0.0)

###  1.562. <a name='MaxValueofEquation'></a>1499. Max Value of Equation

[花花酱](https://www.bilibili.com/video/BV1VK411H7zy?spm_id_from=333.999.0.0)

###  1.563. <a name='CanMakeArithmeticProgressionFromSequence'></a>1502 Can Make Arithmetic Progression From Sequence

[小明](https://www.bilibili.com/video/BV12T4y177vU?spm_id_from=333.999.0.0)

###  1.564. <a name='LastMomentBeforeAllAntsFallOutofaPlank'></a>1503 Last Moment Before All Ants Fall Out of a Plank

[小明](https://www.bilibili.com/video/BV1Fg4y1i7na?spm_id_from=333.999.0.0)

###  1.565. <a name='MinimumPossibleIntegerAfteratMostKAdjacent'></a>1505. Minimum Possible Integer After at Most K Adjacent

[花花酱](https://www.bilibili.com/video/BV1YD4y1S7BQ?spm_id_from=333.999.0.0)

###  1.566. <a name='RangeSumofSortedSubarraySums'></a>1508. Range Sum of Sorted Subarray Sums

[花花酱](https://www.bilibili.com/video/BV1fg4y1v7qe?spm_id_from=333.999.0.0)

###  1.567. <a name='StoneGameIV'></a>1510 Stone Game IV

[小明](https://www.bilibili.com/video/BV1pr4y1w7ao?spm_id_from=333.999.0.0)

###  1.568. <a name='PathwithMaximumProbability'></a>1514 Path with Maximum Probability

[小明](https://www.bilibili.com/video/BV1Ak4y1B7yR?spm_id_from=333.999.0.0)

###  1.569. <a name='BestPositionforaServiceCentre'></a>1515 Best Position for a Service Centre

[小明](https://www.bilibili.com/video/BV1UA411e7PC?spm_id_from=333.999.0.0)

###  1.570. <a name='MaximumNumberofNon-OverlappingSubstrings'></a>1520. Maximum Number of Non-Overlapping Substrings

[花花酱](https://www.bilibili.com/video/BV1yz4y1D7p3?spm_id_from=333.999.0.0)

###  1.571. <a name='NumberofGoodLeafNodesPairs'></a>1530. Number of Good Leaf Nodes Pairs

[花花酱](https://www.bilibili.com/video/BV1bv411q7SD?spm_id_from=333.999.0.0)

###  1.572. <a name='StringCompressionII'></a>1531. String Compression II

[花花酱](https://www.bilibili.com/video/BV1aK4y1v7B9?spm_id_from=333.999.0.0)

###  1.573. <a name='CountGoodTriplets'></a>1534 Count Good Triplets

[小明](https://www.bilibili.com/video/BV11k4y1m7rV?spm_id_from=333.999.0.0)

###  1.574. <a name='FindtheWinnerofanArrayGame'></a>1535 Find the Winner of an Array Game

[小明](https://www.bilibili.com/video/BV1Xp4y1i7ey?spm_id_from=333.999.0.0)

###  1.575. <a name='GettheMaximumScore'></a>1537. Get the Maximum Score

[小梦想家](https://www.bilibili.com/video/BV1KC4y1t7P8?spm_id_from=333.999.0.0)

###  1.576. <a name='KthMissingPositiveNumber'></a>1539. Kth Missing Positive Number

[小梦想家](https://www.bilibili.com/video/BV1SC4y147Eo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK4y1p7E3?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.577. <a name='FindLongestAwesomeSubstring'></a>1542. Find Longest Awesome Substring

[花花酱](https://www.bilibili.com/video/BV1ZD4y1U79Y?spm_id_from=333.999.0.0)

###  1.578. <a name='MaximumNumberofNon-OverlappingSubarraysWithSum'></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum

[小梦想家](https://www.bilibili.com/video/BV1LA411n7L8?spm_id_from=333.999.0.0)

###  1.579. <a name='ThreeConsecutiveOdds'></a>1550. Three Consecutive Odds

[小梦想家](https://www.bilibili.com/video/BV1aV411m7fy?spm_id_from=333.999.0.0)

###  1.580. <a name='MinimumOperationstoMakeArray'></a>1551 Minimum Operations to Make Array

[小明](https://www.bilibili.com/video/BV1u64y1S7fx?spm_id_from=333.999.0.0)

###  1.581. <a name='MinimumNumberofDaystoEatNOranges'></a>1553. Minimum Number of Days to Eat N Oranges

[花花酱](https://www.bilibili.com/video/BV1Qf4y197Zk?spm_id_from=333.999.0.0)

###  1.582. <a name='ThousandSeparator'></a>1556. Thousand Separator

[小梦想家](https://www.bilibili.com/video/BV1Ka4y177HV?spm_id_from=333.999.0.0)

###  1.583. <a name='MinimumNumbersofFunctionCallstoMakeTarget'></a>1558. Minimum Numbers of Function Calls to Make Target

[花花酱](https://www.bilibili.com/video/BV1xC4y1t7Q3?spm_id_from=333.999.0.0)

###  1.584. <a name='StoneGameV'></a>1563. Stone Game V 

[花花酱](https://www.bilibili.com/video/BV1B54y1U77f?spm_id_from=333.999.0.0)

###  1.585. <a name='NumberofWaystoReorderArraytoGetSa'></a>1569. Number of Ways to Reorder Array to Get Sa

[花花酱](https://www.bilibili.com/video/BV1pZ4y1T7TY?spm_id_from=333.999.0.0)

###  1.586. <a name='NumberofWaystoSplitaString'></a>1573. Number of Ways to Split a String

[花花酱](https://www.bilibili.com/video/BV1bi4y1u7c3?spm_id_from=333.999.0.0)

###  1.587. <a name='CheckIfStringIsTransformableWith'></a>1585. Check If String Is Transformable With

[花花酱](https://www.bilibili.com/video/BV1a54y1m75Y?spm_id_from=333.999.0.0)

###  1.588. <a name='SplitaStringIntotheMaxNumberofUniqueSubstri'></a>1593. Split a String Into the Max Number of Unique Substri

[花花酱](https://www.bilibili.com/video/BV14y4y1k77x?spm_id_from=333.999.0.0) 

###  1.589. <a name='MinimumCosttoConnectTwoGroupsofPoints'></a>1595. Minimum Cost to Connect Two Groups of Points

[花花酱](https://www.bilibili.com/video/BV1Xf4y1D7SW?spm_id_from=333.999.0.0)

###  1.590. <a name='NumberofSetsofKNon-OverlappingLine'></a>1621. Number of Sets of K Non-Overlapping Line

[花花酱](https://www.bilibili.com/video/BV1JV411y7eK?spm_id_from=333.999.0.0)

###  1.591. <a name='PathWithMinimumEffort'></a>1631. Path With Minimum Effort

[花花酱](https://www.bilibili.com/video/BV1tr4y1w725?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ft4y1z71X?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.592. <a name='RankTransformofaMatrix'></a>1632 Rank Transform of a Matrix

[小明](https://www.bilibili.com/video/BV1KX4y1F7UA?spm_id_from=333.999.0.0)

###  1.593. <a name='CheckArrayFormationThrough'></a>1640 Check Array Formation Through

[小明](https://www.bilibili.com/video/BV1uh411274P?spm_id_from=333.999.0.0)

###  1.594. <a name='CountSortedVowelStrings'></a>1641 Count Sorted Vowel Strings

[小明](https://www.bilibili.com/video/BV1jf4y1k7bJ?spm_id_from=333.999.0.0)

###  1.595. <a name='FurthestBuildingYouCanReach'></a>1642. Furthest Building You Can Reach

[花花酱](https://www.bilibili.com/video/BV1az4y1C7Pk?spm_id_from=333.999.0.0)

###  1.596. <a name='GetMaximuminGeneratedArray'></a>1646 Get Maximum in Generated Array

[小明](https://www.bilibili.com/video/BV1W54y1s7mg?spm_id_from=333.999.0.0)

###  1.597. <a name='SellDiminishing-ValuedColoredBalls'></a>1648. Sell Diminishing-Valued Colored Balls

[花花酱](https://www.bilibili.com/video/BV11z4y1C7PC?spm_id_from=333.999.0.0)

###  1.598. <a name='CreateSortedArraythroughInstru'></a>1649 Create Sorted Array through Instru

[小明](https://www.bilibili.com/video/BV1ua4y1H7KK?spm_id_from=333.999.0.0)

###  1.599. <a name='DistributeRepeatingIntegers'></a>1655. Distribute Repeating Integers

[花花酱](https://www.bilibili.com/video/BV1qt4y1a7Lm?spm_id_from=333.999.0.0)

###  1.600. <a name='DetermineifTwoStringsAreClose'></a>1657 Determine if Two Strings Are Close

[小明](https://www.bilibili.com/video/BV18z4y1S779?spm_id_from=333.999.0.0)

###  1.601. <a name='MinimumOperationstoReduceX'></a>1658 Minimum Operations to Reduce X

[小明](https://www.bilibili.com/video/BV18t4y1z7Hq?spm_id_from=333.999.0.0)

###  1.602. <a name='MaximizeGridHappiness'></a>1659. Maximize Grid Happiness

[花花酱](https://www.bilibili.com/video/BV1kf4y1v7Js?spm_id_from=333.999.0.0)

###  1.603. <a name='CheckIfTwoStringArraysareEqui'></a>1662 Check If Two String Arrays are Equi

[小明](https://www.bilibili.com/video/BV1LV411t7v4?spm_id_from=333.999.0.0)

###  1.604. <a name='SmallestStringWithAGivenNumer'></a>1663 Smallest String With A Given Numer

[小明](https://www.bilibili.com/video/BV1gv411e7Ly?spm_id_from=333.999.0.0)

###  1.605. <a name='FindtheMostCompetitiveSubseq'></a>1673 Find the Most Competitive Subseq

[小明](https://www.bilibili.com/video/BV1yK4y1H7ni?spm_id_from=333.999.0.0)

###  1.606. <a name='MinimumMovestoMakeArrayComplement'></a>1674. Minimum Moves to Make Array Complement

[花花酱](https://www.bilibili.com/video/BV1qz4y1k7Cm?spm_id_from=333.999.0.0)

###  1.607. <a name='MinimizeDeviationinArray'></a>1675. Minimize Deviation in Array

[花花酱](https://www.bilibili.com/video/BV15541157p6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16f4y167uf?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.608. <a name='MaxNumberofK-SumPairs'></a>1679 Max Number of K-Sum Pairs】

[小明](https://www.bilibili.com/video/BV16t4y1z7kY?spm_id_from=333.999.0.0)

###  1.609. <a name='ConcatenationofConsecutiveBina'></a>1680 Concatenation of Consecutive Bina

[小明](https://www.bilibili.com/video/BV1Py4y117o5?spm_id_from=333.999.0.0)

###  1.610. <a name='MinimumIncompatibility'></a>1681. Minimum Incompatibility

[花花酱](https://www.bilibili.com/video/BV16p4y1z79z?spm_id_from=333.999.0.0)

###  1.611. <a name='StoneGameVII'></a>1690. Stone Game VII

[花花酱](https://www.bilibili.com/video/BV1wf4y1e7xH?spm_id_from=333.999.0.0)

###  1.612. <a name='JumpGameVI'></a>1696. Jump Game VI

[花花酱](https://www.bilibili.com/video/BV1554y1t7Tz?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        
        
        # dp[i] = max(dp[j])+ nums[i] for j in range(i - k, i)
        
        dp = [0] * len(nums)
        dp[0] = nums[0]
        
        q = [0]
        for i in range(1, len(nums)):
            while q and i - q[0] > k:
                q.pop(0)
            dp[i] = dp[q[0]] + nums[i]
            while q and dp[q[-1]] <= dp[i]:
                q.pop(-1)
            q.append(i)     
        return dp[-1]
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        from queue import PriorityQueue
        ans, q = nums[0], PriorityQueue()
        q.put([-nums[0], 0])
        for i in range(1, len(nums)):
            while not q.empty():
                top = q.get()
                if i - top[-1] <= k:
                    q.put(top)
                    break
            ans = -top[0] + nums[i]
            q.put([-ans, i])
        return ans
```

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        #维护当前最大值  方法1：最大堆  方法2:单调递减队列（队首）
        n = len(nums)
        maxHeap = []
        heapq.heapify(maxHeap)
        heapq.heappush(maxHeap, (-nums[0], 0) )
        res = nums[0]

        for i in range(1, n):
            while maxHeap and i - maxHeap[0][1] > k:    #index的距离太大，以后i越来越大，top()就没用了
                heapq.heappop(maxHeap)
            res = -maxHeap[0][0] + nums[i]
            heapq.heappush(maxHeap, (-res, i) )         #dp的思想
        return res
```

###  1.613. <a name='DetermineifStringHalvesAreAlike'></a>1704 Determine if String Halves Are Alike

[小明](https://www.bilibili.com/video/BV1WA41157sf?spm_id_from=333.999.0.0)

###  1.614. <a name='MaximumXORWithanElementFromArray'></a>1707. Maximum XOR With an Element From Array

[花花酱](https://www.bilibili.com/video/BV13v411t742?spm_id_from=333.999.0.0)

###  1.615. <a name='MinimumOperationstoMakeaSubsequence'></a>1713. Minimum Operations to Make a Subsequence

[花花酱](https://www.bilibili.com/video/BV1Yy4y127DQ?spm_id_from=333.999.0.0)

###  1.616. <a name='SwappingNodesinaLinkedList'></a>1721 Swapping Nodes in a Linked List

[小明](https://www.bilibili.com/video/BV1Ji4y1P7Xc?spm_id_from=333.999.0.0)

###  1.617. <a name='LargestSubmatrixWithRearrangements'></a>1727. Largest Submatrix With Rearrangements

[花花酱](https://www.bilibili.com/video/BV1XT4y1N7gy?spm_id_from=333.999.0.0)

###  1.618. <a name='PalindromePartitioningIV'></a>1745. Palindrome Partitioning IV

[花花酱](https://www.bilibili.com/video/BV1yo4y1R75T?spm_id_from=333.999.0.0)

###  1.619. <a name='MinimumLimitofBallsinaBag'></a>1760. Minimum Limit of Balls in a Bag

[花花酱](https://www.bilibili.com/video/BV1bK4y1H7Ly?spm_id_from=333.999.0.0)

###  1.620. <a name='MaximumScorefromPerformingMultiplication'></a>1770. Maximum Score from Performing Multiplication

[花花酱](https://www.bilibili.com/video/BV1Li4y1T7j6?spm_id_from=333.999.0.0)

###  1.621. <a name='MaximizePalindromeLengthFromSubsequences'></a>1771. Maximize Palindrome Length From Subsequences

[花花酱](https://www.bilibili.com/video/BV1Cp4y1H7Xq?spm_id_from=333.999.0.0)

###  1.622. <a name='EqualSumArraysWithMinimumNumberofOperatio'></a>1775. Equal Sum Arrays With Minimum Number of Operatio

[花花酱](https://www.bilibili.com/video/BV1Di4y1T7nF?spm_id_from=333.999.0.0)

###  1.623. <a name='NumberofRestrictedPathsFromFirsttoLastNode'></a>1786. Number of Restricted Paths From First to Last Node

[花花酱](https://www.bilibili.com/video/BV1Df4y147TB?spm_id_from=333.999.0.0)

###  1.624. <a name='MaximumAveragePassRatio'></a>1792. Maximum Average Pass Ratio

[花花酱](https://www.bilibili.com/video/BV1qb4y197zc?spm_id_from=333.999.0.0)

###  1.625. <a name='MaximizeScoreAfterNOperations'></a>1799. Maximize Score After N Operations

[花花酱](https://www.bilibili.com/video/BV1Sf4y1x7Cy?spm_id_from=333.999.0.0)

###  1.626. <a name='MaximumNumberofGroupsGettingFreshDonuts'></a>1815. Maximum Number of Groups Getting Fresh Donuts

[花花酱](https://www.bilibili.com/video/BV1CU4y187tk?spm_id_from=333.999.0.0)

###  1.627. <a name='FrequencyoftheMostFrequentElement'></a>1838. Frequency of the Most Frequent Element

[花花酱](https://www.bilibili.com/video/BV1Ai4y1P7Yt?spm_id_from=333.999.0.0)

###  1.628. <a name='ClosestRoom'></a>1847. Closest Room

[花花酱](https://www.bilibili.com/video/BV1cy4y1x7sz?spm_id_from=333.999.0.0)

###  1.629. <a name='StoneGameVIII'></a>1872. Stone Game VIII

[花花酱](https://www.bilibili.com/video/BV1vb4y1z7wx?spm_id_from=333.999.0.0)

###  1.630. <a name='s'></a>s
