<!-- vscode-markdown-toc -->
* 1. [206. 反转链表Reverse Linked List](#ReverseLinkedList)
* 2. [146. LRU缓存机制【构造🏰】LRU Cache](#LRULRUCache)
* 3. [3. 无重复字符的最长子串 【滑动窗口🔹】数组中重复的数字 Longest Substring Without Repeating Characters](#LongestSubstringWithoutRepeatingCharacters)
* 4. [215. 数组中的第K个最大元素（add）](#Kadd)
* 5. [25. K 个一组翻转链表（add）](#Kadd-1)
* 6. [912 补充题4. 手撕快速排序（add）](#add)
* 7. [15. 三数之和](#)
* 8. [53. 最大子序和53-【贪心🧡】Maximum subarray](#Maximumsubarray)
* 9. [1. 两数之和](#-1)
* 10. [21. 合并两个有序链表](#-1)
* 11. [141-Linked List Cycle](#LinkedListCycle)
* 12. [102-Binary Tree Level Order Traversal](#BinaryTreeLevelOrderTraversal)
* 13. [121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机](#BestTimetoBuyandSellStock121-)
* 14. [160-Intersection of Two Linked Lists](#IntersectionofTwoLinkedLists)
* 15. [88-Merge sorted array](#Mergesortedarray)
* 16. [103. Binary Tree Zigzag Level Order Traversal](#BinaryTreeZigzagLevelOrderTraversal)
* 17. [236-二叉树的最近公共祖先](#-1)
* 18. [20-Valid parentheses](#Validparentheses)
* 19. [5. 【回文🌈】Longest Palindromic Substring -最长回文🌈子串](#LongestPalindromicSubstring-)
* 20. [33. Search in Rotated Sorted Array](#SearchinRotatedSortedArray)
* 21. [200 【🍒并查集】岛屿数量](#-1)
* 22. [415-Add Strings](#AddStrings)
* 23. [46- ★ 全排列](#-1)
* 24. [92-Reverse Linked List II](#ReverseLinkedListII)
* 25. [142 Linked List Cycle II](#LinkedListCycleII)
* 26. [23. 【最小堆🌵】Merge k Sorted Lists](#MergekSortedLists)
* 27. [54. Spiral Matrix](#SpiralMatrix)
* 28. [300 【动态🚀规划 + 二分】Longest Increasing Subsequence 最长上升子序列](#LongestIncreasingSubsequence)
* 29. [704.Binary Search二分查找](#BinarySearch)
* 30. [42. Trapping Rain Water](#TrappingRainWater)
* 31. [232-【构造🏰】Implement Queue using Stacks](#ImplementQueueusingStacks)
* 32. [94-Inorder wih stack](#Inorderwihstack)
* 33. [144-Binary Tree Preorder Traversal](#BinaryTreePreorderTraversal)
* 34. [145-Binary Tree Postorder Traversal](#BinaryTreePostorderTraversal)
* 35. [199 Binary Tree Right Side View](#BinaryTreeRightSideView)
* 36. [143 Reorder List](#ReorderList)
* 37. [70. Climbing Stairs](#ClimbingStairs)
* 38. [124. Binary Tree Maximum Path Sum](#BinaryTreeMaximumPathSum)
* 39. [56. Merge Intervals](#MergeIntervals)
* 40. [剑指 Offer 22. 链表中倒数第k个节点](#Offer22.k)
* 41. [82. 删除排序链表中的重复元素 II(Remove Duplicates from Sorted List](#IIRemoveDuplicatesfromSortedList)
* 42. [69 Sqrt(x) 见 HJ107 求解立方根](#SqrtxHJ107)
* 43. [8. String to Integer(atoi)](#StringtoIntegeratoi)
* 44. [19-Remove Nth Node From End of List](#RemoveNthNodeFromEndofList)
* 45. [2. Add Two Numbers](#AddTwoNumbers)
* 46. [148. Sort List](#SortList)
* 47. [72. Edit Distance 72-编辑距离](#EditDistance72-)
* 48. [4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays](#MedianofTwoSortedArrays)
* 49. [105-从前序与中序遍历序列构](#-1)
* 50. [151. Reverse Words in a String](#ReverseWordsinaString)
* 51. [104-Maximum Depth of Binary](#MaximumDepthofBinary)
* 52. [76-【滑动窗口🔹】最小覆盖子串](#-1)
* 53. [31 ★ Next Permutation](#NextPermutation)
* 54. [239. ★【最小堆🌵 + 滑动窗口🔹单调队列】Sliding Window Maximum](#SlidingWindowMaximum)
        * 54.1. [不类似567，567类似187](#567567187)
* 55. [1143 【二维动态🚀规划】Longest Common Subsequence](#LongestCommonSubsequence)
        * 55.1. [类似题目：516最长回文🌈子序列](#516)
* 56. [129 Sum Root to Leaf Numbers](#SumRoottoLeafNumbers)
* 57. [93. 复原 IP 地址](#IP)
* 58. [110-Balanced Binary Tree](#BalancedBinaryTree)
* 59. [113. 二叉树中和为某一值的路径](#-1)
* 60. [22. Generate Parentheses](#GenerateParentheses)
* 61. [41 First Missing Positive](#FirstMissingPositive)
* 62. [543 Diameter of Binary Tree](#DiameterofBinaryTree)
* 63. [155-【构造🏰】Min Stack](#MinStack)
* 64. [98. Validate Binary Search Tree 98-验证二叉搜索树](#ValidateBinarySearchTree98-)
* 65. [470. Implement Rand10() Using Rand7()](#ImplementRand10UsingRand7)
* 66. [101-Symmetric tree](#Symmetrictree)
* 67. [32 Longest Valid Parentheses](#LongestValidParentheses)
* 68. [43. 字符串相乘](#-1)
* 69. [64. Minimum Path Sum 64-最小路径和](#MinimumPathSum64-)
* 70. [718. 最长重复子数组](#-1)
* 71. [78. Subsets 子集](#Subsets)
* 72. [112-Path Sum](#PathSum)
* 73. [48. 旋转图像 Rotate Image](#RotateImage)
* 74. [234. 【回文🌈】Palindrome Linked List](#PalindromeLinkedList)
* 75. [322. 【动态🚀规划 + 背包 + dfs】Coin Change](#dfsCoinChange)
* 76. [39. Combination Sum 39-组合总和](#CombinationSum39-)
* 77. [169. 【位运算😜】Majority Element](#MajorityElement)
* 78. [83-Remove duplicates from sorted array](#Removeduplicatesfromsortedarray)
* 79. [226-翻转二叉树](#-1)
* 80. [165. Compare Version Numbers](#CompareVersionNumbers)
* 81. [34-在排序数组中查找元素的第一个](#-1)
* 82. [153-寻找旋转排序数组中的最小值](#-1)
* 83. [62-不同路径](#-1)
* 84. [128. 【🍒并查集】Longest Consecutive Sequence](#LongestConsecutiveSequence)
* 85. [468 Validate IP Address](#ValidateIPAddress)
* 86. [136 【位运算😜】Single Number](#SingleNumber)
* 87. [162. Find Peak Element](#FindPeakElement)
* 88. [240. 二维数组的查找](#-1)
* 89. [221-【动态🚀规划】最大正方形](#-1)
* 90. [14-Longest common prefix](#Longestcommonprefix)
* 91. [179 Largest Number](#LargestNumber)
* 92. [138. 复制带随机指针的链表](#-1)
* 93. [695-岛屿的最大面积](#-1)
* 94. [剑指 Offer 36. 二叉搜索树与双向链表](#Offer36.)
* 95. [24-Swap Nodes in Pairs](#SwapNodesinPairs)
* 96. [394 Decode String](#DecodeString)
* 97. [198. 【动态🚀规划】House Robber 198-打家劫舍](#HouseRobber198-)
* 98. [209-长度最小的子数组](#-1)
* 99. [227 Basic Calculator II](#BasicCalculatorII)
* 100. [958. 二叉树的完全性检验](#-1)
* 101. [剑指 Offer 09. 用两个栈实现队列](#Offer09.)
* 102. [122. 买卖股票的最佳时机 II](#II)
* 103. [剑指 Offer 54. 二叉搜索树的第k大节点](#Offer54.k)
* 104. [283. 移动零](#-1)
* 105. [498. 对角线遍历](#-1)
* 106. [662. 二叉树最大宽度](#-1)
* 107. [297. 二叉树的序列化与反序列化](#-1)
* 108. [460. LFU缓存](#LFU)
* 109. [145. 二叉树的后序遍历](#-1)
* 110. [152. 乘积最大子数组](#-1)
* 111. [79. 单词搜索](#-1)
* 112. [补充题5. 手撕归并排序](#5.)
* 113. [剑指 Offer 10- I. 斐波那契数列](#Offer10-I.)
* 114. [剑指 Offer 10- II. 青蛙跳台阶问题](#Offer10-II.)
* 115. [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](#Offer21.)
* 116. [59. 螺旋矩阵 II](#II-1)
* 117. [补充题1. 排序奇升偶降链表](#1.)
* 118. [剑指 Offer 40. 最小的k个数](#Offer40.k)
* 119. [518. 零钱兑换 II](#II-1)
* 120. [224. 基本计算器](#-1)
* 121. [402. 移掉K位数字](#K)
* 122. [补充题23. 检测循环依赖](#23.)
* 123. [7. 整数反转](#-1)
* 124. [328. 奇偶链表](#-1)
* 125. [739. 每日温度](#-1)
* 126. [61. 旋转链表](#-1)
* 127. [剑指 Offer 62. 圆圈中最后剩下的数字](#Offer62.)
* 128. [剑指 Offer 51. 数组中的逆序对](#Offer51.)
* 129. [560. 和为K的子数组](#K-1)
* 130. [50. Pow(x, n)](#Powxn)
* 131. [补充题2. 圆环回原点问题](#2.)
* 132. [225. 用队列实现栈](#-1)
* 133. [230. 二叉搜索树中第K小的元素](#K-1)
* 134. [75. 颜色分类](#-1)
* 135. [47. 全排列 II](#II-1)
* 136. [11. 盛最多水的容器](#-1)
* 137. [139. 单词拆分](#-1)
* 138. [125. 验证回文串](#-1)
* 139. [189. 旋转数组](#-1)
* 140. [剑指 Offer 27. 二叉树的镜像](#Offer27.)
* 141. [74. 搜索二维矩阵](#-1)
* 142. [287. 寻找重复数](#-1)
* 143. [384. 打乱数组](#-1)
* 144. [329. 矩阵中的最长递增路径](#-1)
* 145. [349. 两个数组的交集](#-1)
* 146. [26. 删除排序数组中的重复项](#-1)
* 147. [40. 组合总和 II](#II-1)
* 148. [9. 回文数](#-1)
* 149. [剑指 Offer 52. 两个链表的第一个公共节点](#Offer52.)
* 150. [208. 实现 Trie (前缀树)](#Trie)
* 151. [440. 字典序的第K小数字](#K-1)
* 152. [123. 买卖股票的最佳时机 III](#III)
* 153. [135. 分发糖果](#-1)
* 154. [剑指 Offer 04. 二维数组中的查找](#Offer04.)
* 155. [207. 课程表](#-1)
* 156. [572. 另一个树的子树](#-1)
* 157. [10. 正则表达式匹配](#-1)
* 158. [55. 跳跃游戏](#-1)
* 159. [1047. 删除字符串中的所有相邻重复项](#-1)
* 160. [91. 解码方法](#-1)
* 161. [剑指 Offer 42. 连续子数组的最大和](#Offer42.)
* 162. [445. 两数相加 II](#II-1)
* 163. [213. 打家劫舍 II](#II-1)
* 164. [补充题9. 36进制加法](#9.36)
* 165. [剑指 Offer 45. 把数组排成最小的数](#Offer45.)
* 166. [509. 斐波那契数](#-1)
* 167. [295. 数据流的中位数](#-1)
* 168. [剑指 Offer 61. 扑克牌中的顺子](#Offer61.)
* 169. [106. 从中序与后序遍历序列构造二叉树](#-1)
* 170. [678. 有效的括号字符串](#-1)
* 171. [剑指 Offer 39. 数组中出现次数超过一半的数字](#Offer39.)
* 172. [86. 分隔链表](#-1)
* 173. [114. 二叉树展开为链表](#-1)
* 174. [剑指 Offer 29. 顺时针打印矩阵](#Offer29.)
* 175. [16. 最接近的三数之和](#-1)
* 176. [450. 删除二叉搜索树中的节点](#-1)
* 177. [347. 前 K 个高频元素](#K-1)
* 178. [剑指 Offer 53 - I. 在排序数组中查找数字 I](#Offer53-I.I)
* 179. [344. 反转字符串](#-1)
* 180. [191. 位1的个数](#-1)
* 181. [443. 压缩字符串](#-1)
* 182. [400. 第N个数字](#N)
* 183. [242. 有效的字母异位词](#-1)
* 184. [100. 相同的树](#-1)
* 185. [459. 重复的子字符串](#-1)
* 186. [442. 数组中重复的数据](#-1)
* 187. [120. 三角形最小路径和](#-1)
* 188. [268. 缺失数字](#-1)
* 189. [887. 鸡蛋掉落](#-1)
* 190. [剑指 Offer 34. 二叉树中和为某一值的路径](#Offer34.)
* 191. [557. 反转字符串中的单词 III](#III-1)
* 192. [补充题14. 阿拉伯数字转中文数字](#14.)
* 193. [168. Excel表列名称](#Excel)
* 194. [1095. 山脉数组中查找目标值](#-1)
* 195. [670. 最大交换](#-1)
* 196. [剑指 Offer 11. 旋转数组的最小数字](#Offer11.)
* 197. [210. 课程表 II](#II-1)
* 198. [525. 连续数组](#-1)
* 199. [剑指 Offer 48. 最长不含重复字符的子字符串](#Offer48.)
* 200. [556. 下一个更大元素 III](#III-1)
* 201. [111. 二叉树的最小深度](#-1)
* 202. [37. 解数独](#-1)
* 203. [134. 加油站](#-1)
* 204. [补充题22. IP地址与整数的转换](#22.IP)
* 205. [876. 链表的中间结点](#-1)
* 206. [63. 不同路径 II](#II-1)
* 207. [171. Excel表列序号](#Excel-1)
* 208. [17. 电话号码的字母组合](#-1)
* 209. [494. 目标和](#-1)
* 210. [剑指 Offer 03. 数组中重复的数字](#Offer03.)
* 211. [剑指 Offer 24. 反转链表](#Offer24.)
* 212. [剑指 Offer 33. 二叉搜索树的后序遍历序列](#Offer33.)
* 213. [862. 和至少为 K 的最短子数组](#K-1)
* 214. [343. 整数拆分](#-1)
* 215. [673. 最长递增子序列的个数](#-1)
* 216. [面试题 17.24. 最大子矩阵](#17.24.)
* 217. [611. 有效三角形的个数](#-1)
* 218. [45. 跳跃游戏 II](#II-1)
* 219. [154. 寻找旋转排序数组中的最小值 II](#II-1)
* 220. [85. 最大矩形](#-1)
* 221. [679. 24 点游戏](#-1)
* 222. [108. 将有序数组转换为二叉搜索树](#-1)
* 223. [222. 完全二叉树的节点个数](#-1)
* 224. [84. 柱状图中最大的矩形](#-1)
* 225. [71. 简化路径](#-1)
* 226. [167. 两数之和 II - 输入有序数组](#II-)
* 227. [622. 设计循环队列](#-1)
* 228. [6. Z 字形变换](#Z)
* 229. [96. 不同的二叉搜索树](#-1)
* 230. [547. 省份数量（原朋友圈）](#-1)
* 231. [264. 丑数 II](#II-1)
* 232. [706. 设计哈希映射](#-1)
* 233. [97. 交错字符串](#-1)
* 234. [410. 分割数组的最大值](#-1)
* 235. [44. 通配符匹配](#-1)
* 236. [18. 四数之和](#-1)
* 237. [405. 数字转换为十六进制数](#-1)
* 238. [补充题8. 计算数组的小和](#8.)
* 239. [863. 二叉树中所有距离为 K 的结点](#K-1)
* 240. [337. 打家劫舍 III](#III-1)
* 241. [166. 分数到小数](#-1)
* 242. [面试题 08.12. 八皇后](#08.12.)
* 243. [73. 矩阵置零](#-1)
* 244. [剑指 Offer 46. 把数字翻译成字符串](#Offer46.)
* 245. [503. 下一个更大元素 II](#II-1)
* 246. [763. 划分字母区间](#-1)
* 247. [340. 至多包含 K 个不同字符的最长子串](#K-1)
* 248. [130. 被围绕的区域](#-1)
* 249. [117. 填充每个节点的下一个右侧节点指针 II](#II-1)
* 250. [剑指 Offer 07. 重建二叉树](#Offer07.)
* 251. [378. 有序矩阵中第K小的元素](#K-1)
* 252. [剑指 Offer 32 - III. 从上到下打印二叉树 III](#Offer32-III.III)
* 253. [77. 组合](#-1)
* 254. [528. 按权重随机选择](#-1)
* 255. [279. 完全平方数](#-1)
* 256. [257. 二叉树的所有路径](#-1)
* 257. [692. 前K个高频单词](#K-1)
* 258. [剑指 Offer 50. 第一个只出现一次的字符](#Offer50.)
* 259. [137. 只出现一次的数字 II](#II-1)
* 260. [补充题21. 字符串相减](#21.)
* 261. [354. 俄罗斯套娃信封问题](#-1)
* 262. [253. 会议室 II](#II-1)
* 263. [628. 三个数的最大乘积](#-1)
* 264. [674. 最长连续递增序列](#-1)
* 265. [剑指 Offer 57 - II. 和为s的连续正数序列](#Offer57-II.s)
* 266. [315. 计算右侧小于当前元素的个数](#-1)
* 267. [107. 二叉树的层次遍历 II](#II-1)
* 268. [172. 阶乘后的零](#-1)
* 269. [647. 回文子串](#-1)
* 270. [260. 只出现一次的数字 III](#III-1)
* 271. [188. 买卖股票的最佳时机 IV](#IV)
* 272. [剑指 Offer 35. 复杂链表的复制](#Offer35.)
* 273. [12. 整数转罗马数字](#-1)
* 274. [386. 字典序排数](#-1)
* 275. [752. 打开转盘锁](#-1)
* 276. [395. 至少有K个重复字符的最长子串](#K-1)
* 277. [231. 2的幂](#-1)
* 278. [977. 有序数组的平方](#-1)
* 279. [437. 路径总和 III](#III-1)
* 280. [617. 合并二叉树](#-1)
* 281. [60. 第k个排列](#k)
* 282. [28. 实现 strStr()](#strStr)
* 283. [204. 计数质数](#-1)
* 284. [剑指 Offer 65. 不用加减乘除做加法](#Offer65.)
* 285. [416. 分割等和子集](#-1)
* 286. [51. N皇后](#N-1)
* 287. [补充题24. 双栈排序](#24.)
* 288. [680. 验证回文字符串 Ⅱ](#-1)
* 289. [剑指 Offer 38. 字符串的排列](#Offer38.)
* 290. [701. 二叉搜索树中的插入操作](#-1)
* 291. [530. 二叉搜索树的最小绝对差](#-1)
* 292. [698. 划分为k个相等的子集](#k-1)
* 293. [173. 二叉搜索树迭代器](#-1)
* 294. [426. 将二叉搜索树转化为排序的双向链表](#-1)
* 295. [836. 矩形重叠](#-1)
* 296. [99. 恢复二叉搜索树](#-1)
* 297. [316. 去除重复字母](#-1)
* 298. [109. 有序链表转换二叉搜索树](#-1)
* 299. [115. 不同的子序列](#-1)
* 300. [1312. 让字符串成为回文串的最少插入次数](#-1)

<!-- vscode-markdown-toc-config
    numbering=true
    autoSave=true
    /vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

[Hive SQL面试题(附答案)](https://mp.weixin.qq.com/s/4C4wQdaLdtLuTADi16dEsA)

# 1 day (得分 = 30分) 30

##  1. <a name='ReverseLinkedList'></a>206. 反转链表Reverse Linked List

https://leetcode-cn.com/problems/reverse-linked-list/submissions/

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7zr?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV16Q4y1M767?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        res = None
        while head:
            headnxt = head.next
            head.next = res
            res = head
            head = headnxt
        return res
```

```scala
/**
* time complexity: O(n)
* space complexity: O(1) 
*/
object Solution {
    def reverseList(head: ListNode): ListNode = {
        var res: ListNode = null
        var pre = head

        while (pre != null) {
            val prenxt = pre.next
            pre.next = res
            res = pre
            pre = prenxt
        }
        res
    }
}

```

##  2. <a name='LRULRUCache'></a>146. LRU缓存机制【构造🏰】LRU Cache 

https://leetcode-cn.com/problems/lru-cache/submissions/

[花花酱](https://www.bilibili.com/video/BV19b411c7ue?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7c6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1t7zj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ZQ4y1A74H?spm_id_from=333.999.0.0)

```py
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = collections.OrderedDict()


    def get(self, key: int) -> int:
        if key in self.cache:
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
        return -1


    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        if len(self.cache) == self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value

```

```scala

/**
* chosen solution
* build-in linkedHashMap
* time complexity: O(1)
*/
class LRUCache(_capacity: Int) {

    private val capacity = _capacity
    val cache = collection.mutable.LinkedHashMap[Int, Int]()


    def get(key: Int): Int = {
        cache.get(key) match {
            case Some(v) => 
                cache.remove(key)
                cache.put(key, v)
                v
            case None => -1
        }
    }

    def put(key: Int, value: Int): Unit = {
        cache.get(key) match {
            case Some(_) =>
                cache.remove(key)
                cache.update(key, value)

            case None =>
                if(cache.size >= capacity){
                cache.remove(cache.head._1)
                }
                cache.put(key, value)
        }   

    }
}

```

##  3. <a name='LongestSubstringWithoutRepeatingCharacters'></a>3. 无重复字符的最长子串 【滑动窗口🔹】数组中重复的数字 Longest Substring Without Repeating Characters

https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

[哈哈哈](https://www.bilibili.com/video/BV1h54y1B7No?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1CJ411G7Nn?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1va4y1J7Gx?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ob411n7mv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K411M7d2?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DK4y1b7xp?spm_id_from=333.999.0.0)

涉及 sub 的问题，可以使用 “滑动窗口”

特殊情况：

* 时间复杂度: O(n) + hashset判断是否重复O(n)
  
```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dic = {}
        leftI = 0
        res = 0
        for rightI, char in enumerate(s):
            # char 重复出现，并且 上一个出现 在窗口内部
            # 含义为"tmmzuxt", start在m，当有新的t进来时，上一个t在start的前面，所以，此时的start不需要修改
            if char in dic and leftI <= dic[char]:      # 易错点: and start <= dic[char]: 
                leftI = dic[char] + 1        # 易错点: 这里的dic[char]还是前一个,且 +1
            else:
                res = max(res, rightI - leftI + 1) # 易错点: +1
            dic[char] = rightI         # 易错点: dic[char]滞后更新
        return res
    
```

```scala
/**
* my first commit
* sliding windows
*  time  complexity: O(N), worst: O(2N) -> each char was visited twice
*/
object Solution1 {
    def lengthOfLongestSubstring(s: String): Int = {
        var right = 0
        var left = 0
        var current = ""
        var ret = ""
        
        while(right < s.length) {
            val char = s(right)
            if (current.contains(char)){
                current = current.drop(1)
                left += 1
                 
            }else {
                right += 1
                current += char
            }     
            if(current.length > ret.length) ret = current
        }
        ret.length
    }
}

```

##  4. <a name='Kadd'></a>215. 数组中的第K个最大元素（add）

https://leetcode-cn.com/problems/kth-largest-element-in-an-array/

```py
时间复杂度就是nlogn
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        q = []
        for num in nums:
            # n*log(k+1)
            heapq.heappush(q, num)
            if len(q) > k:
                # n*log(k)
                heapq.heappop(q)
        return heapq.heappop(q)

输入: [3,2,1,5,6,4] 和 k = 2
[1, 3, 2]
[2, 3, 5]
[3, 5, 6]
[4, 6, 5]
```

```py
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k]
```

##  5. <a name='Kadd-1'></a>25. K 个一组翻转链表（add）

https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/dong-hua-yan-shi-di-gui-25-kge-yi-zu-fan-y6hv/

```py
递归
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        cur = head
        cnt = 0
        while cur and cnt != k:
            cur = cur.next
            cnt += 1
        if cnt == k:
            cur = self.reverseKGroup(cur,k)
            while cnt:
                headnxt = head.next
                head.next = cur
                cur = head
                head = headnxt
                cnt -= 1
            head = cur # 易错点: 这一步不能漏
        return head # head 进来，head 返回


```

##  6. <a name='add'></a>912 补充题4. 手撕快速排序（add）

https://leetcode-cn.com/problems/sort-an-array/submissions/

快速排序:

```py
class Solution:
    # 这里需要用到 pivot
    def randomized_partition(self, nums, l, r):
        pivot = random.randint(l, r)
        # 先把 nums[pivot] 靠边站
        nums[pivot], nums[r] = nums[r], nums[pivot]
        i = l - 1
        for j in range(l, r):
            if nums[j] < nums[r]: # nums[r] 就是 pivot
                i += 1
                nums[j], nums[i] = nums[i], nums[j] # nums[i] 存的都是较小的数字
        i += 1
        nums[i], nums[r] = nums[r], nums[i] # pivot 放到中间
        return i
    # 这里需要用到 mid
    def randomized_quicksort(self, nums, l, r):
        if r - l <= 0:
            return
        mid = self.randomized_partition(nums, l, r)
        self.randomized_quicksort(nums, l, mid - 1)
        self.randomized_quicksort(nums, mid + 1, r)

    def sortArray(self, nums: List[int]) -> List[int]:
        self.randomized_quicksort(nums, 0, len(nums) - 1)
        return nums

时间复杂度：O(n log(n))
空间复杂度：O(log n) ~ O(n)
```



```py
堆排序:

     0
    / \
   1   2
  / \ / \
 3  4 5  6

class Solution:
    def max_heapify(self, heap, root, heap_len):
        p = root
        while p * 2 + 2 <= heap_len: # 当不是叶子节点
            l, r = p * 2 + 1, p * 2 + 2 # 代表左右结点
            if r < heap_len and heap[l] < heap[r]:
                bigger = r
            else:
                bigger = l
            # 把最大的元素往上提
            if heap[p] < heap[bigger]:
                heap[p], heap[bigger] = heap[bigger], heap[p]
                p = bigger
            else:
                break
        
    def sortArray(self, nums: List[int]) -> List[int]:
        # 时间复杂度O(N)
        # 从叶子节点开始遍历
        # 如果不是从叶子开始，可能白跑一遍
        for i in range(len(nums) - 1, -1, -1):
            self.max_heapify(nums, i, len(nums))
            
        # 时间复杂度O(N logN)
        for i in range(len(nums) - 1, -1, -1):
            # 把最大的元素放到末尾
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)
        return nums

时间复杂度：O(n log(n))
空间复杂度：O(1)
```

归并排序:

```py
class Solution:
    def merge_sort(self, nums, l, r):
        if l == r:
            return
        mid = (l + r) // 2
        # 先把子序列排序完成
        self.merge_sort(nums, l, mid)
        self.merge_sort(nums, mid + 1, r)
        tmp = []
        i, j = l, mid + 1   # i, j 是两个起始点
        while i <= mid or j <= r:
            # 如果 前半部部分结束了，或者后半部分没有结束
            if i > mid or (j <= r and nums[j] < nums[i]): # 因为前面是or，所以这里必须是对i进行约束
                tmp.append(nums[j])
                j += 1
            else:
                tmp.append(nums[i])
                i += 1

        nums[l: r + 1] = tmp

    def sortArray(self, nums: List[int]) -> List[int]:
        self.merge_sort(nums, 0, len(nums) - 1)
        return nums

时间复杂度：O(n log(n))
空间复杂度：O(n)
```

```py
排序问题各有各的招，我来说一个凑热闹的桶排序。反正所有数字在正负五万之间，你就拿100001个桶，遍历一遍把数字仍对应的桶里边，然后你就排好了。

class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        bucket = collections.defaultdict(int)
        for n in nums:
            bucket[n] += 1
        ans = []
        for i in range(-50000, 50001):
            ans += [i] * bucket[i]
        return ans
你一看这方法能行啊，复杂度也低！那为啥不经常用呢？你猜？你想想要有小数可咋整？
```

##  7. <a name=''></a>15. 三数之和

https://leetcode-cn.com/problems/3sum/

[花花酱](https://www.bilibili.com/video/BV1wp4y1W72o?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Tb411578b?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19K4y1s7co?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19i4y1s7VZ?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n3)

* 时间复杂度:O(1)

双指针法：

先排序：时间复杂度:O(n log(n)) + O(n2)

```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        # nums.sort() # 另一种写法
        nums = sorted(nums)
        res = []
        for i in range(n-2):
            # 优化部分：
            if nums[i] > 0: break
            if nums[i] + nums[i+1] + nums[i+2] > 0: break
            # 这个写法不对：if i+1 < n-2 and nums[i] == nums[i+1]: continue
            # 这样可能直接跳过了[-1,-1,2,3]的前三个
            # 这个写法是正确的↓：
            if i - 1 >= 0 and nums[i] == nums[i-1]: continue
            if nums[i] + nums[n-2] + nums[n-1] < 0: continue
            # 双指针部分：
            left = i + 1
            right = n - 1
            while left < right: 
                if nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                elif nums[i] + nums[left] + nums[right] < 0:
                    left += 1
                else:
                    res.append([nums[i],nums[left],nums[right]])
                    # 去重：
                    while nums[left] == nums[left + 1] and left + 1 < right: # 注意边界
                        left += 1
                    left +=1
                    while nums[right] == nums[right - 1] and left < right - 1: # 注意边界
                        right -= 1
                    right -=1
        return res
```

```scala
/**
* my first commit
* hashset in twoSum
* a very time consuming version
* O(N^2)
*/
object Solution1 {
  def threeSum(nums: Array[Int]): List[List[Int]] = {

      val l = nums.groupBy(identity).mapValues(aa => if(aa.length >=3) aa.take(3) else aa ).values.flatten.toList

     l.zipWithIndex.flatMap {
      case (value, index) =>
        val ll = collection.mutable.ListBuffer(l: _*)
        ll.remove(index)

        twoSum(ll.toList, -value).filter(_.nonEmpty)
          .map(_ :+ value)
    }.map(pair => (pair.toSet, pair)).toMap.values.toList

  }

   def twoSum(nums: List[Int], target: Int): List[List[Int]] = {
    val valueCounter = nums.groupBy(identity).mapValues(_.length)

    nums.collect {
      case value if target - value == value && valueCounter.get(target - value).exists(_ >= 2) =>
        List(value, target - value)
      case value if target - value != value && valueCounter.contains(target - value) =>
        List(value, target - value)

    }
  }

}


```

##  8. <a name='Maximumsubarray'></a>53. 最大子序和53-【贪心🧡】Maximum subarray

https://leetcode-cn.com/problems/maximum-subarray/

[哈哈哈](https://www.bilibili.com/video/BV1QJ411R75H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7dn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11A41187AR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ta4y1i7Sh?spm_id_from=333.999.0.0)

贪心

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5qrso4wuc440.png)

```py
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = preSum = nums[0]
        for num in nums[1:]:
            preSum = max(preSum + num, num)
            res = max(res, preSum)
        return res
```

时间复杂度：O(n)
时间复杂度：O(1)

```scala
object Solution {
    def maxSubArray(nums: Array[Int]): Int = {
        for (i <- Range(1, nums.length)) {
            if (nums(i-1) > 0) {
                nums(i) += nums(i-1)
            }
        }
        nums.max
    }
}
```

##  9. <a name='-1'></a>1. 两数之和


[哈哈哈](https://www.bilibili.com/video/BV1rE411Y7UN?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV19b411v7qp?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zf4y1G7W4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rv411k7VY?spm_id_from=333.999.0.0)

暴力求解：

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i] + nums [j] == target:
                    return [i,j]
```

查找表法:

* 哈希表(不需要维护表的顺序性)

* 平衡二叉搜素树

* 时间复杂度:O(n)

* 时间复杂度:O(n)

```py
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i, num in enumerate(nums):
            if num in dic:
                return [dic[num], i]
            dic[target - num] = i
```

```scala
/**
* chosen solution
* time complexity: O(N)
*/


object Solution0 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}


/**
* more elegant
*/


object Solution1-2 {
  def twoSum(nums: Array[Int], target: Int): Array[Int] = {
    val value2Idx = nums.zipWithIndex.toMap
    nums.zipWithIndex.collectFirst {
      case (value, index) if value2Idx.get(target - value).exists(_ != index) =>
        Array(index, value2Idx(target - value))
    }.get
  }
}
```

##  10. <a name='-1'></a>21. 合并两个有序链表

https://leetcode-cn.com/problems/merge-two-sorted-lists/

[哈哈哈](https://www.bilibili.com/video/BV1rJ41127ry?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7D7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1my4y127bK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1qZ4y1j7Jb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ck4y1k7J9?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(M+N)

* 时间复杂度:O(1)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        cur = dummy # dummy是固定节点，cur是移动指针
        while list1 and list2: # 这里是and
            if list1.val < list2.val: # 易错点：这里是list.val，而不是list
                cur.next = list1
                list1 = list1.next # 向后进一位
            else:
                cur.next = list2
                list2 = list2.next # 向后进一位
            cur = cur.next # 向后进一位
        cur.next = list1 or list2 # 易错点：这里是cur.next，而不是cur。这里是or
        # 等效于：
        # if list1:
        #     cur.next = list1
        # else:
        #     cur.next = list2
        return dummy.next
```

递归解法：

* 时间复杂度:O(M+N)

* 时间复杂度:O(M+N)

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        elif not list2:
            return list1
        elif list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2) # 找到较小头结点，提取出来
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next) # 找到较小头结点，提取出来
            return list2
```

```scala
/**
* iterative version
* time complexity: O(N + M), N is the length of l1, M is the length of l2
*/
object Solution1 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        val headNode = new ListNode(-1, null)
        var cur = headNode
        
        var no1 = l1;
        var no2 = l2;
        
        while(no1 != null && no2 != null) {
            if (no1.x >= no2.x){
                
                cur.next = no2
                no2 = no2.next
            }else {
                cur.next = no1
                no1 = no1.next
            }
            cur = cur.next
        }
        (no1, no2) match {
            case (_, null) => cur.next = no1
            case (null, _) => cur.next = no2
            case _ => throw new RuntimeException()
        }
        
        headNode.next
    }
}



/**
* recursive version
*/

object Solution1-2 {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
        (l1, l2) match {
            case (null, _) => l2
            case (_, null) => l1
            case (a, b) => 
                if (a.x >= b.x){
                    b.next = mergeTwoLists(b.next, a)
                    b
                } else {
                    a.next = mergeTwoLists(a.next, b)
                    a   
                }
        }
    }
}

object Solution {
    def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = {
    if(l1 == null) return l2
    if(l2 == null) return l1

    if (l1.x < l2.x) {
      l1.next = mergeTwoLists(l1.next, l2)
      l1
    } else {
      l2.next = mergeTwoLists(l1, l2.next)
      l2
    }
  }
}

```

##  11. <a name='LinkedListCycle'></a>141-Linked List Cycle

https://leetcode-cn.com/problems/linked-list-cycle/

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7ta?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411H7XP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1KX4y157vh?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1PA411b7gq?spm_id_from=333.999.0.0)

```py
方法一：集合 如果发现节点已在集合内则说明存在环

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            visited.add(head)
            head = head.next
            if head in visited:
                return True
        return False

感觉初始时把快慢指针都指向 head 反而更简洁：

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
        
```


```scala
object Solution1 {
    def hasCycle(head: ListNode): Boolean = {
        
        var cur = head
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        
        var res: Boolean = false
        while (cur != null && res != true) {

            if(visited.contains(cur))  
                res = true
            else {
                visited += cur
                cur = cur.next
            }
        }
        res
    }
}


object Solution3 {
    def hasCycle(head: ListNode): Boolean = {
        var fast = head
        var slow = head
        
        
        var result = false
        while (fast != null && fast.next != null && result != true) {
            fast = fast.next.next
            slow = slow.next
        
            if(fast == slow) result = true
        }
        result
    }
}
```


##  12. <a name='BinaryTreeLevelOrderTraversal'></a>102-Binary Tree Level Order Traversal

https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

[哈哈哈](https://www.bilibili.com/video/BV1W54y197Lc?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14T4y1u7Wk?spm_id_from=333.999.0.0)

> python queue

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)): # 当前层的个数!!!
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res


from collections import deque
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []

        queue = deque([root]) 
        res = []
        
        while queue: 
            level = [] 
            for _ in range(len(queue)): 
                node = queue.popleft() 
                level.append(node.val) 
                if node.left:
                    queue.append(node.left) 
                if node.right:
                    queue.append(node.right) 
            res.append(level) 
        return res
```


> python 递归


```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []

        def bfs(node, level):
            if node: 
                if len(res) < level + 1:
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0)
        return res

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        dic = collections.defaultdict(list)

        def bfs(node, level):
            if node:
                dic[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0) 
        return [*dic.values()]
```

> scala queue

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val buffer =  scala.collection.mutable.Queue[TreeNode]()
        val res =  scala.collection.mutable.ListBuffer[List[Int]]()

        if(root == null) return List[List[Int]]()
        buffer.enqueue(root)
    
        while(buffer.nonEmpty) {
          val cur = scala.collection.mutable.ListBuffer[Int]()
          for ( _ <- 0 until buffer.size) {
            val node = buffer.dequeue
            cur.append(node.value)
            if(node.left != null) buffer.enqueue(node.left)
            if(node.right != null) buffer.enqueue(node.right)
        }
        res += cur.toList
        }
        res.toList
    }
}
```

> scala 递归

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val oderMap = scala.collection.mutable.Map[Int, List[Int]]()
        bfs(root, 1, oderMap)
        oderMap.values.toList
    }
    def bfs(node: TreeNode, level: Int, map: scala.collection.mutable.Map[Int, List[Int]]): Unit = {
        if (node != null) {
            val l = map.get(level)
                .map(_ :+ node.value)
                .getOrElse(List(node.value))

            map(level) = l
            bfs(node.left, level + 1, map)
            bfs(node.right, level + 1, map)
        }
    }
}
```

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        bfs(if(root == null) List() else List(root), List())
    }

    // @annotation.tailrec
    // @annotation.tailrec 告诉编译器，下面这个函数是递归的，在栈桢的管理上，希望编译器能所有优化。
    def bfs(queue: List[TreeNode], ans: List[List[Int]]): List[List[Int]] = {
        if(queue.isEmpty) ans
        else{
        bfs(queue.flatMap(n => List(n.left, n.right)).filter(_ != null), ans :+ queue.map(n => n.value))
        }
    }
}
```

##  13. <a name='BestTimetoBuyandSellStock121-'></a>121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机

https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

[花花酱](https://www.bilibili.com/video/BV1oW411C7UB?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1cZ4y1K7HP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1D7411s7A1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7by?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16z4y1Z7jD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1hA411t76C?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        minprice = 1e9
        for price in prices:
            maxprofit = max(maxprofit,price - minprice)
            minprice = min(minprice,price)
        return maxprofit
```

```scala
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices.foldLeft((Int.MaxValue, 0)){
            case ((minPriceSoFar, maxProfit), price) => (minPriceSoFar min price, maxProfit max (price - minPriceSoFar))
        }._2
    }
}
```

##  14. <a name='IntersectionofTwoLinkedLists'></a>160-Intersection of Two Linked Lists

https://leetcode-cn.com/problems/intersection-of-two-linked-lists/

[哈哈哈](https://www.bilibili.com/video/BV1n741187X6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411H7uq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K4y1J7wx?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1np4y1y789?spm_id_from=333.999.0.0)

```py
## 1. 哈希表

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        visited = set()
        while headA:
            visited.add(headA)
            headA = headA.next
        while headB:
            if headB in visited:
                return headB
            headB = headB.next
        return None

# > 时间复杂度 $O(M+N)$, 空间复杂度 $O(M)$

## 2. 双指针

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        pa,pb = headA, headB
        while pa != pb:
            pa = pa.next if pa else headB
            pb = pb.next if pb else headA
        return pa

# > 时间复杂度 $O(M+N)$, 空间复杂度 $O(1)$
```


```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {
        var ha = headA
        var hb = headB
        
        while(ha != hb){
            if(ha == null){
                ha = headB
            }else{
                ha = ha.next
            }
            
            if(hb == null){
                hb = headA
            }else{
                hb = hb.next
            }
        }
        
        ha
    }
}

```

##  15. <a name='Mergesortedarray'></a>88-Merge sorted array

https://leetcode-cn.com/problems/merge-sorted-array/

[哈哈哈](https://www.bilibili.com/video/BV14J411X7JE?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7bg?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1g54y1s7ZG?spm_id_from=333.999.0.0)

直接合并后排序

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 三个指针
        cur1 = m - 1
        cur2 = n - 1
        i = m + n -1
        # 从后往前遍历
        while cur1 >= 0 and cur2 >= 0:
            if nums1[cur1] < nums2[cur2]:
                nums1[i] = nums2[cur2]
                cur2 -= 1
            else:
                nums1[i] = nums1[cur1]
                cur1 -= 1
            i -= 1
        # 如果后面的那个n还有多余
        if cur2 >= 0:
            nums1[:cur2+1] = nums2[:cur2+1] # 易错点：不包括右边界

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()
```

```scala
object Solution {
    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {
        var trail = m+n-1
        
        var t1 = m-1
        var t2 = n-1
        
        while(t1 > -1 && t2 > -1){
            val e1 = nums1(t1)
            val e2 = nums2(t2)
            
            if(e1 > e2){
                nums1(trail) = e1
                t1 -= 1
                trail -= 1
            }else{
                nums1(trail) = e2
                t2 -= 1
                trail -= 1
            }
        }
        
        if(t1 == -1){
            while(t2 > -1){
                nums1(trail) = nums2(t2)
                t2 -= 1
                trail -= 1
            }
        }else{
            while(t1 > -1){
                nums1(trail) = nums1(t1)
                t1 -= 1
                trail -= 1
            }
        }
        
    }
}

```

##  16. <a name='BinaryTreeZigzagLevelOrderTraversal'></a>103. Binary Tree Zigzag Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1NE411M7Fm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15h411Z7h5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GA411W7NY?spm_id_from=333.999.0.0)

> python 队列

```py
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: 
            return []

        queue = [root]
        res = []
        indexflag = 1 
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

```

递归

```py
class Solution:
    def zigzagLevelOrder(self, root):
        res = []
        def bfs(node, level):
            if node:
                if level >= len(res):
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0)
        for i in range(1, len(res), 2): # flag，各两个逆序
            res[i] = res[i][::-1]
        return res
```

##  17. <a name='-1'></a>236-二叉树的最近公共祖先

[哈哈哈](https://www.bilibili.com/video/BV1ov411172r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411p7dr?spm_id_from=333.999.0.0)

```py
# Python 超越99%执行速度的解法：而且也简短

class Solution:
    def lowestCommonAncestor(self, root, p, q) -> 'TreeNode':

        if root in (None, p, q):
            return root 

        L = self.lowestCommonAncestor(root.left, p, q)
        R = self.lowestCommonAncestor(root.right, p, q)

        return R if None == L else L if None == R else root
```

```scala
/**
*  chosen solution
*  DFS with recursive
*  time complexity O(N), N is the number of node in the tree
*  space complexity O(N)
*/
object Solution0 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }

  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    if (node == null || node == p || node == q) return node
    /**
    *  1. if p and q are node 's child, return p q 's LCA 
    *  2.  if p and q are not node's child return null
    *  3. if p and q, only one of then ar node's child return that node (p or q)
    */
    val left = _lowestCommonAncestor(node.left, p, q)
    val right = _lowestCommonAncestor(node.right, p, q)

    (left, right) match {
      case (null, _) => right  // p and q are both not in left
      case (_, null) => left  // p and q are both not in right
      case (l, r) =>  node // only lowest common ancestor could return both non null node
      // p and q, one of then in left and the other one in right
    }
  }
}
```

##  18. <a name='Validparentheses'></a>20-Valid parentheses

[哈哈哈](https://www.bilibili.com/video/BV1DJ41127uA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7ek?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Hr4y1M7Sc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1sC4y1H7Hs?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1QA411L7y7?spm_id_from=333.999.0.0)

先进后出，所以用栈

* 时间复杂度:O(n)

* 时间复杂度:O(n)

```py
# 这道题背一背！
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{':'}','[':']','(':')'}
        stack = [] # stack 要提前定义好
        for char in s:
            if char in dic: # 是“key”
                stack.append(char) # 一个char进来，要么被append
            elif not stack or dic[stack.pop()] != char: 
                # 如果上一步不被append就是不对的
                # 如果这一步不匹配也是不对
                return False
        return not stack # 如果append上了，但没有被完全pop也是不对的
```

```scala
/**
* my first commitment
* using stack
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def isValid(s: String): Boolean = {
        if(s.isEmpty || s.length % 2 != 0) return false
        val stack = scala.collection.mutable.Stack[Char]()
        
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')

        s.foreach{c => 
            
            if (mapping.contains(c)){
                stack push c
            }else{
                if(stack.isEmpty || mapping(stack.pop) != c) return false 
             
            }
        }
        stack.isEmpty
        
    }
}


/**
* using stack X FP
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1-3 {
    def isValid(s: String): Boolean = {
        val mapping = Map('(' -> ')', '{' -> '}', '[' -> ']')
        
        s.foldLeft(List.empty[Char]){ (stack, c) => 
            stack match {
                case pop :: stackAfterPop if  c.equals(mapping.getOrElse(pop, None)) => stackAfterPop
                case _ => c +: stack
            }
           
        }.isEmpty
        
    }
}

```

##  19. <a name='LongestPalindromicSubstring-'></a>5. 【回文🌈】Longest Palindromic Substring -最长回文🌈子串

[花花酱](https://www.bilibili.com/video/BV18J411j7Pb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1ra4y1Y7Gx?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7P6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1so4y1o765?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1L54y1D7pa?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n3),在两个for循环里面，还做了一次遍历

* 时间复杂度:O(1)

中心扩散法：

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.4sfvjkqc4qo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ur1lzo89kk0.png)

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s


        def palinLen(l,r) -> int:
            while l >= 0 and r < lenStr and s[l] == s[r]: # 注意：边界
                l -= 1
                r += 1
            return r - l - 1 # 注意：是 “-1”

        start = 0  
        end = 1 # 注意：在第一次的时候，end = 1
        maxmaxLen = maxLen = 1

        for mid in range(lenStr):
            maxLen = max(palinLen(mid, mid), palinLen(mid, mid + 1))
            
            if maxLen > maxmaxLen:
                maxmaxLen = maxLen
                start = mid - (maxLen - 1) // 2 #易错点：-1，最好背一背
                end = start + maxLen
        return s[start:end]
```

动态规划法：

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.67y5euem0vo0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.90ngy2t8j3k.png)

* 时间复杂度:O(n2)

* 时间复杂度:O(n2)

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        lenStr = len(s)
        maxlen = maxmaxlen = 1
        start = 0

        if lenStr == 0:
            return ''

        if lenStr == 1:
            return s

        dp = [[False for _ in range(lenStr)] for _ in range(lenStr)]
        for i in range(lenStr):
            dp[1][1] = True 
            # dp[1][1]是正确写法，dp[1,1]是错误写法

        for j in range(1, lenStr): # 把三角形画出来，先j，再i，
            for i in range(j): # 先框定结束j，再框定开始i。
                if s[i] == s[j]:
                    if j - i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                if dp[i][j]:
                    maxlen = j - i + 1
                    if maxlen > maxmaxlen:
                        maxmaxlen = maxlen
                        start = i
        return s[start: start + maxmaxlen]
```


```scala
/**
* chosen solution
* expand around center
* time complexity: O(N * 2 * N) = O(N^2)
*        expandLengths: O(N)
* space complexity: O(1)
*/

object Solution0 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty) return ""
        
        // 0 1 2 3 4 5 6 7
        // r a c e c a r
        // r a c e e c a r
        // b b c e c a a
        val (head, maxlen) = s.indices.foldLeft((0, 1)){
            case ((h, maxlen), i) => 
                val oddlen =  expandLengths(s, i, i)
                val evenlen = expandLengths(s, i, i + 1)
                val len = oddlen max evenlen
                if(len > maxlen)  (i -  (len - 1) / 2, len)
                else (h, maxlen)
        }
        s.slice(head, head + maxlen)
    }
    // return length
    @annotation.tailrec
    def expandLengths(s: String, left: Int, right: Int): Int = {
        if(0 <= left && right < s.length && s(left) == s(right)) expandLengths(s, left - 1, right + 1)
        else right - left - 1
    }
}

/**
* dynamic programming
*/
object Solution3 {
    def longestPalindrome(s: String): String = {
        if(s == null || s.isEmpty ) return ""
        if(s.length < 2) return s
 
        val dp = Array.ofDim[Boolean](s.length, s.length)
        var maxLen = 1
        var head = 0
 
        for(j <- 1 until s.length; i <- 0 until j){
            val currentLen = j - i + 1
            if(s(i) != s(j))  dp(i)(j) = false
            else if(currentLen < 4)  dp(i)(j) = true // currentLen - 2 < 2
            else dp(i)(j) = dp(i + 1)(j - 1)
            
            
            if(dp(i)(j) && currentLen > maxLen){
                maxLen = currentLen
                head = i

            }
        }
        
        s.slice(head, head + maxLen)
    }
}
```

##  20. <a name='SearchinRotatedSortedArray'></a>33. Search in Rotated Sorted Array

[小梦想家](https://www.bilibili.com/video/BV1gJ411V7Sq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV14t4y127hK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16A41147Fp?spm_id_from=333.999.0.0)

```py
# 我的模仿！啊😋

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        # 定义第一个元素和最后一个元素
        l = 0
        r = len(nums) - 1

        while l <= r:
            m = (l+r) // 2
            if nums[m] == target:
                return m
            # 只存在一个上升序列
            if nums[l] <= nums[m]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else: 
                    l = m + 1
            # 只存在一个上升序列
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else: 
                    r = m - 1
        
        return -1
```

```py
# 这道题简直是在跟我开玩笑（狗头）

class Solution(object):
    def search(self, nums, target):
        return nums.index(target) if target in nums else -1
```

```scala

/**
* binary search - iterative version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      
      var ans = -1
      while(ans == -1 && left <= right) {
        val mid = left + (right - left) / 2

        if (target == nums(mid) ){
          ans = mid

        } else if (nums(left) <= nums(mid)){ // left part is in order
          if (nums(mid) > target && target >= nums(left)) { // target is in left part
            right = mid - 1
          } else {
            left = mid + 1
          }
        } else { // right part is in order
          if (nums(mid) < target && target <= nums(right)) { // target is in right part
            left = mid + 1
          } else {
            right = mid - 1
          }
        } 
      }
      ans
    }
}
```

# 2 day (得分 = 15分) 45

##  21. <a name='-1'></a>200 【🍒并查集】岛屿数量

[哈哈哈](https://www.bilibili.com/video/BV15K411p72j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Cg4y1i7dZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1KK4y1U7Ds?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1E64y1T7Nk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Np4y1977S?spm_id_from=333.999.0.0)

[一俩三四五](https://www.bilibili.com/video/BV114411q7sP?from=search&seid=1135814820928819139&spm_id_from=333.337.0.0)

```py
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        f = {}
        def find(x):
            f.setdefault(x,x)
            if f[x] != x:
                f[x] = find(f[x])
            return f[x]
        def union(x,y):
            f[find(y)] = find(x)
            
        if not grid:
            return 0
        row, col = len(grid), len(grid[0])
        # 这里是 union
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    for x, y in [[-1, 0], [0, -1]]:
                        tmp_i = i + x
                        tmp_j = j + y
                        if 0 <= tmp_i < row and 0 <= tmp_j < col and grid[tmp_i][tmp_j] == "1":
                            # 把 array 翻译成 list
                            union(tmp_i * col + tmp_j, i * col + j)
        # 这里是 find
        res = set()
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    res.add(find(col * i + j))
        return len(res)
```

```py
# dfs
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # 行列
        ans = 0
        # 就像是把岛屿一个个蚕食
        # !!! 这里没有 visited
        def dfs(i, j): 
            if 0 <= i < m and 0 <= j < n and grid[i][j] == '1':   # 补充边界条件，防止溢出
                grid[i][j] = '0' # dfs置为0
                dfs(i + 1, j)  # 遍历4个领域
                dfs(i - 1, j)  # 遍历4个领域
                dfs(i, j - 1)  # 遍历4个领域
                dfs(i, j + 1)  # 遍历4个领域

        for i in range(m): # 行列
            for j in range(n): # 行列
                if grid[i][j] == '1': # 如果grid[i][j]为1，则dfs
                    ans += 1
                    dfs(i, j)
        return ans

```

```py
# 厉害的解法：Sink and count the islands.
class Solution(object):
    def numIslands(self, grid):
        def sink(i, j):
            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1':
                grid[i][j] = '0'
                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))
                return 1
            return 0
        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[0])))

```

```scala
/**
* chosen solution
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/

object Solution0 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}

/**
* Union & Find 
* memo
*    1. without modify original grid's elements
* time complexity: O(N * M) both N M is the dimension of grid 
*     both union and find operation's amortized time complexity in UnionFind class are very very close to 1 but not 1
*/


object Solution {
  private val endLabel = '0'
  def numIslands(grid: Array[Array[Char]]): Int = {
    val unionFind = new UnionFind(grid)
    for(i <- grid.indices; j <- grid(0).indices)
      union((i, j), unionFind, grid)
    unionFind.counter

  }

  def union(coord: (Int, Int), unionFind: UnionFind, grid: Array[Array[Char]]): Unit = {
    val (row, col) = coord
    if(grid(row)(col) == endLabel) return

    neighbors(coord, (grid.length, grid(0).length)).foreach {
      case (nr, nc) if grid(nr)(nc) != endLabel  =>
        unionFind.union(coord, (nr, nc))
      case _ =>
    }
  }

  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{ case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

##  22. <a name='AddStrings'></a>415-Add Strings

[哈哈哈](https://www.bilibili.com/video/BV18E411n7Cy?spm_id_from=333.999.0.0)

```py
python

class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        # 从最后一位开始相加
        i, j, carry, tail = len(num1)-1, len(num2)-1, 0, 0
        res = ''

        while i >= 0 or j >= 0 or carry != 0:
            val = carry

            if i >= 0:
                val += ord(num1[i]) - ord('0')
                i -= 1
            if j >= 0:
                val += ord(num2[j]) - ord('0')
                j -= 1

            carry, tail = divmod(val, 10)
            res = str(tail) + res

        return res  

时间复杂度： n

空间复杂度： 1


警察叔叔，我没有用 int
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        equation = num1+'+'+num2
        return str(eval(equation))

class Solution(object):
    def addStrings(self, num1, num2):
        return str((eval(num1)+eval(num2)))
```

##  23. <a name='-1'></a>46- ★ 全排列

类似题目：

https://leetcode-cn.com/problems/permutation-i-lcci/

```py
class Solution:
    def permutation(self, S: str) -> List[str]:
        res = []
        path = ''
        def backtrack(S, path):
            if S == '':
                res.append(path) # 这里不需要：path[:]，因为这里 path 是 str
                return 

            for i in range(len(S)):
                cur = S[i]
                backtrack(S[:i] + S[i+1:], path + cur)
                
        backtrack(S, path)

        return res
```

[哈哈哈](https://www.bilibili.com/video/BV1YA411v7zF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7fm?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oa4y1v7Kz?spm_id_from=333.999.0.0)

```py
# class Solution:
#     def permute(self, nums: List[int]) -> List[List[int]]:
#         res = []
#         path = []
#         def backtrack(nums):
#             if not nums: 
#                 res.append(path[:]) 
#                 return
#             else:
#                 for i in range(len(nums)):
#                     path.append(nums[i])
#                     backtrack(nums[:i]+nums[i+1:]) 
#                     path.pop()
#         backtrack(nums)
#         return res

# 另一种写法😋
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        # n = len(nums)
        def backtrack(nums, path):
            # 易错点：if len(path) == n:
            if not nums: # 判断条件应该是这个
                res.append(path[:]) # 易错点：path[:]
                return
            else:
                for i in range(len(nums)):
                    backtrack(nums[:i] + nums[i+1:], path + [nums[i]]) # 易错点：n是不断变小的
        backtrack(nums, [])
        return res
```

```scala
object Solution {
    var output = List.empty[List[Int]]
    
    def backtrack(nums: Array[Int], l: Int, r: Int): Unit = {
        def swap(a: Int, b: Int) = {
            val temp = nums(a)
            nums(a) = nums(b)
            nums(b) = temp
        }
        
        if(l == r){
            output = output :+ nums.toList
        }else{
            (l to r).map(i => {
                swap(l, i)
                backtrack(nums, l+1, r)
                swap(l, i) //backtrack step
            })
        }
    }
    
    def permute(nums: Array[Int]): List[List[Int]] = {
        output = List.empty[List[Int]]
        var input = nums
        backtrack(input, 0, input.length - 1)
        output
    }
}

```

##  24. <a name='ReverseLinkedListII'></a>92-Reverse Linked List II

[哈哈哈](https://www.bilibili.com/video/BV1n7411G7N4?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV19c411h7UE?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        dummy = ListNode(0, head)
        pre = dummy
        for _ in range(left - 1):
            pre = pre.next
            # 因为需要保留 pre, 所以 left - 1

        cur = pre.next
        for _ in range(right - left):
            # 易错点：顺序不能错，中，后，前，忠厚钱
            aft = cur.next
            cur.next = aft.next
            aft.next = pre.next
            pre.next = aft
        
        return dummy.next
```

##  25. <a name='LinkedListCycleII'></a>142 Linked List Cycle II

https://leetcode-cn.com/problems/merge-k-sorted-lists/

[小明](https://www.bilibili.com/video/BV1W5411L7AF?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV15e41147EY?spm_id_from=333.999.0.0)

![](https://s3.bmp.ovh/imgs/2022/02/5ca7ad17ae2ceeed.png)

```py
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            # 如果相遇
            if slow == fast:
                p = head
                q = slow
                while p != q:
                    p = p.next
                    q = q.next
                # 你也可以 return q
                return p
        return None
```

```scala
object Solution {
    def detectCycle(head: ListNode): ListNode = {
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        var cur = head
        
        var result: ListNode = null

        while (cur != null && result == null) {
            // println(result)
            if(visited.contains(cur))  
                result = cur
            else {
                visited += cur
                cur = cur.next
            }
        }
        result
        
    }
}

```

##  26. <a name='MergekSortedLists'></a>23. 【最小堆🌵】Merge k Sorted Lists

[花花酱](https://www.bilibili.com/video/BV1X4411u7xF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1178e?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK41157mu?spm_id_from=333.999.0.0)

暴力求解法：

* 时间复杂度: O(N) + O(N logN) + O(N)

* 空间复杂度: O(N) + O(N)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.65tcjjz2oy80.png" width="50%">

```py
# so easy，一遍过
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        arr = []
        for listhead in lists:
            while listhead:
                arr.append(listhead.val)
                listhead = listhead.next
        arr.sort()
        dummy = ListNode(0)
        cur = dummy
        for value in arr:
            cur.next = ListNode(value)
            cur = cur.next
        return dummy.next
```

优先队列：

* 时间复杂度: O(N logk) 

* 空间复杂度: O(N) + O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3tftyqf2g4s0.png" width="50%">

```py
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        q = []  # 易错点：先要定义一个空
        dummy = ListNode(0)
        cur = dummy
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(q, (lists[i].val, i))  # 易错点：要可以排序的
                lists[i] = lists[i].next # 易错点：注意，向后一位
        while q: # 易错点：注意这个循环条件
            val, idx = heapq.heappop(q)
            cur.next = ListNode(val)
            cur = cur.next
            if lists[idx]:
                heapq.heappush(q, (lists[idx].val, idx))
                lists[idx] = lists[idx].next # 易错点：注意，向后一位
        return dummy.next
```

两两合并：

* 时间复杂度: O(N logk) 

* 空间复杂度: O(1)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.60itjgowwpo0.png" width="50%">

```py
class Solution:
    def merge2Lists(self, list1, list2):
        dummy = ListNode(0)
        cur = dummy # dummy是固定节点，cur是移动指针
        while list1 and list2: # 这里是and
            if list1.val < list2.val: # 易错点：这里是list.val，而不是list
                cur.next = list1
                list1 = list1.next # 向后进一位
            else:
                cur.next = list2
                list2 = list2.next # 向后进一位
            cur = cur.next # 向后进一位
        cur.next = list1 or list2 # 易错点：这里是cur.next，而不是cur。这里是or
        return dummy.next

    def mergeKLists(self, lists: List[ListNode]) -> ListNode:     
        amount = len(lists)
        interval = 1
        while amount > interval:
            # 0,1,2,3,4,5,6  7-1
            # 0, ,2, ,4, ,6  7-2
            # 0, , , ,4, ,   7-3
            # 0, , , , , ,   7-4
            for i in range(0, amount - interval, 2 * interval):
                lists[i] = self.merge2Lists(lists[i], lists[i + interval]) # 易错点：方括号和小括号不要用错
            interval *= 2
        return lists[0] if amount > 0 else None
```

##  27. <a name='SpiralMatrix'></a>54. Spiral Matrix

https://leetcode-cn.com/problems/spiral-matrix/

[小梦想家](https://www.bilibili.com/video/BV1N7411h7i1?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        # print(list(matrix.pop(0)))
        print(list(zip(*matrix)))
        print(list(zip(*matrix))[::-1])
        return matrix and list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])
        # 含义是，如果matrix为空，则返回matrix
```

```py
return a and b
 
等价于
 
return b if a else a
```

```py
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res += matrix.pop(0) # 易错点：注意是 +=
            matrix = list(zip(*matrix))[::-1] # 易错点：注意 [::-1] 的摆放
        return res
```

```scala
/**
* counterclockwise rotate matrix
* step:
*  1. add first line to list
*  2. counter-clockwise rotate remaining matrix: transpose + entire reverse
*  
*  remaining:
*  4 5 6
*  7 8 9
* 
* transpose:
*   4 7
*   5 8
*   6 9
* 
* reverse:
*   6 9
*   5 8
*   4 7
*/

object Solution2-1 {
    def spiralOrder(matrix: Array[Array[Int]]): List[Int] = { 
        def dfs(mx: Array[Array[Int]]): List[Int] = mx match {
            case mx if mx.isEmpty => List()
            case mx if mx.length == 1 => mx.head.toList
            case _ => mx.head.toList ::: spiralOrder(mx.tail.transpose.reverse)  // counter-clockwise
        }
        dfs(matrix)

    }    
}

```

##  28. <a name='LongestIncreasingSubsequence'></a>300 【动态🚀规划 + 二分】Longest Increasing Subsequence 最长上升子序列

https://leetcode-cn.com/problems/longest-increasing-subsequence/

[花花酱](https://www.bilibili.com/video/BV1Wf4y1y7ou?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1rT4y1ujV?spm_id_from=333.999.0.0)

动态规划： 时间复杂度为 O(n2)

```py

class Solution(object):
    def lengthOfLIS(self, nums):
        if not nums:
            return 0

        dp = [1 for i in range(len(nums))]
        # [10,9,2,5,3,7,101,18]
        # [1,1,1,1,1,1,1,1]
        # [1,1, , , , , , ]
        # [1,1,1, , , , , ]
        # [1,1,1,2, , , , ]
        # [1,1,1,2,1+1, , , ]
        # [1,1,1,2,2,1+1或2+1或2+1, , ]
        # [1,1,1,2,2,3,1+1或2+1或3+1, ]

        for i in range(1, len(nums)): # 先确定结束，再确定开始
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[j] + 1, dp[i])

        return max(dp)

```

贪心 + 二分查找

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6wjfuj0uqvo0.webp)

```py
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        res = []
        for num in nums:
            # bisect_left会把新的元素放在相等元素前面, 即原来值5的索引位置2
            i = bisect_left(res, num)
            if i == len(res):
                res.append(num) # 如果新元素插入在最后面
            else:
                res[i] = num # 如果新元素代替旧元素
        return len(res)
```

```scala
/**
* dynamic programming 
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution0 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}

```

##  29. <a name='BinarySearch'></a>704.Binary Search二分查找

https://leetcode-cn.com/problems/binary-search/

[图灵](https://www.bilibili.com/video/BV1Dh411v7yT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qa4y157E4?spm_id_from=333.999.0.0)

```py
对不起没忍住

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target in nums :
            return nums.index(target)
        else:
            return -1

（版本一）左闭右闭区间，这个模板要记住

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2

            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                return mid
        return -1

（版本二）左闭右开区间，容易写错

# class Solution:
#     def search(self, nums: List[int], target: int) -> int:
#         left, right = 0, len(nums)
#         while left < right:
#             mid = (left + right) // 2
#             if nums[mid] < target:
#                 left = mid+1
#             elif nums[mid] > target:
#                 right = mid
#             else:
#                 return mid
#         return -1
```

```scala
object Solution {
    def search(nums: Array[Int], target: Int): Int = {
        nums.lastIndexOf(target)
    }
}

/**
* my first commitment:
* time complexity: O(logn)
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        println(left, right)
        val mid: Int = left  + (right - left) / 2
        if(nums(mid) == target){
          ans = mid
        } else if(target > nums(mid)) {
          left = mid + 1
        } else {
          right = mid - 1
        }
 
      }
      ans
    }
}

```

##  30. <a name='TrappingRainWater'></a>42. Trapping Rain Water

https://leetcode-cn.com/problems/trapping-rain-water/

[花花酱](https://www.bilibili.com/video/BV1hJ41177gG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fi4y1t7BP?spm_id_from=333.999.0.0)


双指针：

* 时间复杂度: O(n)

* 空间复杂度: O(1)

```py
#   😋我的模仿
[0,1,0,2,1,0,1,3,2,1,2,1]

class Solution:
    def trap(self, height: List[int]) -> int:
        left = 0
        right = len(height) - 1
        leftmax = 0
        rightmax = 0
        res = 0
        while left < right:
            if height[left] < height[right]:
                # 短板效应，移动小的那个值
                leftmax = max(leftmax, height[left])
                # 易错点：注意res和left的次序：先res，后left
                res += leftmax - height[left] 
                left += 1
            else:
                rightmax = max(rightmax, height[right])
                # 易错点：注意res和right的次序：先res，后right
                res += rightmax - height[right]
                right -= 1
        return res
```

##  31. <a name='ImplementQueueusingStacks'></a>232-【构造🏰】Implement Queue using Stacks

https://leetcode-cn.com/problems/implement-queue-using-stacks/

[哈哈哈](https://www.bilibili.com/video/BV1p741177pp?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Gf4y147Vj?spm_id_from=333.999.0.0)


```py
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x):
        # 要把新来的元素压入
        while self.s1:
            self.s2.append(self.s1.pop())
        self.s2.append(x) # 目的是把最后进来的元素最下面
        while self.s2:
            self.s1.append(self.s2.pop())

    def pop(self):
        # 假装最后一个元素是开头
        return self.s1.pop() if self.s1 else None
        

    def peek(self):
        # 假装最后一个元素是开头
        return self.s1[-1] if self.s1 else None

    def empty(self):
        return False if self.s1 else True
```

```scala
/**
* using two stack to implement
* one for push, the other for pop
* time complexity amortized O(1) per operation
* space complexity
*/

class MyQueue() {

  /** Initialize your data structure here. */
  private val inputStack = scala.collection.mutable.ArrayStack[Int]()
  private val outputStack = scala.collection.mutable.ArrayStack[Int]()


  /** Push element x to the back of queue. */
  def push(x: Int) {
    inputStack.push(x)

  }

  /** Removes the element from in front of queue and returns that element. */
  def pop(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.pop()

  }

  /** Get the front element. */
  def peek(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.head
  }

  /** Returns whether the queue is empty. */
  def empty(): Boolean = {
    outputStack.isEmpty && inputStack.isEmpty
  }

}

```

##  32. <a name='Inorderwihstack'></a>94-Inorder wih stack

https://leetcode-cn.com/problems/binary-tree-inorder-traversal/

[哈哈哈](https://www.bilibili.com/video/BV1uV411o78x?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1o54y1B7Z8?spm_id_from=333.999.0.0)

```py

最少代码递归：

class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []

class Solution(object):
    def preorderTraversal(self, root):
        if not root:
            return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []            
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if root:
            res += self.inorderTraversal(root.left)
            res.append(root.val)
            res += self.inorderTraversal(root.right)
        return res

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        res = []
        res.extend(self.inorderTraversal(root.left))
        res.append(root.val)
        res.extend(self.inorderTraversal(root.right))
        return res

# 前序遍历-递归-LC144_二叉树的前序遍历

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        # 保存结果
        result = []
        
        def traversal(root: TreeNode):
            if root == None:
                return
            result.append(root.val) # 前序
            traversal(root.left)    # 左
            traversal(root.right)   # 右

        traversal(root)
        return result

中序遍历-递归-LC94_二叉树的中序遍历

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            result.append(root.val) # 中序
            traversal(root.right)   # 右

        traversal(root)
        return result

# 后序遍历-递归-LC145_二叉树的后序遍历
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            traversal(root.right)   # 右
            result.append(root.val) # 后序

        traversal(root)
        return result

# # 中序遍历需先判断当前结点是否存在，若存在则将该节点放入栈中，再将当前结点设置为结点的左孩子，
# # 若不存在则取栈顶元素为cur，当且仅当栈空cur也为空，循环结束。

# class Solution:
#     def inorderTraversal(self, root: TreeNode) -> List[int]: 
#         stack, res = [], []
#         node = root
#         while stack or node:
#             if node:
#                 stack.append(node)
#                 node = node.left
#             else:
#                 node = stack.pop()
#                 res.append(node.val)
#                 node = node.right
#         return res

# class Solution:
#     def preorderTraversal(self, root: TreeNode) -> List[int]:
#         stack, res = [], []
#         node = root
#         while stack or node:
#             while node:
#                 res.append(node.val)
#                 stack.append(node)
#                 node = node.left
#             node = stack.pop()
#             node = node.right
#         return res

# class Solution:
#     def preorderTraversal(self, root: TreeNode) -> List[int]:
#         def addAllLeft(node):
#             while node:
#                 res.append(node.val) # append 优先
#                 stack.append(node)
#                 node = node.left

#         stack, res = [], []
#         node = root
#         while stack or node:
#             addAllLeft(node)
#             node = stack.pop()
#             node = node.right
#         return res

class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def appendAllLeft(node):
            while node:
                stack.append(node)
                node = node.left

        stack, res = [], []
        appendAllLeft(root)
        while stack:
            node = stack.pop()
            res.append(node.val) # res.append 在中间
            appendAllLeft(node.right)
        return res

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = [root]
        while stack:
            tmp = stack.pop()
            res.append(tmp.val)
            if tmp.left: stack.append(tmp.left) # 目的是left先出：先进，后出，取反则先
            if tmp.right: stack.append(tmp.right) 
        return res[::-1]

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = [root]
        while stack:
            tmp = stack.pop()
            res.append(tmp.val)
            if tmp.right: stack.append(tmp.right)
            if tmp.left: stack.append(tmp.left) # 目的是left先出：后进，先出
        return res
```

##  33. <a name='BinaryTreePreorderTraversal'></a>144-Binary Tree Preorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7NZ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Ch411Q74P?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1RD4y1D7C7?spm_id_from=333.999.0.0)

##  34. <a name='BinaryTreePostorderTraversal'></a>145-Binary Tree Postorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7ub?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1uv411h7Gc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1xZ4y1H7uS?spm_id_from=333.999.0.0)

##  35. <a name='BinaryTreeRightSideView'></a>199 Binary Tree Right Side View

[小明](https://www.bilibili.com/video/BV1854y1W7CB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xK4y1b7Wh?spm_id_from=333.999.0.0)

```py
class Solution:
    def rightSideView(self, root: TreeNode):
        res, level = [], root and [root]
        while level:
            res.append(level[-1].val)
            level = [nxt for n in level for nxt in (n.left, n.right) if nxt]
        return res

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root:
            return []
        res = []
        level = [root]
        while level:
            tmp = []
            for n in level:
                if n.left: tmp.append(n.left)
                if n.right: tmp.append(n.right)
            res.append(level[-1].val)
            level = tmp
        return res

# 递归
class Solution:
    def rightSideView(self, root: TreeNode):
        res = []
        def bfs(node, level):
            if node:
                if level == len(res):
                    res.append(node.val)
                bfs(node.right, level + 1)
                bfs(node.left, level + 1)
        bfs(root, 0)
        return res
```

##  36. <a name='ReorderList'></a>143 Reorder List

https://leetcode-cn.com/problems/reorder-list/

[小明](https://www.bilibili.com/video/BV1Jf4y1Q7y7?spm_id_from=333.999.0.0)

```py
class Solution:
    def reorderList(self, head: ListNode) -> None:
        que = []
        
        cur1 = head
        while cur1.next: # 链表除了首元素全部加入双向队列
            que.append(cur1.next)
            cur1 = cur1.next
        # 双指针
        cur2 = head
        i, j = 0, len(que) - 1
        while i <= j: # 一后一前加入链表
            cur2.next = que[j] # 头部连接到尾部
            cur2 = cur2.next
            j -= 1
            cur2.next = que[i] # 当i = j还是指向本身
            cur2 = cur2.next
            i += 1
        cur2.next = None # 尾部置空

# 双向队列
class Solution:
    def reorderList(self, head: ListNode) -> None:
        que = collections.deque()
        cur = head
        while cur.next: # 链表除了首元素全部加入双向队列
            que.append(cur.next)
            cur = cur.next
        cur = head
        # 一后一前加入链表
        while len(que): # 一后一前加入链表
            cur.next = que.pop()
            cur = cur.next
            if len(que):
                cur.next = que.popleft()
                cur = cur.next
        cur.next = None # 尾部置空
 

```

##  37. <a name='ClimbingStairs'></a>70. Climbing Stairs （重要）

https://leetcode-cn.com/problems/climbing-stairs/

[5:32 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gJ411R7X1?spm_id_from=333.999.0.0)

[哈哈哈 70(重制版)](https://www.bilibili.com/video/BV1G54y197eZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7s9?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DZ4y1H7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ki4y1u7tn?spm_id_from=333.999.0.0)

```py
# 我的模仿

class Solution:
    def climbStairs(self, n: int) -> int:
        dp0 = 1
        dp1 = 1
        for _ in range(n - 1):
            dp1, dp0 = dp0 + dp1, dp1 # 用2个数字分别存储
        return dp1
```

```scala
/**
* dynamic programming
*   1. dp(i) represent climb to i floor's distinct ways
*   2. dp(i) could be calculate from dp(i - 1) + dp(i - 2)
*           (1) taking a single step from dp(i - 1)
*           (2) taking a step of two from dp(i - 2)
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution0 {
    def climbStairs(n: Int): Int = {
        val dp = Array.ofDim[Int](n + 1)
        dp(0) = 1
        dp(1) = 1
        (2 to n).foreach(i => dp(i) = dp(i - 1) + dp(i - 2))
        dp(n)
    }
}
```

```scala
object Solution {
    
    def climbStairs(n: Int): Int = {
        if(n==1){
            1
        }else if(n == 2){
            2
        }else{
            climbStairs(n-1) + climbStairs(n-2)
        }
    }
}
```

##  38. <a name='BinaryTreeMaximumPathSum'></a>124. Binary Tree Maximum Path Sum

[花花酱](https://www.bilibili.com/video/BV1ct411r7qw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CT4y1g7bR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qT4y1J71C?spm_id_from=333.999.0.0)

```py
我的思考：
        # 有两种情况：
        # node.val 往上回收, 构成递归
        return max(left, right) + node.val
        # node.val 不往上回收, 左中右
        res = max(left + right + node.val, res)

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = -1e9
        # left = right = 0
        def subsum(node) -> int:
            nonlocal res # 也可以写成 self.res
            if not node:
                return 0
            # if node.left:
            left = max(subsum(node.left), 0)     # 正负性：left 为负，就不回收
            # if node.right:
            right = max(subsum(node.right), 0)   # 正负性：right 为负，就不回收
            # 有两种情况：node.val 不往上回收, 左中右
            res = max(left + right + node.val, res)
            # 有两种情况：node.val 往上回收, 构成递归
            return max(left, right) + node.val # 正负性：node.val必须回收
        subsum(root)
        return res
```

```scala
object Solution1 {
    def maxPathSum(root: TreeNode): Int = {
        dfs(root)._1
    }

    def dfs(node: TreeNode): (Int, Int) = {
      if (node == null) return (Int.MinValue, 0)
      
      val (leftSoFar, leftEndingHere) = dfs(node.left)
      val (rightSoFar, rightEndingHere) = dfs(node.right)

      val maxSoFar = leftSoFar max rightSoFar max (node.value + leftEndingHere + rightEndingHere)

      val maxEndingHere = 0 max (node.value + (leftEndingHere max rightEndingHere))
      (maxSoFar, maxEndingHere)
    }
}
```

##  39. <a name='MergeIntervals'></a>56. Merge Intervals

[花花酱](https://www.bilibili.com/video/BV11t411J7zV?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1w7411a7Wo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411a7t4?spm_id_from=333.999.0.0)

```py
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort() # 等价于：intervals.sort(key = lambda x: x[0])
        res = []
        for interval in intervals: # res[-1] 和 interval 比较
            if not res or res[-1][1] < interval[0]:
                res.append(interval[:])
            else:
                res[-1][1] = max(res[-1][1], interval[1])
                # 易错点：不是interval[1]，而是max(res[-1][1],interval[1])
                # 比如，[[1,4],[2,3]]
        return res
```

```scala

/**
*  time complexity: O(nlogn) + O(n) = O(nlogn) 
*  space complexity: O(n): sorted array
*/

object Solution1-2 {
    def merge(intervals: Array[Array[Int]]): Array[Array[Int]] = {
      intervals.sortBy(_(0)).foldLeft(List.empty[Array[Int]]){
        case (last::ans, arr) =>
          if (last.last < arr.head) {
            arr::last::ans
          } else {
            Array(last.head, last.last max arr.last)::ans
          }
        case (ans, arr) => arr::ans // for empty ans list
      }.toArray
    }
}
```

##  40. <a name='Offer22.k'></a>剑指 Offer 22. 链表中倒数第k个节点

```py
栈
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        stack = []
        while head:
            stack.append(head)
            head = head.next
        return stack[-k]

快慢指针
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        slow, fast = head, head
        for i in range(k):
            fast = fast.next
        while fast:
            slow = slow.next
            fast = fast.next
        return slow

总长度减k
class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        node, listlen = head, 0  
        while node:
            node = node.next
            listlen += 1

        node = head
        for _ in range(listlen - k):
            node = node.next
        return node  
```

##  41. <a name='IIRemoveDuplicatesfromSortedList'></a>82. 删除排序链表中的重复元素 II(Remove Duplicates from Sorted List

https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

[洛阳](https://www.bilibili.com/video/BV1Fi4y187pj?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = ListNode(0, head)
        cur = dummy
        while cur.next and cur.next.next:
            if cur.next.val == cur.next.next.val:
                # 把所有等于 x 的结点全部删除
                x = cur.next.val
                while cur.next and cur.next.val == x:
                    cur.next = cur.next.next
            else:
                cur = cur.next
        return dummy.next
```

##  42. <a name='SqrtxHJ107'></a>69 Sqrt(x) 见 HJ107 求解立方根

[花花酱](https://www.bilibili.com/video/BV1WW411C7YN?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gJ411R7XR?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7TN?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1PK411s72g?spm_id_from=333.999.0.0)

二分查找:

时间复杂度：O(logN)

空间复杂度：O(1)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        ans = -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x: # 2*2=4
                ans = mid # ans 必须放置在这个位置
                l = mid + 1
            else:
                r = mid - 1
        return ans
```

牛顿迭代法:

时间复杂度：O(logN)

空间复杂度：O(1)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3g2xmodb40u0.png)

```py
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1:
            return x
        res = x # 初始值
        c = x # 牛顿迭代法中的常数
        while res > c / res:
            res = (res + c / res) // 2 # 这里必须用整除
        return int(res)
        
class Solution:
    def mySqrt(self, num: int) -> int:
        x = 1 # 背一背这个套路
        while abs(x**2 - num) > 0.001:
            x -= (x**2 - num) / (2 * x) # 注意这里是减号
        return floor(x)
```

```scala

/**
* Newton's method - iterative
* y = x^2 => f(x) = x^2 - y
* x_{k+1} = x_k - f(x_k) / f'(x_k)
* x_{k+1} = x_k - (x_k^2 - y) / (2x_k) = (x_k + y / x_k) / 2
* time complexity: O(logN)
*/

object Solution2 {
     def mySqrt(x: Int): Int = {
        val precision = math.pow(10, -5)
        
        var ans: Double = x
        while(math.abs(ans * ans - x) > precision){
            ans = (ans + x / ans) / 2
            // println(ans)
        }
        ans.toInt
    }
}


```

```scala
object Solution {
    def mySqrt(x: Int): Int = {
        if(x == 0){
            0
        }else if(x == 1){
            1
        }else{
            var start = 1
            var end = x
            var result = 0
            
            while(start <= end){
                var mid = start + (end - start)/2
                if(mid <= x/mid){
                    result = mid
                    start = mid+1
                }else{
                    end = mid-1
                }
            }
            result
        }
    }
}

```    

# 3 day (得分 = 10分) 55

##  43. <a name='StringtoIntegeratoi'></a>8. String to Integer(atoi)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7pz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1AZ4y1s7TD?spm_id_from=333.999.0.0)

* 时间复杂度:O(n)

* 时间复杂度:O(1)

|模式|描述|
|---|---|
|^|匹配字符串的开头|
|[...]|用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'|
|*|匹配0个或多个的表达式。|
|?|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式|
|+|匹配1个或多个的表达式。|
|\d|匹配任意数字，等价于 [0-9]。|
|\D|匹配任意非数字，等价于 [^0-9]。|

[正则表达式中小括号、中括号、大括号的作用](https://blog.csdn.net/weixin_45621662/article/details/103921232)

```py
import re
class Solution(object):
    def myAtoi(self, s):
        return max(min(int(*re.findall('^[+-]?\d+', s.lstrip())), 2**31 - 1), -2**31)

import re
class Solution:
    def myAtoi(self, s: str) -> int:
        at_oi_re = re.compile('^[ ]*([+-]?\d+)')
        # 易错点：要注意中括号[]和小括号()的区别
        # 易错点：要注意小括号()的位置，小括号的作用是匹配并提取，所以+-要包括起来
        # 易错点：不能漏掉*？

        # 字符串的 开头 匹配 0个或多个[空格]
        # 匹配 0个或多个[+-]
        # 匹配 0个或多个[0-9]
        if not at_oi_re.search(s):
            return 0
        res = int(at_oi_re.findall(s)[0])
        # 易错点：findall返回一个列表，所以必须有[0]
        # 易错点：必须有int()
        #  在范围 [-2^31, 2^31 - 1] 内
        return min(max(res, -(1<<31)), (1<<31) - 1) # 在两者之间，背一背
        # 要加小括号(1<<31)

class Solution(object):
    def myAtoi(self, str):
        str = str.strip()
        strNum = 0
        if len(str) == 0:
            return strNum

        flag = 1
        if str[0] == '+' or str[0] == '-':
            if str[0] == '-':
                flag = -1
            str = str[1:]
        
        for char in str:
            if '0' <= char <='9':
                strNum = strNum * 10 +  ord(char) - ord('0')
            if char < '0' or char > '9':
                break
        strNum *= flag
        return min(max(strNum, -(1<<31)), (1<<31) - 1) 
```

##  44. <a name='RemoveNthNodeFromEndofList'></a>19-Remove Nth Node From End of List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7DQ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1eL411n7KE?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1654y1R7Xe?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1KK4y1E7st?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Z5411c79y?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6ccdr2kcw7c0.png)

```py
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        def getLength(head: ListNode) -> int:
            length = 0
            while head:
                length += 1
                head = head.next
            return length
        
        dummy = ListNode(0, head)
        length = getLength(head)
        cur = dummy
        for i in range(1, length - n + 1):
            cur = cur.next
        cur.next = cur.next.next
        return dummy.next


class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = ListNode(0,head)
        slow = dummy # 慢指针需要指向前一个
        fast = head
        for _ in range(n):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next

        slow.next = slow.next.next

        return dummy.next
```

```scala
/**
* my first commitment - fast & slow pointer
* time complexity O(N + N / 2)
*   1. keep fast pointer is n + 1 ahead to slow pointer
*   2. if fast == null, slow pointer would points to the  preNode of target removing node
*           t 
*   0 1 2 3 4 5
*   s     f
*     s     f
*       s     f
*         s     f
*/
object Solution1-2 {
    def removeNthFromEnd(head: ListNode, n: Int): ListNode = {
      val dummyHead = ListNode(0, head)
      var slow = dummyHead
      var fast = dummyHead
      
      for (i <- 0 until (n + 1) if fast != null) {
        fast = fast.next
      }
      
      while(fast != null) {
        slow = slow.next
        fast = fast.next
      }
      
      slow.next = slow.next.next
      dummyHead.next
    }
  
}
```

##  45. <a name='AddTwoNumbers'></a>2. Add Two Numbers

[花花酱](https://www.bilibili.com/video/BV1EJ411h72z?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1gJ411V7gJ?spm_id_from=333.999.0.0)

[小梦想](https://www.bilibili.com/video/BV1Wb411e77s?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1rZ4y1j7V3?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1DA411L7YQ?spm_id_from=333.999.0.0)

* 时间复杂度:O(max(m,n))

* 时间复杂度:O(max(m,n))

特殊情况：

两个链表的长度不同。

进位

```py

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = cur = ListNode(0) # 易错点：定义一个dummy和一个pointer，都指向ListNode(0)
        carry = 0 # 易错点：carry需要先赋值
        while l1 or l2 or carry: # 易错点：carry要存在
            # 易错点：l1,l2不一定存在，所以不能写成：sumNode = l1 + l2
            # 易错点：调用listnode要有.val
            sumNode = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            tail = sumNode % 10
            carry = sumNode // 10
            cur.next = ListNode(tail)
            cur = cur.next
            # # l1,l2不一定存在，所以不能写成：l1 = l1.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummy.next
```

```scala
object Solution {
    def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = {
      var cur1 = l1
      var cur2 = l2
      val dummy = ListNode(0)
      var prev=dummy
      var carry = 0
      while (cur1!=null ||  cur2!=null || carry !=0) {
        val (s1,next1) = cur1 match {
          case null => (0,null)
          case _=> (cur1.x, cur1.next)
        }
        val (s2,next2) = cur2 match {
          case null => (0,null)
          case _=> (cur2.x,cur2.next)
        }
        val s = s1+s2+carry
        val node = ListNode(s % 10)
        prev.next = node
        prev=node
        carry=s/10
        cur1 = next1
        cur2=next2
      }
      dummy.next
    }
  }
```

##  46. <a name='SortList'></a>148. Sort List

[花花酱](https://www.bilibili.com/video/BV1jW411d7z7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK411A7Gm?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        sortlist = []
        # 先把链表断开
        while head:
            aft = head.next
            head.next = None
            sortlist.append(head)
            head = aft
        # 排序
        sortlist = sorted(sortlist, key=lambda x: x.val)
        # 把链表串联起来
        n = len(sortlist)
        if n == 0:
            return None
        dummy.next = sortlist[0]
        for i in range(n-1):
            sortlist[i].next = sortlist[i+1]
        
        return dummy.next
```

```py
# py3 归并排序，递归实现。空间复杂度主要在递归栈深度：O( log(n) )，整个递归过程有点像后序遍历

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        mid = self.findmid(head)
        left = head # 指定左右
        right = mid.next # 指定左右
        mid.next = None # 断开链接
        l = self.sortList(left)
        r = self.sortList(right)
        return self.merge(l, r)

    def findmid(self,head):
        slow, fast = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        return slow

    def merge(self,l,r):
        dummy = ListNode(0)
        cur = dummy
        while l and r:
            if l.val <= r.val:
                cur.next = l
                l = l.next # 下一个
            else:
                cur.next = r
                r = r.next # 下一个
            cur = cur.next # 下一个
        cur.next = l or r
        return dummy.next

        # 基本用法：
        # v = p1 or p2

        # 它完成的效果等同于：
        # if p1:
        #     v = p1
        # else:
        #     v = p2
```

##  47. <a name='EditDistance72-'></a>72. Edit Distance 72-编辑距离

[花花酱](https://www.bilibili.com/video/BV1cb411u7uX?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wv411P7aQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13Z4y1W7UB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ea4y147FK?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5kci5ryyi3k0.png)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7fq2ehol7rg0.png)

```py
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)

        DP = [[0 for _ in range(len2 + 1)] for _ in range(len1 + 1)]
        
        for i in range(0, len1 + 1):
            for j in range(0, len2 + 1):
                if i == 0:               # 初始化
                    DP[i][j] = j
                elif j == 0:             # 初始化
                    DP[i][j] = i
                elif word1[i - 1] == word2[j - 1]:
                    DP[i][j] = DP[i-1][j-1]
                else:
                    DP[i][j] = min(DP[i-1][j], DP[i][j-1], DP[i-1][j-1]) + 1
                    
        return DP[-1][-1]
```

```py
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        @cache
        def dp(i, j) -> int:
            if i == -1:
                return j + 1
            if j == -1:
                return i + 1
            # 做出选择
            if word1[i] == word2[j]:
                return dp(i - 1, j - 1) # 什么都不做
            else:
                return min(
                    dp(i, j-1) + 1,  # insert
                    dp(i-1, j) + 1,  # delete
                    dp(i-1, j-1) + 1 # replace
                )
        return dp(len(word1)-1, len(word2)-1)
```

```scala
/**
* dynamic programming  - Levenshtein distance
* memo
*    1. dp(i)(j) represent the minimum edit distance from the length i substring from word1 to the length j substring from word2
*    2. dp(i)(j) is solved by its sub-optimal problem 
*         1, delete op: dp(i -1)(j)
*         2. replacement op: dp(i -1)(j - 1)
*         3. insertion op: dp(i)(j - 1)
* time complexity: O(NM) N is the length of word1, N is the length of word2
* space complexity: O(NM)
*/
object Solution1 {
  def minDistance(word1: String, word2: String): Int = {
    val m = word1.length
    val n = word2.length
    /* initial  Levenshtein distance table 
    * dp(i)(j) represent the minimum distance transforming from length i of substring word1 to length j of substring word2
    */
    val dp = Array.tabulate(m + 1, n + 1) {
      case (0, j) => j
      case (i, 0) => i
      case _ => 0
    }

    for (i <- 1 to m; j <- 1 to n) {
      /* i-1 is word1 index, j-1 is word2 index */
      if (word1(i - 1) == word2(j - 1)) {
        // do nothing case
        dp(i)(j) = dp(i - 1)(j - 1)
      } else {
        /**
        *       i-1,    i
        * j-1 replace  insertion     
        *  j   delete  dp(i)(j)
        */
        val replace = dp(i - 1)(j - 1)
        val insert = dp(i)(j - 1)
        val delete = dp(i - 1)(j)
        dp(i)(j) = (replace min insert min delete) + 1
      }
    }
    dp(m)(n)
  }
}
```

##  48. <a name='MedianofTwoSortedArrays'></a>4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays

[官方](https://www.bilibili.com/video/BV1Xv411z76J?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMedianSortedArrays(self, A: List[int], B: List[int]) -> float:
        lenA = len(A)
        lenB = len(B) 
        n = lenA + lenB
        slow, fast = -1, -1
        i, j = 0, 0
        for _ in range(n//2 + 1) :
            slow = fast  
            # 每次循环前将 fast 的值赋给 slow
            # A移动的条件: B遍历到最后 或 当前A<B,满足一个即可
            if j >= lenB or (i < lenA and A[i] < B[j]):
                fast = A[i]
                i += 1
            else :
                fast = B[j]
                j += 1
            
        if (n & 1) == 0: # 与1交,判断奇偶数,更快速
            return (slow + fast) / 2.0
        else:
            return fast

```

##  49. <a name='-1'></a>105-从前序与中序遍历序列构

[哈哈哈](https://www.bilibili.com/video/BV1uv411B73D?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1x54y1d7e8?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1ry4y1U7ZR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14A411q7Nv?spm_id_from=333.999.0.0)

> PYTHON 递归

```py
class Solution:
    def buildTree(self, preorder, inorder):
        if inorder:
            root = TreeNode(preorder.pop(0)) # preorder 在这里的作用就是 pop(0)
            i = inorder.index(root.val)
            root.left = self.buildTree(preorder, inorder[: i])
            root.right = self.buildTree(preorder, inorder[i + 1:])
            return root

```

106-从中序与后序遍历序列构造二叉树

[哈哈哈](https://www.bilibili.com/video/BV1r5411W7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jh411Z7y8?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if inorder:
            root = TreeNode(postorder.pop())
            i = inorder.index(root.val)
            root.left = self.buildTree(inorder[:i], postorder[:i])
            root.right = self.buildTree(inorder[i+1:], postorder[i:])
            return root
```

##  50. <a name='ReverseWordsinaString'></a>151. Reverse Words in a String

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7g4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rT4y1g7AJ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ei4y1V7yA?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        s = s.strip()
        s = s + ' ' # 根据后面的计算规则，在s后面加个空格
        left, right = 0, len(s) - 1
        que = collections.deque()
        word = []
        for char in s:
            if char == ' ' and word:
                que.appendleft(''.join(word))
                word = []
            elif char != ' ':
                word.append(char)

        return ' '.join(que)
```

##  51. <a name='MaximumDepthofBinary'></a>104-Maximum Depth of Binary

[哈哈哈](https://www.bilibili.com/video/BV1AJ411Q7xG?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1u54y1D7Nx?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tK41137GM?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

```scala
object Solution1 {
    def maxDepth(root: TreeNode): Int = {
        if (root == null) return 0
        math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}

object Solution {
    def maxDepth(root: TreeNode): Int = root match {
        case null => 0
        case x: TreeNode => Math.max((1 + maxDepth(x.left)), (1 + maxDepth(x.right)))
    }
}

```

##  52. <a name='-1'></a>76-【滑动窗口🔹】最小覆盖子串

[哈哈哈](https://www.bilibili.com/video/BV1PM4y1K7p6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK4y1t7Qd?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ud8tslp4vz4.png)

```py
class Solution:
    def minWindow(self, s: str, t: str) -> str:
    
        def isContains(windic,targetdic):
            for key in targetdic:
                if windic[key] < targetdic[key]:
                    return False # 只要有一个不满足，则不满足
            return True

        tdic = defaultdict(int) # 固定的
        wdic = defaultdict(int) # 变动的
        for char in t:
            tdic[char] += 1

        minlen = len(s)
        l = 0
        res = ''

        for r in range(len(s)): # 扩展右边界
            if s[r] in tdic:
                wdic[s[r]] += 1  # 变动的
            while isContains(wdic,tdic):
                # 如果是 minWindow
                if r-l+1 <= minlen:
                    minlen = r-l+1
                    res = s[l:r+1]
                # 收缩左边界
                if s[l] in wdic:
                    wdic[s[l]] -= 1  # 变动的
                l += 1   
        return res
```

```scala
/**
* chosen solution
*   time complexity: O(|S| + |T|)
*   space complexity: O(|s| + |T|)

*/
object Solution1 {
  def minWindow(s: String, t: String): String = {

    var left = 0
    val tMap = t.groupBy(identity).mapValues(_.length).toMap

    val budgetMap = scala.collection.mutable.Map() ++ tMap
    var currentString = ""
    var answer = ""

    for (char <- s) {
        budgetMap.get(char) match {

          case Some(e) => budgetMap.update(char, e - 1)
          case None =>
        }
      
      currentString += char

      while(!budgetMap.exists{case (_, v) => v > 0}) {

        val tempChar = s(left)
        if(tMap.contains(tempChar)){
          budgetMap.update(tempChar, budgetMap.getOrElse(tempChar, 0) + 1)
        }

        if(answer.length > currentString.length || answer.isEmpty) {
          answer = currentString
        }
        currentString = currentString.drop(1)
        left += 1
      }
    }

    answer
  }
}

```

##  53. <a name='NextPermutation'></a>31 ★ Next Permutation

[小明](https://www.bilibili.com/video/BV1Uz4y1m72N?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1SK4y1V7ch?spm_id_from=333.999.0.0)

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        # 关键在于从后往前，找到非递减序列
        i = len(nums) - 2
        while i >= 0:
            if nums[i] >= nums[i+1]:
                i -= 1
            else:
                # 寻找i后面比i大的数，交换位置,并且排序
                for j in range(len(nums)-1,i,-1): # 易错点:len(nums)-1,i的区间
                    # 12(3)5(4)
                    if nums[j] > nums[i]:
                        nums[i],nums[j] = nums[j],nums[i]
                        nums[i+1:] = sorted(nums[i+1:])
                        return
        nums.reverse() # 易错点:对于[3,2,1]这种情况，i = 0
```

```scala
/**
* my first commitment
* memo
* 1. find the first index i which breaks the increasing order
* 2. find the last index  j which is larger than index i
* 3. swap(i, j)
* 4. sorting: reverse sequence from i + 1 to the end 
* time complexity: O(n)
*/

object Solution1 {
    def nextPermutation(nums: Array[Int]): Unit = {
        /**
        * find the first index i which breaks the increasing order
        * 0 1 2 3 4 5 6
        * 5 4 7 6 5 4 3
        *   i     j 
        */
      ((nums.length - 2) to 0 by -1).find(idx => nums(idx) < nums(idx + 1)) match {
        case Some(idx) => 
          /* 
          * find the last index  j which  is larger than index i
          */
          val j = ((idx + 1) until nums.length).findLast(i => nums(idx) < nums(i)).getOrElse(idx)
          swap(nums, idx, j)
          reverse(nums, idx + 1, nums.length - 1)
        case None => reverse(nums, 0, nums.length - 1)
      }
    }
    @annotation.tailrec
    def reverse(nums: Array[Int], from: Int, to: Int) {
      if (from < to) {
        swap(nums, from, to)
        reverse(nums, from + 1, to - 1)
      }
    }
  
    def swap(nums: Array[Int], index1: Int, index2: Int) {
      val tmp = nums(index2)
      nums(index2) = nums(index1)
      nums(index1) = tmp
    }
}


```

##  54. <a name='SlidingWindowMaximum'></a>239. ★【最小堆🌵 + 滑动窗口🔹单调队列】Sliding Window Maximum

####  54.1. <a name='567567187'></a>不类似567，567类似187

[花花酱](https://www.bilibili.com/video/BV1WW411C763?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Bf4y1v758?spm_id_from=333.999.0.0)

```py
思路：

维护：最接近右边的最大值的pos
        
# print(winpos)
# [1,3,-1,-3,5,3,6,7]
保证窗口内的值是递减的即可
# []
# [0]
# [1]
# [1, 2]
# [1, 2, 3]
# [4]
# [4, 5]
# [6]

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        winQ = deque()
        res = []
        for r, v in enumerate(nums):
            # 如果新来的数字更大, 所以最右边的数字是最大的
            while winQ and nums[winQ[-1]] < v:
                winQ.pop() # pop() 可能有多次
            winQ.append(r)
            # 如果出界
            l = winQ[0]
            if r - k == l:
                winQ.popleft() # popleft() 顶多一个
            # 开始写入答案
            if r >= k - 1:
                res.append(nums[winQ[0]])

        return res
```

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # 注意 Python 默认的优先队列是小根堆，求最大值，则需要取复数
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        res = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k: 
                heapq.heappop(q) # 把所有出界的最大值弹出，可能不小心攒了许多个
            res.append(-q[0][0]) # 最大值永远在 q[0]
        
        return res

```

```scala

/**
* using max heap, may not AC
* pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)} : keep element's time complexity is O(K)
* time complexity: O(N log K)
*/

object Solution1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        var pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
        val rest = scala.collection.mutable.ArrayBuffer[Int]()
        
        nums.zipWithIndex.foreach{case (v: Int, idx: Int) => {
     
            pq += ((v, idx))
            
            /* keep the elements that is only larger than newest v and the nearest k */
            pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)}       

            if (idx + 1 >= k) {
                rest += pq.head._1
            }
          
        }}        
        rest.toArray
    }
}

/**
* using scala vector, due to scala vector is immutable, any operation about add update remove is generate a new vector
* so it's not a proper substitute for deque
*/

object Solution2 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    var windows = Vector.empty[Int]
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.head <= index - k)
        windows = windows.drop(1)

      while (windows.nonEmpty && nums(windows.last) <= value){
        windows = windows.dropRight(1)
      }
      windows = windows :+ index
      if (index + 1 >= k) {
        ret += nums(windows.head)
      }
    }
    ret.toArray
  }
}



```

##  55. <a name='LongestCommonSubsequence'></a>1143 【二维动态🚀规划】Longest Common Subsequence

####  55.1. <a name='516'></a>类似题目：516最长回文🌈子序列

[小明](https://www.bilibili.com/video/BV19Z4y1W7Xi?spm_id_from=333.999.0.0)

```py
做了几个dp的题之后，总结了dp需要注意的几个要素：

1、 明确dp二维数组表示的含义

2、 base case

3、 状态的转移：对于`回文🌈/LCS`之类的问题则是考虑当前字串和已经计算过的子串之间的关系

4、 由`状态的转移`来确定 loop的边界

5、 由loop的边界`打出表格` 可得出最后一个dp的状态值，即结果。


class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text2)+1) for _ in range(len(text1)+1)]
        for i in range(1, len(text1)+1): 
            for j in range(1, len(text2)+1): 
                if text1[i-1] == text2[j-1]: 
                    dp[i][j] = dp[i-1][j-1] + 1 
                else: 
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]


class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n1, n2 = len(text1), len(text2)
        pre = [0 for _ in range(n2 + 1)]
        dp = [0 for _ in range(n2 + 1)]
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                if text1[i-1] == text2[j-1]:
                    dp[j] = pre[j-1] + 1
                else:
                    dp[j] = max(pre[j], dp[j-1])
                pre[j-1] = dp[j-1] # 注意这里的缩进关系
            pre[j] = dp[j]
        return dp[-1]
```



```scala


  object Solution {
    def longestCommonSubsequence(text1: String, text2: String): Int = {
      val m = text1.length
      val n = text2.length
      //val dp = Array.ofDim[Int](1001,1001)
      val dp = Array.fill(1001,1001)(0)
      for (i<- 1 to m) { // must have space?
        for (j<- 1 to n) {
          dp(i)(j) = if (text1(i-1)== text2(j-1)) dp(i-1)(j-1)+1 else Math.max(dp(i-1)(j),dp(i)(j-1))
        }
      }
      dp(m)(n)
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.longestCommonSubsequence("abcde", "ace") == 3)
    }
    val name = "1143 Longest common sequence"
  }

```

##  56. <a name='SumRoottoLeafNumbers'></a>129 Sum Root to Leaf Numbers

[小明](https://www.bilibili.com/video/BV1VK411H7o5?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        res = 0
        
        def dfs(root, acc):
            nonlocal res
            if not root.left and not root.right: # 易错点：不要忽视了这种情况
                res += acc * 10 + root.val 
            if root.left:
                dfs(root.left, acc * 10 + root.val)
            if root.right:
                dfs(root.right, acc * 10 + root.val)
        dfs(root, 0)
        return res # 在根节点处cur为0，而不是sums

```

##  57. <a name='IP'></a>93. 复原 IP 地址

```py
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        def backtrack(s,path):
            if len(path) == 4 and len(s) == 0:
                res.append('.'.join(path))
                return # 注意点：一定要返回
            for i in range(len(s)):
                left,right = s[:i+1],s[i+1:]
                if 0 <= int(left) <= 255 and str(int(left)) ==  left:
                    backtrack(right,path + [left])  
        backtrack(s,[])    
        return res


```

##  58. <a name='BalancedBinaryTree'></a>110-Balanced Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1NJ411v7b1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Lb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sV411b7hR?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            return max(height(root.left), height(root.right)) + 1

        if not root:
            return True
        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)
        # 注意：左右两个子树也必须balanced
```

##  59. <a name='-1'></a>113. 二叉树中和为某一值的路径

[哈哈哈](https://www.bilibili.com/video/BV1P54y1i73U?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1k54y177fu?spm_id_from=333.999.0.0)

```py
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res=[]

        def dfs(node,path,tsum): # node.val == tsum 结束

            if not node:
                return

            if node.val == tsum and not node.left and not node.right: # 结束条件
                res.append(path[:] + [node.val])  # 需要深拷贝

            dfs(node.left, path + [node.val], tsum - node.val) # 三个部分都需要状态转移
            dfs(node.right, path + [node.val], tsum - node.val)
            
        dfs(root, [], targetSum)
        return res
```

##  60. <a name='GenerateParentheses'></a>22. Generate Parentheses

[小梦想家](https://www.bilibili.com/video/BV1hb411i7t7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vK4y1b744?spm_id_from=333.999.0.0)

回溯法：

* 时间复杂度:O($\frac{4^n}{\sqrt{n}}$)

* 时间复杂度:O($\frac{4^n}{\sqrt{n}}$)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.ud5vx6kpbvk.png" width="50%">

```py
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        def dfs(left,right,itm):
            if left == 0 and right == 0:
                res.append(itm)
                return  # 这里return写不写居然都ac了，可能是因为没有循环吧
            if left > 0:
                dfs(left-1, right, itm + '(') #   状态转移
            if right > left:
                dfs(left, right-1, itm + ')')
        
        res = []
        dfs(n, n, '')
        return res
```


```py
# 相当于比上一层少了一层循环。
# 不懂是不是动态规划，每新增一对括号，
# 就是在上一次的结果的各个位置插入一个"()"，用集合防止重复

class Solution:
    def generateParenthesis(self, n):
        res = {''}
        for i in range(n):
            ini = set()
            for s in res:  # 在上一次的结果的所有字符串的各个位置上插入'()'
                for j in range(len(s) + 1): # 如果s的长度为4，那么就有5个可以插入的位置
                    ini.add(s[:j] + '()' + s[j:])
            res = ini
        return list(res)
                    
                # 错误写法：
                # itm = itm[:j] + '()' + itm[j:]
                # res = res.add(itm)
                # 错误写法：
                # res = res.add(itm[:j] + '()' + itm[j:])
                # 正确写法：



```

```scala

object Solution {
    
    def generateParenthesis(n: Int): List[String] = {
        import scala.collection.mutable._
        def backtrack(acc: ListBuffer[String], curr: String, left: Int, right: Int): Unit = {
            if (left == 0 && right == 0) acc.append(curr)
            else {
                if (left > 0) backtrack(acc, curr + "(", left-1, right)
                if (right > left) backtrack(acc, curr + ")", left, right-1)
            }
        }
      
        val acc = ListBuffer[String]()
        backtrack(acc, "", n, n)
        acc.toList
    }
}

```

##  61. <a name='FirstMissingPositive'></a>41 First Missing Positive

[小明](https://www.bilibili.com/video/BV1fy4y1k7pV?spm_id_from=333.999.0.0)

```py
置换法
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)

        for i in range(n):
            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
# nums[nums[i] - 1]
# [-1, 4, 3, 1] 4 在 4 的位置↓
# [-1, 1, 3, 4] 1 在 1 的位置↓
# [1, -1, 3, 4]

        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
                
        return n + 1
        # 输入：[1] 预期结果：2

```

##  62. <a name='DiameterofBinaryTree'></a>543 Diameter of Binary Tree

[小明](https://www.bilibili.com/video/BV12K4y1r78T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qA411t7LR?spm_id_from=333.999.0.0)

```py
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        res = 0
        def depth(node):
            nonlocal res
            if not node:
                return 0
            L = depth(node.left) + 1 if node.left else 0 # 注意：这里一定要用 if else 结构
            R = depth(node.right) + 1 if node.right else 0 # 注意：这里是边的条数
            res = max(res, L + R)
            return max(L, R)

        depth(root)
        return res
```

# 4 day (得分 = 8分) 63

##  63. <a name='MinStack'></a>155-【构造🏰】Min Stack

[哈哈哈](https://www.bilibili.com/video/BV1H74118748?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1r77W?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ja4y1Y7vY?spm_id_from=333.999.0.0)

   
关键在于  def getMi

```py
class MinStack:

    def __init__(self):
        # 另外用一个stack，栈顶表示原栈里所有值的最小值
        self.minStack = []
        self.stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.minStack == [] or self.minStack[-1] >= val:
            self.minStack.append(val) # minStack 只 append 某一状态下的最小值

    def pop(self) -> None:
        if self.stack[-1] == self.minStack[-1]:
            self.minStack.pop()
        return self.stack.pop() # minStack 只 pop 某一状态下的最小值

    def top(self) -> int:
        return self.stack[-1]


    def getMin(self) -> int:
        return self.minStack[-1]        
```

```py
面试的时候被问到不能用额外空间，就去网上搜了下不用额外空间的做法。思路是栈里保存差值。
                [3,2,1,4] [0,-1,-1, 3]
                mins = 3, 2, 1, 1
                先把这个部分写出来
class MinStack:
    def __init__(self):

        self.diffstack = []
        self.mins = -1


    def push(self, x: int) -> None:
        if not self.diffstack:
            self.diffstack.append(0)
            self.mins = x
        else:
            diff = x-self.mins
            self.diffstack.append(diff)
            self.mins = self.mins if diff > 0 else x
            # mins 是会变化的

    def pop(self) -> None:
        if self.diffstack:
            diff = self.diffstack.pop()
            if diff < 0: 

                top = self.mins # 第一步：顺序不能错
                self.mins = self.mins - diff # 第二步：如果 diff < 0, 那就需要还原 self.mins
            else:     # 如果 diff 一直都 > 0, 那就非常好
                top = self.mins + diff
            return top

    def top(self) -> int:
        return self.mins if self.diffstack[-1] < 0 else self.diffstack[-1] + self.mins

    def getMin(self) -> int:
        return self.mins if self.diffstack else -1
```


```scala
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var min = Int.MaxValue

    def push(x: Int) {
        stack = stack :+ x
        if(x < min){
            min = x
        }
    }

    def pop() {
        stack = stack.init
        min = Int.MaxValue
        stack.map(x => {
            if(x < min) min = x
        })
    }

    def top(): Int = {
        stack.last
    }

    def getMin(): Int = {
        min
    }

}

//替代解决方案：更快
//这里我们将元素添加到列表中而不是附加
//请注意，由于List实际上是一个LinkedList，因此处理列表的“头部”要容易得多
//还有另一个列表来维护列表的最小元素
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var mins = List.empty[Int]

    def push(x: Int) {
        //如果我们将第二个条件设为 x < mins.head，则此行失败
        //with NoSuchElementException: 空列表的头部
        //为什么？？？
        if(mins.isEmpty || mins.head >= x) mins = x +: mins
        stack = x +: stack
    }

    def pop() {
        if(mins.head == stack.head) mins = mins.tail
        stack = stack.tail
    }

    def top(): Int = {
        stack.head
    }

    def getMin(): Int = {
        mins.head
    }

}

```

##  64. <a name='ValidateBinarySearchTree98-'></a>98. Validate Binary Search Tree 98-验证二叉搜索树

[花花酱](https://www.bilibili.com/video/BV12t411Y7TP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Wz4y1R7dF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Hv411478d?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Fi4y147Ng?spm_id_from=333.999.0.0)

```py
有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
```

中序遍历一下就行了

```py
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        result = [float('-inf')]
        valid = True # 必须用valid这个变量，不能用return False

        def traversal(root: TreeNode):
            nonlocal valid # 这一行必不可少，不然虽然不报错，但不能ac
            if root == None:
                return
            traversal(root.left)    # 左
            if result[-1] >= root.val: valid = False
            result.append(root.val) # 中序
            traversal(root.right)   # 右

        traversal(root)
        return valid


class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        def appendAllLeft(node):
            while node:
                stack.append(node)
                node = node.left
        # 这里可以直接 return，不需要valid
        stack, res = [], float('-inf')
        appendAllLeft(root)
        while stack:
            node = stack.pop()
            if res >= node.val: return False
            res = node.val # res.append 在中间
            appendAllLeft(node.right)
        return True

```

定义上下界：

```py
class Solution:
    def isValidBST(self, root):
        def BFS(node, lower, upper):
            if not node:
                return True
            return lower < node.val < upper and BFS(node.left, lower, node.val) and BFS(node.right, node.val, upper)

        return fun(root, float('-inf'), float('inf'))
```

```scala
/**
* chosen solution
* inorder iterative version only keep pre node
* this is also the inorder-iterative-template
* 
* time complexity: O(N)
*/

object Solution0 {
   def isValidBST(root: TreeNode): Boolean = {
    val stack = new collection.mutable.Stack[TreeNode]()
    var node = root
    var pre: TreeNode = null
    var result = true
    while ((node != null || stack.nonEmpty) && result) {
      while (node != null) {
        stack push node
        node = node.left
      }

      node = stack.pop
      if (pre != null && node.value <= pre.value) result = false
      pre = node
      node = node.right

    }
    result
  }
}

/**
* inorder recursive traversal
* memo:
*    1. recursive version with all element storing
* Time complexity O(NlogN)  there are a distinct and sorted operation
* space complexity O(N)
*/
object Solution1 {
  def isValidBST(root: TreeNode): Boolean = {
    val inorder = traversal(root)
    inorder equals inorder.distinct.sorted // why distinct here? [1, 1] is not a BST because left tree should be smaller than root. 
  }
  def traversal(node: TreeNode): List[Int] = {
    if(node == null){
      List.empty[Int]
    }else {
      // (traversal(node.left) :+ node.value) ::: traversal(node.right) 
      traversal(node.left) ::: List(node.value) ::: traversal(node.right)
    }
  }
}



/**
* giving min max range when recursive
* time complexity: O(N)
*/

object Solution4 {
  def isValidBST(root: TreeNode): Boolean = {

    def _isValidBST(node: TreeNode, min: TreeNode, max: TreeNode): Boolean = {

      if(node == null) true
      else {
        if((min != null && node.value <= min.value) || (max != null  && node.value >= max.value)) false
        else {
          _isValidBST(node.lefmt, min, node) && _isValidBST(node.right, node, max)
        }
      }
    }
    _isValidBST(root, null, null)
  }

}
```

##  65. <a name='ImplementRand10UsingRand7'></a>470. Implement Rand10() Using Rand7()

[花花酱](https://www.bilibili.com/video/BV1Ut411Z7KX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AD4y1m7Qb?spm_id_from=333.999.0.0)

```py
class Solution:
    def rand10(self) -> int:
        while True:
            row = rand7()
            col = rand7()
            idx = (row - 1) * 7 + col #（0-42） + （1-7）
            if idx <= 40: # 1-40
                return 1 + (idx - 1) % 10

这样写也是对的，因为 0-9 等概率出现
class Solution:
    def rand10(self):
        while True:
            row = rand7()
            col = rand7()
            idx = (row - 1) * 7 + col #（0-42） + （1-7）
            if idx <= 30: # 1-40
                return 1 + (idx + 1) % 10

class Solution:
    def rand10(self):
        while True:
            res = (rand7()-1)*7 + rand7()#构造1~49的均匀分布
            if res <= 40: #剔除大于40的值，1-40等概率出现。
                break
        return res%10+1 #构造1-10的均匀分布
```

##  66. <a name='Symmetrictree'></a>101-Symmetric tree

[哈哈哈](https://www.bilibili.com/video/BV1VJ41197KD?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xv41167z8?spm_id_from=333.999.0.0)

> Python 迭代：其实就是层序遍历，然后检查每一层是不是回文🌈数组

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        dic = collections.defaultdict(list)

        def bfs(node, level):
            if node:
                dic[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)
            else:
                dic[level].append(None)
        
        bfs(root, 0) 
        for key in dic:
            if dic[key] != dic[key][::-1]:
                return False

        return True

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        # if not root:
        #     return [] 删除
        level = [root]
        while level:
            tmp = []
            vals = [] # 补充
            for n in level:
                if n: # 修改，因为none节点也需要append
                    tmp.append(n.left) # if n.left 被删除
                    tmp.append(n.right) #  if n.right 被删除
                    vals.append(n.val)  # 补充
                else:
                    vals.append(None) # 修改，因为none节点也需要append
            if vals != vals[::-1]:  # 补充
                return False  # 补充
            level = tmp
        return True
```

> Python 递归：

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def twoSym(node1, node2):
            if node1 and node2 and node1.val == node2.val: 
                return twoSym(node1.left, node2.right) and twoSym(node1.right, node2.left)
            elif not node1 and not node2:
                return True
            else:
                return False
        return twoSym(root.left, root.right)
```

> scala:

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def symmetric(nodeA: TreeNode, nodeB: TreeNode): Boolean = {
        if(nodeA == null && nodeB == null){
            true
        }else if(nodeA !=null && nodeB != null){
            if(nodeA.value != nodeB.value){
                false
            }else{
                symmetric(nodeA.left, nodeB.right) && symmetric(nodeA.right, nodeB.left)
            }
        }else{
            false
        }
    }
    
    def isSymmetric(root: TreeNode): Boolean = {
        if(root == null){
            true
        } else{
            symmetric(root.left, root.right)
        }
    }
}

```

##  67. <a name='LongestValidParentheses'></a>32 Longest Valid Parentheses

[小明](https://www.bilibili.com/video/BV1RZ4y1F7nJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1yi4y1G74d?spm_id_from=333.999.0.0)

动态规划：

* 时间复杂度: O(n) 

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6dkova4yjvk0.png)

```py
# 背一背吧，好难。
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        dp = [0]*n
        if n == 0: return 0
        for i in range(n):
            if s[i] == ')' and s[i-dp[i-1]-1] == '(' and i - dp[i-1] - 1 >= 0:
                dp[i] = 2 + dp[i-1] + dp[i-dp[i-1]-2]
        return max(dp)
```

栈：

* 时间复杂度: O(n) 

* 空间复杂度: O(n)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1dgqk0ervhb4.png)

```py
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        length = maxlength = 0
        for i,c in enumerate(s):
            if c == '(':
                stack.append(i)
            if c == ')':
                stack.pop()
                if not stack:
                    stack.append(i) # 记录一下stack[-1]为')'，断开区间
                else:
                    length = i - stack[-1] # stack[-1]为')'，断开区间
                    maxlength = max(maxlength,length)
        return maxlength

```

```scala



/**
* using stack to record the char index in oder to calculate the valid length
* memo:
* 1. always only have one invalid symbol at stack and its position index is 0
* time complexity O(n)
* space complexity O(n)
*/
object Solution1 {

  import collection.mutable

  def longestValidParentheses(s: String): Int = {
    val mapping = Map('(' -> ')')
    val stack = mutable.Stack[Int]()
    stack.push(-1)
    s.indices.foldLeft(0) {
      case (maxLength, idx) =>
        val char = s(idx)
        if (mapping.contains(char)) {
          stack push idx
          maxLength
        } else {
          stack.pop()
          if (stack.isEmpty) {
            stack push idx
            maxLength
          } else {
            (idx - stack.head) max maxLength
          }
        }
    }
  }
}
```

##  68. <a name='-1'></a>43. 字符串相乘

```py
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        m, n = len(num1), len(num2)
        ansArr = [0] * (m + n)
        # 从后往前
        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                ansArr[i + j + 1] += x * int(num2[j])
        
        # 从后往前
        for i in range(m + n - 1, 0, -1):
            ansArr[i - 1] += ansArr[i] // 10
            ansArr[i] %= 10
        
        res = ''.join(str(x) for x in ansArr)
        return str(int(res))
```

```py
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        if num1 == "0" or num2 == "0":
            return "0"
        
        m, n = len(num1), len(num2)
        ansArr = [0] * (m + n)
        for i in range(m - 1, -1, -1):
            x = int(num1[i])
            for j in range(n - 1, -1, -1):
                ansArr[i + j + 1] += x * int(num2[j])
        
        for i in range(m + n - 1, 0, -1):
            ansArr[i - 1] += ansArr[i] // 10
            ansArr[i] %= 10
        
        index = 1 if ansArr[0] == 0 else 0
        ans = "".join(str(x) for x in ansArr[index:])
        return ans

```

##  69. <a name='MinimumPathSum64-'></a>64. Minimum Path Sum 64-最小路径和

[花花酱](https://www.bilibili.com/video/BV12W411679S?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ka4y1i7Vu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1JC4y1x7j1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vi4y1u7a6?spm_id_from=333.999.0.0)

```py
# 可以直接在原数组上进行记忆，不需要额外的空间
# so easy,直接AC
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0:
                    continue
                if i == 0:
                    grid[i][j] += grid[i][j-1]
                if j == 0:
                    grid[i][j] += grid[i-1][j]
                if i > 0 and j > 0:
                    grid[i][j] += min(grid[i-1][j],grid[i][j-1])
        return grid[-1][-1]
```

##  70. <a name='-1'></a>718. 最长重复子数组

```py
# 这个滑动窗口，用的是 left 和 lenth

class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        lenth = left = 0
        if nums1 and nums2:
            # 将数字转换为字符串
            a, b, n = ''.join(map(chr, nums1)), ''.join(map(chr, nums2)), len(nums1)
            while lenth + left < n:
                # 这里使用lenth保存结果，用left跳出循环
                if a[left : left + lenth + 1] in b:
                    lenth += 1
                else:
                    left += 1
        return lenth 



class Solution:
    def findLength(self, A: List[int], B: List[int]) -> int:
        dp = [[0] * (len(B)+1) for _ in range(len(A)+1)]
        result = 0
        for i in range(1, len(A)+1):
            for j in range(1, len(B)+1):
                if A[i-1] == B[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                result = max(result, dp[i][j])
        return result


  3 2 1 4 7
1 0 0 1 0 0
2 0 1 0 0 0
3 1 0 0 0 0
2 0 2 0 0 0
1 0 0 3 0 0

```

##  71. <a name='Subsets'></a>78. Subsets 子集

[花花酱](https://www.bilibili.com/video/BV1jt411k7py?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1HD4y1Q7Te?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1s7pq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1154y1R72Q?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.xmmpwe7mlzk.webp)

时间复杂度：O(n·2^n)

```py
# 【位运算😜】
# class Solution:
#     def subsets(self, nums: List[int]) -> List[List[int]]:
#         size = len(nums)
#         n = 1 << size
#         res = []
#         # i = 0,1,2,3,4,5,6,7
#         for i in range(n):
#             cur = []
#             # j = 0,1,2
#             for j in range(size):
#                 if i >> j & 1:
#                     cur.append(nums[j])
#             res.append(cur)
#         return res

```

```py
class Solution(object):
    def subsets(self, nums):
        res = [[]]
        for num in nums:
            res.extend([subres+[num] for subres in res])
        return res  

# bfs
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = [[]]
        n = len(nums)
        for num in nums:
            for subres in res[:]:
                res.append(subres+[num])
        return res

# 注意代码中res[:]是必须的，因为切片是引用新的对象，
# 此时在循环中res[:]是不更新的，而res是不断有元素push进去的，很trick
```

```py
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  
        def backtrack(startIndex,path):
            res.append(path[:])  # unconditional, 收集子集
            for i in range(startIndex, len(nums)):  #当startIndex已经大于数组的长度了，就终止了，for循环本来也结束了，所以不需要终止条件
                backtrack(i + 1, path + [nums[i]])  # nums[i] 一定要用中括号括起来
        backtrack(0,[])
        return res
```

```scala
object Solution {
    //We either use or don't use the current item at the given index and continue until we are at the end of the array.
    
    def subsets(nums: Array[Int]): List[List[Int]] = {
        def backtrack(nums: List[Int], returnValue: List[Int]): List[List[Int]] = {
            nums
            .headOption
            .map(currentElem => 
                 backtrack(nums.tail, returnValue) ++ backtrack(nums.tail, currentElem +: returnValue))
            .getOrElse(List(returnValue))
        }
        
        backtrack(nums.toList, List.empty[Int])
    }
}

```

##  72. <a name='PathSum'></a>112-Path Sum

[哈哈哈](https://www.bilibili.com/video/BV1T7411r7Yr?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1pb411e7r7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1uK411T7kX?spm_id_from=333.999.0.0)

递归

```py
# 正确写法
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if not root:
            return False
        if root.val == targetSum and not root.left and not root.right:
            return True
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

# 错误写法
# class Solution:
#     def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
#         if not root:
#             return False
#         if root.val == targetSum:
#             return not root.left and not root.right
#         return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)

# class Solution:
#     def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
#         if not root:
#             return False
#         if root.val == targetSum:
#             return True
#         return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

```py
队列
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que = collections.deque([(root, root.val)])
        while que:
            node, tmpsum = que.popleft()
            if not node.left and not node.right and tmpsum == sum:
                return True
            if node.left:
                que.append((node.left, node.left.val + tmpsum))
            if node.right:
                que.append((node.right, node.right.val + tmpsum))
        return False
```

##  73. <a name='RotateImage'></a>48. 旋转图像 Rotate Image

[官方](https://www.bilibili.com/video/BV1mf4y1e7ox?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Wy4y1s7fs?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3kl7avrsvhi0.png" width="30%">

```py
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n//2): # n 和 下面的(n+1) 可以调换位置
            for j in range((n+1)//2):
                matrix[i][j], matrix[j][n-1-i], matrix[n-1-i][n-1-j], matrix[n-1-j][i] = \
                matrix[n-1-j][i], matrix[i][j], matrix[j][n-1-i], matrix[n-1-i][n-1-j]
        return matrix
```

```scala
/**
* my first commitment
* rotate 4 cell in each iteration
*
*   pattern:  (row, col) -> (col, n - 1- row)
*       1. (i, j) - > (j, n - 1 -i)
*       2. (j, n - 1 -i) -> (n - 1 - i, n - 1 - j)
*       3. (n - 1 - i, n - 1 - j) -> (n -1 -j, n - 1 - (n -1 - i) ) =  (n - 1 -j, i)
*       4. (n - 1 -j, i) -> (i, n - 1 - (n - 1 - j)) = (i, j)
*
* ((0,0) -> (0,3) -> (3,3) -> (3,0))
* ((0,1) -> (1,3) -> (3,2) -> (2,0))
* ((1,0) -> (0,2) -> (2,3) -> (3,1))
* ((1,1) -> (1,2) -> (2,2) -> (2,1))
* 
*/
object Solution1 {
    def rotate(matrix: Array[Array[Int]]): Unit = {
      val n = matrix.size
      printMatrix(n)
      
      for (i <- 0 until (n / 2).toInt + n % 2; j <- 0 until (n / 2).toInt){      
        val tmp = matrix(n - 1 -j)(i)
        matrix(n - 1 - j)(i) = matrix(n - 1 - i)(n - j - 1)
        matrix(n - 1 - i)(n - j - 1) = matrix(j)(n - 1 - i)
        matrix(j)(n - 1 - i) = matrix(i)(j)
        matrix(i)(j) = tmp
      }
    }

    /**
        (0, 0) (0, 1) (0, 2) (0, 3)  
        (1, 0) (1, 1) (1, 2) (1, 3)  
        (2, 0) (2, 1) (2, 2) (2, 3)  
        (3, 0) (3, 1) (3, 2) (3, 3)  
    */
}

```

##  74. <a name='PalindromeLinkedList'></a>234. 【回文🌈】Palindrome Linked List

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ML?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        vals = []
        cur = head
        while cur:
            vals.append(cur.val)
            cur = cur.next
        return vals == vals[::-1]



```

```scala
/**
* very brilliant solution
*/
object Solution2 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null) {
            return true
        }
        var p = head
        var result = true
        def go(node: ListNode): Unit = {
            if (node.next != null) {
                go(node.next)
            }
            if (p.x != node.x) {
                result = false
            }
            p = p.next
        }
        go(head)
        result
    }
}
```


##  75. <a name='dfsCoinChange'></a>322. 【动态🚀规划 + 背包 + dfs】Coin Change - 见 518 Coin Change

https://leetcode-cn.com/problems/coin-change/

[花花酱](https://www.bilibili.com/video/BV1SW411C7d1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1tz4y1d7XM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ty4y187dh?spm_id_from=333.999.0.0)

```py
动态🚀规划

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [10e9] * (amount + 1)
        dp[0] = 0

        for i in range(1, amount + 1):
            for coin in coins:
                if i >= coin:
                    # i 就是一个 target, 求出每个 target 的最小值
                    dp[i] = min(dp[i], dp[i-coin] + 1)
         # 这道题的难点在于：最后结果的输出
        return dp[-1] if dp[-1] != 10e9 else -1


import functools
class Solution:
    def coinChange(self, coins, amount):
        @functools.lru_cache(None)
        def helper(amount):
            tmp = float("inf")
            if amount == 0:
                return 0
            for c in coins:
                if amount - c >= 0:
                    tmp = min(tmp, helper(amount - c) + 1) # 这个 +1 一定要在大括号里面
            return tmp
            
        res = helper(amount)
        return res if res != float("inf") else -1



class Solution:
    def coinChange(self, coins, amount):
        import functools

        @functools.lru_cache(None)
        def helper(amount):
            if amount == 0:
                return 0
            return min(helper(amount - c) if amount - c >= 0 else float("inf") for c in coins) + 1

        res = helper(amount)
        return res if res != float("inf") else -1


```

```scala
/**
* dynamic programming: bottom up
* time complexity: O(S * N), S is the amount, N is the coin denomination count
* space complexity: O(S)
*/

object Solution {
    def coinChange(coins: Array[Int], amount: Int): Int = {
         
        val dp = Array.fill[Int](amount + 1)(amount + 1) // record the minimum needed coins of each denominations

        dp(0) = 0
        for (i <- 1 to amount; denominations <- coins) {

            if(denominations <= i) {
                dp(i) = dp(i) min (dp(i - denominations) + 1)
            }        
        }
    
        if (dp.last > amount) -1 else dp.last
    }
}

```

##  76. <a name='CombinationSum39-'></a>39. Combination Sum 39-组合总和

[花花酱](https://www.bilibili.com/video/BV1gb411u7dy?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Wz411e79d?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12Z4y157nE?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []

        def backtrack(firstIdx, path):
            if sum(path) == target:
                res.append(path[:]) 
                # 易错点，这里是res.append(path[:])，而不是res.append(path)
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx, len(candidates)):
                    backtrack(i, path + [candidates[i]])
        backtrack(0, [])
        return res
```

```scala

/**
* my first commitment: dfs - backtracking
*/

object Solution1-1 {
    import collection.mutable
    def combinationSum(candidates: Array[Int], target: Int): List[List[Int]] = {
      
      def dfs(combination: List[Int], ans: mutable.Set[List[Int]]): Unit = {
        val currentSum = combination.sum
        
        if (currentSum == target) {
          ans += combination.toList
          
        } else if (currentSum < target){
          val diff = target - currentSum
          candidates.filter(n => n <= diff).foreach{ case n => dfs(n :: combination, ans)}
        }
      }
      val ans = mutable.Set.empty[List[Int]]
      dfs(List.empty[Int], ans)
      ans.map(l => l.groupBy(identity).mapValues(_.length).toMap -> l).toMap.values.toList // distinct 
    }
}
```

##  77. <a name='MajorityElement'></a>169. 【位运算😜】Majority Element

[花花酱](https://www.bilibili.com/video/BV1hb411c7bF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7pW?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ff4y1U7Vn?spm_id_from=333.999.0.0)


```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        return sorted(nums)[len(nums) // 2]

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[len(nums) // 2]


class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)

# 投票策略，半数以上获胜

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = None

        for vot in nums:
            if count == 0:
                candidate = vot
            count += (1 if vot == candidate else -1)

        return candidate
```

```scala
/**
* HashMap
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution2 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.groupBy(identity).mapValues(_.length).maxBy(_._2)._1  
    }
}


/**
* sorting array and pick middle element
* time complexity O(NlogN)
*/

object Solution3 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.sorted(Ordering.Int)(nums.length / 2)
    }
}

//Alternate solution O(n) but NO EXTRA SPACE
object Solution {
    def majorityElement(nums: Array[Int]): Int = {     
        var candidate = nums.head
        var count = 0
        nums.foreach(vot => {
            if(count == 0) { 
                candidate = vot
                count = 0
            }
            if(vot == candidate) count+=1;
            else count-=1;
        })
        
        candidate
    }
}

```

##  78. <a name='Removeduplicatesfromsortedarray'></a>83-Remove duplicates from sorted array

[哈哈哈](https://www.bilibili.com/video/BV1yJ411R7FZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7s7?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1zK411L7Gg?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next # 要么删除
            else:
                cur =  cur.next # 要么下一个
        return head
```

##  79. <a name='-1'></a>226-翻转二叉树

[哈哈哈](https://www.bilibili.com/video/BV1Sh411R7B2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73E?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FK411p7Co?spm_id_from=333.999.0.0)

```py
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```

```py
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        Q = deque([root])
        while Q:
            r = Q.pop()
            if r.left or r.right:
                r.left, r.right = r.right, r.left
                if r.left: Q.append(r.left)
                if r.right: Q.append(r.right)
        return root
```

##  80. <a name='CompareVersionNumbers'></a>165. Compare Version Numbers

[小梦想家](https://www.bilibili.com/video/BV19K4y1C7L3?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pk4y117dF?spm_id_from=333.999.0.0)

```py
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = version1.split(".")
        v2 = version2.split(".")

        while v1 or v2:
            x = int(v1.pop(0)) if v1 else 0
            y = int(v2.pop(0)) if v2 else 0

            if x > y:
                return 1
            elif x < y:
                return -1
        return 0
```

##  81. <a name='-1'></a>34-在排序数组中查找元素的第一个 - 类似剑指offer53

https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/

[哈哈哈](https://www.bilibili.com/video/BV1Zv411y71t?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1GU4y1j7dq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ef4y1v7Vz?spm_id_from=333.999.0.0)

```py
# Python 二分法

class Solution:
    def searchRange(self, nums, target):
        left = 0
        right = len(nums)-1
        res = [0,0]
        
        if target not in nums:
            return [-1,-1]

        # 寻找左侧边界
        while left <= right:
            mid = (right + left) // 2
            if nums[mid] == target:
                right = mid - 1 # 结束条件, 因为保留 left，所以移动 right
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[0] = left

        # 寻找右侧边界
        right = len(nums)-1 # 只移动 right 端点
        while left <= right:
            mid = (right + left) // 2
            if nums[mid] == target:
                left = mid + 1 # 结束条件, 因为保留 right，所以移动 left
            elif nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        res[1] = right

        return res
```


```scala
/**
* modify binary search template
* memo
*  1. search first and last the the same function
*  2. if nums(mid) == target we could move left to check if left part exists target number
*  3. finding last by target + 1,  then we could get last position of target by first position of (target + 1) - 1
* tricky:
*  1. ans = nums.length
*  2. first > last  means that target doesn't exists
*
* time complexity: O(2logN)
*/
 
 object Solution2 {
    def searchRange(nums: Array[Int], target: Int): Array[Int] = {
        val first = search(nums, target)
        val last = search(nums, target + 1) - 1
        if (first > last) Array(-1, -1) else Array(first, last)
    }

    def search(nums: Array[Int], target: Int): Int = {
      var ans = nums.length
      var left = 0
      var right = nums.length - 1
      while (left <= right) {
        val mid = left + (right - left) / 2
        if (nums(mid) >= target) {
          ans = mid
          right = mid - 1
        }else {
          left = mid + 1
        } 
      }
      ans
    }
}

```

# 5 day (得分 = 6分) 69

##  82. <a name='-1'></a>153-寻找旋转排序数组中的最小值

[哈哈哈](https://www.bilibili.com/video/BV1bT4y1w7yK?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1yK411L7rp?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMin(self, nums):
        left, right = 0, len(nums) - 1
        # [4,5,6,7,0,1,2]
        # 只用 mid 和 right 比较

        while left <= right:
            mid = (right + left) // 2       
            if nums[mid] == nums[right]:    # 此时 left 和 right 相等，直接返回
                return nums[right]
            elif nums[mid] < nums[right]:   # 比右界小，nums[mid] 可能是最小值，不能去掉
                right = mid                 # 比如 [5,6,7,0,1,2,4]
            else:                           # 比右界大，nums[mid] 肯定不会是最小值     
                left = mid + 1
```

```scala

/**
* my first commitment binary search
*/
object Solution1 {
    def findMin(nums: Array[Int]): Int = {
        search(nums, 0, nums.length - 1)
    }
  
    def search(nums: Array[Int], left: Int, right: Int): Int = {
      if (left > right) return nums(left)
      val mid = left + (right - left) / 2
      val leftAns = if (nums(mid) >= nums(left)){ // left part in order
        nums(left)
      } else {
        search(nums, left, mid - 1)
      }
      
      val rightAns = if (nums(mid) <= nums(right)) { // right part in order
        nums(mid)
      } else {
        search(nums, mid + 1, right)
      }
      
      leftAns min rightAns
    }
}
```

##  83. <a name='-1'></a>62-不同路径

[哈哈哈](https://www.bilibili.com/video/BV1mC4y1W7Je?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sg4y1v7PM?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1cp4y167qx?spm_id_from=333.999.0.0)

二维动态规划：

时间复杂度：O(mn)

空间复杂度：O(mn)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 易错点：dp千万不要写错
        # 其他写法：dp = [[1 for i in range(n)] for j in range(m)]
        # 其他写法：dp = [[1]*n]*m
        dp = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]
        for i in range(1, m): # 这里从 1 开始
            for j in range(1, n): # 这里从 1 开始
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
```

一维动态规划：

时间复杂度：O(mn)

空间复杂度：O(n)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 易错点：dp千万不要写错
        dp = [1] * n
        for i in range(1, m):
            for j in range(1, n):
                dp[j] += dp[j - 1]
        return dp[-1]
```

```scala
/**
* fill dp array with 1
*/
object Solution2-1{
    def uniquePaths(m: Int, n: Int): Int = {
      val dp = Array.fill[Int](m, n)(1)
      for (i <- 1 until m; j <- 1 until n) {
        dp(i)(j) = dp(i - 1)(j) + dp(i)(j - 1)
      }
      
      dp.last.last
    }
}
```

##  84. <a name='LongestConsecutiveSequence'></a>128. 【🍒并查集】Longest Consecutive Sequence

[花花酱](https://www.bilibili.com/video/BV14t411Y7cg?spm_id_from=333.999.0.0)

[一俩三四五](https://www.bilibili.com/video/BV1LJ41137r2?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

```py
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        res = 0
        numSet = set(nums)

        for num in numSet:
            if num - 1 not in numSet: # 去重，表示和前面的不连续
                cur = num
                curlen = 1

                while cur + 1 in numSet: # 表示和后面的联系
                    cur += 1
                    curlen += 1

                res = max(res, curlen)

        return res
```

##  85. <a name='ValidateIPAddress'></a>468 Validate IP Address

[小明](https://www.bilibili.com/video/BV1tg4y1q7Kq?spm_id_from=333.999.0.0)

```py

class Solution:
    def validIPAddress(self, IP: str) -> str:
        if "." in IP:
            # ipv4
            ipv4 = IP.split(".")
            if len(ipv4) != 4:
                return "Neither"
            for num in ipv4:
                # 192.168.01.1 为无效IPv4地址
                # 192.168@1.1 为无效IPv4地址
                # 0 <= xi <= 255 
                if (len(num) > 1 and num[0] == "0")  \
                    or not num.isdigit()  \
                    or (int(num) < 0)  \
                    or (int(num) > 255):
                    return "Neither"
            return "IPv4"
        else:
            ipv6 = IP.split(":")
            if len(ipv6) != 8:
                return "Neither"
            for num in ipv6:
                # 1 <= xi.length <= 4
                # 可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )。
                if not num \
                    or len(num) > 4  \
                    or not all(map(lambda x: x.lower() in "0123456789abcdef", num)):
                    return "Neither"
            return "IPv6"


```

##  86. <a name='SingleNumber'></a>136 【位运算😜】Single Number

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7bf?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Sp4y1D7M3?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7PU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pa4y1t7tr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```py
class Solution:
    def singleNumber(self, nums):
        a = 0
        for num in nums:
            a = a ^ num
        return a

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)
```

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.reduce(_^_)
    }
}
```

##  87. <a name='FindPeakElement'></a>162. Find Peak Element

[小梦想家](https://www.bilibili.com/video/BV1Rb411n7dT?spm_id_from=333.999.0.0)

```py
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l = 0 
        r = len(nums) - 1 

        while l <= r:
            mid = (l + r) >> 1

            if l == r : return r # 关键在于这里

            elif nums[mid] < nums[mid + 1]: # 关键在于这里，背一背吧
                l = mid + 1
            elif nums[mid] > nums[mid + 1]:
                r = mid # right 可能是最终结果，所以不能省略
# [1,2,1,3,5,6,4]
# 3 < 5, 向右移动，left 指向 5，right 指向 4，想较大值方向移动
# 6 > 4, 向左移动，left 指向 5，right 指向 6 
# 5 < 6, 向右移动，left 指向 6，right 指向 6 
```

##  88. <a name='-1'></a>240. 二维数组的查找 - 74 Search a 2D Matrix

[哈哈哈](https://www.bilibili.com/video/BV1dz411i7jC?spm_id_from=333.999.0.0)


```py
class Solution:
    def searchMatrix(self, matrix, target):
        # 从右上角开始找
        i, j = 0, len(matrix[0]) - 1
        while i < len(matrix) and j >= 0:
            if matrix[i][j] == target: 
                return True
            elif target < matrix[i][j]: 
                j -= 1 # 若目标小了就左移
            elif target > matrix[i][j]: 
                i += 1 # 目标大了就下移
        return False
```

##  89. <a name='-1'></a>221-【动态🚀规划】最大正方形

[哈哈哈](https://www.bilibili.com/video/BV1XT4y137Gq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16K411575r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1mA411q7Sw?spm_id_from=333.999.0.0)

```py
# 右下角的坐标为 (x, y)
# 那么 (x - 1, y - 1) 一定需要是一个 square，
# 并且该点的左边全为1，上边也为1，按照这个进行理解变长的增加。
构建dp：
class Solution:
    def maximalSquare(self, matrix):
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * n for _ in range(m)]
        maxEdge = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    # 当 i 和 j 等于0时，i-1 为 -1
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    maxEdge = max(dp[i][j], res)
        return maxEdge * maxEdge

原地修改：
class Solution:
    def maximalSquare(self, matrix):
        maxEdge = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                if i and j: # 这个写法妙啊，刚好就跳过了 i-1
                    if matrix[i][j] == "1":
                        matrix[i][j] = min(int(matrix[i-1][j-1]), int(matrix[i][j-1]), int(matrix[i-1][j])) + 1
                    else:
                        matrix[i][j] = 0
                maxEdge = max(maxEdge, int(matrix[i][j]))
        return maxEdge**2       
```

##  90. <a name='Longestcommonprefix'></a>14 - Longest common prefix

[哈哈哈](https://www.bilibili.com/video/BV1cJ411D7qU?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Eb411i7QN?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1tV411k7GY?spm_id_from=333.999.0.0)

* 时间复杂度: O(mn), m 是字符串平均长度, n 是字符串数量

* 时间复杂度: O(1)

```py
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        lookup = set()
        res = ''
        i = 0
        minlen = min(len(string) for string in strs)
        while i < minlen:
            lookup = set(string[i] for string in strs)
            if len(lookup) == 1:
                res += lookup.pop() # set集合中用pop弹出数据
                i += 1
            else:
                break
        return res
```

```scala
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var flag = true
            var count = 1
            var output = ""
        
            var minLength = strs.map(_.length).min
        
        while(flag && count <= minLength){
            
            /**
            lst.forall(_ == lst.head)  // true  if empty or all the same
            lst.exists(_ != lst.head)  // false if empty or all the same
            */
            
            if(strs.map(s => s.substring(0, count)).distinct.length == 1){
                output = strs(0).substring(0, count)
                count += 1
            }else{
                flag = false
            }
        }
        
        output
        }
    }
}

//Alternate solution (better complexity)
object Solution {
    def longestCommonPrefix(strs: Array[String]): String = {
        if(strs.isEmpty){
            ""
        }else{
            var prefix = strs(0)
            
            (1 until strs.length).map(i => {
                
                while(strs(i).indexOf(prefix) != 0){
                    prefix = prefix.substring(0, prefix.length - 1)
                }
                
            })
            
            prefix
        }
    }
}

```

##  91. <a name='LargestNumber'></a>179 Largest Number

[小明](https://www.bilibili.com/video/BV1mV411m7aN?spm_id_from=333.999.0.0)

```py
from functools import cmp_to_key
class Solution(object):
    def largestNumber(self, nums):
        # 第一步：定义比较函数，把最大的放左边
        # 第二步：排序
        # 第三步：返回结果
        def compare(a, b):
            return int(b + a) - int(a + b)
        nums = sorted([str(x) for x in nums], key = cmp_to_key(compare))
        # nums = sorted(map(str, nums), key = cmp_to_key(compare))
        return str(int(''.join(nums)))
```

```py
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        # 按照字典序由大到小排序
        nums = sorted([str(x) for x in nums], reverse = True)
        for i in range(len(nums) - 1):
            for j in range(i, len(nums)):
        # [3,30,34,5,9] 的 3,30 不能按照字典序排序，需要交换位置
                if str(nums[i]) + str(nums[j]) < str(nums[j]) + str(nums[i]):
                    nums[i], nums[j] = nums[j], nums[i]
        return str(int(''.join(nums)))
```

##  92. <a name='-1'></a>138. 复制带随机指针的链表

```py
"""
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

hash解法：

class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head: return
        hash = {}

        cur = head
        while cur:
            hash[cur] = Node(cur.val)
            cur = cur.next
        
        cur = head
        while cur:
            hash[cur].next = hash.setdefault(cur.next)
            # hash[cur].next = hash.get(cur.next) 这里也可以用 get
            hash[cur].random = hash.setdefault(cur.random)
            cur = cur.next
            
        return hash[head]

dict.setdefault(key, default = None)  -->  有key获取值，否则设置 default，并返回default
dict.get(key, default = None)  -->  有key获取值，否则返回 default
```

```py
就背一背吧，反正看不懂
class Solution:
    def copyRandomList(self, head):
        def copyNode(node, visited):
            if not node: 
                return None
            if node in visited: 
                return visited[node]
            # 第一步：
            copy = Node(node.val, None, None)
            visited[node] = copy
            # 第二步：顺序不能错
            copy.next = copyNode(node.next, visited)
            copy.random = copyNode(node.random, visited)
            return copy

        return copyNode(head, {})
```

##  93. <a name='-1'></a>695-岛屿的最大面积

[哈哈哈](https://www.bilibili.com/video/BV1s54y1B77k?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wz4y1R7e6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1k64y1c798?spm_id_from=333.999.0.0)

```py
堆栈：

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        res = 0
        for i, lists in enumerate(grid):
            for j, n in enumerate(lists):
                area = 0
                stack = [(i, j)]
                while stack:
                    x, y = stack.pop()
                    # if 范围 + 值
                    if x < 0 or y < 0 or x == len(grid) or y == len(grid[0]) or grid[x][y] != 1:
                        continue
                    area += 1
                    grid[x][y] = 0
                    for dx, dy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        newX, newY = x + dx, y + dy
                        stack.append((newX, newY))
                res = max(res, area)
        return res

dfs

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        
        def dfs(i, j):
            grid[i][j] = 0 # 删除这个grid
            acc = 1
            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                # if 范围 + 值
                if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:
                    acc += dfs(x, y)
            return acc
        
        res = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    res = max(res, dfs(i, j))
        return res

并查集

union面积 是基于 find 和 dpArea
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        def find(v):
            if parent[v] != v:
                parent[v] = find(parent[v])
            return parent[v]
        # 简洁的写法是：
        # def union(i, j):
        #     parent[find(i)] = find(j)
        def union(v1, v2):
            r1 = find(v1)
            r2 = find(v2)
            if r1 != r2:
                parent[r2] = r1
                dpArea[r1] += dpArea[r2] # 合并, 到r1
        
        m, n = len(grid), len(grid[0])
        parent = [i * n + j for i in range(m) for j in range(n)]
        dpArea = [0] * (m * n) # 合并
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    cur = i * n + j
                    dpArea[cur] = 1  # 合并
                    if 0 <= i + 1 < m and grid[i + 1][j]:
                        dpArea[cur + n] = 1  # 合并
                        union(cur, cur + n)
                    if 0 <= j + 1 < n and grid[i][j + 1]:
                        dpArea[cur + 1] = 1  # 合并
                        union(cur, cur + 1)
        return max(dpArea)
```



##  94. <a name='Offer36.'></a>剑指 Offer 36. 二叉搜索树与双向链表

```py
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: 
            return

        rootlist = []
        treefunc = lambda r: r and (treefunc(r.left) or rootlist.append(r) or treefunc(r.right))
        def dfs(cur):
            if cur:
                dfs(cur.left) # 递归左子树, 进入下一层
                rootlist.append(cur)
                dfs(cur.right) # 递归右子树, 进入下一层
        
        dfs(root)
        lenth = len(rootlist)
        for i, cur in enumerate(rootlist):
            # i + 1 - lenth 的坐标值: -6 -5 -4 -3 -2 -1  0
            # i 的坐标值:              0  1  2  3  4  5  6
            # i - 1 的坐标值:         -1  0  1  2  3  4  5
            cur.left, cur.right = rootlist[i - 1], rootlist[i + 1 - lenth]
        return rootlist[0]
```

##  95. <a name='SwapNodesinPairs'></a>24-Swap Nodes in Pairs

[哈哈哈](https://www.bilibili.com/video/BV1M7411n7FT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV13J411V7hG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ih411f7YK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1VC4y1s75E?spm_id_from=333.999.0.0)

![](https://s3.bmp.ovh/imgs/2022/02/3738eb13202e2566.png)

```py
# 方法一：递归
class Solution(object):
    def swapPairs(self, head):

        if not head or not head.next:
            return head

        tmp = head.next
        # tmp 和 head 交换位置
        head.next = self.swapPairs(head.next.next)
        tmp.next = head
        return tmp # 易错点：注意，新的头已经变成了tmp
``` 

![](https://s3.bmp.ovh/imgs/2022/02/18153c0d0979e358.png)

```py
# 方法二：迭代
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head # 易错点：这句话不要漏
        cur = dummy
        while cur.next and cur.next.next:
            # 一共3个指针: first,second,cur
            first = cur.next
            second = cur.next.next
            
            # 把图画出来
            first.next = second.next
            second.next = first
            cur.next = second
            # 指针移动
            cur = cur.next.next
        return dummy.next
```

```scala
/**
* chosen solution
* iterative version
* memo
*   1. dummyHead
*   2. need two pointer: pre node and current node
*  time complexity: O(N), each node only visit once
*/
object Solution0 {
    def swapPairs(head: ListNode): ListNode = {
        val nHead = new ListNode(0, head)
        var pre: ListNode  = nHead
        var curr = pre.next

        while (curr != null && curr.next != null) {
            val (pos1, pos2, next) = (curr, curr.next, curr.next.next)
            pre.next = pos2
            pos2.next = pos1
            pos1.next = next

            pre = pre.next.next
            curr = pre.next  
        }
        
        nHead.next
    }
}



/**
* recursive version
*/
object Solution2 {
    def swapPairs(head: ListNode): ListNode = {
        _swap(head)
    }   
    
    def _swap(n: ListNode): ListNode = {
        if(n == null) n
        else {
            (n, n.next) match {
                case (a, null) => a
                case (a: ListNode, b: ListNode) => 
                    /** a b 要交換位子
                     */
                    a.next = _swap(b.next) // a 指向 b 的 next (已交換完成）
                    b.next = a // b 的 next 接上 a 就交換完成
                    b
            }
        } 
    }
}
```

##  96. <a name='DecodeString'></a>394 Decode String

[小明](https://www.bilibili.com/video/BV145411V75E?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GZ4y1p7pE?spm_id_from=333.999.0.0)

```py
本题核心思路：是在栈里面每次存储两个信息, 

(左括号前的`字符串`, 左括号前的`数字`)

class Solution:
    def decodeString(self, s: str) -> str:
        stack = []  
        tmp, num = "", 0 
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c) # 3
            elif c == "[":
                stack.append((tmp, num)) # 比如abc3[def], 当遇到第一个 "[" 的时候，压入栈中的是("abc", 3)
                tmp, num = "", 0
            elif c == "]":
                top = stack.pop() # 然后遍历括号里面的字符串def, 当遇到 "]" 的时候, 从栈里面弹出一个元素(s1, n1)
                tmp = top[0] + tmp * top[1] # 得到新的字符串为 abc + def * 3
            else:
                tmp += c # abc def
        return tmp

```

##  97. <a name='HouseRobber198-'></a>198. 【动态🚀规划】House Robber 198-打家劫舍

[12:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1tW411676f?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1u64y1M7PA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7hu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gZ4y1N75c?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV18g4y1i7f9?spm_id_from=333.999.0.0)

```py
动态🚀规划，典型例题：
class Solution:
    def rob(self, nums: List[int]) -> int:
        dp0 = 0
        dp1 = 0
        for num in nums:
            dp0, dp1 = dp1, max(dp0 + num, dp1) # (隔一个的和+当前, 前一个的和)
        return dp1
```


```scala
//While using DP: we try to store values of repetitive calculations
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var dp = Array.fill(nums.length+1)(0)
            
            dp(0) = 0
            dp(1) = nums(0)
            (1 to nums.length-1).map(i => {
                dp(i+1) = Math.max(dp(i), dp(i-1) + nums(i))
            })
            
            dp(nums.length)
        }
    }
}

//Another way to do the same
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.isEmpty){
            0
        }else{
            var rob = nums(0)
            var no_rob = 0
            var prev = rob
            for(i <- 1 until nums.length){
                prev = rob
                rob = no_rob + nums(i)
                no_rob = Math.max(prev, no_rob)
                
            }
            Math.max(no_rob, rob)
        }
    }
}

```

##  98. <a name='-1'></a>209-长度最小的子数组

[哈哈哈](https://www.bilibili.com/video/BV1JZ4y1N7Rt?spm_id_from=333.999.0.0)

```py
暴力解法；

class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        minlen = n + 1
        for i in range(n):
            total = 0
            #  连续子数组, 所以是 i 到 j 累加
            for j in range(i, n):
                total += nums[j]
                if total >= s:
                    minlen = min(minlen, j - i + 1)
                    break
        
        return 0 if minlen == n + 1 else minlen
```


```py
       
O(n log n) 时间复杂度，用二分

class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        l, r, res = 0, len(nums), 0
        def isWinEnough(size):
            sums = 0
            for i in range(len(nums)):
                sums += nums[i]
                # 固定大小的滑动窗口
                if i >= size:
                    sums -= nums[i - size]
                # 然后判断是否满足要求
                if sums >= s:
                    return True
            return False
            
        while l <= r:
            mid = (l + r) // 2  # 滑动窗口大小
            if isWinEnough(mid):  # 如果这个大小的窗口可以那么就缩小
                res = mid
                r = mid - 1
            else:  # 否则就增大窗口
                l = mid + 1
        return res

```

##  99. <a name='BasicCalculatorII'></a>227 Basic Calculator II - 见 224. 基本计算器

[小明](https://www.bilibili.com/video/BV1Qy4y167Ax?spm_id_from=333.999.0.0)

https://www.bilibili.com/video/BV1t4411c7m6?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

https://www.bilibili.com/video/BV1v54y1a74b?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

```py
class Solution:
    def calculate(self, s: str) -> int:
        stack = []
        num, op = 0, "+"  # 这个"+", 在最前面,是因为算法符号具有滞后性
        for i, char in enumerate(s):
            if char.isdigit():
                num = 10 * num + int(char)
            if char in "+-*/" or i == len(s)-1:
                if op == "+":
                    stack.append(num)
                elif op == "-":
                    stack.append(-num)
                elif op == "*":
                    stack.append(stack.pop()*num)
                elif op == "/":
                    stack.append(int(stack.pop()/float(num)))
                num, op = 0, char # op 的赋值放在最后面, 是因为算法符号具有滞后性
        return sum(stack)

```

```py
# 本题不含括号和符号位，所以将 '/' 替换为 '//' 就可以直接调用 eval 了。
class Solution(object):
    def calculate(self, s):
        return eval(s.replace('/', '//'))
```

##  100. <a name='-1'></a>958. 二叉树的完全性检验

```py
2 * v 和 2 * v + 1
         1
        / \
       2   3
      / \ / \
     4  5 6  7

2 * v + 1 和 2 * v + 2
         0
        / \
       1   2
      / \ / \
     3  4 5  6

class Solution(object):
    def isCompleteTree(self, root):
        stack = [(root, 1)]
        i = 0
        # 本来这边应该要用 queue 的，因为需要 popleft
        while i < len(stack):
            node, v = stack[i]
            i += 1
            if node:
                stack.append((node.left,  2 * v))
                stack.append((node.right, 2 * v + 1))

        return stack[-1][1] == len(stack)
```

# 6 day (得分 = 5分) 74

##  101. <a name='Offer09.'></a>剑指 Offer 09. 用两个栈实现队列

```py
stack_in 只负责进入
stack_out 只负责取出

只有 stack_out 为空时才把 stack_in 的所有元素倾倒进stack_out中，这样顺序就不会乱了
class CQueue:

    def __init__(self):
        self.stack_in = []
        self.stack_out = []

    def appendTail(self, value: int) -> None:
        self.stack_in.append(value)

    def deleteHead(self) -> int:
        # 如果 self.stack_out 没有内容，就 呼叫 self.stack_in
        if not self.stack_out:
            if not self.stack_in: # 都为空
                return -1
            else: # 把in栈中的东西全部倒入out栈中
                while self.stack_in:
                    self.stack_out.append(self.stack_in.pop())
        # 如果 self.stack_out 有内容，就直接 pop
        return self.stack_out.pop()
```

##  102. <a name='II'></a>122-【贪心🧡】买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II

[哈哈哈](https://www.bilibili.com/video/BV12K411A7rL?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d7411x78d?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7iq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Fk4y1R7ve?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y1L7LG?spm_id_from=333.999.0.0)

```py
贪心算法：一次遍历，只要`今天价格`小于`明天价格`就在今天买入然后明天卖出，时间复杂度 O(n)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
            preprice = price
        return maxprofit
```

```scala

/**
* greedy alg: one line pass
*/

object Solution1-2 {
  def maxProfit(prices: Array[Int]): Int = {
    if(prices.length > 1) prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum else 0
  }
}

//Alternate solution
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices
            .foldLeft(0,Int.MaxValue)((t, current) => (t._1 + 0.max(current-t._2), current))
            ._1
    }
}

```


##  103. <a name='Offer54.k'></a>剑指 Offer 54. 二叉搜索树的第k大节点 - 230 Kth Smallest Element in a B

```py
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        def inorder(root):
            if not root:
                return

            inorder(root.right)
            self.k -= 1
            if self.k == 0: 
                self.res = root.val
                return
            inorder(root.left)

        self.k = k
        inorder(root)
        return self.res
```

##  104. <a name='-1'></a>283. Move Zeros

[小梦想家](https://www.bilibili.com/video/BV1m441187Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ba4y1t7eK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Wp4y1y7pT?spm_id_from=333.999.0.0)

```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0:
                # 把 index 的位置变成不是 0, i 的位置变成是 0
                nums[slow], nums[fast] = nums[fast], nums[slow]
                # slow 的位置不是 0, 都在前面
                slow += 1
#                       [0, 1, 0, 3, 12]
# slow: 0 fast: 1 nums: [1, 0, 0, 3, 12]
# slow: 1 fast: 3 nums: [1, 3, 0, 0, 12]
# slow: 2 fast: 4 nums: [1, 3, 12, 0, 0]

```

```scala
//Alternate solution: calculate the number of shifts 
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        
        var zeroCount = 0
        //count of zero is amount character is shifted to left
        //from first zero position traverse array left
        for(a <- 0 to nums.size-1){   
            //count zeroes and shift when not zero
            if(nums(a) == 0){
                zeroCount = zeroCount + 1
            }else if(zeroCount > 0){
                //shift left if not 0 by zeroCount
                nums(a - zeroCount) = nums(a)
                nums(a) = 0
            }
        }
    }
}

```

##  105. <a name='-1'></a>498. 对角线遍历

```py


'''


    m, n = 7
   每层的索引和:
            0:              (00)               i: 0 ~ 0
            1:            (01)(10)             i: 0 ~ 1
            2:          (20)(11)(02)           i: 0 ~ 2
            3:        (03)(12)(21)(30)         i: 0 ~ 3
            4:      (40)(31)(22)(13)(04)       i: 0 ~ 4
            5:    (05)(14)(23)(32)(41)(50)     i: 0 ~ 5
            6:  (60)(51)................(06)   i: 0 ~ 6
            7:    (16)................(61)     i: 1 ~ 6
            8:      (62)............(26)       i: 2 ~ 6
            9:        (36)........(36)         i: 3 ~ 6
           10:          (64)....(46)           i: 4 ~ 6
           11:            (56)(65)             i: 5 ~ 6
           12:              (66)               i: 6 ~ 6

        按照“层次”遍历，依次append在索引边界内的值即可
'''





class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:
        m, n = len(matrix), len(matrix) and len(matrix[0])
        # tmp = collections.defaultdict(list), 这个方法相对没那么好
        tmp = [[] for _ in range(m + n - 1)]
        for i in range(m):
            for j in range(n):
                tmp[i + j].append(matrix[i][j])
        res = []
        for i, diag in enumerate(tmp):
            res.extend(diag if i % 2 else diag[::-1])
        return res
```

##  106. <a name='-1'></a>662. Maximum Width of Binary Tree

[花花酱](https://www.bilibili.com/video/BV1cv411q7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16a4y1h7fG?spm_id_from=333.999.0.0)

```py
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        res = 0
        queue = collections.deque([(root, 1)])
        while queue:
            res = max(res, queue[-1][1] - queue[0][1] + 1)# 只能写在这里！否则不存在
            for _ in range(len(queue)):
                node, pos = queue.popleft()
                if node.left:  queue.append((node.left,  pos * 2))
                if node.right: queue.append((node.right, pos * 2 + 1))
        return res 
```

##  107. <a name='-1'></a>297. Serialize and Deserialize Binary Tree

[花花酱](https://www.bilibili.com/video/BV1Hb411c7cr?spm_id_from=333.999.0.0)

```py
class Codec:
    def serialize(self, root):
        # 前序遍历
        def func(r):
            return str(r.val) + ',' + func(r.left) + func(r.right) if r else ','
        return func(root)

    def deserialize(self, data):
        # 前序遍历
        lis = data.split(',')[::-1]
        def func():
            val = lis.pop()
            return TreeNode(val, func(), func()) if val else None
        return func()

```

##  110. <a name='-1'></a>152 【动态🚀规划】乘积最大子数组

[哈哈哈](https://www.bilibili.com/video/BV12a4y1i76G?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iK411K7yG?spm_id_from=333.999.0.0)

maxdp * num, mindp * num, num

```py
# 动态🚀规划：

# 遍历时，每次分别存储 前i个中连续数组 [最大的乘积和] 和 [最小乘积和]

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums: return 
        res = nums[0]
        maxdp = nums[0]
        mindp = nums[0]
        for num in nums[1:]:
            maxdp, mindp = max(maxdp * num, mindp * num, num), min(maxdp * num, mindp * num, num)
            res = max(res, maxdp)
        return res

# 之所有存 [最小乘积和]，是因为 [最小乘积和] 如果是负数有可能遇到负数，

# 相乘后结果更大 Python
```

```scala

object Solution2-1 {
    def maxProduct(nums: Array[Int]): Int = {
        
        val (_, _, ans) = (1 until nums.length).foldLeft((nums.head, nums.head, nums.head)){
            case ((min, max, ans), idx) => 
                val a = nums(idx) * min 
                val b = nums(idx) * max
                val newMin = a min b min nums(idx)
                val newMax = a max b max nums(idx)
                (newMin, newMax, ans max newMax)
        }
        ans
    }
}



```

##  111. <a name='-1'></a>79. Word Search

[小梦想家](https://www.bilibili.com/video/BV1yE411g7Tb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iZ4y1T78D?spm_id_from=333.999.0.0)

```py
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def dfs(i, j, word):
            # 单词是否出现在以i，j为起点的网格中
            # word[0] 和 word[1:] 划分
            # 结束条件：
            if len(word) == 1:
                return word[0] == board[i][j]
            # 结束条件：
            if board[i][j] != word[0]:
                return False
            
            # 设置现场
            visit[i][j] = True
            for dire in direction: # 对四个方向进行搜索
                newi, newj = i + dire[0], j + dire[1]
                if 0 <= newi < len(board) and 0 <= newj < len(board[0]) and not visit[newi][newj]:
                    if dfs(newi, newj, word[1:]): # dfs成功
                        return True
            # 还原现场
            visit[i][j] = False

        direction = [(0,1), (0, -1), (1, 0), (-1, 0)]
        m = len(board)
        n = len(board[0])
        visit = [[False] * n for _ in range(m)]
        for i in range(m): # 遍历所有格子作为单词起点
            for j in range(n):
                if dfs(i, j, word): # dfs成功
                    return True
        return False
```


```scala
/**
* directly compare with char by char
* if there are only one word should be checked in board, brute force is a more efficient method
*/

object Solution2 {
  private val visitedLabel = '#'
  def exist(board: Array[Array[Char]], word: String): Boolean = {
    dfs(word, board)
  }

  def dfs(word: String, board: Array[Array[Char]]): Boolean = {

    def _dfs(coord: (Int, Int), wordIdx: Int): Boolean = {
      val char = board(coord._1)(coord._2)

      if(wordIdx >= word.length || char != word.charAt(wordIdx)) false
      else if(char == word.charAt(wordIdx) && wordIdx == word.length - 1) true
      else {
        board(coord._1)(coord._2) = visitedLabel
        val exists = getNeighbors(coord, (board.length, board(0).length)) exists {
          case (nr, nc) if board(nr)(nc) != visitedLabel => _dfs((nr, nc), wordIdx + 1)
          case _ => false
        }
        board(coord._1)(coord._2) = char
        exists
      }
    }
    
    val coords = for (i <- board.indices.view; j <- board(0).indices.view) yield (i ,j)
    coords.exists(_dfs(_, 0))
  }

  val getNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

##  113. <a name='Offer10-I.'></a>剑指 Offer 10- I. 斐波那契数列

```py

from functools import lru_cache
class Solution:
    @lru_cache(None)
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return (self.fib(n - 1) + self.fib(n - 2)) % 1000000007
        # 1 1 2 3 5


也可以这样写，同时赋值。
class Solution:
    def fib(self, n: int) -> int:
        MOD = 10 ** 9 + 7
        if n < 2:
            return n
        dp0, dp1 = 0, 1
        for _ in range(2, n + 1): # 注意：这里的边界
            dp1, dp0 = (dp1 + dp0) % MOD, dp1
            # index: 1 2 3 4 5
            # fib:   1 1 2 3 5
        return dp1
```

##  115. <a name='Offer21.'></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面

```py
类似前面的移动0
class Solution:
    def exchange(self, nums: List[int]) -> List[int]:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] & 1 == 1:
                # 把 [fast上的奇数] 移动到 [slow的位置] 上
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1
        return nums
```

##  116. <a name='II-1'></a>59. Spiral Matrix II 

[小梦想家](https://www.bilibili.com/video/BV1J741157Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1q5411G7MY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        res    = [[0 for _ in range(n)] for _ in range(n)]
        x,  y  = 0, 0 
        dx, dy = 0, 1
        # 0,1 -> 1,0 -> 0,-1 -> -1,0
        for num in range(1, n * n + 1):
            res[x][y] = num
            nx, ny = x + dx, y + dy

            if not 0 <= nx < n or not 0 <= ny < n or res[nx][ny] != 0:
            # 易错点：or res[nx][ny] != 0 顺序很重要，一定要在最后，就像贪吃蛇
                dx, dy = dy, -dx # 调头

            x += dx
            y += dy
        return res
```

## 328. 奇偶链表 (Odd Even Linked List)

[洛阳](https://www.bilibili.com/video/BV1v64y1u7AH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ag4y1B78z?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def oddEvenList(self, head):
        if head == None:
            return head
        # odd 和 even 都是移动指针
        # evenHead 是固定的
    
        odd  = head
        even = evenHead = head.next
        # 当 2 和 3 存在
        while even and even.next:
            # 1 -> 2的后面
            odd.next = even.next
            # 1 变成 3
            odd = odd.next
            # 2 -> 3的后面
            even.next = odd.next 
            # 2 变成 4
            even = even.next
        odd.next = evenHead # 先奇数，后偶数
        return head 
```

##  117. <a name='1.'></a>补充题1. 排序奇升偶降链表

1. 按奇偶位置拆分链表，得 1->3->5->7->NULL 和 8->6->4->2->NULL  328. 奇偶链表
2. 反转偶链表，得 1->3->5->7->NULL 和 2->4->6->8->NULL         206. 反转链表
3. 合并两个有序链表，得 1->2->3->4->5->6->7->8->NULL           21. 合并两个有序链表

https://mp.weixin.qq.com/s/0WVa2wIAeG0nYnVndZiEXQ

```py
输入: 1->8->3->6->5->4->7->2->NULL
输出: 1->2->3->4->5->6->7->8->NULL

class ListNode:    
    def __init__(self, x):        
        self.val = x        
        self.next = None

class Solution:    
    def sortOddEvenList(self,head):     
        if not head or not head.next:      
            return head        
        oddList,evenList = self.partition(head)        
        evenList = self.reverse(evenList)        
        return self.merge(oddList,evenList)    

    def partition(self, head: ListNode) -> ListNode:        
        evenHead = head.next        
        odd, even = head, evenHead        
        while even and even.next:            
            odd.next = even.next            
            odd = odd.next            
            even.next = odd.next            
            even = even.next        
        odd.next = None # 节点需要断开
        return [head,evenHead]    

    def reverse(self,head):    
        res = None
        while head:
            headnxt = head.next
            head.next = res
            res = head
            head = headnxt
        return res    

    def merge(self,p,q):        
        dummy = ListNode(0)        
        cur = dummy        
        while p and q:            
            if p.val <= q.val:               
                cur.next = p                
                p = p.next            
            else:                
                cur.next = q                
                q = q.next            
            cur = cur.next        
        cur.next = p or q        
        return dummy.next
```

##  118. <a name='Offer40.k'></a>剑指 Offer 40. 最小的k个数

```py
import heapq
class Solution(object):
    def getLeastNumbers(self, arr, k):
        return heapq.nsmallest(k, arr)

class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        arr.sort()
        return arr[:k]

class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
        if k == 0:
            return list()
        # 这里需要弹出最大值，而heapq只能弹出最小值，所以需要取反
        hp = [-x for x in arr[:k]]
        heapq.heapify(hp)
        for i in range(k, len(arr)):
            if -hp[0] > arr[i]: # arr[i] 更小，则更符合条件，所以放进hp去
                heapq.heappushpop(hp, -arr[i])
        ans = [-x for x in hp]
        return ans

输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
hp：
[-3, -2]
[-2, -1]

```

##  119. <a name='II-1'></a>518 Coin Change 2 - 见 322. 【动态🚀规划 + 背包 + dfs】Coin Change

https://leetcode-cn.com/problems/coin-change-2/

[小明](https://www.bilibili.com/video/BV1jC4y1a7YT?spm_id_from=333.999.0.0)

```py
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        # dp[i]代表金额为i的时候能凑成总金额的硬币组合数量
        dp = [0] * (amount + 1)
        dp[0] = 1
        for i in range(len(coins)):
            # 假如只有1个硬币，假如有2个硬币，假如有3个硬币~ ~ ~
            for j in range(coins[i], amount + 1):
               dp[j] += dp[j - coins[i]]
        return dp[-1]
```

##  120. <a name='-1'></a>224. 基本计算器 - 见 227 Basic Calculator II 两道题完全不同

https://www.bilibili.com/video/BV1Nb4y1z7hG?from=search&seid=1882841343164929357&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.71qtf391s5w0.png" width="40%">

```py

class Solution:
    def calculate(self, s: str) -> int:
        stack = [1]
        sign = 1
        i = 0
        res = 0
        while i < len(s):
            if s[i].isdigit():
                num = 0
                while i < len(s) and s[i].isdigit():
                    num = 10 * num + int(s[i])
                    i += 1
                res += sign * num
            else:
                if s[i] == '+':   sign = stack[-1]
                elif s[i] == '-': sign = -stack[-1]
                # -(1-(4+5+2)-3)+(6+8)
                # stack[-1] 是因为负负得正
                elif s[i] == '(': stack.append(sign)
                elif s[i] == ')': stack.pop()
                i += 1
        return res
```

# 7 day (得分 = 4分) 78

##  121. <a name='K'></a>402 Remove K Digits

[小明](https://www.bilibili.com/video/BV1PV411C79X?spm_id_from=333.999.0.0)

形成一个新的最小的数字：

```py
输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。

class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        numStack = []
        
        # 构建单调递增的数字串
        for digit in num:
            while k and numStack and numStack[-1] > digit: # 3个条件
                numStack.pop()
                k -= 1
        
            numStack.append(digit)
        
        # 如果 K > 0，删除末尾的 K 个字符
        finalStack = numStack[:-k] if k else numStack
        
        # 抹去前导零
        return "".join(finalStack).lstrip('0') or "0"

```

##  122. <a name='23.'></a>补充题23. 检测循环依赖

```s
现有n个编译项，编号为 0 ~ n-1。给定一个二维数组，

表示编译项之间有依赖关系。如[0, 1]表示1依赖于0。

若存在循环依赖则返回空；不存在依赖则返回可行的编译顺序。
```

```py
目标：是让 graph 里面，全部进入 que，最后进入 res
class Solution:
    def haveCircularDependency(self, n: int, prerequisites):
        graph = [[] for _ in range(n)] # 邻接表存储图结构
        indegree = [0 for _ in range(n)] # 每个点的入度
        # 将依赖关系加入邻接表中g，并各个点入度
        for pre in prerequisites:
            a, b = pre[0], pre[1]
            graph[a].append(b)
            indegree[b] += 1
            
        # 一次性将入度为0的点全部入队
        que = deque()
        for i in range(n):
            if indegree[i] == 0:
                que.append(i)

        res = []
        while que:
            start = que.popleft()
            res.append(start)
            # 删除边时，将终点的入度-1。若入度为0，果断入队
            for end in graph[start]:
                indegree[end] -= 1
                if indegree[end] == 0:
                    que.append(end)
        # 若存在循环依赖则返回空；不存在依赖则返回可行的编译顺序。
        return res if len(res) == n else []
```

##  123. <a name='-1'></a>7 Reverse Integer

[哈哈哈](https://www.bilibili.com/video/BV1sE411e73m?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7bM?spm_id_from=333.999.0.0)

* 时间复杂度: O(log10(n)), 每次迭代都会除以 10

* 时间复杂度: O(1)

```py
字符串法：
class Solution:
    def reverse(self, x: int) -> int:
        s = str(x)

        if '-' in s:
            sn = '-'
            s = s[1:len(s)]
        else:
            sn = ''

        for i in range(len(s)):
            sn = sn + s[len(s)-1-i]
        if int(sn) < -2**31 or int(sn) > 2**31-1:
            return 0
        return int(sn)

计算法：
class Solution:
    def reverse(self, x: int) -> int:
        res = 0 
        a = abs(x)

        while a != 0:
            tmp = a % 10
            res = res * 10 + tmp
            a = a // 10
        # 要注意return和while的相对位置
        # 不要写在while循环内部

        if x > 0 and res < 1<<31:
            return res 
        elif x < 0 and res <= 1<<31:
            return -res
        else:
            return 0
```


```scala
object Solution {
    def reverse(x: Int): Int = {
        if(x == 0){
            0
        }else{
            var output = 0L
            var num = x
            var flag = false
            
            if(x < 0){
                num = Math.abs(num)
                flag = true
            }
            
        
            while(num!=0){
                var mod = num%10
            
                output = (output*10) + mod
            
                num = num/10
            }
            
            val res = if(flag){
                output * (-1)
            }else{
                output
            }
            //To avoid overflow
            if(res < Int.MinValue || res > Int.MaxValue) 0 else res.toInt
        }
    }
}
```

##  125. <a name='-1'></a>739-Daily Temperatures

[哈哈哈](https://www.bilibili.com/video/BV1Q7411L7w8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ov411z7rM?spm_id_from=333.999.0.0)

```py
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = [0] * n # 如果温度递减，那么答案都是 0
        stack = []
        # 用 i 来触发计算
        for i in range(n):
            tmpt = temperatures[i]
            # 指在第 i 天之后，才会有更高的温度。
            # [73,74,75,71,69,72,76,73]
            # []
            # [0]
            # [1]
            # [2]
            # [2, 3]
            # [2, 3, 4]
            # [2, 5]
            # [6]
            # 如果比前一项大，则直接pop，成功
            while stack and temperatures[stack[-1]] < tmpt:
                preIdx = stack.pop()
                res[preIdx] = i - preIdx
            stack.append(i) 
        return res
```

##  126. <a name='-1'></a>61. Rotate List

[花花酱](https://www.bilibili.com/video/BV14y4y1r728?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV117411L7UG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jK411N7e6?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Xk4y1d7gF?spm_id_from=333.999.0.0)

```py
注意：这里很喜欢用 cur.next
# 思路：先把链表首尾相连，再找到位置断开循环
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 易错点：要排除一些特殊情况
        if not head or not head.next:
            return head
            
        cur = head
        nodeNum = 1
        # 链接成一个环
        while cur.next:
            cur = cur.next
            nodeNum += 1
        cur.next = head


        # cur 指针指向开头
        cur = cur.next
        # 输入：head = [1,2,3,4,5], k = 2
        # 输出：[4,5,1,2,3]
        # steps 到达 new head 的前一个 node，就是 3，steps = 5-2-1
        steps = nodeNum - k % nodeNum - 1
        for _ in range(steps):
            cur = cur.next


        res = cur.next
        cur.next = None
        return res
```

##  127. <a name='Offer62.'></a>剑指 Offer 62. 圆圈中最后剩下的数字

```py
https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/

0个人时候游戏就不存在了， 1个人时候直接获胜， 
 
反推公式：

f(n,m) = (f(n,m) + m) % i #i为当前人数

f(8,3) = [f(7,3) + 3] % 8

约瑟夫环：

class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        res = 0
        for i in range(2, n + 1):
            res = (res + m) % i
        return res
```

##  128. <a name='Offer51.'></a>剑指 Offer 51. 数组中的逆序对

```py
如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对：
输入: [7,5,6,4]
输出: 5
class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        q = []
        res = 0
        for v in nums:
            # 变负数插入，绝了-v，构成递增序列
            i = bisect.bisect_left(q,-v) # bisect_left 返回的待插入位置分别是 0，1，1，3，
            res += i # 前面有多少个比它大的，当前数就有多少个逆序对,加起来就是逆序对总数 5
            q[i:i] = [-v]
            # 这里也可以写：q.insert(i, -v)
        return res
# q[i:i] = [-v] 的效果如下，是一个排好序的数组：
# [-7]
# [-7, -5]
# [-7, -6, -5]
# [-7, -6, -5, -4]

如果不用负数，就要用 res += len(q) - i 了，

并且要改用 i = bisect.bisect(q, v)。

```

##  129. <a name='K-1'></a>560. 【前缀和🎨】Subarray Sum Equals K 和为K的子数组

[花花酱](https://www.bilibili.com/video/BV1XW411d71i?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d54y127ri?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vK4y1k7ku?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV13t4y1y7ya?spm_id_from=333.999.0.0)

```py
查表法：
class Solution:
    def subarraySum(self, nums: 'List[int]', target: 'int') -> 'int':
        presum, res, dic = 0, 0, {}
        dic[0] = 1 # 刚好前 n 个的和为 target
        for num in nums:
            presum += num
            if presum - target in dic:
                res += dic[presum - target]
                # sums - target 就是前缀和
            if presum not in dic:
                dic[presum] = 0
            dic[presum] += 1
        # 输入：nums = [1,2,3], k = 3
        # 输出：2
        # -1000 <= nums[i] <= 1000 注意: nums 有正负
        # {0:1, 1:1}
        # {0:1, 1:1, 3:1}
        # {0:1, 1:1, 3:1, 6:1}
        return res
```


##  130. <a name='Powxn'></a>50 Pow(x, n)

[小明](https://www.bilibili.com/video/BV1W54y1q7CV?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ai4y147kr?spm_id_from=333.999.0.0)

```py
class Solution:
    def myPow(self, x: float, n: int) -> float:
        res = 1

        if n < 0:
            x = 1 / x
            n = - n

        # 类似2分，速度更快
        while n > 0:
            if n % 2 == 1:
                res *= x # 注意: res 这里, 同步发生变化
            n >>= 1 # 等价于 n //= 2
            x *= x       # 注意: x 这里, 同步发生变化
        return res
```

```scala

/**
* recursive version : bottom-up
* memo
*   1. n may be negative or positive
*   2. n may be odd or even
* O(logN) in time
*/
object Solution1 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) 1
    else if(n > 0) {
      n % 2 match{
        case 1 => myPow(x * x, n / 2) * x
        case 0 => myPow(x * x, n / 2)
      }
    }else{
      val t = myPow(x, n / 2)
      math.abs(n % 2) match{
        case 1 => t * t * (1 / x)
        case 0 => t * t
      }
    }

  }
}

/**
* top-down - iterative version 
* Binary Exponentiation with negative n
*
* each iteration is calculate pow(base, nn) * ans
*   ex: input x = 2, n = 10
*    0. base: 2.0, nn: 10 ans: 1.0 => pow(2, 10) * 1 =  1024
*    1. base: 4.0, nn: 5, ans: 1.0  => pow(4, 5) * 1 = 1024
*    2. base: 16.0, nn: 2, ans: 4.0 => pow(16, 2) * 4 = 1024
*    3. base: 256.0, nn: 1, ans: 4.0 => pow(256, 1) * 4 = 1024
*    4. base: 65536.0, nn: 0, ans: 1024.0 => pow(65536, 0) * 1024 = 1024
*
* time complexity: O(logN)
*/

object Solution2 {
  def myPow(x: Double, n: Int): Double = {
    if (n == 0) return 1
    var ans = 1.0
    var nn = n
    var base = x

    while (nn != 0) {
     /* nn could be -1 if nn < 0 and run nn % 2, so using nn & 1 here */
      if((nn & 1) == 1)  ans = ans * base
      nn = nn / 2
      base = base * base
    }
    // judge n to decide whether reverse ans
    if (n < 0) 1.0 / ans else ans  
  }
}

```

##  131. <a name='2.'></a>补充题2. 圆环回原点问题

```s
圆环上有 10 个点，编号为 0 ~ 9。
从`0点`出发，每次可以`逆时针`和`顺时针`走一步，问走`n步`回到`0点`共有多少种走法。

输入: 2
输出: 2
解释：有 2 种方案。分别是 0->1->0 和 0->9->0
```

```py
# 走 n 步到 0 的方案数 = 走 n-1 步到 1 的方案数 + 走 n-1 步到 9 的方案数。
# 公式之所以取余是因为 j-1 或 j+1 可能会超过圆环 0~9 的范围
class Solution:
    def backToOrigin(self,n):
        # 点的个数为 10
        circle = 10
        # step 在外面，site 在里面
        dp = [[0 for site in range(circle)] for step in range(n + 1)]
        dp[0][0] = 1
        for step in range(1, n + 1): # 走 1 ~ n 步
            for site in range(circle):
                # dp[i][j] 表示从 0 出发，走 step 步到 site 的方案数
                # ps:公式之所以`取余`是因为 site-1 或 site+1 可能会超过圆环 0~9 的范围
                dp[step][site] = dp[step-1][(site-1+circle)%circle] + dp[step-1][(site+1)%circle]
        return dp[n][0]
```

##  132. <a name='-1'></a>225-【构造🏰】Implement Stack using Queues

[哈哈哈](https://www.bilibili.com/video/BV1p741177pK?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ep4y1Y77j?spm_id_from=333.999.0.0)

```py
q2当作缓存队列

class MyStack:

    def __init__(self):
        # q1和q2是两个队列
        ## 保证q1当中永远有元素
        ## 保证q2当中永远没有元素
        self.q1 = deque([])
        self.tmp = deque([])

    def push(self, x: int) -> None:
        self.q1.append(x)
        
    def pop(self) -> int:
        # 把 [-1] 用 popleft 搞定 
        while len(self.q1) > 1:
            self.tmp.append(self.q1.popleft())
        self.q1, self.tmp = self.tmp, self.q1
        return self.tmp.popleft()
        
    def top(self) -> int:
        return self.q1[-1]

    def empty(self) -> bool:
        return not self.q1

```

```scala
/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */


/**
* chosen solution
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack0() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}




 /**
 * my first commit
 * two queue version
 * time complexity: 
 *   push: O(1)
 *   pop: O(2n - 1)  n is the element in queue1
 *   top: O(2n - 1)
 */
class MyStack1() {

    /** Initialize your data structure here. */
    var queue1 = scala.collection.mutable.Queue[Int]()
    var queue2 = scala.collection.mutable.Queue[Int]()

    /** Push element x onto stack. */
    def push(x: Int) {
        queue1.enqueue(x)
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
       }
    
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        ret
        
    }

    /** Get the top element. */
    def top(): Int = {
        while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
        }
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        queue1.enqueue(ret)
        ret
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty && queue2.isEmpty
    }

}

```

##  133. <a name='K-1'></a>230 Kth Smallest Element in a B - 见 剑指 Offer 54. 二叉搜索树的第k大节点

[小明](https://www.bilibili.com/video/BV1ha4y1i7dZ?spm_id_from=333.999.0.0)

```py
# 中序遍历
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        def appendAllLeft(node):
            while node:
                stack.append(node)
                node = node.left

        stack, res = [], []
        appendAllLeft(root)
        while stack:
            node = stack.pop()
            k -= 1
            if k == 0:
                return node.val
            appendAllLeft(node.right)

kthLargest: 先右后左
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        def inorder(root):
            if not root: return
            inorder(root.right)
            self.k -= 1
            if self.k == 0: 
                self.res = root.val
                return
            inorder(root.left)

        self.k = k
        inorder(root)
        return self.res

kthSmallest: 先左后右
class Solution:
    def kthSmallest(self, root, k: int) -> int:
        def dfs(root):
            if not root:
                return

            dfs(root.left)
            self.k -= 1
            if self.k == 0: 
                self.res = root.val
                return
            dfs(root.right)

        self.k = k
        dfs(root)
        return self.res
```


```scala
/**
* my first commit
* inorder iterative template
* time complexity: O(H + K) => H is tree height, H + K = element in stack
*/

object Solution1 {
    def kthSmallest(root: TreeNode, k: Int): Int = {
        
        val stack = collection.mutable.Stack[TreeNode]()
        var node = root
        var counter = 0
        
        
        while(node != null || stack.nonEmpty) {
            while(node != null) {
                stack push node
                node = node.left
            }
            node = stack.pop
            counter += 1
            if(counter == k) return node.value
            else node = node.right
            
        }
        -1
    }
}

/**
* inorder traversal - recursive version
* time complexity: O(H + k)
*/

object Solution2-1 {
    import scala.collection.mutable
    def kthSmallest(root: TreeNode, k: Int): Int = {
        val ret = _kthSmallest(root, k, mutable.ListBuffer.empty)

        ret(k - 1)
    }
    
    def _kthSmallest(node: TreeNode, k:Int, l: mutable.ListBuffer[Int]): mutable.ListBuffer[Int]  = {
       if(node == null) l
       else {
           _kthSmallest(node.left, k, l)
           l += node.value
           if(l.size >= k) l  // shortcut
           else  _kthSmallest(node.right, k, l)  
       }
    }
}



```

##  134. <a name='-1'></a>75. Sort Colors

[小梦想家](https://www.bilibili.com/video/BV1rE411n7mL?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ua4y1v7yd?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1tz4y1o7n5?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5l1bfbznzwc0.png)

```py
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        idx, left, right = 0, 0, len(nums) - 1
        while idx <= right:
            # 交换完位置后 idx 依旧在原位
            if nums[idx] == 2 and idx < right:
                nums[idx], nums[right] = nums[right], 2
                right -= 1
            # 交换完位置后 idx 依旧在原位
            elif nums[idx] == 0 and idx > left:
                nums[idx], nums[left] = nums[left], 0
                left += 1
            else:
            # idx 为 1, 或者 idx 与 [right/left] 相交
                idx += 1
```

##  135. <a name='II-1'></a>47 - ★ 全排列 II-剪枝版

类似题目：

https://leetcode-cn.com/problems/permutation-ii-lcci/

```py
class Solution:
    def permutation(self, S: str) -> List[str]:
        res = []
        S = sorted(S)
        def backtrack(S,path):
            if not S:
                res.append(path)
            else:
                for i in range(len(S)):
                    if i > 0 and S[i] == S[i-1]:  # 剪枝
                        continue
                    backtrack(S[:i] + S[i+1:], path + S[i])

        backtrack(S,'')
        return res
```

[哈哈哈](https://www.bilibili.com/video/BV1Ev411672A?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1qK4y1x7Qs?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1z54y1a7rQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        def backtrack(nums,path):
            if not nums:
                res.append(path[:])
            else:
                for i in range(len(nums)):
                    if i > 0 and nums[i] == nums[i-1]: # 剪枝
                        continue
                    backtrack(nums[:i] + nums[i+1:],path + [nums[i]])

        backtrack(nums,[])
        return res
```

##  136. <a name='-1'></a>11. Container With Most Water 

[花花酱](https://www.bilibili.com/video/BV1CW41167qB?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Gn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1A5411E7oM?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1TK41157jH?spm_id_from=333.999.0.0)

暴力解法：

* 时间复杂度:O(n2)

* 时间复杂度:O(1)

双指针法：

由于盛水面积由较短边控制，所以，指针放在两端，每次只移动较短边。因为，移动较长边的话。一定仍然是不变的。

* 时间复杂度:O(n)

* 时间复杂度:O(1)

```py
# 这个写起来超级简单！
# NO BUG
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left = 0
        right = len(height)-1
        maxRes = res = 0
        while left < right:
            res = (right - left) * min(height[left], height[right])
            if height[left] < height[right]:
                # 由于短板效应，只需要移动短板即可
                left += 1
            else:
                right -= 1
            maxRes = max(maxRes,res)
        return maxRes
```

```scala

/**
* two pointer version
* memo
*  1. fix left side,, the volume is bounded by left side if left side is shorter 
*  2. fix right side. the volume is bounded by right side if right side is shorter
*/

object Solution2 {
    def maxArea(height: Array[Int]): Int = {
      
      var left = 0
      var right = height.length - 1
      var volume = 0
      
      while(left < right) {
        val current = (right - left) * (height(right) min height(left))
        volume = volume max current
        
        if (height(left) < height(right)) // left is shorter
          left += 1
        else // right is shorter
          right -= 1
      }
      volume
    }
         
}

```

##  137. <a name='-1'></a>139 【动态🚀规划 + 背包】Word Break

[小明](https://www.bilibili.com/video/BV1p54y1k7vf?spm_id_from=333.999.0.0)

```py
# python 动态🚀规划

# 从 i = 0 开始分析：i = 0， 遍历 j in range(1, n+1)， 

# 即遍历所有以 s[0] 开头的组合，把第一个单词可能的情况全部找出来。

# 此时相当于把打头的单词可能的情况全部找出来了。

# 然后基于第一个单词一个单词一个单词地接上去。

class Solution:
    def wordBreak(self, s, wordDict):
        n = len(s) 
        dp = [True] + [False]*n

        for end in range(1, n + 1):
            for start in range(end):
                # 前提是 start 为 true, end 才为 true
                if dp[start] and s[start: end] in wordDict:
                    dp[end] = True # 说明 s[: i] 在 wordDict 中
                    break # 优化部分：剩下的切分点 j 不用再寻找了，也可以不写，像下方一样
        return dp[-1]

```

##  138. <a name='-1'></a>125 【回文🌈】Valid Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1d7411n7cF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7ML?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17h411Z7ey?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

isalnum() 方法检测字符串是否由`字母`和`数字`组成。

isalpha() 方法检测字符串是否只由`字母`组成。

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) - 1
        while left < right:
            # 易错点：if not s[left].isalnum() 是不对的，因为存在连续多个“非数字的情况”
            # 易错点：while left < right 不能省略
            while left < right and not s[left].isalnum(): 
                left += 1
            while left < right and not s[right].isalnum(): 
                right -= 1
            if s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else:
                return False
        return True
```

python牛逼的一行代码：

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        sgood = "".join(ch.lower() for ch in s if ch.isalnum())
        return sgood == sgood[::-1]

class Solution:
    def isPalindrome(self, s):
        s = ''.join(filter(str.isalnum,s)).lower()
        return s==s[::-1]
```


```scala
/**
* two pointer comparison
* memo
*  1. alphanumeric = letters + numerals
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def isPalindrome(s: String): Boolean = {
      val newString = s.filter(_.isLetterOrDigit).toLowerCase
      isPalindrome(newString, 0, newString.length - 1)
    }
    @annotation.tailrec
    def isPalindrome(s: String, left: Int, right: Int): Boolean = {
      if (left > right) return true
      if (s(left) == s(right)) isPalindrome(s, left + 1, right - 1)
      else false
    }
}
```



##  139. <a name='-1'></a>189. Rotate Array 

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Yy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N541177Bk?spm_id_from=333.999.0.0)

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        rotate = k % len(nums)
        if rotate:
            nums[:] = nums[::-1]
            nums[:rotate] = nums[:rotate][::-1]
            nums[rotate:] = nums[rotate:][::-1]
```

# 8 day (得分 = 3分) 81

##  141. <a name='-1'></a>74 Search a 2D Matrix - 240. 二维数组的查找

[小明](https://www.bilibili.com/video/BV1aK4y1h7Bb?spm_id_from=333.999.0.0)

```py
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        l = 0
        r = m * n - 1
        while l <= r:
            mid = (l + r) // 2
            midRow = mid // n
            midCol = mid % n
            if matrix[midRow][midCol] == target:
                return True
            elif matrix[midRow][midCol] > target:
                r = mid - 1 # 易错点：+1,-1不要写反了
            else:
                l = mid + 1
        return False
```

##  142. <a name='-1'></a>287 Find the Duplicate Number

[小明](https://www.bilibili.com/video/BV1Ug4y1v7mF?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pz4y1X7qR?spm_id_from=333.999.0.0)

```py
        """
        :type nums: List[int]
        :rtype: int
        """
        #数组只能读 所以不能排序,不能swap数组下标
        #时间复杂度小于 O(n^2) 不能暴力
        #空间复杂度 O(1) 不能额外开辟数组
        
        ''' 1、暴力不符合题意
        for i in nums:
            count = 0
            for num in nums:
                if num == i:
                    count += 1
            if count > 1:
                return i
        return -1
        '''
        
        '''2、小于O(n^2) 二分查找
        我们不要考虑数组,只需要考虑 数字都在 1 到 n 之间
        示例 1:
        arr = [1,3,4,2,2] 此时数字在 1 — 5 之间

        mid = (1 + 5) / 2 = 3 arr小于等于的3有4个(1,2,2,3)，1到3中肯定有重复的值
        mid = (1 + 3) / 2 = 2 arr小于等于的2有3个(1,2,2)，1到2中肯定有重复的值    if cnt > mid:  right = mid
        mid = (1 + 2) / 2 = 1 arr小于等于的1有1个(1)，2到2中肯定有重复的值        if cnt <= mid: left = mid + 1
        所以重复的数是 2 
        '''

要求：

只用常量级 O(1) 的额外空间

class Solution(object):
    def findDuplicate(self, nums):

        low, high = 1, len(nums) - 1
        while low <= high:
            mid = (low + high) >> 1
            cnt = sum(x <= mid for x in nums)
            if cnt > mid:
                high = mid - 1
            else:
                low = mid + 1

线性级时间复杂度 O(n)

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # node = index of nums
        # node.next = nums[node]
        # node.next.next = nums[nums[node]]
        slow = nums[0]         #先走一步
        fast = nums[nums[0]] 
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]] # 曾经犯的一个错误，以为这里会固定地在环入口，值相同的那个点相遇
        root = 0                    # 其实它们可以在环上任何一个node相遇，这里就是任何一个数组的下标index    
        while root != slow:
            root = nums[root]
            slow = nums[slow]
        return slow             # 回到循环结束的上一步
                                # nums[proot] == nums[pslow]
                                # The last slow = nums[proot] and this value at least has two slot in the array

```

##  143. <a name='-1'></a>384. 打乱数组

https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-by-leetcode-solution-og5u/

```py
官方版本：
class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums
        self.original = nums.copy()

    def reset(self) -> List[int]:
        self.nums = self.original.copy()
        return self.nums

    def shuffle(self) -> List[int]:
        for i in range(len(self.nums)):
            j = random.randrange(i, len(self.nums))
            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]
        return self.nums

精简版本：
from random import random
class Solution:

    def __init__(self, nums: [int]):
        self.nums = nums

    def reset(self) -> [int]:
        return self.nums

    def shuffle(self) -> [int]:
        return sorted(self.nums, key=lambda k: random())
```

##  144. <a name='-1'></a>329. 【动态🚀规划 + dfs】Longest Increasing Path in a Matrix

[花花酱](https://www.bilibili.com/video/BV1mW411d7q8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK4y1K7SX?spm_id_from=333.999.0.0)

动态🚀规划

```py
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        lst = []
        for i in range(m):
            for j in range(n):
                lst.append((matrix[i][j], i, j))
        lst.sort()
# 先预处理，对矩阵的值按从小到大排序，按大小顺序才能保证依赖的子问题都求解过了
        dp = [[1 for _ in range(n)] for _ in range(m)] # 注意：😁这里存的是结束位置，初始dp[i][j]都等于1
# 🌵 这里循环了 m*n 次
        for num, i, j in lst:
            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                prex, prey = i + di, j + dj
# 若matrix[i][j]四个方向有任意小于它，则可以更新dp[i][j] = max(dp[i][j], 1 + dp[r][c])
                if 0 <= prex < m and 0 <= prey < n and matrix[i][j] > matrix[prex][prey]:
                    dp[i][j] = max(dp[i][j], 1 + dp[prex][prey])
# dp[i][j] 表示以 matrix[i][j] 结尾的最长递增长度
        return max([dp[i][j] for i in range(m) for j in range(n)])
```

```py
class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        @lru_cache(None)
        def dfs(x: int, y: int) -> int:
            ans = 1
            for dx, dy in  [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]:
                    # 从 x, y 点出发, 可以到达的最远距离
                    ans = max(ans, dfs(nx, ny) + 1)
            return ans

        res = 0
        m, n = len(matrix), len(matrix[0])
# 🌵 这里循环了 m*n 次
        for i in range(m):
            for j in range(n):
                res = max(res, dfs(i, j)) # 注意：😁这里存的是从开始位置能到达多远
        return res


```

##  145. <a name='-1'></a>349. Intersection of Two Arrays

https://leetcode-cn.com/problems/intersection-of-two-arrays/

[小梦想家](https://www.bilibili.com/video/BV1zx411o7i1?spm_id_from=333.999.0.0)

```py
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1 = set(nums1)
        set2 = set(nums2)
        return [x for x in set1 if x in set2]

class Solution:
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        return list(set(nums1) & set(nums2))

```

##  146. <a name='-1'></a>26-Remove duplicates from sorted array

[哈哈哈](https://www.bilibili.com/video/BV1UJ411m7Pz?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i77e?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV13V41177Mq?spm_id_from=333.999.0.0)

> for循环法：

```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow = 0 #注意：count是从0开始的
        for fast in range(len(nums)):
            if nums[fast] != nums[slow]:
                slow += 1
                nums[slow] = nums[fast]
        return slow + 1
```

##  147. <a name='II-1'></a>40. Combination Sum II 40-组合总和 II

[花花酱](https://www.bilibili.com/video/BV1Pb411u7Yd?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1gT4y1J7JE?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()
        # candidates.reverse()
        def dfs(firstIdx, path):
            if sum(path) == target:
                res.append(path[:])
                return
            if sum(path) > target:
                return
            if sum(path) < target:
                for i in range(firstIdx,len(candidates)):
                    # 易错点：需要剪枝
                    if i > firstIdx and candidates[i] == candidates[i-1]: continue
                    # [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]会超时
                    dfs(i+1, path + [candidates[i]])
        dfs(0, [])
        return res
```

##  148. <a name='-1'></a>9-【回文🌈】Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1hJ411S7kt?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Jb411i7YG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Af4y1m7kk?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return True if str(x) == str(x)[::-1] else False
```

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False

        if x < 10:
            return True

        bkp = x
        res = 0

        while x:
            tmp = x % 10
            res = res*10 + tmp
            x //= 10

        return bkp == res
```

翻转一半字符法：

* 时间复杂度:O(log10(n)), 每次迭代都会除以10



```scala
package lc009 {
  object Solution {
    def isPalindrome(x: Int): Boolean = {
      if (x<0) return false
      if (x==0) return true
      if (x%10==0) return false
      val y=x.toString.reverse
      return y==x.toString
    }
  }
}
```

##  150. <a name='Trie'></a>208. 【构造🏰】Implement Trie (Prefix Tree)

[花花酱](https://www.bilibili.com/video/BV1Ut411a74P?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zz4y1R7j8?spm_id_from=333.999.0.0)

```py

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            if c not in r: r[c] = {}
            r = r[c]
        r['#'] = True

    # def insert(self, word: str) -> None:
    #     r = self.root
    #     for c in word:
    #         r = r.setdefault(c, {})
    #     r['#'] = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r: return False
            r = r[c]
        return '#' in r

    # def search(self, word: str) -> bool:
    #     r = self.root
    #     for c in word:
    #         if c not in r: return False
    #         r = r[c]
    #     return r.get("#", False)

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r: return False
            r = r[c]
        return True


```

```scala
/**
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie2() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}
```

##  151. <a name='K-1'></a>440. 字典序的第K小数字

https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/

```py
我们求字典序第k个就是上图`前序遍历`访问的第k节点！

class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        def getCnt(prefix, n):
            cnt, cur, next = 0, prefix, prefix + 1
            while cur <= n:
                cnt += min(next, n + 1) - cur # 比如n是195的情况195到100有96个数
                cur, next = cur * 10, next * 10
            return cnt
        
        poi, prefix = 1, 1 # 扣除掉第一个0节点
        while poi < k:
            cnt = getCnt(prefix, n)
            if poi + cnt > k:
                prefix *= 10 
                poi += 1 # 刨除根节点
            else: 
                prefix += 1
                poi += cnt
        return prefix



https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/solution/yi-tu-sheng-qian-yan-by-pianpianboy/


但是不需要用`前序遍历`，如果我们能通过`数学方法`求出`节点1`和`节点2`之间需要走几步，减少很多没必要的移动。

其实只需要按`层节点个数计算`即可，图中`节点1`和`节点2`在`第二层`，因为 n = 13，`节点1`可以移动到`节点2`（同一层）所以在第二层需要移动1步。

第三层，移动个数就是 (13 - 10 + 1) = 4 （min（13 + 1， 20） - 10）

所以`节点1`到`节点2`需要移动 1 + 4 = 5 步

1. 当移动步数 <= k，说明: 

需要向`右节点`移动，图中就是`节点1`移动到`节点2`。

2. 当移动步数 > k，说明: 

目标值在`节点1`和`节点2`之间，我们要向下移动！即从`节点1`移动到`节点10`。



class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        
        def cal_steps(n, n1, n2):
            step = 0
            while n1 <= n:
                step += min(n2, n + 1) - n1
                n1 *= 10
                n2 *= 10
            return step
                
        cur = 1
        k -= 1
        
        while k > 0:
            steps = cal_steps(n, cur, cur + 1)
            if steps <= k: # 第k个数不在以cur为根节点的树上
                k -= steps 
                cur += 1  # prefix在字典序数组中从左往右移动
            else:  # 在子树中
                k -= 1
                cur *= 10 # prefix 在字典序数组中从上往下移动
        
        return cur

# 当前值： 1 2
# 当前值： 10 20
# steps: 11 cur: 2 k: 3
# 当前值： 2 3
# 当前值： 20 30
# steps: 5 cur: 20 k: 2
# 当前值： 20 21
# steps: 1 cur: 21 k: 1
# 当前值： 21 22
# steps: 1 cur: 22 k: 0


ss = Solution()
print(ss.findKthNumber(23,15))

```

##  152. <a name='III'></a>123-买卖股票的最佳时机 III

[哈哈哈](https://www.bilibili.com/video/BV1Xp4y1k7aD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rk4y117z8?spm_id_from=333.999.0.0)

```py
# 我的写法：
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        profit1 = profit2 = 0
        buy1 = buy2 = prices[0]
        for i in range(1,n):
            # 实际上，是从卖出那天开始算，也就是第二天
            buy1 = min(buy1, prices[i])
            profit1 = max(profit1, prices[i] - buy1)
            buy2 = min(buy2, prices[i] - profit1)  # buy2[i]-profit1[i-1] 相当于一个虚拟的买入价格
            profit2 = max(profit2, prices[i] - buy2)
        return profit2

```

```scala
object Solution3-1 {
    def maxProfit(prices: Array[Int]): Int = {
        val (buy1, sell1, buy2, sell2) = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case ((buy1, sell1, buy2, sell2), cost) =>
                (
                    buy1 max -cost,
                    sell1 max (buy1 + cost),
                    buy2 max (sell1 - cost),
                    sell2 max (buy2 + cost)
                )
        }
        sell1 max.sell2
    }
}
```

##  153. <a name='-1'></a>135. 分发糖果

https://leetcode-cn.com/problems/candy/

```py
class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        dp = [1] * n
        # 从左往右
        for i in range(1, n):
            if ratings[i] > ratings[i - 1]:
                dp[i] = dp[i - 1] + 1
                # [1, 1, 2]
        # 从右往左
        for j in range(n - 2, -1, -1):
            if ratings[j] > ratings[j + 1]:
                dp[j] = max(dp[j], dp[j + 1] + 1)
                # [2, 1, 2]
        return sum(dp)
# 输入: [1,0,2]
# 输出: 5
```

##  155. <a name='-1'></a>207-课程表

[花花酱](https://www.bilibili.com/video/BV1Ut411a74a?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV19k4y1r76s?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jz411B7UJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xp4y1Y7FJ?spm_id_from=333.999.0.0)


```py
# python
from collections import defaultdict 
class Solution:
    def canFinish(self, numCourses, prerequisites):
        indegree = defaultdict(lambda:0)  
        graph = defaultdict(list)         
        for end,stt in prerequisites:
            graph[stt].append(end)
            indegree[end] += 1
        que = []                  
        for i in range(numCourses):
            if indegree[i] == 0:
                que.append(i)    
        for i in que:
            for j in graph[i]:
                indegree[j] -= 1
                if indegree[j] == 0: que.append(j)
        return len(que) == numCourses
```

```scala

// new and apply
// Use the new keyword when you want to refer to a class's own constructor:
// 解法是 每个node(node)，1.它依赖的node个数(parent) 2.统计依赖它的node个数(son)，
// 一个node没有依赖其它节点，放入zeroInDegree
// 对zeroIndegree的node遍历，对每个依赖它的node都可以直接除去依赖


  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum == numCourses
    }
  }

  class Test extends BaseExtension {
    def init {
      val input = Array(Array(0,1),Array(1,2))
      println(Solution.canFinish(3,input) == true)
      //println(lru.get(1) == 1)
    }

    val name = "207 course schedule"
  }

```

##  156. <a name='-1'></a>572-另一个树的子树

[哈哈哈](https://www.bilibili.com/video/BV1cA411t7zD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1wt4y197aB?spm_id_from=333.999.0.0)

```py
这题不可能是简单题

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        def dfs(A,B): # 函数的功能要明确，用来判断当前子树是否一致
            if not B and not A: 
                return True
            if not A and B: 
                return False
            if not B and A:
                return False
            if A.val != B.val: 
                return False
            return dfs(A.left, B.left) and dfs(A.right, B.right)
        
        if not root or not subRoot:
            return False
        if root.val == subRoot.val:
            if dfs(root, subRoot):
                return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
```

##  157. <a name='-1'></a>10. 正则表达式匹配

https://leetcode-cn.com/problems/regular-expression-matching/solution/

```py
        """
        思路：动态规划， 定义二维dp数组，其中dp[i][j]表示s的前i个字符和p的前j个字符是否匹配，
        为了方便初始化，我们将s和p的长度均+1
        考虑到P中可能出现三种字符：普通字母(a-z)、'*'或者是'.', 则其动态转移方程分别是：
        1) 如果p[j]为普通字母，dp[i][j]==dp[i-1][j-1] and s[i]==p[j]
        2) 如果p[j]为'.', dp[i][j]==dp[i-1][j-1]
        3) 如果p[j]为'*', 则情况比较复杂, 分以下两种情况讨论：
           A. 以s="c", p="ca*"为例，此时'*'匹配0次，dp[i][j]==dp[i][j-2]
           B. 以s="caa", p="ca*"为例，此时'*'匹配多次，dp[i][j]==dp[i-1][j] and s[i]==p[j-1] (考虑到通配符'.', 还有p[j-1]=='.'的情况)
        """
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 为了解决s="a", p="c*a"中*组合在p开头0次匹配的问题，
        # 我们需要额外初始化dp[0][:], 为此，在s前加一特殊字符，以方便操作
        s = " " + s
        p = " " + p
        dp = [[False] * len(p) for _ in range(len(s))]   # [len(s)+1, len(s)+1]
        dp[0][0] = True  # 假定s和p都从空字符开始
        
        for i in range(len(s)):  # s的空字符需要额外初始化
            for j in range(1, len(p)):
                if p[j] == '*' and dp[i][j-2]:   # *可以出现0次或者多次
                    dp[i][j] = dp[i][j-2]
                elif p[j] == '*' and p[j-1] in ('.', s[i]):
                    dp[i][j] = dp[i-1][j]
                elif p[j] in ('.', s[i]):
                    dp[i][j] = dp[i-1][j-1]
        return dp[-1][-1]
```

##  158. <a name='-1'></a>55 Jump Game

[小明](https://www.bilibili.com/video/BV14K4y1b7Fw?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1be411s7XX?spm_id_from=333.999.0.0)

```py
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

# 精简一下的for循环😁
class Solution:
    def canJump(self, nums: List[int]) -> bool:

        cover = 0
        n = len(nums)

        for i in range(n):
            if cover >= i: # 易错点：在判断下一个cover前，先要判断i是否能够到达
                cover = max(cover, i + nums[i])
                # if cover == i:
                    # return False # 易错点：应该考虑特殊情况[0,1,2]
                if cover >= n - 1:
                    return True
        return False
```

```scala
/**
* Greedy: check max reach position
* memo
*  1. record max reach position: if current position is larger than max reach position, it means we couldn't jump to current position and it wouldn't be able to jump to last position
* time complexity: O(N)
*/

object Solution3-1 {
    def canJump(nums: Array[Int]): Boolean = {
      var maxReachPos = nums(0)
      nums.indices.forall { pos =>  
          if (pos > maxReachPos) false  
          else {
            maxReachPos = maxReachPos max (pos + nums(pos))
            true
          }
        }        
    }
}

```

##  159. <a name='-1'></a>1047. 删除字符串中的所有相邻重复项

类似消消看

```py
class Solution(object):
    def removeDuplicates(self, S):
        # 初始化栈
        stack = []
        # 遍历栈元素
        for char in S:
            if stack and stack[-1] == char:
                stack.pop()
            else:
                stack.append(char)
        return "".join(stack)
```

##  160. <a name='-1'></a>91. Decode Ways

[花花酱](https://www.bilibili.com/video/BV1Lb411y7ec?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1G7M5?spm_id_from=333.999.0.0)

```py
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

```py
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp0 = 1 # 这里 dp = 0 或者是 dp = 1 都可以，因为在第一轮的循环过后会更新
        dp1 = 1
        for i in range(n):
            res = 0
            if '1' <= s[i] <= '9': # 当前项
                res = dp1
            if i > 0 and '10' <= s[i-1:i+1] <= '26': # 当前项 + 前一项
                res += dp0
            dp1, dp0 = res, dp1
        return dp1
```

```scala
/**
* my first commitment dynamic programming
* memo:
* 1.subproblem dp(i) represents the decode ways of the sub-string which length is i 
* 2. dp(i) could be sum from dp(i-1) or dp(i-2) if s(i -1, i) or s(i-2, i) are valid coding
*  idx:   0 1 2 3 4 5 6 7
*  length 1 2 3 4 5 6 7 8
&  value  1 2 1 3 2 5 8 3
*   
*   dp(1) => "1"
*   dp(2) => "12" :
*            valid("12") + dp(0)
*            valid("2") + dp(1)
*   dp(3) => "121" :
*           valid("21") + dp(1)
*           valid("1) + dp(2)
*
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def numDecodings(s: String): Int = {
      if(s == null || s.length == 0) return 0 
      val dp = Array.ofDim[Int](s.length + 1)
      dp(0) = 1
      dp(1) = if (s(0) == '0') 0 else 1
      (2 to s.length).foreach { idx =>
        val single = s.slice(idx-1, idx).toInt
        val tens = s.slice(idx-2, idx).toInt
        if (0 < single && single <= 9)
          dp(idx) += dp(idx-1)
        if (10 <= tens && tens <= 26)
          dp(idx) += dp(idx-2)
      
      }
      dp.last
    }
}
```

# 9 day (得分 = 2分) 83

##  162. <a name='II-1'></a>445-Add Two Numbers II

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7Qz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pt4y1m78o?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17a4y1s7BG?spm_id_from=333.999.0.0)

```py
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        s1, s2 = [], []
        while l1:
            s1.append(l1.val)
            l1 = l1.next
        while l2:
            s2.append(l2.val)
            l2 = l2.next
        res = None
        carry = 0
        while s1 or s2 or carry:
            a = s1.pop() if s1 else 0 
            b = s2.pop() if s2 else 0 

            cur = a + b + carry
            carry = cur // 10
            tail = cur % 10

            curnode = ListNode(tail)
            curnode.next = res
            res = curnode
        return res

```


##  163. <a name='II-1'></a>213.【动态🚀规划】 House Robber II 213-打家劫舍II

[18:13 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ea4y147oh?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1GD4y1d7DS?spm_id_from=333.999.0.0)

```py
# dp[i] = max(dp[i-2] + nums[i], dp[i-1])
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        # 易错点：注意特殊情况
        if n <= 2:
            return max(nums)

        dp1 = [0] * (n - 1)
        dp1[0] = nums[0]
        dp1[1] = max(nums[1],nums[0])
        for i in range(2, n - 1):
            dp1[i] = max(dp1[i-2] + nums[i], dp1[i-1])

        dp2 = [0] * (n - 1)
        dp2[0] = nums[1]
        dp2[1] = max(nums[1], nums[2])
        # 易错点：注意，根据递推式，这里不是，dp2[1] = nums[2]
        for i in range(2, n - 1):
            dp2[i] = max(dp2[i-2] + nums[i + 1], dp2[i-1])

        return max(dp1[-1],dp2[-1])

降维以后：

class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        # 易错点：注意特殊情况
        if n <= 2:
            return max(nums)

        def robrange(start, end):
            dp0 = 0
            dp1 = 0
            for i in range(start, end):
                dp1, dp0 = max(dp0 + nums[i], dp1), dp1
            return dp1
        # 也可以这么写：
        # def robrange(start,end):
        #     dp0 = 0
        #     dp1 = 0
        #     for num in nums[start:end]:
        #         dp1, dp0 = max(dp0 + num, dp1), dp1
        #     return dp1
        return max(robrange(0, n - 1), robrange(1, n))
```


##  164. <a name='9.36'></a>补充题9. 36进制加法 - 见 415 - Add Strings

```s
36进制由 0-9，a-z，共 36 个字符表示。

要求按照加法规则计算出任意两个36进制正整数的和，如 1b + 2x = 48  （解释：47 + 105 = 152）

要求：不允许使用先将36进制数字整体转为10进制，相加后再转回为36进制的做法

题目分析：此题难度倒不是很大，实际上是 LC415. 字符串相加的扩展。

LC415 是十进制的大数相加，而本题是`36进制`的大数相加。

顺便提一句，我强烈推荐415题使用以下代码的写法，优雅简洁，不容易出Bug。

如果第一次见，可能需要多反应会儿，但明白了以后就会有相见恨晚的感觉。
```


##  166. <a name='-1'></a>509. 【动态🚀规划 + 递归】Fibonacci Number

[1:30 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15y4y147Re?spm_id_from=333.999.0.0)

```py
class Solution:
    def fib(self, n: int) -> int:
        a, b = 0, 1
        for i in range(n): 
            a, b = b, a + b # py的单行更新值
    	return a



    
class Solution:
    @cache
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)

# 记忆化递归
class Solution:
    def fib(self, n: int) -> int:
        dic = {}
        def helper(n):
            # 这个写法是错误的：if n == 0 or 1:
            if n < 2:
                return n
            elif n in dic:
                return dic[n]
            else:
                dic[n] = helper(n - 1) + helper(n - 2)
                return dic[n]
        return helper(n)
```

```scala
/**
* recursive version - top-down
* time complexity: O(2^N）
* space complexity: O(N)
*/

object Solution3 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
           fib(N - 1) + fib(N - 2)
        }
    }
}


```


##  167. <a name='-1'></a>295. 数据流的中位数

```py
from heapq import *
class MedianFinder:
    def __init__(self):
        self.max_h = []
        self.min_h = []
        heapify(self.max_h)
        heapify(self.min_h)
        
    def addNum(self, num):
       # 每次都插入到最小
        heappush(self.min_h, num)
       # 然后，将最小堆里面的栈顶元素，取出来，放到最大堆中去，这样就能保证最小堆的堆，都比最大堆的堆顶大
        heappush(self.max_h, - heappop(self.min_h))
        if len(self.min_h) < len(self.max_h): # 如果最大堆太大了
            heappush(self.min_h, - heappop(self.max_h))

        # 对于如何实现大顶堆?
        # 1. 添加元素进去时，取反
        # 2. 取出元素时，也取反

        # 满足两个特性：
        # 1. `大顶堆`中最大的数值 <= `小顶堆`中的最小数, 也就是小于小顶堆的堆顶
        # 2. 两个堆中元素相差为 0, 或者为 1, 不能 > 1

    def findMedian(self):
        max_len = len(self.max_h)
        min_len = len(self.min_h)
        return self.min_h[0] if max_len != min_len else (- self.max_h[0] + self.min_h[0]) / 2
```

##  168. <a name='Offer61.'></a>剑指 Offer 61. 扑克牌中的顺子

```py
class Solution:
    def isStraight(self, nums: List[int]) -> bool:
        repeat = set()
        ma, mi = 0, 14
        for num in nums:
            if num == 0: continue # 跳过大小王
            ma = max(ma, num) # 最大牌
            mi = min(mi, num) # 最小牌
            if num in repeat: return False # 若有重复，提前返回 false
            repeat.add(num) # 添加牌至 Set
        return ma - mi < 5 # 最大牌 - 最小牌 < 5 则可构成顺子 

```

##  170. <a name='-1'></a>678 Valid Parenthesis String

[小明](https://www.bilibili.com/video/BV1ap4y1X7nu?spm_id_from=333.999.0.0)

```py
## 方法三：左右对称

class Solution:
    def checkValidString(self, s: str) -> bool:
        left = right = 0
        for i, c in enumerate(s):    
            # 从左向右看左括号能否有效
            left  += -1 if c == ')' else 1 
            # 从右向左看右括号能否有效
            right += -1 if s[-i-1] == '(' else 1
            # 注意：在循环过程中，只要出现一次负数，就直接返回 false
            if left < 0 or right < 0: return False
       
        return True

```

##  172. <a name='-1'></a>86. 分隔链表(Partition List)

[洛阳](https://www.bilibili.com/video/BV1t64y1u7Ei?spm_id_from=333.999.0.0)

```py
快慢指针 slow -> fast -> None


class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        dummy1 = ListNode(0)
        dummy2 = ListNode(0)
        slow, fast, cur = dummy1, dummy2, head
        while cur:
            if cur.val < x:
                slow.next = cur # dummy1 指向第一个小于x的node
                slow = slow.next
            else:
                fast.next = cur # dummy2 指向第一个大于x的node
                fast = fast.next
            cur = cur.next
        slow.next = dummy2.next
        fast.next = None
        return dummy1.next
```

##  173. <a name='-1'></a>114题. 二叉树展开为链表

https://www.bilibili.com/video/BV1T7411A7S8?from=search&seid=15731266160913668837&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6tma3pncods0.png" width="80%">

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5csg54lu3lw0.png" width="50%">

递归

```s
给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
```

```py
class Solution:
    def flatten(self, root: TreeNode) -> None:
        if not root: return
        stack = [root]
        pre = None # 穿针引线
        while stack:
            tmp = stack.pop()
            if pre:
                pre.left = None # 穿针引线
                pre.right = tmp # 穿针引线
            if tmp.right: stack.append(tmp.right)
            if tmp.left: stack.append(tmp.left) # 目的是left先出：后进，先出
            pre = tmp
        return root

class Solution:
    def flatten(self, root: TreeNode) -> None:
        preorderList = []
        
        def traversal(root: TreeNode):
            if not root: return
            preorderList.append(root) # 前序
            traversal(root.left)    # 左
            traversal(root.right)   # 右

        traversal(root)
        n = len(preorderList)
        for i in range(1, n):
            prev, curr = preorderList[i - 1], preorderList[i] # 穿针引线
            prev.left = None # 穿针引线
            prev.right = curr # 穿针引线
        return preorderList and preorderList[0]
        
```

##  175. <a name='-1'></a>16. 3Sum Closest

[小梦想家](https://www.bilibili.com/video/BV11441187Rr?spm_id_from=333.999.0.0)

```py
# 和上一题差不多
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        minAim = sum(nums[0:3]) - target
        n = len(nums)
        for i in range(n - 2):
            # 三指针：i + left + right
            left = i + 1
            right = n - 1
            while left < right:
                aim = nums[i] + nums[left] + nums[right] - target
                if abs(aim) < abs(minAim): minAim = aim
                if aim == 0:  return target
                elif aim > 0:  right -= 1
                else:          left  += 1
        return minAim + target
```


```scala

/**
* my first commitment
* two pointer approximate
* 
* time complexity: O(N^2)
*/
object Solution1 {
  def threeSumClosest(nums: Array[Int], target: Int): Int = {
    val l = nums.sorted
    // slice(0, 3) is slower 
    l.indices.foldLeft(l.take(3).sum){
      case (closestSum, idx) => twoSum(l, target, idx, closestSum)
    }

  }

  def twoSum(nums: Array[Int], target: Int, from: Int, closestSum: Int): Int = {
    val fromValue = nums(from)

    @annotation.tailrec
    def _twoSum(left: Int, right: Int, previousSum: Int): Int = {
      if(left >= right) return previousSum


      val currentSum = fromValue + nums(left) + nums(right)

      val currentDiff = math.abs(target - currentSum)
      val previousDiff = math.abs(target - previousSum)

      val newClosest = if(currentDiff > previousDiff) previousSum else currentSum


      if(currentSum < target) _twoSum(left + 1, right, newClosest)
      else if(currentSum > target) _twoSum(left, right - 1, newClosest)
      else _twoSum(left + 1, right - 1, newClosest)

    }

    _twoSum(from + 1, nums.length - 1, closestSum)
  }
}
```

##  176. <a name='-1'></a>450. Delete Node in a BST

[花花酱](https://www.bilibili.com/video/BV1XW411d7yU?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1YK4y1h7Mw?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
    # 假如要删除的不是根节点
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)

    # 假如删除的是根节点
        elif not root.left:
            root = root.right # 删除根节点
        else:
            p = root.left
            while p.right:
                p = p.right
    
            p.right = root.right # 找到左子树中最大的节点，链接到 root.right
            root = root.left # 删除根节点
        return root
```


##  177. <a name='K-1'></a>347. 【最小堆🌵】Top K Frequent Elements 

[花花酱](https://www.bilibili.com/video/BV1Mt411371T?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sk4y1B7vj?spm_id_from=333.999.0.0)

```py
#时间复杂度：O(nlogk)
#空间复杂度：O(n)
import heapq
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dic = collections.defaultdict(int)
        for i in range(len(nums)):
            dic[nums[i]] += 1
        hp = [] #小顶堆
        for key, freq in dic.items():
            heapq.heappush(hp, (freq, key))
            if len(hp) > k: 
                heapq.heappop(hp)
        return [x[1] for x in hp]
```

```scala
object Solution {
    def topKFrequent(nums: Array[Int], k: Int): Array[Int] = {
        var hm = scala.collection.mutable.Map.empty[Int, Int]
        for(elem <- nums){
            hm.get(elem) match{
                case Some(count) => hm += (elem -> (count+1))
                case None => hm += (elem -> 1)
            }
        }
        
        // hm.toList.sortBy(x => (x._2)*(-1)).take(k).map(_._1).toArray
        // The above is a sorting approach. We can use Heap/PriorityQueue to achieve better time complexity
        
        import scala.math.Ordering.Implicits._
        
        def orderByFrequency(tup: (Int, Int)) = tup._2
        
        val pq = new scala.collection.mutable.PriorityQueue[(Int, Int)]()(Ordering.by(orderByFrequency))
        
        for(entry <- hm){
            pq.enqueue(entry)
        }
        
        println(pq)
        (1 to k).map(_ => pq.dequeue).map(_._1).toArray
        
    }
}

```

##  179. <a name='-1'></a>344. Reverse String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7Ha?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nC4y1a7DR?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1nQ4y1R7nH?spm_id_from=333.999.0.0)

```py
class Solution: 
    def reverseString(self, s: List[str]) -> None:

    """
    Do not return anything, modify s in-place instead.
    """
    l, r = 0, len(s) - 1
    while l < r:
        s[l], s[r] = s[r], s[l]
        l += 1
        r -= 1
    return s
```

```scala
object Solution {
    def reverseString(s: Array[Char]): Unit = {
        var begin = 0
        var end = s.length - 1
        while(begin < end){
            var temp = s(begin)
            s(begin) = s(end)
            s(end) = temp
            
            begin += 1
            end -= 1
        }
    }
}

```

##  180. <a name='-1'></a>191 Number of 1 Bits

[小明](https://www.bilibili.com/video/BV1i5411J7SA?spm_id_from=333.999.0.0)

```py
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = sum(1 for i in range(32) if n & (1 << i)) 
        return res


1111000
1110111
& 运算后，去掉最后的1
1110000

# 从1开始，每次<<一位，与n做与运算，如果不为0，则该位为1
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            n &= n - 1
            res += 1
        return res

```

```scala
object Solution0 {
    def hammingWeight(n: Int): Int = {
        var counter = 0
        var num = n         
        while (num != 0) {
            counter += 1
            num &= (num-1)                
        }
        counter
    }
}

```


# 10 day (得分 = 2分) 85

##  181. <a name='-1'></a>443. String Compression

[小梦想家](https://www.bilibili.com/video/BV1rE411f7Ld?spm_id_from=333.999.0.0)

```py
class Solution:
    def compress(self, chars: List[str]) -> int:
        n = len(chars)
        slow = 0
        cnt = 1
        for fast in range(n):
            # 在 aa，bb，ccc 的最后一位触发计算
            if fast == n - 1 or chars[fast] != chars[fast+1]:
                chars[slow] = chars[fast] 
                slow += 1
                if cnt > 1: # cnt 重新置为 1 前，需要统计是几位数
                    for k in str(cnt):
                        chars[slow] = k
                        slow += 1
                cnt = 1 # cnt 重新置为 1，而不是 0
            else:
                cnt += 1
        return slow
# 输入：chars = ["a","a","b","b","c","c","c"]
# 输出：返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]
```

##  182. <a name='N'></a>400. 第N个数字

```py
class Solution:
    def findNthDigit(self, n: int) -> int:
        d, count = 1, 9
        while n > d * count:
            n -= d * count
            d += 1
            count *= 10
            print
        index = n - 1
        num = 10 ** (d - 1) + index // d
        digitIndex = index % d
        return int(str(num)[digitIndex])
# 问第 300 个数
# 1 ~ 9        9个数字
# 10 ~ 99     90个数字
# 100 ~ 999  900个数字
# 300 - 9 - 2*90 = 111
# (111 - 1) // 3 = 36
# (111 - 1) % 3 = 2
# 100 + 36 = 136

```

##  183. <a name='-1'></a>242. Valid Anagram 

[小梦想家](https://www.bilibili.com/video/BV1Db411s78v?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hV411i73u?spm_id_from=333.999.0.0)

```py
直接返回两个计数器是否相等即可

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t) 
```

```py
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import defaultdict
        
        sdic = defaultdict(int)
        tdic = defaultdict(int)

        for x in s: sdic[x] += 1
        
        for x in t: tdic[x] += 1

        return sdic == tdic
```

```scala
/**
* my first commit
* time complexity: O(N)
*/
object Solution1 {
  def isAnagram(s: String, t: String): Boolean = {
    charCounter(s) equals charCounter(t)
  }
  private def charCounter(str: String): Map[Char, Int] = {
    str.foldLeft(collection.mutable.Map.empty[Char, Int]) {
      (map, s) =>
        map.get(s) match {
          case Some(e) =>
            map.update(s, e + 1)
            map
          case None =>
            map.update(s, 1)
            map
        }
    }.toMap
  }
}
```

##  184. <a name='-1'></a>100-Same Tree 

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7ti?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vf4y1R7Ue?spm_id_from=333.999.0.0)

> python:

```py
self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

```py
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        return str(p) == str(q)
```



> scala

```scala
object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        if (p == null && q == null) {
        true
        } else if (p == null || q == null) {
        false
        } else if (p.value == q.value) {
        isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        } else {
        false
        }
    }
}
```

##  185. <a name='-1'></a>459 Repeated Substring Pattern

[小明](https://www.bilibili.com/video/BV1Yt4y1S7XZ?spm_id_from=333.999.0.0)

```py
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        for i in range(1, len(s) // 2 + 1):
            if s == s[:i] * (len(s) // i):
                return True
        return False

```

##  186. <a name='-1'></a>442 Find All Duplicates in an Array

[小明](https://www.bilibili.com/video/BV1Lh411d7AD?spm_id_from=333.999.0.0)

```py
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        l = []
        for i in nums:
            # 取绝对值
            i = abs(i)
            # 把相应下标减1的值设为负数
            if nums[i-1] > 0:
                nums[i-1] *= -1
            # 值为负的话，说明该值已经出现过，添加到输出列表l中
            else:
                l.append(i)
                
        return l

[4, 3, 2, 7, 8, 2, 3, 1]
[4, 3, 2, -7, 8, 2, 3, 1]   
[4, 3, -2, -7, 8, 2, 3, 1]    
[4, -3, -2, -7, 8, 2, 3, 1]
[4, -3, -2, -7, 8, 2, -3, 1]
[4, -3, -2, -7, 8, 2, -3, -1]
[4, [-3], -2, -7, 8, 2, -3, -1] 
[4, [-3], [-2], -7, 8, 2, -3, -1] 
[-4, [-3], [-2], -7, 8, 2, -3, -1] 
```

##  187. <a name='-1'></a>120 【动态🚀规划】Triangle

[小明](https://www.bilibili.com/video/BV1m54y1L7Af?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        i = len(triangle) - 2
        while i >= 0:
            subi = i
            while subi >= 0:
                triangle[i][subi] += min(triangle[i+1][subi],triangle[i+1][subi+1])
                subi -= 1
            i -= 1
        return triangle[0][0]
```

```scala
object Solution {
    def minimumTotal(triangle: List[List[Int]]): Int = {
        val depth = triangle.size
        val dp = triangle.last.toArray
        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices) {
            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) 
        }
        dp(0)
    }
}
```

##  188. <a name='-1'></a>268 【位运算😜】Missing Number


[小明](https://www.bilibili.com/video/BV1LU4y1p7n7?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1caw225arjj4.webp)

```py
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        total = n * (n + 1) // 2
        arrSum = sum(nums)
        return total - arrSum
```

```py
你能否实现`线性时间复杂度`、仅使用`额外常数空间`的算法解决此问题 ?

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        xor = len(nums) # 注意这里
        for i, num in enumerate(nums):
            xor ^= i
            xor ^= num
        return xor

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        xor = 0
        for i, num in enumerate(nums):
            xor ^= i ^ num
        return xor ^ len(nums) # 注意这里
```


```scala
//Removing foldLeft improved time
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        var idealSum = (size * (size + 1))/2
        for(num <- nums){
            idealSum -= num
        }
        idealSum
    }
}
```

##  189. <a name='-1'></a>887. Super Egg Drop

[花花酱](https://www.bilibili.com/video/BV1Tv411i7cP?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ri4y1t78d?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3ld2gccb6ey0.webp" width="30%">

```py
请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？

dp[k][m] 的含义是 k 个鸡蛋 移动 m 次最多能够确定多少楼层
这个角度思考
dp[k][m] 最多能够确定的楼层数为 L

那么我选定第一个扔的楼层之后，我要么碎，要么不碎

这就是把 L 分成 3 段:
左边：是碎的那段 长度是   dp[k][m - 1]
右边：是没碎的那段 长度是 dp[k - 1][m - 1] 因为已经碎了一个了
中间：是我选定扔的楼层 是 1

所以递推公式是: dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1

根据递推公式 如果采用 k 倒着从大到小计算 就可以只存一行的 dp[k] 直接原地更新 dp[k] 不影响后续计算 

只需要 O(K) 空间复杂度 O(KlogN) 鸡蛋完全够用的时候 就是走 LogN 步 最差情况是 1 个鸡蛋走 N 步 O(KN)

class Solution:
    def superEggDrop(self, eggs: int, level: int) -> int:
            dp = [0] * (eggs + 1)
            m = 0
            while dp[eggs] < level:
                m += 1
                for gg in range(eggs, 0, -1): # 从 eggs ~ 1
                    # 鸡蛋碎了，剩下的鸡蛋可以遍历多少楼层
                    # 鸡蛋没碎，可以遍历的楼层数目
                    dp[gg] = dp[gg - 1] + dp[gg] + 1
            return m

# 移动次数: 1 鸡蛋 0-3 对应楼层: [0, 1, 1, 1]
# 移动次数: 2 鸡蛋 0-3 对应楼层: [0, 2, 3, 3]
# 移动次数: 3 鸡蛋 0-3 对应楼层: [0, 3, 6, 7]
# 移动次数: 4 鸡蛋 0-3 对应楼层: [0, 4, 10, 14]
```


##  191. <a name='III-1'></a>557. 反转字符串中的单词 III

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join([i[::-1] for i in s.split(' ')])

一行就是快乐

class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join(i[::-1] for i in s.split())



class Solution:
    def reverseWords(self, s: str) -> str:
        s = s.split(' ')
        sll = len(s)
        for i in range(sll):
            # 把 str 转换成 list
            s[i] =  list(s[i])
            left = 0
            right = len(s[i]) - 1
            while left < right:
                s[i][right], s[i][left] = s[i][left], s[i][right]
                left += 1
                right -= 1
            s[i] = ''.join(s[i])
        s = ' '.join(s)
        return s
```

##  192. <a name='14.'></a>补充题14. 阿拉伯数字转中文数字

##  193. <a name='Excel'></a>168-Excel Sheet Column Title

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7FY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H777?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def convertToTitle(self, columnNumber):
        res = ''
        while columnNumber:
            columnNumber -= 1                       # 又想了好久才知道在哪里减一。。
            res = chr(columnNumber % 26 + 65) + res # A的ascii码为65
            columnNumber = columnNumber // 26 
        return res
```

##  194. <a name='-1'></a>1095. Find in Mountain Array

[花花酱](https://www.bilibili.com/video/BV1m5411V7x7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK4115778?spm_id_from=333.999.0.0)

```py
注意：这里用
MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）
MountainArray.length() - 会返回该数组的长度

"""
This is MountainArray's API interface.
You should not implement it, or speculate about its implementation
"""
class MountainArray:
   def get(self, index: int) -> int:
   def length(self) -> int:

def binary_search(mountain, target, l, r, key=lambda x: x):
    target = key(target)
    while l <= r:
        mid = (l + r) // 2
        cur = key(mountain.get(mid))
        if cur == target:
            return mid
        elif cur < target:
            l = mid + 1
        else:
            r = mid - 1
    return -1

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        l, r = 0, mountain_arr.length() - 1
        while l < r:
            mid = (l + r) // 2
            if mountain_arr.get(mid) < mountain_arr.get(mid + 1):
                l = mid + 1
            else:
                r = mid
        peak = l
        index = binary_search(mountain_arr, target, 0, peak) # 递增序列 二分查找
        if index != -1:
            return index
        index = binary_search(mountain_arr, target, peak + 1, mountain_arr.length() - 1, lambda x: -x) # 递增序列 二分查找
        return index

```


##  195. <a name='-1'></a>670. 最大交换

```py
class Solution:
    def maximumSwap(self, num: int) -> int:
        string = list(str(num))
        lastI = [None for _ in range(10)]      # 数字 0 ~ 9, 一共 9 个数字

        for i, d in enumerate(string):
            lastI[int(d)] = i                  # 统计每个数字出现的最后的位置

        for i, d in enumerate(string):          # 从最高位开始，往后面寻找
            for j in range(9, int(d), -1):      # 从最低位开始，往前面寻找
                if lastI[j] and lastI[j] > i:   # 位置的元素交换
                    string[lastI[j]], string[i] = string[i], string[lastI[j]]
                    return int(''.join(string))
        
        return num # 已是最大值就返回原数字
```

##  197. <a name='II-1'></a>210. Course Schedule II 210-课程表II

[花花酱](https://www.bilibili.com/video/BV1gW411y7Kb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ja4y147on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qt4y1X7oC?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kK411W7rL?spm_id_from=333.999.0.0)

```py
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        indgree = [0] * numCourses
        graph = [[] for _ in range(numCourses)]
        for end, stt in prerequisites:
            indgree[end] += 1
            graph[stt].append(end)
        res = [i for i, j in enumerate(indgree) if not j]
        for end in res:
            for stt in graph[end]:
                indgree[stt] -= 1
                if not indgree[stt]:
                    res.append(stt)
        return len(res) == numCourses and res or []
```

```scala

import scala.collection.mutable.ArrayBuffer
// 与lc207类似，不过要给出顺序

  object Solution {
    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      val ans = ArrayBuffer[Int]()
      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        ans += cur
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum match {
        case canFinshNum if canFinshNum == numCourses => ans.toArray
        case _ => Array()
      }
    }
  }

```

##  198. <a name='-1'></a>525. 【前缀和🎨】Contiguous Array

[花花酱](https://www.bilibili.com/video/BV14W411d7SD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV185411t7tu?spm_id_from=333.999.0.0)

```py
0 变 -1 是精髓，sum_dct = {0:-1} 是细节。

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        presumDic = {}
        presumDic[0] = -1
        res = 0
        s = 0
        for i in range(len(nums)):
            s += 1 if nums[i] == 1 else -1
            if s in presumDic:
                res = max(res, i - presumDic[s])
            else:
                presumDic[s] = i
        return res

```

##  200. <a name='III-1'></a>556 Next Greater Element III - 类似 31 ★ Next Permutation

[小明](https://www.bilibili.com/video/BV19t4y167yb?spm_id_from=333.999.0.0)

```py
    # 3 步走：
    # 1. 从后往前，非递减序列的前一个 i
    # 2. 从后往前，比 i 大的 j
    # 3. i 和 j 交换位置
    # 4. [i+1:] 排序

    # 123(4)(5)
    # 12(3)5(4)
    # 124(3)(5)
    # 12(4)(5)3
    # 125(3)(4)
    # 1(2)54(3)

class Solution:
    def nextGreaterElement(self, n: int) -> int:
        nums = list(str(n))
        # 关键在于从后往前，找到非递减序列
        i = len(nums) - 2
        while i >= 0:
            if nums[i] >= nums[i+1]:
                i -= 1
            else:
                # 寻找i后面比i大的数，交换位置,并且排序
                for j in range(len(nums)-1,i,-1): # 易错点:len(nums)-1,i的区间
                    # 12(3)5(4)
                    if nums[j] > nums[i]:
                        nums[i],nums[j] = nums[j],nums[i]
                        nums[i+1:] = sorted(nums[i+1:])
                        res =  int(''.join(nums))
                        return res if res < (1<<31) else -1
        return -1 # 易错点:对于[3,2,1]这种情况，i = 0
```


# 11 day (得分 = 2分) 87

##  201. <a name='-1'></a>111-Minimum Depth of Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1E7411k7KY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1XZ4y1G7xM?spm_id_from=333.999.0.0)

递归

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root:
            if root.left and root.right:
                return 1+min(self.minDepth(root.left),self.minDepth(root.right))
            elif root.left:
                return 1+self.minDepth(root.left) #较高一层的值
            elif root.right:
                return 1+self.minDepth(root.right) #较高一层的值
            else:
                return 1
        else:
            return 0
```

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        # 如果 没有 root
        if not root:
            return 0
        # 如果 只有 root
        elif not root.left and not root.right:
            return 1
        else:
        # 如果 root 有 子树
            minDepth = float('inf')
            if root.left:
                minDepth = min(self.minDepth(root.left), minDepth) 
            if root.right:
                minDepth = min(self.minDepth(root.right), minDepth) 
            return minDepth + 1
```

队列

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        que = collections.deque([(root, 1)]) # 注意这个写法：[(root, 1)] 的括号
        while que:
            node, depth = que.popleft()
            if not node.left and not node.right:
                return depth
            if node.left: 
                que.append((node.left, depth + 1)) # 注意这个写法：(node.left, depth + 1) 的括号
            if node.right:
                que.append((node.right, depth + 1))
        
        return 0
```

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        bfs(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def bfs(queue: List[TreeNode], res: Int): Int = {
        if(queue.isEmpty) res
        // node has no child 
        else if(queue.exists(t => t.left == null && t.right == null)) res + 1
        else bfs(queue.flatMap(t => List(t.left, t.right)).filter(_ != null), res + 1)
    }
}

object Solution1 {
    def minDepth(root: TreeNode): Int = {
        if (root == null) return 0
        val left = minDepth(root.left) 
        val right = minDepth(root.right) 

        if (left == 0 || right == 0) left + right + 1 else math.min(left, right) + 1
        
    }
}

object Solution1_2 {
    def minDepth(root: TreeNode): Int = {
        if(root == null) 0
        else if(root.left == null) minDepth(root.right) + 1
        else if(root.right == null) minDepth(root.left) + 1
        else minDepth(root.right) + 1 min minDepth(root.left) + 1
    
    }
}
```

队列

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        if(root == null) return 0
        val que = scala.collection.mutable.Queue[TreeNode]()
        var depth = 0
        var flag = true
        que.enqueue(root)
        
        while(que.nonEmpty && flag){
            depth += 1
            for(_ <- 0 until que.size; if flag){
                val node = que.dequeue
                if(node.left == null && node.right == null) flag = false
                else {
                    if(node.left != null) que.enqueue(node.left)
                    if(node.right != null) que.enqueue(node.right)
                } 
            } 
        }
        depth
        
    }
} 
```

##  202. <a name='-1'></a>37. Sudoku Solver 解数独

[花花酱](https://www.bilibili.com/video/BV1Tt41137Xr?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1f5411h7er?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3k462gpgb5k0.png)

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows = [set() for _ in range(9)]
        cols = [set() for _ in range(9)]
        grids = [[set() for _ in range(3)] for _ in range(3)]
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    if  board[i][j] not in rows[i] and \
                        board[i][j] not in cols[j] and \
                        board[i][j] not in grids[i//3][j//3]:
                        rows[i].add(board[i][j])
                        cols[j].add(board[i][j])
                        grids[i//3][j//3].add(board[i][j])

        def dfs(i,j):
            if board[i][j] != '.': # 被数字填满

                if i == 8 and j == 8:
                    self.flag = True
                    return
                if j < 8:
                    dfs(i,j+1)
                if j == 8:
                    dfs(i+1,0)
                    
            else:
                for num in range(1,10):
                    item = str(num)
                    if  item not in rows[i] and \
                        item not in cols[j] and \
                        item not in grids[i//3][j//3]:
                        board[i][j] = item
                        rows[i].add(item)
                        cols[j].add(item)
                        grids[i//3][j//3].add(item)

                        # 易错点:注意缩进关系
                        if i == 8 and j == 8:
                            self.flag = True
                            return
                        if j < 8:
                            dfs(i,j+1)
                        if j == 8:
                            dfs(i+1,0)
                        if self.flag:
                            return
                            
                        board[i][j] = '.'
                        rows[i].remove(item)
                        cols[j].remove(item)
                        grids[i//3][j//3].remove(item)

        self.flag = False
        dfs(0,0)

```

##  203. <a name='-1'></a>134. Gas Station

[小梦想家](https://www.bilibili.com/video/BV1BC4y1472f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1754y1176F?spm_id_from=333.999.0.0)

```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        start = 0
        curSum = 0
        totalSum = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            if curSum < 0:
                curSum = 0
                start = i + 1
        if totalSum < 0: return -1
        return start
```

##  204. <a name='22.IP'></a>补充题22. IP地址与整数的转换

https://mp.weixin.qq.com/s/UWCuEtNS2kuAuDY-eIbghg

##  205. <a name='-1'></a>876.Middle of the Linked List 链表的中间结点

[图灵](https://www.bilibili.com/video/BV1Kv411p7vf?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Pz41187WS?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK411T74X?spm_id_from=333.999.0.0)

```py
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        A = [head]
        while A[-1].next:
            A.append(A[-1].next)
        return A[len(A) // 2]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        n, cur = 0, head
        while cur:
            n += 1
            cur = cur.next
        k, cur = 0, head
        while k < n // 2:
            k += 1
            cur = cur.next
        return cur

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python 快慢双指针

class Solution(object):
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow


```

```py
第一种先计数再找中点，第二种快慢指针

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        first = head
        count = 0
        while first != None:
            first = first.next
            count += 1
        second = head
        count = count//2
        while count > 0:
            second = second.next
            count -= 1
        return second
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        first = second = head
        while first != None and first.next != None:
            first = first.next.next
            second = second.next
        return second
```

##  206. <a name='II-1'></a>63 Unique Paths II

[小明](https://www.bilibili.com/video/BV1Sv411L7qe?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pp4y1v7KR?spm_id_from=333.999.0.0)

```py
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        # 易错点：注意边界上也可能有obstacle
        # 易错点：dp = [[0]*(n+1)]*(m+1)这些写法是错误的
        dp = [[0]*(n+1) for _ in range(m+1)]
        # 易错点：dp[1][1] = 1,这个数字会被重新计算，所以应该写成：
        dp[0][1] = 1
        # 构建了一个大一圈的矩阵，但实际计算的时候，仍然是mn的大小
        for i in range(1,m+1):
            for j in range(1,n+1):
                if not obstacleGrid[i-1][j-1]:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        print(dp)
        return dp[-1][-1]
```

##  207. <a name='Excel-1'></a>171. Excel Sheet Column Number

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7nT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1h541187Sv?spm_id_from=333.999.0.0)

```py
# python 从左到右遍历
        #26进制转10进制
class Solution:
def titleToNumber(self, columnTitle: str) -> int:
        res = 0
        for char in columnTitle:
            res *= 26
            res += ord(char) - ord('A') + 1 
        return res
```


```scala
//Alternate solution
object Solution {
    def titleToNumber(s: String): Int = 
        s.foldLeft(0)((acc, ch) => acc * 26 + (ch - 'A' + 1))
}

```

##  208. <a name='-1'></a>17. Letter Combinations of a Phone Number 

[花花酱](https://www.bilibili.com/video/BV1PW411y7r2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7sL?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ti4y1A73M?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Sp4y1r7YP?spm_id_from=333.999.0.0)

深度优先 or 广度优先

* 时间复杂度:O(3m × 4n), m是对应3个字母的数字, n是对应4个字母的数字

* 时间复杂度:O(3m × 4n), m是对应3个字母的数字, n是对应4个字母的数字

```py
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits: # 易错点：一定要判断判断字符串是否为空
            return [] 
        dic = {'2':'abc','3':'def','4':'ghi','5':'kjl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        res = [char for char in dic[digits[0]]] # 前面的排在前面
        for num in digits[1:]:
            res = [string + char for string in res for char in dic[num]]
        return res
```

```py
class Solution:
    def letterCombinations(self, digits):
        if not digits:
            return list()
        
        phoneMap = {
            "2": "abc",
            "3": "def",
            "4": "ghi",
            "5": "jkl",
            "6": "mno",
            "7": "pqrs",
            "8": "tuv",
            "9": "wxyz",
        }

        groups = (phoneMap[digit] for digit in digits)
        return ["".join(combination) for combination in itertools.product(*groups)]
```

##  209. <a name='-1'></a>494. 【动态🚀规划 + 背包 + dfs(startI)无for循环】Target Sum

[花花酱](https://www.bilibili.com/video/BV1WW411C7Mp?spm_id_from=333.999.0.0)

[花花酱 下](https://www.bilibili.com/video/BV1WW411C7Mr?spm_id_from=333.999.0.0)

0-1背包（二维动态规划）

```py
class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        # 求得新的目标
        sums = sum(nums)
        # 注意，需要排除掉一些特殊状况
        bagSize = sums + target
        # 也可以写成：bagSize = sums - target

        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2
        # 构建dp，numLen在外围
        dp = [[0] * (bagSize+1) for _ in range(n+1)]
        # 赋值，dp的第一个元素
        dp[0][0] = 1
        for i in range(1,n+1):
            num = nums[i-1] # 易错点: num = nums[i-1]单独提出来写，不容易出错
            for j in range(bagSize+1):
                if j-num >= 0: # 易错点: 这里必需要是>=
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-num]
                else:
                    dp[i][j] = dp[i-1][j]
#    [[1, 0, 0, 0, 0], 
#     [1, 1, 0, 0, 0], 
#     [1, 2, 1, 0, 0], 
#     [1, 3, 3, 1, 0], 
#     [1, 4, 6, 4, 1], 
#     [1, 5, 10, 10, 5]]
        return dp[-1][-1]
```

0-1背包（一维动态规划）

```py
class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        # 求得新的目标
        sums = sum(nums)
        # 注意，需要排除掉一些特殊状况
        bagSize = sums + target
        # 也可以写成：bagSize = sums - target
        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2
        # 构建dp，numLen在外围
        dp = [0] * (bagSize+1)
        # 赋值，dp的第一个元素
        dp[0] = 1
        for num in nums:
            for j in range(bagSize,num-1,-1):
                dp[j] += dp[j-num] # 对于没有当前num时的case + 有了num时bagSize-num的cas
        # 含义就是：
        # 对于1个num，bagsize的填满情况
        # 对弈2个num，bagsize的填满情况
        return dp[-1]

数字： 1 dp: [1, 0, 0, 0, 0]
数字： 1 dp: [1, 0, 0, 0, 0]
数字： 1 dp: [1, 0, 0, 0, 0]
数字： 1 dp: [1, 1, 0, 0, 0]
--------------------
数字： 1 dp: [1, 1, 0, 0, 0]
数字： 1 dp: [1, 1, 0, 0, 0]
数字： 1 dp: [1, 1, 1, 0, 0]
数字： 1 dp: [1, 2, 1, 0, 0]
--------------------
数字： 1 dp: [1, 2, 1, 0, 0]
数字： 1 dp: [1, 2, 1, 1, 0]
数字： 1 dp: [1, 2, 3, 1, 0]
数字： 1 dp: [1, 3, 3, 1, 0]
--------------------
数字： 1 dp: [1, 3, 3, 1, 1]
数字： 1 dp: [1, 3, 3, 4, 1]
数字： 1 dp: [1, 3, 6, 4, 1]
数字： 1 dp: [1, 4, 6, 4, 1]
--------------------
数字： 1 dp: [1, 4, 6, 4, 5]
数字： 1 dp: [1, 4, 6, 10, 5]
数字： 1 dp: [1, 4, 10, 10, 5]
数字： 1 dp: [1, 5, 10, 10, 5]
--------------------

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        sums = sum(nums)
        bagSize = sums + target
        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2

        @cache
        def dfs(startI,total):
            # 如果要写递归，那么这个递归的结束条件一定要背出来
            if startI == len(nums):
                return 1 if total == 0 else 0
            # 如果要写递归，那么这个递归的结束条件一定要背出来
            return dfs(startI+1,total-nums[startI]) + dfs(startI+1,total)

        return dfs(0,bagSize)

```

```py
# 思路

# 每个数，只有取正、取负数，这两种处理。因此可以做深度优先遍历，为了避免重复计算，加上记忆法。

# DFS 到 nums[i] 时，取正数，则要求后面的数，处理后的 next_target = current_target - nums[i];
# 取负数的处理同上，后续要处理的 next_target = current_target + nums[i]；
# 用 python 语法糖简单演示下：

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        # @lru_cache(None)
        def dfs(startIdx, sum) -> int:
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return dfs(startIdx + 1, sum - nums[startIdx]) + dfs(startIdx + 1, sum + nums[startIdx])

        return dfs(0, target)

# @lru_cache(None) 好神奇，瞬间提高效率
# 如果不用@lru_cache(None)，用这种方式会超时，Java的就不会啊
# 同样的解法，Java 不超时是因为 Java 运行速度比 Python 快得多。
# 而 Python 如果不用 lru_cache 或者显式的记忆数组存储 dfs 的结果，
# 大量重复计算会导致超时，因为 Python 运行速度慢

# DFS

class Solution:
    def findTargetSumWays(self, nums: List[int], V) -> int:
        def dfs(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum==0 else 0
            res = 0
            res += dfs(sum-nums[startIdx], startIdx+1)
            res += dfs(sum+nums[startIdx], startIdx+1)
            return res
        return dfs(V, 0)


# 递归，findSum(s, start_idx) 函数的意思是从start_index开始向后的子集合能有几种得到s的方法

class Solution(object):
    def findTargetSumWays(self, nums, S):
        def findSum(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return findSum(sum+nums[startIdx], startIdx+1) + findSum(sum-nums[startIdx], startIdx+1)
        return findSum(S, 0)
# 但是这样会超时，所以用cache 记一下

class Solution(object):
    def findTargetSumWays(self, nums, S):
        def findSum(s, start_idx):
            if start_idx == len(nums):
                return 1 if s == 0 else 0
            if (s, start_idx) not in cache:
                cache[(s, start_idx)] = findSum(s+nums[start_idx], start_idx+1) + findSum(s-nums[start_idx], start_idx+1)
            return cache[(s, start_idx)]
            
        cache = {}
        return findSum(S, 0)
```


##  210. <a name='Offer03.'></a>剑指 Offer 03. 数组中重复的数字

https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/

```py
Python3 方法一： 先排序，然后看相邻元素是否有相同的，有直接return。 不过很慢，时间O(nlogn)了，空间O(1)

class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        nums.sort()
        pre = nums[0]
        n = len(nums)
        for index in range(1, n):
            if pre == nums[index]:
                return pre
            pre = nums[index]
方法二：哈希表 时间O(n)，空间O（n）

class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        repeatDict = {}
        for num in nums:
            if num not in repeatDict:
                repeatDict[num] = 1
            else:
                return num
方法三：时间复杂度O(n)，空间复杂度O(1)。可以看做是一种原地哈希，不过没有用到字典。具体做法就是因为题目中给的元素是 < len（nums）的，所以我们可以让 位置i 的地方放元素i。如果位置i的元素不是i的话，那么我们就把i元素的位置放到它应该在的位置，即 nums[i] 和nums[nums[i]]的元素交换，这样就把原来在nums[i]的元素正确归位了。如果发现 要把 nums[i]正确归位的时候，发现nums[i]（这个nums[i]是下标）那个位置上的元素和要归位的元素已经一样了，说明就重复了，重复了就return

class Solution:
    def findRepeatNumber(self, nums) -> int:
        n = len(nums)
        for i in range(n):
            while i != nums[i]:              
                if nums[i] == nums[nums[i]]:
                    return nums[i]
                temp = nums[i]
                nums[i], nums[temp] = nums[temp], nums[i]
            #   注意这里不要写成nums[i], nums[nums[i]] = nums[nums[i]], nums[i]
方法1：利用python set的无序不重复特性：利用Python中的set集合为无序不重复集合，通过判断temp_set的长度确定是否是重复数字。

class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        temp_set = set()
        repeat = -1
        for i in range(len(nums)):
            temp_set.add(nums[i])
            if len(temp_set) < i + 1:
                repeat = nums[i]
                break
        return repeat
方法2：利用python的sort函数排序，然后计算相邻两个数据是否相等即可。

class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)-1):
            if nums[i]==nums[i+1]:
                return nums[i]
```


##  212. <a name='Offer33.'></a>剑指 Offer 33. 二叉搜索树的后序遍历序列

```py
class Solution:
    def verifyPostorder(self, postorder: [int]) -> bool:
        def recur(i, j):
            if i >= j: return True
            p = i
            while postorder[p] < postorder[j]: p += 1
            m = p
            while postorder[p] > postorder[j]: p += 1
            return p == j and recur(i, m - 1) and recur(m, j - 1)

        return recur(0, len(postorder) - 1)

作者：jyd
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def verifyPostorder(self, postorder: [int]) -> bool:
        stack, root = [], float("+inf")
        for i in range(len(postorder) - 1, -1, -1):
            if postorder[i] > root: return False
            while(stack and postorder[i] < stack[-1]):
                root = stack.pop()
            stack.append(postorder[i])
        return True

作者：jyd
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

大家好呀，还有一种解法。简单翻了几篇题解好像没人提到类似的思路。个人理解这题跟构造BST考察的内容是类似的，我们只需要利用数组尝试构建一棵BST就可以了，如果构建完成，最终数组为空，说明是合法的BST。若构建结束数组不为空，说明不是合法的BST。

实际代码实现不需要真的构建一棵BST，只需要判断是否符合BST结构，符合则移除数组的最后一个元素，不符合直接返回即可。这样实现的话，不符合规则提前返回，相当于剪枝了。

最差情况下需要遍历全部节点，时间复杂度为O(N)。空间上只有2个常量，另外就是递归使用的栈空间，递归的深度和树的深度相关。常规情况下空间复杂度为O(logN)，极端情况下（拉成一条链）空间复杂度为O(N)。

对了，构造顺序是根->右->左，这个点挺关键的，因为是后续遍历序列，而我们是倒序遍历数组的。

Python代码如下：

class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        def build(postorder: List[int], ma: int, mi: int):
            if not postorder: return
            val = postorder[-1]
            if not mi < val < ma: return
            postorder.pop() # 根
            build(postorder, ma, val) # 右
            build(postorder, val, mi) # 左

        build(postorder, sys.maxsize, -sys.maxsize)
        return not postorder

python3易理解的方法

# 先找到根节点的右子节点，然后判断右子树的值是否全大于root；然后再递归根节点的左右子树即可
class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        if not postorder: return True
        root = postorder[-1]
        cur_index = 0
        for i in range(len(postorder)):
            if postorder[i] >= root:
                cur_index = i
                break
        left = postorder[:cur_index]
        right = postorder[cur_index : -1]
        for val in right:
            if val < root:
                return False
        return self.verifyPostorder(left) and self.verifyPostorder(right)

我在第一次循环找第一个大于root的索引是用的大于,结果[4,6,7,5]这个测试用例通不过,这是为啥呢

class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        if not postorder: return True

        root = postorder[-1]

        index = 0
        for i, num in enumerate(postorder):
            if num > root:
                index = i
                break
        
        left = postorder[:index]
        right = postorder[index:-1]

        for num in right:
            if num < root:
                return False
        
        return self.verifyPostorder(left) and self.verifyPostorder(right)

python3: 简单递归操作

1 最后一个数为根节点，通过根节点不断切割左右子树，递归判断左右子树是否为二叉搜索树。

class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        
        def helper(nums):
            if len(nums) <= 1: return True
            root = nums[-1]
            for i in range(len(nums)):
                if nums[i] > root: break
            for j in range(i, len(nums)-1):
                if nums[j] < root: return False
            return helper(nums[:i]) and helper(nums[i:-1])
        
        if not postorder: return True
        return helper(postorder)

用反证法来做：

1.假设postorder是某棵二叉搜索树的后序遍历结果；

2.对该棵二叉搜索数进行中序遍历就可以得到一个单调递增的数组，那么对后序遍历结果postorder进行升序排序同样可以得到该二叉搜索树的中序遍历结果inorder；

3.如果假设成立，即可以用inorder和postorder构造出一颗二叉搜索树，如果无法构造，则与假设矛盾，即postorder不是某二叉搜索树的后序遍历结果。

class Solution:
    def verifyPostorder(self, postorder: List[int]) -> bool:
        inorder = sorted(postorder)  
        def check(postorder, inorder):
            if len(postorder) == 0:return True
            elif postorder[-1] not in inorder:return False
            else:
                index = inorder.index(postorder[-1])
                if check(postorder[:index], inorder[:index]) and \
                    check(postorder[index:-1], inorder[index+1:]):return True
                else:return False
        return check(postorder, inorder)
```

##  213. <a name='K-1'></a>862. 和至少为 K 的最短子数组

```py
class Solution(object):
    def shortestSubarray(self, A, K):
        N = len(A)
        P = [0]
        for x in A:
            P.append(P[-1] + x)

        #Want smallest y-x with Py - Px >= K
        ans = N+1 # N+1 is impossible
        monoq = collections.deque() #opt(y) candidates, represented as indices of P
        for y, Py in enumerate(P):
            #Want opt(y) = largest x with Px <= Py - K
            while monoq and Py <= P[monoq[-1]]:
                monoq.pop()

            while monoq and Py - P[monoq[0]] >= K:
                ans = min(ans, y - monoq.popleft())

            monoq.append(y)

        return ans if ans < N+1 else -1

作者：LeetCode
链接：https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/solution/he-zhi-shao-wei-k-de-zui-duan-zi-shu-zu-by-leetcod/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

##  214. <a name='-1'></a>343-整数拆分

[哈哈哈](https://www.bilibili.com/video/BV1Dp4y1U79P?spm_id_from=333.999.0.0)

```py
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n + 1)
        for i in range(2, n + 1):
            for j in range(i):
                dp[i] = max(dp[i], j * (i - j), j * dp[i - j])
        return dp[n]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Solution:
    def integerBreak(self, n: int) -> int:
        if n < 4:
            return n - 1
        
        dp = [0] * (n + 1)
        dp[2] = 1
        for i in range(3, n + 1):
            dp[i] = max(2 * (i - 2), 2 * dp[i - 2], 3 * (i - 3), 3 * dp[i - 3])
        
        return dp[n]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Solution:
    def integerBreak(self, n: int) -> int:
        if n <= 3:
            return n - 1
        
        quotient, remainder = n // 3, n % 3
        if remainder == 0:
            return 3 ** quotient
        elif remainder == 1:
            return 3 ** (quotient - 1) * 4
        else:
            return 3 ** quotient * 2

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
Python：

class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[2] = 1
        for i in range(3, n + 1):
            # 假设对正整数 i 拆分出的第一个正整数是 j（1 <= j < i），则有以下两种方案：
            # 1) 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j * (i-j)
            # 2) 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i-j]
            for j in range(1, i - 1):
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
        return dp[n]

新加入的数字，最大值可能是：

1.在前面的所有数中加上一个数去乘 如dp[8] = dp[5] * (8 - 5)

2.把自己平分成两个接近的数然后相乘 如dp[6] = 3 * 3 dp[5] = 2 * 3

状态转移方程:

dp[i] = max( max((i-j)*dp[j]) , (i//2) ** 2) ) if i % 2 == 0

dp[i] = max( max((i-j)*dp[j]) , (i//2) * ((i//2) + 1) ) if i % 2 == 0

class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        for i in range( n + 1):
            maxN = 0
            for j in range(i):
                maxN = max(maxN, (i-j) * dp[j])
            if i % 2 == 0:
                maxN2 = (i//2) ** 2
            else:
                maxN2 = (i//2) * ((i//2) + 1)
            dp[i] = max(maxN , maxN2)
        return dp[n]

分析： 拥有最优子结构的特性： 如上例， 10 = 6 * 4； 那么6也应该拆分成乘积最大的3*3； 重叠子问题： 10 可以拆成 6 + 4； 12可拆成6 + 6, 都要计算6的最大乘积； 无后效性， 当10 拆分成6 + 4（或者12拆成6 + 6）之后， 6之后怎么拆与之前无关（无论这个6来自10还是12）； 所以满足动态规划的条件， 故可用动态规划解题

定义dp[i] : 表示整数 i 拆分之后可得到的最大乘积

状态转移方程： 先考虑拆分成A * B；此后一共有3种情况， 继续拆解AB, 只拆解A, 只拆解B， 故： dp[i] = max((i - j) * j, dp[i-j]*dp[j], dp[i-j] * j, (i-j) * dp[j])， 而A * B的个数是i // 2个， 所以还要将每次得到的dp[i ]考虑进去， 即： dp[i] = max(dp[i], (i - j) * j, dp[i-j]*dp[j], dp[i-j] * j, (i-j) * dp[j])

class Solution:
    def integerBreak(self, n):
        if n < 2:
            return 0

        dp = [1] * (n + 1)
        for i in range(3, n + 1):
            for j in range(1, i // 2 + 1):
                dp[i] = max(dp[i], (i - j) * j, dp[i-j]*dp[j], dp[i-j] * j, (i-j) * dp[j]) 
        
        return dp[n]
优化： 在拆解A * B时， 可以看到循环中， A是从1开始增大的， 因此其实对她的拆解已经就完成在A从小变大的过程中： 所以： dp[i] = max(dp[i], (i - j) * j, dp[i-j] * j)

class Solution:
    def integerBreak(self, n):
        if n < 2:
            return 0

        dp = [1] * (n + 1)
        for i in range(3, n + 1):
            for j in range(1, i // 2 + 1):
                dp[i] = max(dp[i], (i - j) * j, dp[i-j] * j) 
        
        return dp[n]
```

##  215. <a name='-1'></a>673 Number of Longest Increasing Subse

[小明](https://www.bilibili.com/video/BV1gT4y1F7y3?spm_id_from=333.999.0.0)


```py
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        n, max_len, ans = len(nums), 0, 0
        dp = [0] * n
        cnt = [0] * n
        for i, x in enumerate(nums):
            dp[i] = 1
            cnt[i] = 1
            for j in range(i):
                if x > nums[j]:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        cnt[i] = cnt[j]  # 重置计数
                    elif dp[j] + 1 == dp[i]:
                        cnt[i] += cnt[j]
            if dp[i] > max_len:
                max_len = dp[i]
                ans = cnt[i]  # 重置计数
            elif dp[i] == max_len:
                ans += cnt[i]
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-by-w12f/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        d, cnt = [], []
        for v in nums:
            i = bisect(len(d), lambda i: d[i][-1] >= v)
            c = 1
            if i > 0:
                k = bisect(len(d[i - 1]), lambda k: d[i - 1][k] < v)
                c = cnt[i - 1][-1] - cnt[i - 1][k]
            if i == len(d):
                d.append([v])
                cnt.append([0, c])
            else:
                d[i].append(v)
                cnt[i].append(cnt[i][-1] + c)
        return cnt[-1][-1]

def bisect(n: int, f: Callable[[int], bool]) -> int:
    l, r = 0, n
    while l < r:
        mid = (l + r) // 2
        if f(mid):
            r = mid
        else:
            l = mid + 1
    return l

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-by-w12f/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


执行用时：1644 ms, 在所有 Python3 提交中击败了5.02%的用户 内存消耗：15.4 MB, 在所有 Python3 提交中击败了14.14%的用户 直接泪目 pdd挂了投了正式批，我还是喜欢coding

class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        # 求最长递增子序列的二分方法，过程中统计个数，长度好做，个数呢两个for？
        if not nums:
            return 0
        dp = [1 for i in range(len(nums))]
        cnt = [0 for i in range(len(nums))]
        # dp[i]表示以nums[i]结尾的最长的子序列的长度
        cnt[0] = 1
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i]>nums[j]:#nums[i] nums[j] 可以组成递增序列
                    dp[i] = max(dp[i], dp[j]+1)
            for j in range(i):
                if nums[i]>nums[j] and dp[i]==dp[j]+1:
                    cnt[i] += cnt[j] #how does this works?

            if cnt[i] == 0:# 前面没有比它小的
                cnt[i] = 1
        max_dp=max(dp)
        res = 0
        for i in range(len(nums)):
            if dp[i] == max_dp:
                res += cnt[i]
        return res
                

class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        if size<= 1: return size

        dp = [1 for i in range(size)]
        count = [1 for i in range(size)]

        maxCount = 0
        for i in range(1, size):
            for j in range(i):
                if nums[i] > nums[j]:
                    if dp[j] + 1 > dp[i] :
                        dp[i] = dp[j] + 1
                        count[i] = count[j]
                    elif dp[j] + 1 == dp[i] :
                        count[i] += count[j]
                if dp[i] > maxCount:
                    maxCount = dp[i];
        result = 0
        for i in range(size):
            if maxCount == dp[i]:
                result += count[i]
        return result;

和300题非常像，增加的东西就是子序列的长度。300题时看了题解，这次完全是自己做出来的，不容易啊

创建两个列表，一个表示个数，一个表示长度，两者是一一对应的

然后开始遍历每个数字nums[i]，在每趟遍历的时候都设置两个参数，最长的长度maxLen以及对应的个数maxCnt

对于每个数字，都遍历其之前的数字nums[j]

发现nums[i]>nums[j]，则说明出现了新的递增序列，根据nums[j]和l[j]对应更新最长序列的个数及长度

遍历过后，如果maxCnt != 0，就说明在这趟遍历中出现了新的序列，就把maxCnt和maxLen更新给dp和l

否则就说明没有新的序列出现，那么此时把1分别更新给dp和l（因为对于当前nums[i]来说，只有[nums[i]]这一个序列）

最后求一下l中最长的长度maxLenofAll，再次遍历dp，把所有长度为maxLenofAll的个数都加起来，就是最后的答案了

执行用时：712 ms, 在所有 Python3 提交中击败了84.38%的用户 内存消耗：15.2 MB, 在所有 Python3 提交中击败了47.68%的用户

class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        dp = [1]   #表示个数
        l = [1]    #表示长度

        for i in range(1, len(nums)):

            maxCnt, maxLen = 0, 0   #最长的序列个数，以及长度

            for j in range(i):
                if nums[i] > nums[j]:   #如果当前数比nums[j]大，说明可以构成递增序列
                    if l[j] > maxLen:     #更长，则更新最长的长度和个数
                        maxLen = l[j]     
                        maxCnt = dp[j]  
                    elif l[j] == maxLen:  #相等时，把个数加上去
                        maxCnt += dp[j] 

            if maxCnt != 0:  #如果maxCnt不为0，则说明出现了新的递增序列
                dp.append(maxCnt)
                l.append(maxLen + 1)
            else:    #如果为0则说明没有新的递增序列，该处个数为1（只有当前数字的序列）
                dp.append(1)
                l.append(1)

        maxLenofAll = max(l)   #统计最长的序列的所有次数
        ans = 0
        for i in range(len(dp)):
            if l[i] == maxLenofAll:   #长度和个数一一对应
                ans += dp[i]
        return ans
```

##  216. <a name='17.24.'></a>面试题 17.24. 最大子矩阵

https://leetcode-cn.com/problems/max-submatrix-lcci/solution/zhe-yao-cong-zui-da-zi-xu-he-shuo-qi-you-jian-dao-/

```py
翻译一个python版本

class Solution:
    def getMaxMatrix(self, matrix: List[List[int]]) -> List[int]:
        N = len(matrix)
        M = len(matrix[0])
        a = [0] * M
        maxdp = float('-inf')
        ans = [0] * 4
        for i in range(N):           
            for k in range(M):
                a[k] = 0
            for j in range(i,N):
                dp = 0
                for k in range(M):
                    a[k] += matrix[j][k]
                    #print('a[k]=',a[k])
                    if dp <= 0:
                        dp = a[k]
                        c1 = k
                    else:
                        dp += a[k]
                    if dp > maxdp:
                        maxdp = dp
                        ans[0] = i
                        ans[1] = c1
                        ans[2] = j
                        ans[3] = k
                    #print('i=',i,'j=',j,'k=',k,'dp=',dp,'maxdp=',maxdp,ans,'\n')
        return ans
```

##  217. <a name='-1'></a>611. 有效三角形的个数

```py
class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n):
            for j in range(i + 1, n):
                left, right, k = j + 1, n - 1, j
                while left <= right:
                    mid = (left + right) // 2
                    if nums[mid] < nums[i] + nums[j]:
                        k = mid
                        left = mid + 1
                    else:
                        right = mid - 1
                ans += k - j
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-triangle-number/solution/you-xiao-san-jiao-xing-de-ge-shu-by-leet-t2td/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n):
            k = i
            for j in range(i + 1, n):
                while k + 1 < n and nums[k + 1] < nums[i] + nums[j]:
                    k += 1
                ans += max(k - j, 0)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-triangle-number/solution/you-xiao-san-jiao-xing-de-ge-shu-by-leet-t2td/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

感觉官方的解答又有点问题（为什么说又），O(n^2)得这样写才行吧

class Solution:
    def triangleNumber(self, nums: List[int]) -> int:
        nums.sort()
        res = 0
        for k in range(len(nums)):
            i, j = 0, k - 1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    res += j - i
                    j -= 1
                else:
                    i += 1
        return res

以上解法不用担心数组里的0

0805更新：抱歉！官方解法没问题
class Solution:
    def triangleNumber(self, nums: 'List[int]') -> 'int':
        nums.sort()
        res = 0
        # 从大到小遍历
        for i in range(len(nums) - 1, 1, -1):
            l, r = 0, i -1
            while l < r:
                # 只要较小的两个值之和大于最大的值，则一定可组成三角形
                if nums[l] + nums[r] > nums[i]:
                    #i, r 和从l到r-1都可组成三角形，个数为 (r-1) - l + 1 = r - l
                    res += (r-1) - l + 1
                    r -= 1
                else: l += 1
        return res

一开始是试着固定第一个数i，后两个用指针j和k，结果发现不行，因为可能i,j,k不符合三角形，但是i,j,k-1可能符合，因此找不准j和k，所以行不通；
如果是固定最后一个数k，如果找到i、j可以组成三角形，i、j之内的数肯定可以，之外的数不行，因此直接计算j-i就行
```

##  218. <a name='II-1'></a>45 Jump Game II

[小明](https://www.bilibili.com/video/BV1fb4y1Z77x?spm_id_from=333.999.0.0)

```py
class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        maxPos, end, step = 0, 0, 0
        for i in range(n - 1):
            if maxPos >= i:
                maxPos = max(maxPos, i + nums[i])
                if i == end:
                    end = maxPos
                    step += 1
        return step

#   😋我的模仿

class Solution:
    def jump(self, nums: List[int]) -> int:
        n = len(nums)
        jump = 0
        cover = 0
        stop = 0
        i = 0
        while cover >= i and i < n-1: 
            #易错点：是n-1，不是n，只要调到最后一格就算成功
            cover = max(cover,i + nums[i])
            if i == stop:
                jump += 1
                stop = cover
            i += 1
        return jump
```

##  220. <a name='-1'></a>85. 最大矩形

```py
这一题的算法本质上和84题Largest Rectangle in Histogram一样，对每一行都求出每个元素对应的高度，这个高度就是对应的连续1的长度，然后对每一行都更新一次最大矩形面积。那么这个问题就变成了Largest Rectangle in Histogram。本质上是对矩阵中的每行，均依次执行84题算法。

class Solution:
    def maximalRectangle(self, matrix) -> int:
        if len(matrix) == 0:
            return 0
        res = 0
        m, n = len(matrix), len(matrix[0])
        heights = [0] * n
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '0':
                    heights[j] = 0
                else:
                    heights[j] = heights[j] + 1
            res = max(res, self.largestRectangleArea(heights))
        return res

    def largestRectangleArea(self, heights):
        heights.append(0)
        stack = []
        res = 0
        for i in range(len(heights)):
            while stack and heights[i] < heights[stack[-1]]:
                s = stack.pop()
                res = max(res, heights[s] * ((i - stack[-1] - 1) if stack else i))
            stack.append(i)
        return res

python 72ms 99.5% 感觉中文版的评论= =好像确实不如英文版啊= =python这么强的二进制操作，没人说= = 一年后更新，加入注释方便大家理解，思路就是通过二进制的&运算求矩形高度，>>运算来计算矩形宽度，然后每一行都遍历一遍，得出最大值。

class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        nums = [int(''.join(row), base=2) for row in matrix] #先将每一行变成2进制的数字
        ans, N = 0, len(nums)
        for i in range(N):#遍历每一行，求以这一行为第一行的最大矩形
            j, num = i, nums[i]
            while j < N: #依次与下面的行进行与运算。
                num = num & nums[j]  #num中为1的部分，说明上下两行该位置都是1，相当于求矩形的高，高度为j-i+1
                # print('num=',bin(num))
                if not num: #没有1说明没有涉及第i到第j行的竖直矩形
                    break
                width, curnum = 0, num
                while curnum: 
                    #将cursum与自己右移一位进行&操作。如果有两个1在一起，那么cursum才为1，相当于求矩形宽度
                    width += 1
                    curnum = curnum & (curnum >> 1)
                    # print('curnum',bin(curnum))
                ans = max(ans, width * (j-i+1))
                # print('i','j','width',i,j,width)
                # print('ans=',ans)
                j += 1
        return ans

借用了上题的单调栈：

class Solution(object):
    def maximalRectangle(self, matrix):
        """
        :type matrix: List[List[str]]
        :rtype: int
        """
        row = len(matrix)
        col = len(matrix[0])
        res = 0
        height  = [0]*(col+2)
        for i in range(row):
            st = [0]
            for j in range(col):
                if matrix[i][j]=='1':
                    height[j+1] +=1
                if matrix[i][j]=='0':
                    height[j+1] =0
            for k in range(1,len(height)):
                while(height[k]<height[st[-1]]):
                    h = height[st.pop()]
                    w = k-st[-1]-1
                    res = max(res,h*w)
                st.append(k)
        return  res

python 每一行当成柱状图处理 用单调栈 时间复杂度O(mn) 空间复杂度O(n)

class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        m,n,ans = len(matrix), len(matrix[0]),0
        up, q=[0]*n, [-1]
        for i in range(m):
            up=[up[k]+1 if matrix[i][k]=="1" else 0 for k in range(n)]
            for j in range(n):
                while q[-1]!=-1 and up[q[-1]]>=up[j]:
                    ans=max(ans, (j-q[-2]-1)*up[q[-1]])
                    q.pop()
                q.append(j)
            while q[-1]!=-1:
                ans=max(ans, (n-q[-2]-1)*up[q[-1]])
                q.pop()
        return ans
```


# 12 day (得分 = 2分) 89

##  221. <a name='-1'></a>679. 24 点游戏

```py
class Solution:
    def judgePoint24(self, nums: List[int]) -> bool:
        TARGET = 24
        EPSILON = 1e-6
        ADD, MULTIPLY, SUBTRACT, DIVIDE = 0, 1, 2, 3

        def solve(nums: List[float]) -> bool:
            if not nums:
                return False
            if len(nums) == 1:
                return abs(nums[0] - TARGET) < EPSILON
            for i, x in enumerate(nums):
                for j, y in enumerate(nums):
                    if i != j:
                        newNums = list()
                        for k, z in enumerate(nums):
                            if k != i and k != j:
                                newNums.append(z)
                        for k in range(4):
                            if k < 2 and i > j:
                                continue
                            if k == ADD:
                                newNums.append(x + y)
                            elif k == MULTIPLY:
                                newNums.append(x * y)
                            elif k == SUBTRACT:
                                newNums.append(x - y)
                            elif k == DIVIDE:
                                if abs(y) < EPSILON:
                                    continue
                                newNums.append(x / y)
                            if solve(newNums):
                                return True
                            newNums.pop()
            return False

        return solve(nums)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

##  222. <a name='-1'></a>108 Convert Sorted Array to Binary Search Tree 

[花花酱](https://www.bilibili.com/video/BV1F7411H7tH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1JJ411q74U?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wa411c7tS?spm_id_from=333.999.0.0)

> python

```py
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if nums:
            mid = len(nums) // 2
            root = TreeNode(nums[mid])
            root.left = self.sortedArrayToBST(nums[:mid])
            root.right = self.sortedArrayToBST(nums[mid+1:])
            return root
```

scala 中没有这种形式的写法 nums[:mid]，nums[mid+1:]

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def formTree(nums: Array[Int], begin: Int, end: Int): TreeNode = {
        var mid = begin + Math.ceil((end - begin)/2).toInt
        TreeNode(
            nums(mid), 
            if(mid <= begin) null else formTree(nums, begin, mid-1), 
            if(mid >= end) null else formTree(nums, mid+1, end)
        )
    }
    
    def sortedArrayToBST(nums: Array[Int]): TreeNode = {
        if(nums.isEmpty){
            null
        }else{
            formTree(nums, 0, nums.size - 1)
        }
    }
}

```

##  223. <a name='-1'></a>222. Count Complete Tree Nodes

[花花酱](https://www.bilibili.com/video/BV1n44y1E73D?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qz411i7bh?spm_id_from=333.999.0.0)

两种递归

```py
class Solution(object):
    def countNodes(self, root):
        if root == None:
        	return 0
        if root.left == None and root.right == None:
        	return 1
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)

class Solution(object):
    def countNodes(self, root):
        if not root:
            return 0
        lh, rh = self.getHeight(root.left), self.getHeight(root.right)
        if lh == rh:  # 左右子树高度相同，说明左子树必满 则节点数=左子树节点 + root节点(=1) + 递归找右子树
            return (pow(2, lh) - 1) + 1 + self.countNodes(root.right)
        else:  # 左子树比右子树高，说明右子树必满 同理
            return (pow(2, rh) - 1) + 1 + self.countNodes(root.left)

    def getHeight(self, root):
        ret = 0
        while root:
            ret += 1
            root = root.left
        return ret
# 相对来说，递归法利用公式更容易理解：
# 既然说了是 complete binary tree，那么必然有特性可用，
# complete binary tree的特性是除了最后一层，之前的就是perfect tree.
```

```py
# 完全二叉树的性质{根节点的左右子树至少有一个是满二叉树}， 
# 首先从根节点开始计算左右子树的高度，如果相等则为满二叉树，直接返回 
# 否则递归计算左右子树 
# Note：乍一看时间复杂度为O(N*logN)，
# 但是根据完全二叉树的性质,其子树中至少有一个满二叉树，
# 所以只会有一个递归会正真的执行下去 
# 查找深度的时间复杂度为logN,递归的深度为O(logN)，
# 所以总的时间复杂度为O(logN * logN)

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        left = right = 0
        tmp1 = tmp2 =  root

        # 求出树的深度
        while tmp1:
            left += 1
            tmp1 = tmp1.left
        while tmp2:
            right += 1
            tmp2 = tmp2.right

        # 利用树的深度
        if left == right:
            return 2 ** left - 1
        else:
            return 1 + self.countNodes(root.left) + self.countNodes(root.right)  #根据完全二叉树的性质，这两地递归真正执行的只有一个


# 所以寻找左子树的最左边的高度和右子树的最右边的node高度，
# 如果相同就是perfect tree，高度2^h - 1， 否则递归的来看左子树和右子树

class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
        	return 0
        
        p, q = root,root

        leftHeight = 0
        rightHeight = 0

        while p:
        	p = p.left
        	leftHeight += 1

        while q:
        	q = q.right
        	rightHeight += 1

        if leftHeight == rightHeight:
        	return (int)(math.pow(2,leftHeight) - 1)
        else:
        	return 1 + self.countNodes(root.left) + self.countNodes(root.right)



# 我随便写了写，还准备修改，没想到一提交啪就通过了，很快啊！

class Solution(object):
    def countNodes(self, root):
        if not root: return 0
        depth=0
        
        def getDepth(root):
            nonlocal depth
            depth += 1
            if root.left:
                getDepth(root.left)
            else:
                return
            
        getDepth(root)
        ans=2**(depth-1)-1
        
        def dfs(node,path):
            nonlocal ans
            path.append(node)
            if node.left:
                dfs(node.left,path)
            if node.right:
                dfs(node.right,path)
            if not node.left and not node.right:
                if len(path)==depth:
                    ans+=1
            path.pop()
            
        dfs(root,[])
        return ans
```

##  224. <a name='-1'></a>84. 柱状图中最大的矩形 Largest Rectangle in Histogram

[官方](https://www.bilibili.com/video/BV16D4y1D7ed?spm_id_from=333.999.0.0)

```py
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        left, right = [0] * n, [0] * n

        mono_stack = list()
        for i in range(n):
            while mono_stack and heights[mono_stack[-1]] >= heights[i]:
                mono_stack.pop()
            left[i] = mono_stack[-1] if mono_stack else -1
            mono_stack.append(i)
        
        mono_stack = list()
        for i in range(n - 1, -1, -1):
            while mono_stack and heights[mono_stack[-1]] >= heights[i]:
                mono_stack.pop()
            right[i] = mono_stack[-1] if mono_stack else n
            mono_stack.append(i)
        
        ans = max((right[i] - left[i] - 1) * heights[i] for i in range(n)) if n > 0 else 0
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        left, right = [0] * n, [n] * n

        mono_stack = list()
        for i in range(n):
            while mono_stack and heights[mono_stack[-1]] >= heights[i]:
                right[mono_stack[-1]] = i
                mono_stack.pop()
            left[i] = mono_stack[-1] if mono_stack else -1
            mono_stack.append(i)
        
        ans = max((right[i] - left[i] - 1) * heights[i] for i in range(n)) if n > 0 else 0
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

动态规划

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        result = 0
        minleftindex, minrightindex = [0]*len(heights), [0]*len(heights)
        
        minleftindex[0]=-1
        for i in range(1,len(heights)):
            t = i-1
            while t>=0 and heights[t]>=heights[i]: t=minleftindex[t]
            minleftindex[i]=t
            
        minrightindex[-1]=len(heights)
        for i in range(len(heights)-2,-1,-1):
            t=i+1
            while t<len(heights) and heights[t]>=heights[i]: t=minrightindex[t]
            minrightindex[i]=t
        
        for i in range(0,len(heights)):
            left = minleftindex[i]
            right = minrightindex[i]
            summ = (right-left-1)*heights[i]
            result = max(result,summ)
        return result
单调栈 版本二

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.insert(0,0) # 数组头部加入元素0
        heights.append(0) # 数组尾部加入元素0
        st = [0]
        result = 0
        for i in range(1,len(heights)):
            while st!=[] and heights[i]<heights[st[-1]]:
                midh = heights[st[-1]]
                st.pop()
                if st!=[]:
                    minrightindex = i
                    minleftindex = st[-1]
                    summ = (minrightindex-minleftindex-1)*midh
                    result = max(summ,result)
            st.append(i)
        return result


最左边插个0，heights最后补充一个0可以很好的简化代码

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = [-1]
        heights.append(0)
        n,ans = len(heights),0
        for i in range(n):
            while len(stack) > 1 and heights[stack[-1]] > heights[i]:
                p = stack.pop()
                l,r = stack[-1],i
                ans = max(ans,heights[p] * (r - l - 1))            
            stack.append(i)
        return ans
```

##  225. <a name='-1'></a>71. Simplify Path

[小梦想家](https://www.bilibili.com/video/BV1V7411w7jX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1D5411J72c?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def simplifyPath(self, path):
        stack = []
        for i in path.split('/'):
            if i not in ['', '.', '..']:
                stack.append(i)
            elif i == '..' and stack:
                stack.pop()
        return "/" + "/".join(stack)
```

```py
# cool
from os.path import abspath

class Solution:
    def simplifyPath(self, path: str) -> str:
        return abspath(path)

from functools import reduce
class Solution:
    def simplifyPath(self, path: str) -> str:
        return "/"+"/".join(reduce(lambda x, y: x[:-1] if y == ".." else x + [y] if y and y != "." else x, path.split("/"), []))

# 等效于:

class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        for i in path.split('/'):
            if i == '..':
                if stack:
                    stack.pop()
                else:
                    continue
            elif i and i != '.': # 注意这里是elif,而不是if
                stack.append(i)
        return "/" + "/".join(stack)
```

##  226. <a name='II-'></a>167-Two Sum II - Input array is sorted

[哈哈哈](https://www.bilibili.com/video/BV167411h7ou?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7id?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1VZ4y1M7eu?spm_id_from=333.999.0.0)

```py
python 3 有点二分法的味道

    # 双指针
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r =0, n-1 
        while l <= r:
            if numbers[l] + numbers[r] == target:
                return [l+1, r+1]
            elif numbers[l] + numbers[r] < target:
                l +=1
            else:
                r -=1
        return [-1, -1]

    # hasn表，利用hash表记录所有的差值
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        visited = dict()
        for index, num in enumerate(numbers):
            if num in visited:
                return [visited[num]+1, index+1]
            visited[target - num] = index
```

##  227. <a name='-1'></a>622 Design Circular Queue

[小明](https://www.bilibili.com/video/BV1kV411n7Uk?spm_id_from=333.999.0.0)

```py
class MyCircularQueue:

    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the queue to be k.
        """
        self.queue = [0]*k
        self.headIndex = 0
        self.count = 0
        self.capacity = k

    def enQueue(self, value: int) -> bool:
        """
        Insert an element into the circular queue. Return true if the operation is successful.
        """
        if self.count == self.capacity:
            return False
        self.queue[(self.headIndex + self.count) % self.capacity] = value
        self.count += 1
        return True

    def deQueue(self) -> bool:
        """
        Delete an element from the circular queue. Return true if the operation is successful.
        """
        if self.count == 0:
            return False
        self.headIndex = (self.headIndex + 1) % self.capacity
        self.count -= 1
        return True

    def Front(self) -> int:
        """
        Get the front item from the queue.
        """
        if self.count == 0:
            return -1
        return self.queue[self.headIndex]

    def Rear(self) -> int:
        """
        Get the last item from the queue.
        """
        # empty queue
        if self.count == 0:
            return -1
        return self.queue[(self.headIndex + self.count - 1) % self.capacity]

    def isEmpty(self) -> bool:
        """
        Checks whether the circular queue is empty or not.
        """
        return self.count == 0

    def isFull(self) -> bool:
        """
        Checks whether the circular queue is full or not.
        """
        return self.count == self.capacity

作者：LeetCode
链接：https://leetcode-cn.com/problems/design-circular-queue/solution/she-ji-xun-huan-dui-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


from threading import Lock

class MyCircularQueue:

    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the queue to be k.
        """
        self.queue = [0]*k
        self.headIndex = 0
        self.count = 0
        self.capacity = k
        # the additional attribute to protect the access of our queue
        self.queueLock = Lock()

    def enQueue(self, value: int) -> bool:
        """
        Insert an element into the circular queue. Return true if the operation is successful.
        """
        # automatically acquire the lock when entering the block
        with self.queueLock:
            if self.count == self.capacity:
                return False
            self.queue[(self.headIndex + self.count) % self.capacity] = value
            self.count += 1
        # automatically release the lock when leaving the block
        return True

作者：LeetCode
链接：https://leetcode-cn.com/problems/design-circular-queue/solution/she-ji-xun-huan-dui-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Node:
    def __init__(self, value, nextNode=None):
        self.value = value
        self.next = nextNode

class MyCircularQueue:

    def __init__(self, k: int):
        """
        Initialize your data structure here. Set the size of the queue to be k.
        """
        self.capacity = k
        self.head = None
        self.tail = None
        self.count = 0

    def enQueue(self, value: int) -> bool:
        """
        Insert an element into the circular queue. Return true if the operation is successful.
        """
        if self.count == self.capacity:
            return False
        
        if self.count == 0:
            self.head = Node(value)
            self.tail = self.head
        else:
            newNode = Node(value)
            self.tail.next = newNode
            self.tail = newNode
        self.count += 1
        return True


    def deQueue(self) -> bool:
        """
        Delete an element from the circular queue. Return true if the operation is successful.
        """
        if self.count == 0:
            return False
        self.head = self.head.next
        self.count -= 1
        return True


    def Front(self) -> int:
        """
        Get the front item from the queue.
        """
        if self.count == 0:
            return -1
        return self.head.value

    def Rear(self) -> int:
        """
        Get the last item from the queue.
        """
        # empty queue
        if self.count == 0:
            return -1
        return self.tail.value
    
    def isEmpty(self) -> bool:
        """
        Checks whether the circular queue is empty or not.
        """
        return self.count == 0

    def isFull(self) -> bool:
        """
        Checks whether the circular queue is full or not.
        """
        return self.count == self.capacity

作者：LeetCode
链接：https://leetcode-cn.com/problems/design-circular-queue/solution/she-ji-xun-huan-dui-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class MyCircularQueue:

    def __init__(self, k):
        """
        Initialize your data structure here. Set the size of the queue to be k.
        :type k: int
        """
        self.size = k+1
        self.data = [0]*self.size
        self.head = self.rear = 0

    def enQueue(self, value):
        """
        Insert an element into the circular queue. Return true if the operation is successful.
        :type value: int
        :rtype: bool
        """
        if self.isFull():
            return False
        self.data[self.rear] = value
        self.rear = (self.rear+1)%self.size
        return True
    def deQueue(self):
        """
        Delete an element from the circular queue. Return true if the operation is successful.
        :rtype: bool
        """
        if self.isEmpty():
            return False
        self.head = (self.head+1)%self.size
        return True
        
    def Front(self):
        """
        Get the front item from the queue.
        :rtype: int
        """
        if self.isEmpty():
            return -1
        return self.data[self.head]
        

    def Rear(self):
        """
        Get the last item from the queue.
        :rtype: int
        """
        if self.isEmpty():
            return -1
        return self.data[(self.rear-1)%self.size]

    def isEmpty(self):
        """
        Checks whether the circular queue is empty or not.
        :rtype: bool
        """
        return self.head ==self.rear
        

    def isFull(self):
        """
        Checks whether the circular queue is full or not.
        :rtype: bool
        """
        return (self.head - self.rear)%self.size ==1
        
@mbinary 第一个函数。self.size 为什么等于k+1呀？

@mbinary 请教大哥，为什么k要+1

@Ye_prgmr 为了便于实现 isFull, isEmpty. 可以看到 isFull 当 full 的时候 rear 和 head 指针相差1， 
而 rear 指向的位置是没有元素的， 也就是说 填充了 size-1 = k 个元素， 所以 size = k+1

@搬铁少年ai 为了便于实现 isFull, isEmpty. 可以看到 isFull 当 full 的时候 rear 和 head 指针相差1， 
而 rear 指向的位置是没有元素的， 也就是说 填充了 size-1 = k 个元素， 所以 size = k+1
```

##  228. <a name='Z'></a>6. ZigZag Conversion

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7uH?spm_id_from=333.999.0.0)

```py
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        n, r = len(s), numRows
        if r == 1 or r >= n:
            return s
        t = r * 2 - 2
        c = (n + t - 1) // t * (r - 1)
        mat = [[''] * c for _ in range(r)]
        x, y = 0, 0
        for i, ch in enumerate(s):
            mat[x][y] = ch
            if i % t < r - 1:
                x += 1  # 向下移动
            else:
                x -= 1
                y += 1  # 向右上移动
        return ''.join(ch for row in mat for ch in row if ch)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode-solution-4n3u/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def convert(self, s: str, numRows: int) -> str:
        r = numRows
        if r == 1 or r >= len(s):
            return s
        mat = [[] for _ in range(r)]
        t, x = r * 2 - 2, 0
        for i, ch in enumerate(s):
            mat[x].append(ch)
            x += 1 if i % t < r - 1 else -1
        return ''.join(chain(*mat))

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode-solution-4n3u/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def convert(self, s: str, numRows: int) -> str:
        n, r = len(s), numRows
        if r == 1 or r >= n:
            return s
        t = r * 2 - 2
        ans = []
        for i in range(r):  # 枚举矩阵的行
            for j in range(0, n - i, t):  # 枚举每个周期的起始下标
                ans.append(s[j + i])  # 当前周期的第一个字符
                if 0 < i < r - 1 and j + t - i < n:
                    ans.append(s[j + t - i])  # 当前周期的第二个字符
        return ''.join(ans)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode-solution-4n3u/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


为什么不问问神奇Python3呢

class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1: return s
        res, n = [''] * numRows, 2 * numRows - 2

        for i, c in enumerate(s):
            res[min(idx := i % n, n - idx)] += c
        
        return ''.join(res)


思路还是很简单的， 建立字典， key就是行index， value就是对应行的所有字母。遍历字符串， 对于每个字母， 计算在第几行， 加入字典。

class Solution: 
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1: return s
        dct = defaultdict(str)
        cycle_count = numRows * 2 - 2
        for index, char in enumerate(s):
            index_ = index % cycle_count
            if index_ >= numRows:
                index_  = cycle_count - index_
            dct[index_] += char
        ans = ""
        for i in range(numRows):
            ans += dct[i]
        return ans
```

##  229. <a name='-1'></a>96. Unique Binary Search Trees

[小梦想家](https://www.bilibili.com/video/BV1xV411Y731?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1e5411W72t?spm_id_from=333.999.0.0)

```py
# 基于上一问修改
class Solution:
    def numTrees(self, n: int) -> int:

        @cache
        def backtrack(n):
            if n <= 1:
                return 1
            else:
                res = 0 # res一定要写在backtrack里面
                for i in range(n):
                    leftTrees = backtrack(i)
                    rightTrees = backtrack(n-i-1)
                    res += leftTrees*rightTrees # 易错点：一定是加号
                return res
                    
        return backtrack(n)

class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2,n+1):
            for subi in range(i):
                dp[i] += dp[subi]*dp[i-subi-1]
        return dp[-1]
```

##  230. <a name='-1'></a>547 【🍒并查集 + dfs + 队列】朋友圈

[哈哈哈](https://www.bilibili.com/video/BV1Ta411F7rk?spm_id_from=333.999.0.0)

[郭郭](https://www.bilibili.com/video/BV1eX4y157jr?from=search&seid=13286624680279107242&spm_id_from=333.337.0.0)

🍒并查集 

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def find(i: int) -> int:
            if parent[i] != i:
                parent[i] = find(parent[i])
            return parent[i]
        
        def union(i: int, j: int):
            parent[find(i)] = find(j)
        
        proN = len(isConnected)
        parent = list(range(proN))
        
        for i in range(proN):
            for j in range(i + 1, proN):
                if isConnected[i][j] == 1:
                    union(i, j)
        
        res = sum(parent[i] == i for i in range(proN))
        # 求出 i 就是 parent 的总和
        return res
```

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def dfs(i: int):
            for j in range(proN):
                if isConnected[i][j] == 1 and j not in visited:
                    visited.add(j)
                    dfs(j)
        
        proN = len(isConnected)
        visited = set()
        res = 0

        for i in range(proN):
            if i not in visited:
                dfs(i)
                res += 1
        
        return res
```

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        proN = len(isConnected)
        visited = set()
        res = 0
        
        for i in range(proN):
            if i not in visited:
                peopleQ = collections.deque([i])
                while peopleQ:
                    peo = peopleQ.popleft()
                    visited.add(peo)
                    for fri in range(proN):
                        if isConnected[peo][fri] == 1 and fri not in visited:
                            peopleQ.append(fri)
                res += 1
        
        return res

不用递归，可以实现双100%：

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        candidates = set(range(1, len(isConnected)))
        # candidates就是not visited
        if not candidates:
            return 1
        res = 0
        peopleQ = [0]
        while candidates:
            while peopleQ:
                peo = peopleQ.pop()
                friends = [fri for fri in candidates if isConnected[peo][fri]]
                for i in friends:
                    peopleQ.append(i)
                    candidates.remove(i)
            res += 1
            if candidates:
                peopleQ = [list(candidates)[0]]
        return res
```

```scala


/**
* union & find: implement both union by rank and path compression
* time complexity : 
*   in union & find each op:
*           find: very very close to O(1) amortized
*           union: very very close to O(1) amortized
*   the entire ：
*       O(n + M), n is node size, M is the times we call Union operation which cause O(1) 
*       n (constructor) + M (call union times)
*/

object Solution1 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    unionFind.counter

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)
  var counter = M

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
    counter -= 1
  }
} 

/**
* union & find: without counter in union&find to record current cluster
*       O(n + M + n), n is node size, M is the times we call Union operation which cause O(1) 
*       n (construct union & find ) + M (call union times)  + n (n time call findRoot)
*/
object Solution1-2 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    M.indices.map(unionFind.findRoot).distinct.size

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
  }
}


``` 

##  231. <a name='II-1'></a>264. 【动态🚀规划 + 3指针】Ugly Number II

[花花酱](https://www.bilibili.com/video/BV1yW411C7Sm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vT4y1775u?spm_id_from=333.999.0.0)

```py
# python 实习面试这道题挂了，但我就不懂了，第一次见这题目谁能想到3指针的方法？
# [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]
class Solution(object):
    def nthUglyNumber(self, n):
        res = [1]
        idx2 = 0
        idx3 = 0
        idx5 = 0
        for i in range(n-1):
            nxt = min(res[idx2]*2, res[idx3]*3, res[idx5]*5)
            res.append(nxt)
            print(res[idx2]*2, res[idx3]*3, res[idx5]*5, res)
            if nxt == res[idx2]*2:
                idx2 += 1
            if nxt == res[idx3]*3:
                idx3 += 1
            if nxt == res[idx5]*5:
                idx5 += 1
        return res[-1]

# 2 3 5 [1, 2]
# 4 3 5 [1, 2, 3]
# 4 6 5 [1, 2, 3, 4]
# 6 6 5 [1, 2, 3, 4, 5]
# 6 6 10 [1, 2, 3, 4, 5, 6]
# 8 9 10 [1, 2, 3, 4, 5, 6, 8]
# 10 9 10 [1, 2, 3, 4, 5, 6, 8, 9]
# 10 12 10 [1, 2, 3, 4, 5, 6, 8, 9, 10]
# 12 12 15 [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]

```

##  233. <a name='-1'></a>97. 交错字符串

```py
使用队列进一步简化时间复杂度和空间占用，击败99.78%/92.35%

class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        n1, n2, n3 = len(s1), len(s2), len(s3)
        if n1+n2!=n3:
            return False
        q=deque([0])
        for i in range(n3):
            n=len(q)
            if n==0:
                return False
            for j in range(n):
                h=q.popleft()
                if i-h<n1 and s3[i]==s1[i-h] and (len(q)<=1 or q[-1]!=h):
                    q.append(h)
                if h<n2 and s3[i]==s2[h]:
                    q.append(h+1)
        return len(q)>0

python DFS 本来超时，加上lru cache就过了，居然还是28ms击败100%

class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        self.memo = {}
        res = self.dfs(s1, s2, s3)
        return res
    
    @functools.lru_cache()
    def dfs(self, s1, s2, s3):
        l1, l2 = len(s1), len(s2)
        if l1 == 0 or l2 == 0:
            return s3 == s1 + s2
        key = ' '.join([s1, s2, s3])
        if key not in self.memo:
            flag = (s1[0] == s3[0] and self.isInterleave(s1[1:], s2, s3[1:]))
            flag |= (s2[0] == s3[0] and self.isInterleave(s1, s2[1:], s3[1:]))
            self.memo[key] = flag
        
        return self.memo[key]
也不会啥，就给大家贴一个Python实现版本吧

class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        n, m, t = len(s1), len(s2), len(s3)
        if n + m != t: return False

        f = [False] * (m + 1)
        f[0] = True
        for i in range(n + 1):
            for j in range(m + 1):
                p = i + j - 1
                if i > 0:
                    f[j] = f[j] and s1[i - 1] == s3[p]
                if j > 0:
                    f[j] = f[j] or (f[j-1] and s2[j - 1] == s3[p])
        
        return f[m]

```

##  234. <a name='-1'></a>410. Split Array Largest Sum

[花花酱](https://www.bilibili.com/video/BV14W411d7D4?spm_id_from=333.999.0.0)

```py
class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:
        n = len(nums)
        f = [[10**18] * (m + 1) for _ in range(n + 1)]
        sub = [0]
        for elem in nums:
            sub.append(sub[-1] + elem)
        
        f[0][0] = 0
        for i in range(1, n + 1):
            for j in range(1, min(i, m) + 1):
                for k in range(i):
                    f[i][j] = min(f[i][j], max(f[k][j - 1], sub[i] - sub[k]))
        
        return f[n][m]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:
        def check(x: int) -> bool:
            total, cnt = 0, 1
            for num in nums:
                if total + num > x:
                    cnt += 1
                    total = num
                else:
                    total += num
            return cnt <= m


        left = max(nums)
        right = sum(nums)
        while left < right:
            mid = (left + right) // 2
            if check(mid):
                right = mid
            else:
                left = mid + 1

        return left

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

首先分析题意，可以得出结论，结果必定落在【max（nums）， sum（nums）】这个区间内，因为左端点对应每个单独的元素构成一个子数组，右端点对应所有元素构成一个子数组。

然后可以利用二分查找法逐步缩小区间范围，当区间长度为1时，即找到了最终答案。

每次二分查找就是先算一个mid值，这个mid就是代表当前猜测的答案，然后模拟一下划分子数组的过程，可以得到用这个mid值会一共得到的子区间数cnt，然后比较cnt和m的关系，来更新区间范围。

本题跟1014 875 非常类似。

class Solution(object):
    def splitArray(self, nums, m):
        """
        :type nums: List[int]
        :type m: int
        :rtype: int
        """
        # max(nums), sum(nums)
        if len(nums) == m:
            return max(nums)
        
        lo, hi = max(nums), sum(nums)
        while(lo < hi):
            mid = (lo + hi) // 2 # 最大和
            
            #------以下在模拟划分子数组的过程
            temp, cnt = 0, 1
            for num in nums:
                temp += num
                # cnt += 1
                if temp > mid:#说明当前这个子数组的和已经超过了允许的最大值mid，需要把当前元素放在下一个子数组里
                    temp = num
                    cnt += 1
            # print temp, cnt, mid
            #------以上在模拟划分子数组的过程
            
            if cnt > m: #说明分出了比要求多的子数组，多切了几刀，说明mid应该加大，这样能使子数组的个数减少
                lo = mid + 1
            elif cnt <= m:
                hi = mid

                
        return lo
```

##  235. <a name='-1'></a>44. 通配符匹配

```py
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        m, n = len(s), len(p)

        dp = [[False] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = True
        for i in range(1, n + 1):
            if p[i - 1] == '*':
                dp[0][i] = True
            else:
                break
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if p[j - 1] == '*':
                    dp[i][j] = dp[i][j - 1] | dp[i - 1][j]
                elif p[j - 1] == '?' or s[i - 1] == p[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                
        return dp[m][n]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        def allStars(st: str, left: int, right: int) -> bool:
            return all(st[i] == '*' for i in range(left, right))
        
        def charMatch(u: str, v: str) -> bool:
            return u == v or v == '?'

        sRight, pRight = len(s), len(p)
        while sRight > 0 and pRight > 0 and p[pRight - 1] != '*':
            if charMatch(s[sRight - 1], p[pRight - 1]):
                sRight -= 1
                pRight -= 1
            else:
                return False
        
        if pRight == 0:
            return sRight == 0
        
        sIndex, pIndex = 0, 0
        sRecord, pRecord = -1, -1
        while sIndex < sRight and pIndex < pRight:
            if p[pIndex] == '*':
                pIndex += 1
                sRecord, pRecord = sIndex, pIndex
            elif charMatch(s[sIndex], p[pIndex]):
                sIndex += 1
                pIndex += 1
            elif sRecord != -1 and sRecord + 1 < sRight:
                sRecord += 1
                sIndex, pIndex = sRecord, pRecord
            else:
                return False

        return allStars(p, pIndex, pRight)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wildcard-matching/solution/tong-pei-fu-pi-pei-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 思路:

**思路一:** 利用两个指针进行遍历。

在代码里解释.

时间复杂度为:$O(mn)$

**思路二:** 动态规划

dp[i][j]表示s到i位置,p到j位置是否匹配!

初始化:

dp[0][0]:什么都没有,所以为true
第一行dp[0][j],换句话说,s为空,与p匹配,所以只要p开始为*才为true
第一列dp[i][0],当然全部为False
动态方程:

如果(s[i] == p[j] || p[j] == "?") && dp[i-1][j-1] ,有dp[i][j] = true

如果p[j] == "*" && (dp[i-1][j] = true || dp[i][j-1] = true) 有dp[i][j] = true

​ note:

​ dp[i-1][j],表示*代表是空字符,例如ab,ab*

​ dp[i][j-1],表示*代表非空任何字符,例如abcd,ab* # 附上自顶向下方法

关注我的知乎专栏,了解更多解题技巧,一起进步!

​​

## 代码:

思路一

class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        i = 0
        j = 0
        start = -1
        match = 0
        while i < len(s):
            # 一对一匹配,匹配成功一起移
            if j < len(p) and (s[i] == p[j] or p[j] == "?"):
                i += 1
                j += 1
            # 记录p的"*"的位置,还有s的位置
            elif j < len(p) and p[j] == "*":
                start = j
                match = i
                j += 1
            # j 回到 记录的下一个位置
            # match 更新下一个位置
            # 这不代表用*匹配一个字符
            elif start != -1:
                j = start + 1
                match += 1
                i = match
            else:
                return False
         # 将多余的 * 直接匹配空串
        return all(x == "*" for x in p[j:])

思路2

class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        sn = len(s)
        pn = len(p)
        dp = [[False] * (pn + 1) for _ in range(sn + 1)]
        dp[0][0] = True
        for j in range(1, pn + 1):
            if p[j - 1] == "*":
                dp[0][j] = dp[0][j - 1]

        for i in range(1, sn + 1):
            for j in range(1, pn + 1):
                if (s[i - 1] == p[j - 1] or p[j - 1] == "?"):
                    dp[i][j] = dp[i - 1][j - 1]
                elif p[j - 1] == "*":
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
        return dp[-1][-1]
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        import functools

        @functools.lru_cache(None)
        def dfs(i, j):
            if j == len(p): return i == len(s)
            if i < len(s) and s[i] == p[j] and dfs(i + 1, j + 1):
                return True
            if i < len(s) and p[j] == "?" and dfs(i + 1, j + 1): return True
            if p[j] == "*":
                # * 依次表示多个, 一个, 零个字符
                if (i < len(s) and (dfs(i + 1, j) or dfs(i + 1, j + 1))) or dfs(i, j + 1) : return True
            return False
        
        return dfs(0, 0)

记忆化搜索，就是得错几次才能考虑完全、

class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 怎么处理*的情况

        @lru_cache()
        def dfs(i, j):
            if i == len(s) and (j == len(p) or (p[j:].count('*') == len(p) - j)):
                return True 
            
            if j >= len(p) or i >= len(s):
                return False

            if p[j] == '*':
                return dfs(i+1, j) or dfs(i+1, j+1) or dfs(i, j+1)
            
            if p[j] == '?':
                return dfs(i+1, j+1)
            
            if p[j] == s[i]:
                return dfs(i+1, j+1)
            
            return False
        
        return dfs(0, 0)
```


##  236. <a name='-1'></a>18. 四数之和

```py
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        quadruplets = list()
        if not nums or len(nums) < 4:
            return quadruplets
        
        nums.sort()
        length = len(nums)
        for i in range(length - 3):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target:
                break
            if nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target:
                continue
            for j in range(i + 1, length - 2):
                if j > i + 1 and nums[j] == nums[j - 1]:
                    continue
                if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target:
                    break
                if nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target:
                    continue
                left, right = j + 1, length - 1
                while left < right:
                    total = nums[i] + nums[j] + nums[left] + nums[right]
                    if total == target:
                        quadruplets.append([nums[i], nums[j], nums[left], nums[right]])
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        right -= 1
                    elif total < target:
                        left += 1
                    else:
                        right -= 1
        
        return quadruplets

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
八个月前，这道题差点把我逼疯

八个月后，我终于战胜了它

class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        d={}
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                d.setdefault(nums[i]+nums[j],[]).append((i,j))
        result=set()
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                for a,b in d.get(target-nums[i]-nums[j],[]):
                    temp={i,j,a,b}
                    if len(temp)==4:
                        result.add(tuple(sorted(nums[t] for t in temp)))
        return result

Python：

# 双指针法
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        
        nums.sort()
        n = len(nums)
        res = []
        for i in range(n):
            if i > 0 and nums[i] == nums[i - 1]: continue
            for k in range(i+1, n):
                if k > i + 1 and nums[k] == nums[k-1]: continue
                p = k + 1
                q = n - 1

                while p < q:
                    if nums[i] + nums[k] + nums[p] + nums[q] > target: q -= 1
                    elif nums[i] + nums[k] + nums[p] + nums[q] < target: p += 1
                    else:
                        res.append([nums[i], nums[k], nums[p], nums[q]])
                        while p < q and nums[p] == nums[p + 1]: p += 1
                        while p < q and nums[q] == nums[q - 1]: q -= 1
                        p += 1
                        q -= 1
        return res
# 哈希表法
class Solution(object):
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        # use a dict to store value:showtimes
        hashmap = dict()
        for n in nums:
            if n in hashmap:
                hashmap[n] += 1
            else: 
                hashmap[n] = 1
        
        # good thing about using python is you can use set to drop duplicates.
        ans = set()
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    val = target - (nums[i] + nums[j] + nums[k])
                    if val in hashmap:
                        # make sure no duplicates.
                        count = (nums[i] == val) + (nums[j] == val) + (nums[k] == val)
                        if hashmap[val] > count:
                            ans.add(tuple(sorted([nums[i], nums[j], nums[k], val])))
                    else:
                        continue
        return ans
```

##  237. <a name='-1'></a>405 【位运算😜】Convert a Number to Hexadecimal

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7ds?spm_id_from=333.999.0.0)

```py
三种方法

1.第一种库函数(汉明重量的题目也可以使用库函数)
2.第二种不用位运算😜，整除求余一顿操作，逆向取余，搞定
3.第三种使用位运算😜，把第二中的整除换做位移，求余换做与运算
详细思路看代码
代码

# 库函数作弊通过
class Solution:
    def toHex(self, num: int) -> str:
        return hex(num & 0xFFFFFFFF)[2:] # 0xFFFFFFFF 2 ^ 32 - 1
```

```py
学习大牛的思路，记下来慢慢
32位整数，每4位1个字节，一个字节转成16进制刚好是0—f之间的一个字符；最多需要转换8次，可能有几个“0”，最后去掉就是了。

直接 ans = []
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0:
            return "0"
        template = "0123456789abcdef"
        ans = []
        for _ in range(8):
            ans.append(template[num % 16])
            num //= 16
        ans.reverse()
        return "".join(ans).lstrip("0")

直接 result = ""

class Solution(object):
    def toHex(self, num):

        num = num & 0xffffffff
        result = ""
        lib = "0123456789abcdef"
        if num == 0:
            return "0"
        while num:
            result = lib[num % 16] + result # 一定要加在右边
            num //= 16

        return result

format的用法很多，值得深入学习

print((1 << 32) + (-32))
print(bin((1 << 32) + (-32)))
print(format(((1 << 32) + (-32)), '0o'))
print(format(((1 << 32) + (-32)), '0x'))
4294967264
0b11111111111111111111111111100000
37777777740
ffffffe0

class Solution:
    def toHex(self, num):

        if num < 0:
            num = (1 << 32) + num
        return format(num, '0x')
```

##  238. <a name='8.'></a>补充题8. 计算数组的小和


https://mp.weixin.qq.com/s/rMsbcUf9ZPhvfRoyZGW6HA

##  239. <a name='K-1'></a>863. All Nodes Distance K in Binary Tree

[花花酱](https://www.bilibili.com/video/BV14W411d7mz?spm_id_from=333.999.0.0)

```py
来个python的翻译代码，我越学越感觉啥都不会。

为什么要判断from节点，避免root搜到root.left再从root.left搜回root的情况。

记录父节点，相当于node多了一个属性，node.father, 但它是单独记录在TreeNode结构外面，功能是一样的。

这里注意root的father是None，避免哈希表的keyerror。

class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        nodemap = {root.val: None}
        def findParent(root):
            if root.left:
                nodemap[root.left.val] = root
                findParent(root.left)
            if root.right:
                nodemap[root.right.val] = root
                findParent(root.right)            
            
        def findAns(root, nodefrom, depth, k):
            if not root: return
            if depth == k:
                self.ans.append(root.val)
                return
            if root.left != nodefrom:
                findAns(root.left, root, depth + 1, k)
            if root.right != nodefrom:
                findAns(root.right, root, depth + 1, k)
            if nodemap[root.val] != nodefrom:
                findAns(nodemap[root.val], root, depth + 1, k)
            
        self.ans = []
        findParent(root)
        findAns(target, None, 0, k)
        
        return self.ans


这道题就是先把二叉树转化图,再用图的bfs,求得解

所以,这道题关键就是如何把树转化成图,不难直接看代码就可以理解.

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def distanceK(self, root, target, K):
        """
        :type root: TreeNode
        :type target: TreeNode
        :type K: int
        :rtype: List[int]
        """
        from collections import defaultdict
        graph = defaultdict(set)
        # 建图
        def dfs(root):
            if root.left :
                graph[root.val].add(root.left.val)
                graph[root.left.val].add(root.val)
                dfs(root.left)
            if root.right:
                graph[root.val].add(root.right.val)
                graph[root.right.val].add(root.val)
                dfs(root.right)
        dfs(root)
        #print(graph)
        cur = [target.val]
        visited ={target.val}
        while K:
            next_time = []
            while cur:
                tmp = cur.pop()
                for node in graph[tmp]:
                    if node not in visited:
                        visited.add(node)
                        next_time.append(node)
            K -= 1
            cur = next_time
        return cur
```

##  240. <a name='III-1'></a>337 House Robber III

[小明](https://www.bilibili.com/video/BV1WD4y1X7JQ?spm_id_from=333.999.0.0)

```py
# 补充一个Python的：

class Solution:
    def rob(self, root: TreeNode) -> int:
        def _rob(root):
            if not root: return 0, 0
            
            ls, ln = _rob(root.left)  # 前一项表示根节点偷，后一项表示根节点不偷
            rs, rn = _rob(root.right) # 前一项表示根节点偷，后一项表示根节点不偷
            
            return root.val + ln + rn, max(ls, ln) + max(rs, rn) # 前一项表示根节点偷，后一项表示根节点不偷

        return max(_rob(root))
# ls表示偷左子树能带来的最大收益，ln表示不偷左子树能带来的最大收益，rs、rn同理

# 这个解法好像有点厉害

# 从root开始抢起来，最大能抢到的两个可能： 抢root和不抢root

# - rob_root = max(rob_L + rob_R , no_rob_L + no_nob_R + root.val)
# - no_rob_root = rob_L + rob_R


# 这个递归写起来就很厉害了


# ```
class Solution(object):
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(root):
            if not root: return 0, 0
            rob_L, no_rob_L = dfs(root.left) # 前一项表示根节点偷，后一项表示根节点不偷
            rob_R, no_rob_R = dfs(root.right) # 前一项表示根节点偷，后一项表示根节点不偷
            return max(no_rob_R + no_rob_L + root.val , rob_L + rob_R), rob_L + rob_R # 前一项表示根节点偷，后一项表示根节点不偷
        return dfs(root)[0]

class Solution:
    def rob(self, root: TreeNode) -> int:
        result = self.rob_tree(root)
        return max(result[0], result[1])
    
    def rob_tree(self, node):
        if node is None:
            return (0, 0) # (偷当前节点金额，不偷当前节点金额)
        left = self.rob_tree(node.left)
        right = self.rob_tree(node.right)
        val1 = node.val + left[1] + right[1] # 偷当前节点，不能偷子节点
        val2 = max(left[0], left[1]) + max(right[0], right[1]) # 不偷当前节点，可偷可不偷子节点
        return (val1, val2)

class Solution:
    def rob(self, root: TreeNode) -> int:
        if root is None:
            return 0
        if root.left is None and root.right  is None:
            return root.val
        # 偷父节点
        val1 = root.val
        if root.left:
            val1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            val1 += self.rob(root.right.left) + self.rob(root.right.right)
        # 不偷父节点
        val2 = self.rob(root.left) + self.rob(root.right)
        return max(val1, val2)
```


# 13 day (得分 = 1分) 90

##  241. <a name='-1'></a>166. Fraction to Recurring Decimal

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7PE?spm_id_from=333.999.0.0)

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # ----------情况一：没有余数----------
        if numerator % denominator == 0:
            return str(numerator // denominator)
        # ----------情况一：没有余数----------


        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        s = []

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if (numerator < 0) != (denominator < 0):
            s.append('-')
        # ----------------得到负数----------------
        # ----------------得到负数----------------


        # 整数部分
        numerator = abs(numerator)
        denominator = abs(denominator)
        integerPart = numerator // denominator
        s.append(str(integerPart))
        s.append('.')

        # 小数部分
        indexMap = {}
        remainder = numerator % denominator
        while remainder and remainder not in indexMap:
            indexMap[remainder] = len(s) 

            # 这里需要一个计数器，s的长度递增，所以用len(s)
            # 解法二中：
            # i = 0
            # i += 1
            # 也是可以的。
            # len(s) 可以直接指向 insertIndex-插入位置

            print("余数remainder: ",indexMap.keys())
            remainder *= 10
            s.append(str(remainder // denominator))
            remainder %= denominator
        if remainder:  # 有循环节
            insertIndex = indexMap[remainder]
            s.insert(insertIndex, '(') #左侧插入
            s.append(')')

        return ''.join(s)
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
```

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        dic = {}
        res = []

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if numerator*denominator<0:
            sign = "-"
        else:
            sign = ""
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator = abs(numerator)
        denominator = abs(denominator)
        intPart,res = divmod(numerator, denominator)


        # ----------情况一：没有余数----------
        if res==0:
            return sign + str(intPart)
        # ----------情况一：没有余数----------
        
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        res.append(str(intPart))
        res.append(".")

        dic[res]= len(res) # 是 2
        while res!=0:
            intPart,res = divmod(10*res,denominator)
            res.append(str(intPart))
            # 如果余数出现在字典中，加上（）并返回
            if res in dic:
                res.insert(dic[res],"(") #左侧插入
                res.append(")")     #右侧插入
                return sign + "".join(res)
            # 继续记录余数和(索引位置
            
            dic[res] = len(res) # i+=1
        # 如果余数为0
        return sign + "".join(res) 
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # 处理整数部分
        ans = ""

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if numerator * denominator < 0:
            ans += "-"
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart, res = divmod(numerator, denominator)
        # ans += f"{q}"
        ans += str(intPart)


        # ----------情况一：没有余数----------
        if 0 == res:
            return ans
        # ----------情况一：没有余数----------

        
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        ans += '.'
        # 小数部分：除法发现循环节
        index = len(ans)  # 小数点后一个位置
        numerator = res * 10  # 被除数增加十倍
        dic = {numerator: index}
        while True:
            intPart, res = divmod(numerator, denominator)
            ans += str(intPart)
            if res == 0:
                break
            numerator = res * 10
            if numerator in dic:  # 发现循环节
                return ans[:dic[numerator]] + f"({ans[dic[numerator]:]})" # 直接加括号（）
            dic[numerator] = index + 1  # 新被除数位置
            index += 1
        return ans
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        sign = "" if numerator * denominator >= 0 else "-"
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart = numerator // denominator

        # ----------情况一：没有余数----------
        if numerator % denominator == 0: return sign + str(intPart)
        # ----------情况一：没有余数----------

        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        res, dic, index = numerator % denominator, {}, 3
        ans = [sign, str(intPart), "."]
        while res:
            if res not in dic:
                dic[res] = index
            else:
                ans.insert(dic[res], "(")
                ans.append(")")
                break
            res *= 10
            ans.append(str(res // denominator))
            res %= denominator
            index += 1
        return "".join(ans)
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
```

##  242. <a name='08.12.'></a>面试题 08.12. 八皇后

##  243. <a name='-1'></a>73. Set Matrix Zeroes

[小梦想家](https://www.bilibili.com/video/BV1W7411T7rX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1X64y1Y7kG?spm_id_from=333.999.0.0)

```py
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        tmp = []
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == 0:
                    tmp.append([i,j])
        for r,c in tmp:
            for j in range(len(matrix[0])):
                matrix[r][j] = 0
            for i in range(len(matrix)):
                matrix[i][c] = 0
        return matrix
```

```scala

/**
* my first commitment
* time complexity: O(N * M)
* space complexity: O(N + M)
*/
object Solution1 {
    import collection.mutable
    def setZeroes(matrix: Array[Array[Int]]): Unit = {
      val cols = mutable.Set.empty[Int]
      val rows = mutable.Set.empty[Int]
      
      for (i <- matrix.indices; j <- matrix(i).indices; if matrix(i)(j) == 0) {
        rows += i
        cols += j
      }
      
      rows.foreach(row => matrix(row).indices.foreach(matrix(row)(_) = 0))
      cols.foreach(col => matrix.indices.foreach(matrix(_)(col) = 0))
    }
}



/**
* using first column and row to record cell to be set to zero
* memo:
*  1. we should set first columns and first row in the last, otherwise we cannot distinguish the zero between set by us and originally is
* time complexity: O(NM)
* space complexity: O(1)
*/
object Solution2 {
    import collection.mutable
    def setZeroes(matrix: Array[Array[Int]]): Unit = {
      var rowZero = false
      var colZero = false
      
      /**
      * using first row and first column as flag 
      */
      for (i <- matrix.indices; j <- matrix(i).indices; if matrix(i)(j) == 0) {
        if (i == 0) rowZero = true
        if (j == 0) colZero = true
        matrix(i)(0) = 0
        matrix(0)(j) = 0
      }
    
      /**
      * set one row to zero except first cell
      */
      (1 until matrix.length).foreach {
        case rowIdx if matrix(rowIdx)(0) == 0 => matrix(rowIdx).indices.foreach(matrix(rowIdx)(_) = 0)
        case _ =>
      }
      
      /**
      * set one column to zero except first cell
      */
      (1 until matrix(0).length).foreach {
        case colIdx if matrix(0)(colIdx) == 0 => matrix.indices.foreach(matrix(_)(colIdx) = 0)
        case _ => 
      }
      
      /**
      * set first column and first row to zero if true
      */
      if(rowZero) matrix(0).indices.foreach(matrix(0)(_) = 0)
      if(colZero) matrix.indices.foreach(matrix(_)(0) = 0)
      
    }
}
```

##  244. <a name='Offer46.'></a>剑指 Offer 46. 把数字翻译成字符串

##  245. <a name='II-1'></a>503 【栈】Next Greater Element II

[哈哈哈](https://www.bilibili.com/video/BV197411L77N?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1k5411t7Pa?spm_id_from=333.999.0.0)


```py
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = nums[:]
        stack = []
        for idx, cur in sorted(enumerate(nums),key = lambda x: x[1]):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            stack.append(idx)
        
        while stack:
            res[stack[-1]] = -1
            stack.pop()
        
        return res
        
# 哭，我又理解错题目了
# 输入：
# [5,4,3,2,1]
# 输出：
# [-1,5,4,3,2]
# 预期结果：
# [-1,5,5,5,5]
```

```py
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = nums[:]
        stack = []
        # 双倍nums大法好
        for idx, cur in enumerate(nums + nums):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            if idx < len(nums): # 易错点：append(idx)是有条件的
                stack.append(idx)
        
        while stack:
            res[stack[-1]] = -1
            stack.pop()
        
        return res

更简单的写法:

class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = [-1] * len(nums)
        stack = []
        # 双倍nums大法好
        for idx, cur in enumerate(nums + nums):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            if idx < len(nums): # 易错点：append(idx)是有条件的
                stack.append(idx)
        return res


```

##  246. <a name='-1'></a>763 Partition Labels

[小明](https://www.bilibili.com/video/BV1Ca4y177LW?spm_id_from=333.999.0.0)

##  247. <a name='K-1'></a>340. 至多包含 K 个不同字符的最长子串

##  248. <a name='-1'></a>130. 【🍒并查集】Surrounded Regions 130-被围绕的区域

[花花酱](https://www.bilibili.com/video/BV1dE411f7U4?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV18y4y1j7JH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411k7TH?spm_id_from=333.999.0.0)


```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        f = {}
        def find(x):
            f.setdefault(x,x)
            if f[x]!=x:
                f[x] = find(f[x])
            return f[x]
        def union(x,y):
            f[find(y)] = find(x)
        if not board or not board[0]:
            return
        row,col = len(board),len(board[0])
        dummy = row*col
        for i in range(row):
            for j in range(col):
                if board[i][j] == "O":
                    if i == 0 or i == row - 1 or j == 0 or j == col - 1:
                        union(i * col + j, dummy)
                    else:
                        for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                            if board[i + x][j + y] == "O":
                                union(i * col + j, (i + x) * col + (j + y))
                                
        for i in range(row):
            for j in range(col):
                if find(dummy) == find(i * col + j):
                    board[i][j] = "O"
                else:
                    board[i][j] = "X"
```


```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m = len(board)
        n = len(board[0])
        que = collections.deque()

        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1: # 易错点：m 和 n 不要写反了
                    if board[i][j] == 'O':
                        que.append((i,j))

        while que:
            x,y = que.popleft()
            board[x][y] = 'A'
            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                # 易错点：x+dx 和 x 不要写反了
                if 0 <= x+dx < m-1 and 0 <= y+dy < n-1 and board[x+dx][y+dy] == 'O': # 易错点：'O'不要写成0
                    board[x+dx][y+dy] = 'A'
                    que.append((x+dx,y+dy))

        for i in range(m):
            for j in range(n):
                # 易错点：== 和 = 不要写反了
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == 'A':
                    board[i][j] = 'O'

        return board
```

另一种写法

```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        n, m = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < n or not 0 <= y < m or board[x][y] != 'O':
                return
            
            board[x][y] = "A"
            dfs(x + 1, y)
            dfs(x - 1, y)
            dfs(x, y + 1)
            dfs(x, y - 1)
         
        for i in range(n):
            dfs(i, 0)
            dfs(i, m - 1)
        
        for i in range(m - 1):
            dfs(0, i)
            dfs(n - 1, i)
        
        for i in range(n):
            for j in range(m):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"
```


##  249. <a name='II-1'></a>117 Populating Next Right Pointers in Ea (可跳过)

[小明](https://www.bilibili.com/video/BV1np4y1r7fQ?spm_id_from=333.999.0.0)

看不懂，懵逼了

```py
# 看不懂，懵逼了

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        dummy = Node()
        dummy.next = root
        while dummy.next:
            curp = dummy.next
            dummy.next = None
            pre = dummy
            while curp:
                for cur in [curp.left, curp.right]:
                    if cur:
                        pre.next = cur
                        pre = cur
                curp = curp.next
        return root

# python 非递归方法，常数空间，从顶到下，逐层连接
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        first = root # left_most表示当前层的最左边节点
        while first: # 每次循环连接当前层的下一层
            dummy = pre = Node(0) # head表示下一层的虚拟头部
            cur = first
            while cur : # 遍历当前层，将下一层连接 
                if cur.left :
                    pre.next = cur.left
                    pre = pre.next
                if cur.right :
                    pre.next = cur.right
                    pre = pre.next
                cur = cur.next
            first = dummy.next
        return root
```


##  250. <a name='Offer07.'></a>剑指 Offer 07. 重建二叉树

##  251. <a name='K-1'></a>378-【最小堆🌵】有序矩阵中第K小的元素

[哈哈哈](https://www.bilibili.com/video/BV1mT4y1w7u2?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Zy4y127qr?spm_id_from=333.999.0.0)

```py
# 无脑暴力法一行版

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        return sorted(sum(matrix,[]))[k-1]
# 暴力pq一行
import heapq
class Solution(object):
    def kthSmallest(self, matrix, k):
        return heapq.nsmallest(k,sum(matrix,[]))[-1]
#  heapq一行
class Solution(object):
    def kthSmallest(self, matrix, k):
        return list(heapq.merge(*matrix))[k-1]

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        rec = sorted(sum(matrix, []))
        return rec[k - 1]

# 无脑暴力法优化版
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        l=heapq.nlargest(len(lis)-k+1,lis)
        return l[-1]
# 无脑暴力法
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        lis.sort()
        return lis[k-1]
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        n = len(matrix)
        pq = [(matrix[i][0], i, 0) for i in range(n)]
        heapq.heapify(pq)

        ret = 0
        for i in range(k - 1):
            num, x, y = heapq.heappop(pq)
            if y != n - 1:
                heapq.heappush(pq, (matrix[x][y + 1], x, y + 1))
        
        return heapq.heappop(pq)[0]
# binary search
# ```python
import bisect
class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k
        :rtype
        """
        l, r = matrix[0][0], matrix[-1][-1]
        while l <= r:
            mid = l + ((r - l) >> 2)
            if sum(bisect.bisect_right(row, mid) for row in matrix) < k:
                l = mid + 1
            else:
                r = mid - 1
        return l
```



##  252. <a name='Offer32-III.III'></a>剑指 Offer 32 - III. 从上到下打印二叉树 III

##  253. <a name='-1'></a>77. 组合

```py
class Solution:
    def combine(self, n, k):
            res = []
            path = []
            def backtrack(StartIndex):
                if len(path) == k:
                    res.append(path[:])
                    return
                for i in range(StartIndex, n+1):
                    path.append(i)
                    backtrack(i+1)
                    path.pop()
            backtrack(1)
            return res
```

##  254. <a name='-1'></a>528 Random Pick with Weight

[小明](https://www.bilibili.com/video/BV1UV411r7MK?spm_id_from=333.999.0.0)

##  255. <a name='-1'></a>279 【动态🚀规划 + 背包】Perfect Squares

[小明](https://www.bilibili.com/video/BV1r5411Y7MH?spm_id_from=333.999.0.0)

```py
# 动态🚀规划
        '''版本一，先遍历背包, 再遍历物品'''
        '''版本二， 先遍历物品, 再遍历背包'''
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10e5] * (n + 1)
        dp[0] = 0
        # 也可以 sqrt = floor(n**0.5) 
        sqrt = ceil(n**0.5) 
        for i in range(sqrt + 1): # 易错点：必须要 sqrt+1 比如输入：n = 1
            num = i**2
            for j in range(num, n + 1):
                if j >= num:
                    dp[j] = min(dp[j], dp[j-num] + 1) 
        return dp[-1]
```

##  256. <a name='-1'></a>257-二叉树的所有路径

[哈哈哈](https://www.bilibili.com/video/BV1rf4y1X7He?spm_id_from=333.999.0.0)

```py
class Solution:
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        def construct_paths(root, path):
            if root:
                path += str(root.val)
                if not root.left and not root.right:  # 当前节点是叶子节点
                    paths.append(path)  # 把路径加入到答案中
                else:
                    path += '->'  # 当前节点不是叶子节点，继续递归遍历
                    construct_paths(root.left, path)
                    construct_paths(root.right, path)

        paths = []
        construct_paths(root, '')
        return paths

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        paths = list()
        if not root:
            return paths

        node_queue = collections.deque([root])
        path_queue = collections.deque([str(root.val)])

        while node_queue:
            node = node_queue.popleft()
            path = path_queue.popleft()

            if not node.left and not node.right:
                paths.append(path)
            else:
                if node.left:
                    node_queue.append(node.left)
                    path_queue.append(path + '->' + str(node.left.val))
                
                if node.right:
                    node_queue.append(node.right)
                    path_queue.append(path + '->' + str(node.right.val))
        return paths

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python3 最好理解的递归实现

class Solution:
            
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root:
            return []
        if not root.left and not root.right:
            return [str(root.val)]
        paths = []
        if root.left:
            for i in self.binaryTreePaths(root.left):
                paths.append(str(root.val) + '->' + i)
        if root.right:
            for i in self.binaryTreePaths(root.right):
                paths.append(str(root.val) + '->' + i)
        return paths  
paths 递归每调用一次要创建一个以便给上一层遍历（叠加）
调用self.binaryTreePaths(root.left)得到的是左子树的全部路径，加入左子树为[1,2,3],那么得到的结果是[1,2],[1,3]两组，然后还要和根节点进行拼接，所以要用循环。
```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//Given a binary tree, return all root-to-leaf paths.
//
//Note: A leaf is a node with no children.
//
//Example:
//
//Input:
//
//1
///   \
//2     3
//\
//5
//
//Output: ["1->2->5", "1->3"]
//
//Explanation: All root-to-leaf paths are: 1->2->5, 1->3

package lc0257 {

  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def binaryTreePaths(root: TreeNode): List[String] = {
      val tmp = ArrayBuffer[Int]()
      val ret =ArrayBuffer[ArrayBuffer[Int]]()
      helper(root, tmp, ret)
      ret.toList.map({
        x=>x.mkString("->")
      })
    }

    def helper(node:TreeNode,tmp:ArrayBuffer[Int],ret:ArrayBuffer[ArrayBuffer[Int]]): Unit = {
      if (node==null) {
        return
      }

      tmp += node.value

      if (node.left == null && node.right==null) {
          ret += tmp.clone()
      } else {
        helper(node.left, tmp, ret)
        helper(node.right, tmp, ret)
      }
      tmp.remove(tmp.length-1)
    }
  }

  class Test extends BaseExtension {
    def init {
      val t1 = Tree.build(IndexedSeq("1","2 3","5 N N N"))
      println(Solution.binaryTreePaths(t1))
    }
    val name = "257 binary tree path"
  }
}

```

##  257. <a name='K-1'></a>692. Top K Frequent Words

[花花酱](https://www.bilibili.com/video/BV1Mt41137eL?spm_id_from=333.999.0.0)

##  258. <a name='Offer50.'></a>剑指 Offer 50. 第一个只出现一次的字符

##  259. <a name='II-1'></a>137 【位运算😜】Single Number II

[小明](https://www.bilibili.com/video/BV1Hv411B7rd?spm_id_from=333.999.0.0)

方法二：依次确定每一个二进制位

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ro27dupbn40.webp)

```py
细节：

需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，

那么可能会得到错误的答案。

这是因为「有符号整数类型」（即 int 类型）的第 31 个二进制位（即最高位）是补码意义下的符号位，对应着 -2^{31}

而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2^{31}

因此在某些语言（例如 Python ）中需要对最高位进行特殊判断。

时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围

空间复杂度：O(1)

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            total = sum((num >> i) & 1 for num in nums)
            if total % 3:
                # Python 这里对于最高位需要特殊判断
                if i == 31:
                    ans -= (1 << i)
                else:
                    ans |= (1 << i)
        return ans

这个解法看不懂，放弃：


时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围

空间复杂度：O(1)

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ones, twos = 0, 0
        for num in nums:
            ones = ones ^ num & ~ twos
            twos = twos ^ num & ~ ones
        return ones
```


##  260. <a name='21.'></a>补充题21. 字符串相减


# 14 day (得分 = 1分) 91

##  261. <a name='-1'></a>354. 俄罗斯套娃信封问题

##  262. <a name='II-1'></a>253. 会议室 II

##  263. <a name='-1'></a>628. 三个数的最大乘积

##  264. <a name='-1'></a>674. 最长连续递增序列

##  265. <a name='Offer57-II.s'></a>剑指 Offer 57 - II. 和为s的连续正数序列

##  266. <a name='-1'></a>315. Count of Smaller Numbers After Self

[花花酱](https://www.bilibili.com/video/BV1BW411C7TM?spm_id_from=333.999.0.0)

##  267. <a name='II-1'></a>107-Binary Tree Level Order Traversal II

[哈哈哈](https://www.bilibili.com/video/BV1eJ411z7d6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1yK411n76R?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qA411i7P4?spm_id_from=333.999.0.0)


```py
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res[::-1]
```

##  268. <a name='-1'></a>172-Factorial Trailing Zeroes

[哈哈哈](https://www.bilibili.com/video/BV1hE411n7TM?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7tS?spm_id_from=333.999.0.0)

```py
class Solution:
    def trailingZeroes(self, n: int) -> int:
        # Calculate n!
        factorial = 1
        for i in range(2, n + 1):
            factorial *= i
        # Count how many 0's are on the end.
        res = 0
        while factorial % 10 == 0:
            res += 1
            factorial //= 10
            
        return res



class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n > 0:
            n //= 5
            ans += n
        return ans


class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n >= 5:
            ans += n//5
            n = n//5
        return ans
```

```scala
object Solution {
    def trailingZeroes(n: Int): Int = {
        var count5 = 0
        var count2 = 0
        
        var temp = n
        while(temp>=5){
            count5 += temp/5
            temp = temp/5
        }
        
        temp = n
        while(temp>=2){
            count2 += temp/2
            temp = temp/2
        }
        
        if(count5 < count2) count5 else count2
    }
}

```

##  269. <a name='-1'></a>647 【动态🚀规划 + 回文🌈】Palindromic Substrings

[小明](https://www.bilibili.com/video/BV1g54y1h7uv?spm_id_from=333.999.0.0)

```py
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        res = 0
        # 这个部分其实可以不写：
        # for i in range(n):
        #     dp[i][i]=1
        for i in range(n):
            for j in range(i, -1, -1):
                if s[i] == s[j] and (i - j <= 1 or dp[i - 1][j + 1]):
                    dp[i][j] = 1
                    res += 1
        return res



class Solution(object):
    def countSubstrings(self, s):
        '''
        双指针太暴力了吧
        '''
        cnt = 0
        for i in range(0,len(s)):
            for j in range(i+1,len(s)+1):
                if s[i:j] == s[i:j][::-1]:
                    cnt += 1
        return cnt
```

```py
# Python3中心扩展法非常简洁代码
# 直接利用中心扩展法, 依次计数找到的所有的回文🌈子串即可；
# 无需在字符串中插入特殊字符, center中心位置从0到最后一个元素移动,
# 每次移动0.5, 表示移动到当前元素与下一个元素中间作为中心。
### 代码
from math import floor,ceil
class Solution:
    def countSubstrings(self, s: str) -> int:
        center = ans = 0
        while center < len(s):
            low, high = floor(center), ceil(center)
            while low >=0 and high < len(s) and s[low] == s[high]:
                low, high, ans = low-1, high+1, ans+1
            center += 0.5
        return ans
```

##  270. <a name='III-1'></a>260-【位运算😜】只出现一次的数字 III

[哈哈哈](https://www.bilibili.com/video/BV15Z4y1H7Sw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK411J7dN?spm_id_from=333.999.0.0)

难点在于只出现一次的数字不止一个，

但是刚好有且只有两个

```py

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        freq = Counter(nums)
        return [num for num, occ in freq.items() if occ == 1]

```

```py
复杂度分析

时间复杂度：O(n)，其中 n 是数组 nums 的长度。

空间复杂度：O(1)。

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        xorsum = 0
        for num in nums:
            xorsum ^= num # 找到这两个数的差异
        
        lsb = xorsum & (-xorsum) # 找到这两个数的差异的最后一位1
        type1 = type2 = 0
        for num in nums:
            if num & lsb: # 这里只能用 &，来决num & lsb == 100 or 0
                type1 ^= num
            else:
                type2 ^= num
        
        return [type1, type2]


思路, 先全部异或一次, 得到的结果, 考察其的某个非0位(比如最高非0位), 那么只出现一次的两个数中, 在这个位上一个为0, 一个为1, 由此可以将数组中的元素分成两部分,重新遍历, 求两个异或值
```

##  271. <a name='IV'></a>188 【动态🚀规划】Best Time to Buy and Sell Stock IV

[小明](https://www.bilibili.com/video/BV1f54y1k7cX?spm_id_from=333.999.0.0)

```py
# 背一背
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0

        buy = [prices[0]] * (k+1)
        sell = [0] * (k+1)
        for price in prices:
            for time in range(1,k+1): 
                # 对于每一个新来的价格，依 time 比较 and 更新
                buy[time-1] = min(buy[time-1],  price - sell[time-1])
                sell[time]  = max(sell[time], price - buy[time-1])
                # print('价格:',price,'次数:',time,'buy:',buy)
                # print('价格:',price,'次数:',time,'sell:',sell)
                
        return sell[k]


if __name__ == "__main__":   
	s = Solution()
	print(s.maxProfit(k = 2, prices = [3,2,6,5,0,3,-1,3]))

价格: 3 次数: 1 buy: [3, 3, '*']
价格: 3 次数: 1 sell: [0, 0, 0]
价格: 3 次数: 2 buy: [3, 3, '*']
价格: 3 次数: 2 sell: [0, 0, 0]
--------------------
价格: 2 次数: 1 buy: [2, 3, '*']
价格: 2 次数: 1 sell: [0, 0, 0]
价格: 2 次数: 2 buy: [2, 2, '*']
价格: 2 次数: 2 sell: [0, 0, 0]
--------------------
价格: 6 次数: 1 buy: [2, 2, '*']
价格: 6 次数: 1 sell: [0, 4, 0]
价格: 6 次数: 2 buy: [2, 2, '*']
价格: 6 次数: 2 sell: [0, 4, 4]
--------------------
价格: 5 次数: 1 buy: [2, 2, '*']
价格: 5 次数: 1 sell: [0, 4, 4]
价格: 5 次数: 2 buy: [2, 1, '*']
价格: 5 次数: 2 sell: [0, 4, 4]
--------------------
价格: 0 次数: 1 buy: [0, 1, '*']
价格: 0 次数: 1 sell: [0, 4, 4]
价格: 0 次数: 2 buy: [0, -4, '*']
价格: 0 次数: 2 sell: [0, 4, 4]
--------------------
价格: 3 次数: 1 buy: [0, -4, '*']
价格: 3 次数: 1 sell: [0, 4, 4]
价格: 3 次数: 2 buy: [0, -4, '*']
价格: 3 次数: 2 sell: [0, 4, 7]
--------------------
价格: -1 次数: 1 buy: [-1, -4, '*']
价格: -1 次数: 1 sell: [0, 4, 7]
价格: -1 次数: 2 buy: [-1, -5, '*']
价格: -1 次数: 2 sell: [0, 4, 7]
--------------------
价格: 3 次数: 1 buy: [-1, -5, '*']
价格: 3 次数: 1 sell: [0, 4, 7]
价格: 3 次数: 2 buy: [-1, -5, '*']
价格: 3 次数: 2 sell: [0, 4, 8]
--------------------
8


```




```scala
/**
* chosen solution
* dynamic programming
* memo 
*    1: using an 3-dim array to record previous state
*     dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's restrictions
*  space complexity: O(K),  worst case: O(N)N
*/ 
object Solution0 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
/**
* my first commitment
* dynamic programming
* memo 
*    1: using an 3-dim array to record all previous state
*         dp[state index][k times transaction][buy or sell]
*     dp definition: dp[i][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's constraint
*/
object Solution1 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum
    val profits = Array.ofDim[Int](prices.length, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val ii = (i + prices.length - 1) % prices.length
      profits(i)(j)(1) = profits(ii)(j)(1)  max ( profits(ii)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(i)(j)(0) = profits(ii)(j)(0)  max ( profits(ii)(j - 1)(1) - prices(i)) // buy
      else
        profits(i)(j)(0) = profits(ii)(j)(0)  max  - prices(i) // buy
    }

    profits(prices.length - 1).map(_.max).max
  }
}

/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/

object Solution1-2 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum


    val profits = Array.ofDim[Int](2, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val currentI = (i + 1) % 2
      val preciousI = i % 2
      profits(currentI)(j)(1) = profits(preciousI)(j)(1)  max ( profits(preciousI)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max ( profits(preciousI)(j - 1)(1) - prices(i)) // buy
      else
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max  - prices(i) // buy
    }
    profits(prices.length % 2).map(_.max).max // prices.length % 2: decide the newest status index
  }

  private def debugProfits(profits: Array[Array[Array[Int]]]): Unit = {
        profits.zipWithIndex.foreach{
          case (p, i) =>
            println(s"status: $i")
            p.zipWithIndex.foreach{
            case (pp, j) =>
                println(s"transaction $j: hold: ${pp(0)}, sell: ${pp(1)}")
          }
            println(" ")
        }
  }
}
/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/
object Solution1-3 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
```

##  272. <a name='Offer35.'></a>剑指 Offer 35. 复杂链表的复制

##  273. <a name='-1'></a>12. Integer to Roman

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Wf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hN411Q7ka?spm_id_from=333.999.0.0)

```py
# 这个写起来超级简单！
# NO BUG
class Solution:
    def intToRoman(self, num: int) -> str:
        strlist = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        numlist = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        res = ''
        for i in range(len(numlist)):
            while num >= numlist[i]:
                num -= numlist[i]
                res = res + strlist[i]
        return res
```

```py
# 其他方法
class Solution:

    VALUE_SYMBOLS = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]
    print(type(VALUE_SYMBOLS))
    def intToRoman(self, num: int) -> str:
        roman = list()
        for value, symbol in Solution.VALUE_SYMBOLS:
            while num >= value:
                print("-"*20)
                print(num)
                num -= value
                roman.append(symbol)
                print(roman)
            if num == 0:
                break
        return "".join(roman)
```

```scala
package com.zhourui.leetcode

//class Solution {
//  public:
//    string intToRoman(int num) {
//      vector<int> t1{1000,900,500,400,100,90,50,40,10,9,5,4,1};
//      vector<string> t2{"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
//      string ret="";
//      for (int i=0;i<t1.size();i++) {
//      if (num>=t1[i]) {
//      int c = num/t1[i];
//      for (int j=0;j<c;j++) {
//      ret+=t2[i];
//    }
//      num=num%t1[i];
//    } else if (num==0) {
//      break;
//    }
//    }
//      return ret;
//    }
//};


//object Solution {
//  case class RomanNumber(decValue: Int, romanStr: String)
//  val numbers = Seq(
//    RomanNumber(1000, "M"),
//    RomanNumber(900, "CM"),
//    RomanNumber(500, "D"),
//    RomanNumber(400, "CD"),
//    RomanNumber(100, "C"),
//    RomanNumber(90, "XC"),
//    RomanNumber(50, "L"),
//    RomanNumber(40, "XL"),
//    RomanNumber(10, "X"),
//    RomanNumber(9, "IX"),
//    RomanNumber(5, "V"),
//    RomanNumber(4, "IV"),
//    RomanNumber(1, "I")
//  )
//  def intToRoman(num: Int): String = {
//    def loop(num:Int, romans: Seq[RomanNumber]): String = {
//      romans match {
//        case RomanNumber(x, romanStr) :: _ if x < num => romanStr + loop(num-x, romans)
//        case RomanNumber(x, romanStr) :: _ if x == num => romanStr
//        case RomanNumber(x, _) :: tail if x > num => loop(num, tail)
//      }
//    }
//    loop(num, numbers)
//  }
//}
package lc0012_integertoroman {
  object Solution {
    case class RomanNumber(s:String, i: Int)
    def intToRoman(num: Int): String = {
      val numbers:Seq[RomanNumber] = Seq(
        RomanNumber("M",1000),
        RomanNumber("CM",900),
        RomanNumber("D",500),
        RomanNumber("CD",400),
        RomanNumber("C",100),
        RomanNumber("XC",90),
        RomanNumber("L",50),
        RomanNumber("XL",40),
        RomanNumber("X",10),
        RomanNumber("IX",9),
        RomanNumber("V",5),
        RomanNumber("IV",4),
        RomanNumber("I",1)
      )
      // 很巧妙 利用seq的head 和tail 递归调用
      // :: 相当于拼接

      def loop(num:Int, romans:Seq[RomanNumber]): String = {
        romans match {
          case RomanNumber(romanStr, v) :: lst if v == num => romanStr
          case RomanNumber(romanStr, v) :: lst if v < num => romanStr+loop(num-v,romans)
          case RomanNumber(romanStr, v) :: tail => loop(num,tail)
        }
      }
      loop(num, numbers)
    }
  }
}

```


##  274. <a name='-1'></a>386

```py
class Solution:
    def lexicalOrder(self, n):
        def dfs(num):
            if num > n:
                return
            ans.append(num)
            for nxt in range(num * 10, num * 10 + 10):
                dfs(nxt)

        ans = []
        for num in range(1, 10):
            dfs(num)
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(i: int = 1) -> None:
            if i > n:
                return
            for j in range(i, min(n + 1, (10 if i < 10 else i + 10))):
                ans.append(j)
                dfs(j * 10)
        ans = []
        dfs()
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(rec, i, n):
            if i > n: return -1
            rec.append(i);
            child = i * 10
            for j in range(10):
                if dfs(rec, child+j, n) == -1:break
            return
        rec = []
        for i in range(1, 10):
            dfs(rec, i, n)
        return rec
```

```py
class Solution:
    def lexicalOrder(self, n):
        return sorted(list(range(1,n+1)),key=lambda x:str(x))

class Solution:
    def lexicalOrder(self, n):
        return [int(j) for j in sorted([str(i) for i in range(1, n + 1)])]

# 字符串排序

class Solution:
    def lexicalOrder(self, n):
        l = sorted([str(i) for i in range(1, n + 1)])
        return [int(i) for i in l]
```

```py
class Solution:
    def lexicalOrder(self, n):
        orders = []
        stack = [(1, 8)]
        while len(stack) > 0:
            orders.append(stack[-1][0])
            (last, step) = stack.pop()
            if last+1 <= n and step > 0:
                stack.append((last+1, step-1))
            if last*10 <= n:
                stack.append((last*10, 9))
        return orders

class Solution:
    def lexicalOrder(self, n):
        ans = []
        num = 1
        while len(ans) < n:
            while num <= n:  # 不断进入下一层
                ans.append(num)
                num *= 10
            while num % 10 == 9 or num > n:  # 不断返回上一层
                num //= 10
            num += 1  # 遍历该层下一个数
        return ans

class Solution(object):
    def lexicalOrder(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        res = []
        cur = 1
        for i in range(n):
            res.append(cur)
            if (cur * 10 <= n):
                cur *= 10
            elif cur + 1 <= n and (cur + 1) % 10 != 0:
                cur += 1
            else:
                while (cur/10) % 10 == 9:
                    cur /= 10
                cur = cur / 10 + 1
        return res
```

##  275. <a name='-1'></a>752. Open the Lock

[花花酱](https://www.bilibili.com/video/BV1NW411y74z?spm_id_from=333.999.0.0)

##  276. <a name='K-1'></a>395 Longest Substring with At Least K

[小明](https://www.bilibili.com/video/BV1hD4y1X7rq?spm_id_from=333.999.0.0)

##  277. <a name='-1'></a>231. 【位运算😜】Power of Two

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rV411r7AL?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0


class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return bin(n).count('1') == 1 and n > 0



class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & -n) == n
```

```py
2147483648是整数范围内最大的2次幂，若n是2的幂，那么2147483648一定能整除它

class Solution(object):
    def isPowerOfTwo(self, n):
        return n > 0 and 2147483648 % n == 0

        
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        BIG = 1<<30 # 我试了一下，30,31,32都对
        return n > 0 and BIG % n == 0
```

```scala
/**
* time complexity  O(1)
*/
object Solution {
    def isPowerOfTwo(n: Int): Boolean = {
        n > 0 && (n & (n - 1) ) == 0
    }
}
```

##  278. <a name='-1'></a>977 Squares of a Sorted Array

[小明](https://www.bilibili.com/video/BV1EX4y1u7Mb?spm_id_from=333.999.0.0)

##  279. <a name='III-1'></a>437 【前缀和🎨】Path Sum III

[小明](https://www.bilibili.com/video/BV1tZ4y1M7JR?spm_id_from=333.999.0.0)

时间复杂度 O(n), 空间复杂度 O(n)

```py
def pathSum(self, root, sum):
    
    self.dicts = {0: 1}
    self.res = 0
    def helper(root, prefix_sum, sum):
        if not root:
            return 0
            
        prefix_sum += root.val
        
        if prefix_sum - sum in self.dicts:
            self.res += self.dicts[prefix_sum - sum]
            
        
        self.dicts[prefix_sum] = self.dicts.get(prefix_sum, 0) + 1
        
        helper(root.left, prefix_sum, sum)
        
        helper(root.right, prefix_sum, sum)
        
        # Note: 回到上一层时, 需要将当前的前缀和对应的路径数目减1      
        self.dicts[prefix_sum] -= 1
    
    helper(root, 0, sum)
    return res    
```

##  280. <a name='-1'></a>617. 合并二叉树


# 15 day (得分 = 1分) 92

##  281. <a name='k'></a>60. 第k个排列

##  282. <a name='strStr'></a>28-Implement str

[哈哈哈](https://www.bilibili.com/video/BV1eL411n7YS?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1BJ41117d6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1UK411K7zB?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411i7cG?spm_id_from=333.999.0.0)

解法一：直接用.index()

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "":
            return 0
        if needle in haystack:
            return haystack.index(needle)
        else:
            return -1
```

解法二：在对整个needle字符串比较

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        for i in range(len(haystack)-len(needle)+1):
            if haystack[i:i+len(needle)] == needle:
                return i 
        return -1
```

```scala
object Solution {
    def strStr(haystack: String, needle: String): Int = {
        if(needle.isEmpty){
            0
        }else if(haystack.isEmpty){
            -1
        }else{
            var needleLength = needle.length
            var head = 0
            var end = head + needleLength
            var flag = true
            
            while(flag && (end <= haystack.length)){
                if(needle.equals(haystack.substring(head, end))){
                    flag = false
                }else{
                    head += 1
                    end += 1
                }
            }
            
            if(flag) -1 else head
        }
    }
}

```

##  283. <a name='-1'></a>204-Count Primes

[哈哈哈](https://www.bilibili.com/video/BV167411w7Sf?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7cV?spm_id_from=333.999.0.0)

```py
# 埃氏筛代码重点理解一下j从i*i开始吧，

# 因为计算i*i之前就计算了i*2，i*3...,i*(i-1)。 

# 这题搜到一个非常牛逼的算法,叫做厄拉多塞筛法. 

# 比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,

# 然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,

# 然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,

# 再把5所有的倍数划去.以此类推.

# 代码的实现上用了非常好的技巧:

# 即i是从(2,int(n**0.5)+1)而非(2,n).这个技巧是可以验证的,

# 比如说求9以内的质数个数,那么只要划掉sqrt(9)以内的质数倍数,

# 剩下的即全为质数. 所以在划去倍数的时候也是从i*i开始划掉,而不是i+i.

class Solution:
    def countPrimes(self, n) -> int:
        if n < 3:
            return 0     
        else:
            # 首先生成了一个全部为1的列表
            isPrime = [1] * n
            # 因为0和1不是质数,所以列表的前两个位置赋值为0
            isPrime[0],isPrime[1] = 0,0
             # 此时从index = 2开始遍历,output[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引
             # 全部赋值为0. 此时output[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推.
            for i in range(2,int(n**0.5)+1): 
                if isPrime[i] == 1:
                    isPrime[i*i:n:i] = [0] * len(isPrime[i*i:n:i])
         # 最后output中的数字1表明该位置上的索引数为质数,然后求和即可.
        return sum(isPrime)

import math
from math import sqrt
class Solution(object):
    def countPrimes(self, n):
        isprime = [1]*n
        for i in range(2,int(sqrt(n))+1):
            if isprime[i]:
                for j in range(i*i,n,i):
                    isprime[j] = 0
        count = 0
        for i in range(2,n):
            if isprime[i]:count += 1
        return count

# 这个解法真是太赞了!又学到了很多~~~ 和大家分享一下
class Solution(object):
    def countPrimes(self, n):

        isPrime = [1 for i in range(n)]

        i = 2
        while i * i < n:
        	if isPrime[i]:
        		j = i * i 
        		while j < n :
        			isPrime[j] = 0
        			j += i
        	i += 1

        return sum(isPrime[2:])
```

```scala
object Solution {
    def countPrimes(n: Int): Int = {
        
        //Sieve of Eratosthenes
        
        var primeArray = Array.fill(n)(false)
        (2 until n).map(i => primeArray(i) = true)
        
        //We need to check for all numbers i, where i < sqrt(n)
        //To avoid doing sqrt operation again & again (since its expensive)
        //We can do i*i < n
        
        var i =2
        while(i*i < n){
            if(primeArray(i)){
                var j = i*i
                while(j < n){
                    primeArray(j) = false
                    j += i //because we are only checking multiple of i for each i in iteration
                }
            }
            i+=1
        }
        
        primeArray.filter(x => x).length
    }
}

```


##  284. <a name='Offer65.'></a>剑指 Offer 65. 不用加减乘除做加法

##  285. <a name='-1'></a>416. 【动态🚀规划 + 背包 + dfs(startI)无for循环】Partition Equal Subset Sum

####  1.201.1. <a name='494'></a>相似题目：494题

[花花酱](https://www.bilibili.com/video/BV1AW411y7So?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oZ4y1G7QY?spm_id_from=333.999.0.0)

“动态🚀规划” 的解法

```py
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 2:
            return False
        
        total = sum(nums)
        if total % 2 != 0:
            return False
        
        target = total // 2
        dp = [True] + [False] * target
        for i, num in enumerate(nums):
            for j in range(target, num - 1, -1):
                dp[j] |= dp[j - num]
                # dp[j] = dp[j] or dp[j-num]
        
        return dp[target]

根据494题修改的动态规划：

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        # 求得新的目标
        sums = sum(nums)
        # 注意，需要排除掉一些特殊状况
        if sums % 2 == 1: return False
        bagSize = sums // 2
        # 构建dp，numLen在外围
        dp = [0] * (bagSize+1)
        # 赋值，dp的第一个元素
        dp[0] = 1
        for num in nums:
            for j in range(bagSize,num-1,-1):
                dp[j] += dp[j-num] # 对于没有当前num时的case + 有了num时bagSize-num的cas
        # 含义就是：
        # 对于1个num，bagsize的填满情况
        # 对弈2个num，bagsize的填满情况
        return dp[-1] != 0
```

```py
# python递归...

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        # @lru_cache(None)
        def dp(i,N):                                #dp(i,N)返回nums[0...i]中且当前和为N的状态下，能否凑成和为target的结果
            if N>target or i<0:return False
            if N==target: return True
            # 这个很巧妙每次可以选择将nums[i]加进N，或者不将nums[i]加进N
            return dp(i-1, N+nums[i]) or dp(i-1,N)   

        if sum(nums)%2 != 0: return False              #目标和为奇数时不能分割成两个元素相等的子集
        target = sum(nums) // 2                         #原问题等价于将nums划分为元素和为nums一半的两个子集的划分方式是否存在
        return dp(len(nums)-1, 0)
```


##  286. <a name='N-1'></a>51. N皇后

##  287. <a name='24.'></a>补充题24. 双栈排序

##  288. <a name='-1'></a>680 【回文🌈】Valid Palindrome II

[哈哈哈](https://www.bilibili.com/video/BV167411h7x1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y147xn?spm_id_from=333.999.0.0)

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def checkPalindrome(low, high):
            i, j = low, high
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        low, high = 0, len(s) - 1
        while low < high:
            if s[low] == s[high]: 
                low += 1
                high -= 1
            else:
                return checkPalindrome(low + 1, high) or checkPalindrome(low, high - 1)
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-palindrome-ii/solution/yan-zheng-hui-wen-zi-fu-chuan-ii-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def validPalindrome(self, s: str, flag=False) -> bool:
        if s == s[::-1]:
            return True 
        start, end = 0, len(s) - 1
        while start < end:
            if s[start] == s[end]:
                start, end = start+1, end-1
            elif not flag:
                return self.validPalindrome(s[start+1:end+1], True) or self.validPalindrome(s[start:end], True)
            else:
                return False
        return True

class Solution:
    def validPalindrome(self, s):
        if s == s[::-1]:
            return True
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] == s[r]:
                l, r = l + 1, r - 1
            else:
                a = s[l + 1 : r + 1]
                b = s[l:r]
                return a == a[::-1] or b==b[::-1]
```

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        n = len(s)
        i = next((i for i in range(n>>1) if s[i] != s[~i]), -1)
        return i == -1 or s[i+1:n-i] == s[i+1:n-i][::-1] or s[i:n-i-1] == s[i:n-i-1][::-1]
```

##  289. <a name='Offer38.'></a>剑指 Offer 38. 字符串的排列

##  290. <a name='-1'></a>701 Insert into a Binary Search Tree

[小明](https://www.bilibili.com/video/BV1q54y1k76s?spm_id_from=333.999.0.0)

##  291. <a name='-1'></a>530. Minimum Absolute Difference in BST

[花花酱](https://www.bilibili.com/video/BV1fW411k7eT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1FJ41147BB?spm_id_from=333.999.0.0)

```py
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        inorder = []
        def dfs(root):
            nonlocal inorder
            if not root:
                return 
            dfs(root.left)
            inorder.append(root.val)
            dfs(root.right) 
        dfs(root)
        return min([inorder[i]-inorder[i-1] for i in range(1,len(inorder))])

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        
        def inorder(node):
            if node:
                yield from inorder(node.left)
                yield node.val
                yield from inorder(node.right)

        pre, cur = tee(inorder(root))
        next(cur, None)
        return min(b-a for a, b in zip(pre, cur))
```

```py
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        self.res = float('inf')
        self.tmp = -1
        def dfs(root):
            if not root:
                return
            dfs(root.left)
            if self.tmp == -1:
                self.tmp = root.val
            else:
                self.res = min(self.res, abs(root.val - self.tmp))
                self.tmp = root.val
            dfs(root.right)
        dfs(root)
        return self.res

递归

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        ret = inf
        pre = None
        def dfs(node):
            nonlocal ret, pre
            if not node: return   
            dfs(node.left)
            if pre != None: ret = min(node.val - pre, ret)             
            pre = node.val
            dfs(node.right)                
        dfs(root)       
        return ret

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        """解题思路：二叉搜索树的中序遍历是一个递增且无重复元素的序列"""
        path = []
        min_ = float('INF')  

        def traval(root):  # 中序遍历
            nonlocal path
            if not root: return

            traval(root.left)
            path.append(root.val)
            traval(root.right)

        
        traval(root)
        result = list(zip(path, path[1:]))   # 窗口大小为2，步长为1
        for i, j in result:
            if abs(j - i) < min_:
                min_ = abs(j - i)
        
        return min_
```

##  292. <a name='k-1'></a>698. 划分为k个相等的子集

##  293. <a name='-1'></a>173 【构造🏰】Binary Search Tree Iterator

[小明](https://www.bilibili.com/video/BV1qK41137h1?spm_id_from=333.999.0.0)

```py
# next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。

class BSTIterator(object):

    def __init__(self, root):
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self):
        tmp = self.stack.pop()
        res = tmp.val

        tmp = tmp.right
        while tmp:
            self.stack.append(tmp)
            tmp = tmp.left
        return res

    def hasNext(self):
        # 直接写也可以：return self.stack 
        return self.stack != []



class BSTIterator(object):
    def __init__(self, root):
        self.stack = []
        self.pushAllLeft(root)
        

    def hasNext(self):
        return self.stack != []
        

    def next(self):
        tmp = self.stack.pop()
        self.pushAllLeft(tmp.right)
        return tmp.val
            
    def pushAllLeft(self, node):
        while node:
            self.stack.append(node)
            node = node.left
```

递归解法不符合题目：不能用递归 应该用迭代

##  294. <a name='-1'></a>426【剑指36】. 将二叉搜索树转化为排序的双向链表【字节跳动】-
将一个 二叉搜索树 就地转化为一个 已排序的双向循环链表 。

对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

特别地，我们希望可以 就地 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

![](https://s3.bmp.ovh/imgs/2022/01/11d8ac60b4c3deb6.png)

```py
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return
        path = []
        def inorder(root):
            if not root: return 
            inorder(root.left)
            path.append(root)
            inorder(root.right)    
        inorder(root)
        for i in range(len(path)):
            path[i].left = path[i-1]
            path[i].right = path[(i+1)%len(path)]
        return path[0]
        
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        a, f = [], lambda r: r and (f(r.left) or a.append(r) or f(r.right))
        f(root)
        n = len(a)
        for i, r in enumerate(a):
            r.left, r.right = a[i - 1], a[i + 1 - n]
        return n and a[0] or None

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        def dfs(cur):
            if not cur: return
            dfs(cur.left) # 递归左子树
            if self.pre: # 修改节点引用
                self.pre.right, cur.left = cur, self.pre
            else: # 记录头节点
                self.head = cur
            self.pre = cur # 保存 cur
            dfs(cur.right) # 递归右子树
        
        if not root: return
        self.pre = None
        dfs(root)
        self.head.left, self.pre.right = self.pre, self.head
        return self.head

作者：jyd
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 思路:

其实就是左右节点指向改变，右节点指向下一个比它大的数，左节点指向比它小的数。又是二叉搜索树，自然想到中序遍历。

思路一：中序遍历（非递归和递归）

写法一：用栈(非递归)

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:return 
        # 当一个中间节点
        head = Node(-1, None, None)
        # 记录为先前节点,找到下一个节点才能串起来
        prev = head
        # 中序遍历的非递归
        stack = []
        p = root
        while p or stack:
            while p:
                stack.append(p)
                p = p.left
            p = stack.pop()
            # 改变左右方向
            prev.right = p
            p.left = prev
            # 改变先前节点
            prev = p
            p = p.right
        # 将head 删掉   
        head.right.left = prev
        prev.right = head.right
        return head.right
写法二：递归

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:return 
        # 当一个中间节点
        head = Node(-1, None, None)
        # 记录为先前节点,找到下一个节点才能串起来
        prev = head

        # 中序遍历的递归
        def inorder(root):
            nonlocal prev
            if not root:
                return 
            inorder(root.left)
            prev.right = root
            root.left = prev
            prev = prev.right
            inorder(root.right)
        
        inorder(root)
        # 将head 删掉   
        head.right.left = prev
        prev.right = head.right
        return head.right
思路二：分治

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return
        left = self.treeToDoublyList(root.left)
        right = self.treeToDoublyList(root.right)
        root.left = root
        root.right = root
        return self.connect(self.connect(left, root), right)

    def connect(self, node1, node2):
        if not (node1 and node2):
            return node1 or node2
        tail1, tail2 = node1.left, node2.left
        tail1.right = node2
        node2.left = tail1
        tail2.right = node1
        node1.left = tail2
        return node1
```

```py
"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def myinorderTraversal(self, root: 'Node') -> 'Node':
        ''' traversal order:  right subtree -> root -> left subtree '''

        # conrer case
        if not root: return None

        sentinel = Node()    # 虚拟哨兵尾节点
        successor = sentinel # 后驱指针

        def inorder(r = root):
            nonlocal successor
            if not r: return
        
            inorder(r.right)
            # 不建议初学这么写
            r.right, successor.left, successor = successor, r, r
            inorder(r.left)

        inorder()
        successor.left = sentinel.left
        sentinel.left.right = successor
        return successor

    def inorderTraversal(self, root: 'Node') -> 'Node':
        ''' traversal order:  left subtree -> root -> right subtree '''

        # conrer case
        if not root: return None

        sentinel = Node()      # 虚拟哨兵头节点
        predecessor = sentinel # 前驱指针

        def inorder(r = root):
            nonlocal predecessor
            if not r: return
        
            inorder(r.left)
            # 不建议初学这么写
            predecessor.right, r.left, predecessor = r, predecessor, r
            inorder(r.right)

        inorder()
        sentinel.right.left = predecessor
        predecessor.right = sentinel.right
        return sentinel.right


    treeToDoublyList = myinorderTraversal
    # treeToDoublyList = inorderTraversal
```

```py
辅助栈

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:
            return root
        # 辅助栈        
        helper, start = [], None
        current, pre = root, None
        while len(helper) != 0 or current != None:
            if current != None:
                helper.append(current)
                current = current.left
            else:
                current = helper.pop()
                if pre != None:
                    current.left = pre
                    pre.right = current
                else:
                    start = current
                pre = current
                current = current.right
        start.left = pre
        pre.right = start
        return start

迭代

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        # left : pre right: nex
        dummy = Node(None)
        p = dummy
        if not root:
            return root
        stack = [[root, False]]
        while stack:
            node, visited = stack.pop()
            if not visited:
                if node.right:
                    stack.append([node.right, False])
                stack.append([node, True])
                if node.left:
                    stack.append([node.left, False])
            else:
                node.left = p
                node.right = None
                p.right = node
                p = p.right
        head = dummy.right
        head.left = p
        p.right = head
        return head

def treeToDoublyList(self, root: 'Node') -> 'Node':
        pre = None
        head = None
        def inorder(root):
            nonlocal pre
            nonlocal head
            if not root:
                return 

            inorder(root.left)
            if pre:
                pre.right, root.left = root, pre
            else:
                head = root #第一个节点,bst最小的节点
            pre = root
            inorder(root.right)

        if not root:
            return
        inorder(root)
        pre.right, head.left = head, pre
        return head
```

##  295. <a name='-1'></a>836. 矩形重叠

##  296. <a name='-1'></a>99. 恢复二叉搜索树

##  297. <a name='-1'></a>316 【贪心🧡】Remove Duplicate Letters

[小明](https://www.bilibili.com/video/BV1x54y1R7y7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Tz4y167pC?spm_id_from=333.999.0.0)

```py
# 思路是参考别人的，
# 如果数比栈顶小，而且栈顶在后面还有的话，
# 就弹出栈顶。
# python自带列表弹出和加入最后一个数都是很快的。
# 然后在前面加一个0，因为0比一切字母小，可以不用判空，方便很多

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        result = ["0"] # 初值不要为空，不然index为-1会报错
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            print("s[idx:]",s[idx:],"数量: ",s[idx:].count(result[-1]),"需要大于0,表示要把c删掉，必须后面还有c")
            if char not in result:
                while char < result[-1] and s[idx:].count(result[-1]) > 0:
                    result.pop(-1) # result 删除最后一位
                result.append(char)
        return "".join(result[1:])

# 递归贪心版本
class Solution(object):
    def removeDuplicateLetters(self, str):
        """
        :type s: str
        :rtype: str
        """
        print("-"*50)
        # 先按字典排序
        for char in sorted(set(str)):
            print("-"*20,char)
            suffix = str[str.index(char):]
            print(suffix)


            # 看余下的是否能组成所需的字母
            # if len(set(suffix)) == len(set(str)): 也可以
            if set(suffix) == set(str):
                return char + self.removeDuplicateLetters(suffix.replace(char, ''))
                # 逐步把char后面的char替换掉
        return ''

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = ''
        while s:
            print(list(map(s.rindex, set(s))))
            i = min(map(s.rindex, set(s)))
            c = min(s[:i+1])
            print(s[:i+1])
            result += c
            s = s[s.index(c):].replace(c, '')
            print(s)
        return result

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        rindex = {char: idx for idx, char in enumerate(s)}
        print("rindex",rindex)
        result = '' 
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            if char not in result:
                while char < result[-1:] and idx < rindex[result[-1:]]:
                    # 如果 char 比 最后一位result[-1:] 小
                    # result 删除最后一位
                    print("rindex[result[-1:]",rindex[result[-1:]])
                    result = result[:-1] 
                result += char
        return result

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        n = len(s)
        stack = [s[0]]
        for i in range(1,n):
            if s[i] not in stack and s[i]>stack[-1]:
                stack.append(s[i])
            elif s[i] not in stack:
                while stack and s[i]<stack[-1] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
        return "".join(stack)

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        n = len(s)
        for i in range(n):
            if s[i] in stack:
                continue
            else:
                while stack and stack[-1] > s[i] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
            
        return "".join(stack)

# 思路三：栈
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        from collections import Counter
        c = Counter(s)
        stack = []
        existed = set()
        for a in s:
            # print(stack)
            if a not in existed:
            	# 判断后面还有没有该字母
                while stack and stack[-1] > a and c[stack[-1]] > 0:
                    existed.remove(stack.pop())
                stack.append(a)
                existed.add(a)
            c[a] -= 1
        return "".join(stack)

# 思路二：迭代
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        res = ""
        while s:
            # 从右往左找，找到最小位置的索引号
            loc = min(map(s.rindex, s))
            # 找该索引前面最小的字母
            a = min(s[:loc + 1])
            res += a
            s = s[s.index(a):].replace(a, "")
        return res
```

##  298. <a name='-1'></a>109题. 有序链表转换二叉搜索树

https://www.bilibili.com/video/BV19a4y157U8?spm_id_from=333.999.0.0

https://www.bilibili.com/video/BV1ff4y197dS?spm_id_from=333.999.0.0

当递归的是一个链表`头`时，需要切断

```py
class Solution:
    def sortedListToBST(self, head) -> TreeNode:
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)

        fast = head
        slow = head
        pre =  head

        while fast and fast.next:
            pre = slow # pre切断
            slow = slow.next
            fast = fast.next.next
        mid = TreeNode(slow.val)
        # print(head.val,node.val,last.val)
        mid.right = self.sortedListToBST(slow.next) # 从mid+1到tail
        pre.next = None # pre切断
        mid.left = self.sortedListToBST(head) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        return mid
```

https://www.bilibili.com/video/BV19K411T73P?p=2&spm_id_from=pageDriver

当递归的是一个链表`头尾`时，不需要切断

```py
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getMedian(head: ListNode, tail: ListNode) -> ListNode:
            fast = slow = head
            while fast != tail and fast.next != tail:
                fast = fast.next.next
                slow = slow.next
            return slow
        
        def buildTree(left: ListNode, right: ListNode) -> TreeNode:
            if left == right:
                return None
            mid = getMedian(left, right)
            root = TreeNode(mid.val)
            root.left = buildTree(left, mid) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
            root.right = buildTree(mid.next, right) # 从mid+1到tail
            return root
        
        return buildTree(head, None)
```

##  299. <a name='-1'></a>115. 【动态🚀规划】Distinct Subsequences

[花花酱](https://www.bilibili.com/video/BV1EW411d7PC?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV185411G7F6?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        for i in range(sN+1):
            for j in range(tN+1):
                if j == 0:  
                    dp[i][j] = 1
                elif i == 0:  
                    dp[i][j] = 0
                elif s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
Python3:

class SolutionDP2:
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(s), len(t)
        if n1 < n2:
            return 0

        dp = [0 for _ in range(n2 + 1)]
        dp[0] = 1

        for i in range(1, n1 + 1):
            prev = dp[:] # 深拷贝一下
            end = i if i < n2 else n2 # 剪枝，保证s的长度大于等于t, 因为对于任意i，i > n1, dp[i] = 0, 没必要跟新状态。 
            for j in range(1, end + 1):
                if s[i - 1] == t[j - 1]:
                    dp[j] = prev[j - 1] + prev[j]
                else:
                    dp[j] = prev[j]
        return dp[-1]
```


##  300. <a name='-1'></a>1312. 【回文🌈】Minimum Insertion Steps to Make a String Palindrom

[花花酱](https://www.bilibili.com/video/BV1HJ411L7b2?spm_id_from=333.999.0.0)



