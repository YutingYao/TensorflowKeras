<!-- vscode-markdown-toc -->
* 1. [题目](#)
	* 1.1. [100-Same Tree](#SameTree)
	* 1.2. [101-Symmetric tree](#Symmetrictree)
	* 1.3. [102-Binary Tree Level Order Traversal](#BinaryTreeLevelOrderTraversal)
	* 1.4. [103. Binary Tree Zigzag Level Order Traversal](#BinaryTreeZigzagLevelOrderTraversal)
	* 1.5. [104-Maximum Depth of Binary](#MaximumDepthofBinary)
	* 1.6. [105-从前序与中序遍历序列构](#-1)
	* 1.7. [106-从中序与后序遍历序列构造二叉树](#-1)
	* 1.8. [107-Binary Tree Level Order Traversal II](#BinaryTreeLevelOrderTraversalII)
	* 1.9. [108 Convert Sorted Array to Binary Search Tree](#ConvertSortedArraytoBinarySearchTree)
	* 1.10. [109题. 有序链表转换二叉搜索树](#-1)
	* 1.11. [110-Balanced Binary Tree](#BalancedBinaryTree)
	* 1.12. [111-Minimum Depth of Binary Tree](#MinimumDepthofBinaryTree)
	* 1.13. [112-Path Sum](#PathSum)
	* 1.14. [113. 二叉树中和为某一值的路径](#-1)
	* 1.15. [114题. 二叉树展开为链表](#-1)
	* 1.16. [115. 【动态🚀规划】Distinct Subsequences](#DistinctSubsequences)
	* 1.17. [116. Populating Next Right Pointers in Each Node](#PopulatingNextRightPointersinEachNode)
	* 1.18. [117 Populating Next Right Pointers in Ea (可跳过)](#PopulatingNextRightPointersinEa)
	* 1.19. [118-Pascal's Triangle](#PascalsTriangle)
	* 1.20. [119-Pascal's Triangle II](#PascalsTriangleII)
	* 1.21. [120 【动态🚀规划】Triangle](#Triangle)
	* 1.22. [121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机](#BestTimetoBuyandSellStock121-)
	* 1.23. [122-【贪心🧡】买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II](#II122-BestTimetoBuyandSellStockII)
	* 1.24. [123-买卖股票的最佳时机 III](#III)
	* 1.25. [124. Binary Tree Maximum Path Sum](#BinaryTreeMaximumPathSum)
	* 1.26. [125 【回文🌈】Valid Palindrome](#ValidPalindrome)
	* 1.27. [126. (bfs好难暂时放弃) Word Ladder II](#bfsWordLadderII)
	* 1.28. [127. Word Ladder](#WordLadder)
	* 1.29. [128. 【🍒并查集】Longest Consecutive Sequence](#LongestConsecutiveSequence)
	* 1.30. [129 Sum Root to Leaf Numbers](#SumRoottoLeafNumbers)
	* 1.31. [130. 【🍒并查集】Surrounded Regions 130-被围绕的区域](#SurroundedRegions130-)
	* 1.32. [131 【回文🌈】分割回文🌈串](#-1)
	* 1.33. [132. 【动态🚀规划 + 回文🌈】Palindrome Partitioning II](#PalindromePartitioningII)
	* 1.34. [133. Clone Graph](#CloneGraph)
	* 1.35. [134. Gas Station](#GasStation)
	* 1.36. [138 Copy List with Random Pointer](#CopyListwithRandomPointer)
	* 1.37. [136 【位运算😜】Single Number](#SingleNumber)
	* 1.38. [137 【位运算😜】Single Number II](#SingleNumberII)
	* 1.39. [139 【动态🚀规划 + 背包】Word Break](#WordBreak)
	* 1.40. [140 Word Break II](#WordBreakII)
	* 1.41. [141-Linked List Cycle](#LinkedListCycle)
	* 1.42. [142 Linked List Cycle II](#LinkedListCycleII)
	* 1.43. [143 Reorder List](#ReorderList)
	* 1.44. [144-Preorder with stack](#Preorderwithstack)
	* 1.45. [144-Binary Tree Preorder Traversal](#BinaryTreePreorderTraversal)
	* 1.46. [145-Postorder with stack](#Postorderwithstack)
	* 1.47. [145-Binary Tree Postorder Traversal](#BinaryTreePostorderTraversal)
	* 1.48. [146 【构造🏰】LRU Cache](#LRUCache)
	* 1.49. [147 Insertion Sort List](#InsertionSortList)
	* 1.50. [148. Sort List](#SortList)
	* 1.51. [149. Max Points on a Line](#MaxPointsonaLine)
	* 1.52. [150. Evaluate Reverse Polish Notation](#EvaluateReversePolishNotation)
	* 1.53. [151. Reverse Words in a String](#ReverseWordsinaString)
	* 1.54. [152 【动态🚀规划】乘积最大子数组](#-1)
	* 1.55. [153-寻找旋转排序数组中的最小值](#-1)
	* 1.56. [154 Find Minimum in Rotated Sorted Arr](#FindMinimuminRotatedSortedArr)
	* 1.57. [155-【构造🏰】Min Stack](#MinStack)
	* 1.58. [160-Intersection of Two Linked Lists](#IntersectionofTwoLinkedLists)
	* 1.59. [162. Find Peak Element](#FindPeakElement)
	* 1.60. [165. Compare Version Numbers](#CompareVersionNumbers)
	* 1.61. [166. Fraction to Recurring Decimal](#FractiontoRecurringDecimal)
	* 1.62. [167-Two Sum II - Input array is sorted](#TwoSumII-Inputarrayissorted)
	* 1.63. [168-Excel Sheet Column Title](#ExcelSheetColumnTitle)
	* 1.64. [169. 【位运算😜】Majority Element](#MajorityElement)
	* 1.65. [171. Excel Sheet Column Number](#ExcelSheetColumnNumber)
	* 1.66. [172-Factorial Trailing Zeroes](#FactorialTrailingZeroes)
	* 1.67. [173 【构造🏰】Binary Search Tree Iterator](#BinarySearchTreeIterator)
	* 1.68. [174 Dungeon Game](#DungeonGame)
	* 1.69. [179 Largest Number](#LargestNumber)
	* 1.70. [186. Reverse Words in a String II](#ReverseWordsinaStringII)
	* 1.71. [187 【位运算😜】Repeated DNA Sequences](#RepeatedDNASequences)
	* 1.72. [188 【动态🚀规划】Best Time to Buy and Sell Stock IV](#BestTimetoBuyandSellStockIV)
	* 1.73. [189. Rotate Array](#RotateArray)
	* 1.74. [190. 【位运算😜】Reverse Bits](#ReverseBits)
	* 1.75. [191 Number of 1 Bits](#Numberof1Bits)
	* 1.76. [198. 【动态🚀规划】House Robber 198-打家劫舍](#HouseRobber198-)
	* 1.77. [199 Binary Tree Right Side View](#BinaryTreeRightSideView)
	* 1.78. [200 【🍒并查集】岛屿数量](#-1)
	* 1.79. [201 【位运算😜】Bitwise AND of Numbers Range](#BitwiseANDofNumbersRange)
	* 1.80. [202. 快乐数 Happy Number](#HappyNumber)
	* 1.81. [203. Remove Linked List Elements](#RemoveLinkedListElements)
	* 1.82. [204-Count Primes](#CountPrimes)
	* 1.83. [205. isomorphic strings](#isomorphicstrings)
	* 1.84. [206-Reverse Linked List](#ReverseLinkedList)
	* 1.85. [207-课程表](#-1)
	* 1.86. [208. 【构造🏰】Implement Trie (Prefix Tree)](#ImplementTriePrefixTree)
	* 1.87. [209-长度最小的子数组](#-1)
	* 1.88. [210. Course Schedule II 210-课程表II](#CourseScheduleII210-II)
	* 1.89. [211 Add and Search Word](#AddandSearchWord)
	* 1.90. [212. 【构造🏰 + 困难】Word Search II](#WordSearchII)
	* 1.91. [213.【动态🚀规划】 House Robber II 213-打家劫舍II](#HouseRobberII213-II)
	* 1.92. [216. Combination Sum III 216-组合总和 III](#CombinationSumIII216-III)
	* 1.93. [217. Contains Duplicate](#ContainsDuplicate)
	* 1.94. [218. The Skyline Problem](#TheSkylineProblem)
	* 1.95. [219. Contains Duplicate II](#ContainsDuplicateII)
	* 1.96. [220 Contains Duplicate III](#ContainsDuplicateIII)
	* 1.97. [221-【动态🚀规划】最大正方形](#-1)
	* 1.98. [222. Count Complete Tree Nodes](#CountCompleteTreeNodes)
	* 1.99. [223. Rectangle Area](#RectangleArea)
	* 1.100. [224](#-1)
	* 1.101. [225-【构造🏰】Implement Stack using Queues](#ImplementStackusingQueues)
	* 1.102. [226-翻转二叉树](#-1)
	* 1.103. [227 Basic Calculator II](#BasicCalculatorII)
	* 1.104. [228 Summary Ranges](#SummaryRanges)
	* 1.105. [229. Majority Element II](#MajorityElementII)
	* 1.106. [230 Kth Smallest Element in a B](#KthSmallestElementinaB)
	* 1.107. [231. 【位运算😜】Power of Two](#PowerofTwo)
	* 1.108. [232-【构造🏰】Implement Queue using Stacks](#ImplementQueueusingStacks)
	* 1.109. [234. 【回文🌈】Palindrome Linked List](#PalindromeLinkedList)
	* 1.110. [235. Lowest Common Ancestor of a Binary Search Tree](#LowestCommonAncestorofaBinarySearchTree)
	* 1.111. [236-二叉树的最近公共祖先](#-1)
	* 1.112. [237. Delete Node in a Linked List](#DeleteNodeinaLinkedList)
	* 1.113. [238 【前缀和🎨】Product of Array Except Self](#ProductofArrayExceptSelf)
	* 1.114. [239. 【最小堆🌵 + 滑动窗口🔹】Sliding Window Maximum](#SlidingWindowMaximum)
	* 1.115. [240. 二维数组的查找](#-1)
	* 1.116. [242. Valid Anagram](#ValidAnagram)
	* 1.117. [243. Shortest Word Distance](#ShortestWordDistance)
	* 1.118. [246. Strobogrammatic Number](#StrobogrammaticNumber)
	* 1.119. [257-二叉树的所有路径](#-1)
	* 1.120. [258. Add Digits](#AddDigits)
	* 1.121. [260-【位运算😜】只出现一次的数字 III](#III-1)
	* 1.122. [263 Ugly Number](#UglyNumber)
	* 1.123. [264. 【动态🚀规划 + 3指针】Ugly Number II](#UglyNumberII)
	* 1.124. [268 【位运算😜】Missing Number](#MissingNumber)
	* 1.125. [270. Closest Binary Search Tree Value](#ClosestBinarySearchTreeValue)
	* 1.126. [274 H-Index](#H-Index)
	* 1.127. [278. First Bad Version](#FirstBadVersion)
	* 1.128. [279 【动态🚀规划 + 背包】Perfect Squares](#PerfectSquares)
	* 1.129. [282. Expression Add Operators](#ExpressionAddOperators)
	* 1.130. [283. Move Zeros](#MoveZeros)
	* 1.131. [284 Peeking Iterator](#PeekingIterator)
	* 1.132. [287 Find the Duplicate Number](#FindtheDuplicateNumber)
	* 1.133. [289. 【位运算😜】Game of Life](#GameofLife)
	* 1.134. [290. Word Pattern](#WordPattern)
	* 1.135. [297. Serialize and Deserialize Binary Tree](#SerializeandDeserializeBinaryTree)
	* 1.136. [299. Bulls and Cows](#BullsandCows)
	* 1.137. [300 【动态🚀规划 + 二分】Longest Increasing Subsequence 最长上升子序列](#LongestIncreasingSubsequence)
	* 1.138. [301. Remove Invalid Parentheses](#RemoveInvalidParentheses)
	* 1.139. [303 【构造🏰】区域和检索 - 数组不可变](#-1)
	* 1.140. [304. 【构造🏰】Range Sum Query 2D](#RangeSumQuery2D)
	* 1.141. [309. 【动态🚀规划】Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期](#BestTimetoBuyandSellStockwithCooldown309-)
	* 1.142. [305 【🍒并查集】Number of Island](#NumberofIsland)
	* 1.143. [310 Minimum Height Trees](#MinimumHeightTrees)
	* 1.144. [312 Burst Balloons](#BurstBalloons)
	* 1.145. [315. Count of Smaller Numbers After Self](#CountofSmallerNumbersAfterSelf)
	* 1.146. [316 【贪心🧡】Remove Duplicate Letters](#RemoveDuplicateLetters)
	* 1.147. [318【位运算😜】](#-1)
	* 1.148. [319](#-1)
	* 1.149. [321. Create Maximum Number](#CreateMaximumNumber)
	* 1.150. [322. 【动态🚀规划 + 背包 + dfs】Coin Change](#dfsCoinChange)
	* 1.151. [324](#-1)
	* 1.152. [326. Power of Three](#PowerofThree)
	* 1.153. [328. 奇偶链表 (Odd Even Linked List)](#OddEvenLinkedList)
	* 1.154. [329. 【动态🚀规划 + dfs】Longest Increasing Path in a Matrix](#dfsLongestIncreasingPathinaMatrix)
	* 1.155. [332 Reconstruct Itinerary](#ReconstructItinerary)
	* 1.156. [334 Increasing Triplet Subseque](#IncreasingTripletSubseque)
	* 1.157. [337 House Robber III](#HouseRobberIII)
	* 1.158. [338 【位运算😜】Counting Bits](#CountingBits)
	* 1.159. [342. 【位运算😜】Power of Four](#PowerofFour)
	* 1.160. [343-整数拆分](#-1)
	* 1.161. [344. Reverse String](#ReverseString)
	* 1.162. [345. Reverse Vowels of a String](#ReverseVowelsofaString)
	* 1.163. [346 Moving Average from Data Stream](#MovingAveragefromDataStream)
	* 1.164. [347. 【最小堆🌵】Top K Frequent Elements](#TopKFrequentElements)
	* 1.165. [349. Intersection of Two Arrays](#IntersectionofTwoArrays)
	* 1.166. [350. 【动态🚀规划 + 双指针 + 哈希表】Intersection of Two Arrays II](#IntersectionofTwoArraysII)
	* 1.167. [ 351 【🍒并查集】Android Unlocking Pattern](#351AndroidUnlockingPattern)
	* 1.168. [355. 设计推特 Design Twitter](#DesignTwitter)
	* 1.169. [359 Logger Rate Limiter](#LoggerRateLimiter)
	* 1.170. [367. Valid Perfect Square](#ValidPerfectSquare)
	* 1.171. [368 Largest Divisible Subset](#LargestDivisibleSubset)
	* 1.172. [371【位运算😜】](#-1)
	* 1.173. [373. Find K Pairs with Smallest Sums查找和最小的k对数字](#FindKPairswithSmallestSumsk)
	* 1.174. [374. Guess Number Higher or Lower](#GuessNumberHigherorLower)
	* 1.175. [376-摆动序列](#-1)
	* 1.176. [377. 【动态🚀规划】Combination Sum IV](#CombinationSumIV)
		* 1.176.1. [类似题目：416题，494题，不可以重复，377重复](#416494377)
	* 1.177. [378-【最小堆🌵】有序矩阵中第K小的元素](#K)
	* 1.178. [380 Insert Delete GetRandom O(1)](#InsertDeleteGetRandomO1)
	* 1.179. [382 Linked List Random Node](#LinkedListRandomNode)
	* 1.180. [383 Ransom Note](#RansomNote)
	* 1.181. [386](#-1)
	* 1.182. [387. First Unique Character in a String](#FirstUniqueCharacterinaString)
	* 1.183. [389. 【位运算😜】Find the Difference](#FindtheDifference)
	* 1.184. [391. Perfect Rectangle](#PerfectRectangle)
	* 1.185. [392. 【动态🚀规划】Is Subsequence](#IsSubsequence)
	* 1.186. [393. UTF-8 Validation](#UTF-8Validation)
	* 1.187. [394 Decode String](#DecodeString)
	* 1.188. [395 Longest Substring with At Least K](#LongestSubstringwithAtLeastK)
	* 1.189. [399. 【🍒并查集 + floyd 🌞】Evaluate Division](#floydEvaluateDivision)
	* 1.190. [402 Remove K Digits](#RemoveKDigits)
	* 1.191. [404. Sum of Left Leaves](#SumofLeftLeaves)
	* 1.192. [405 【位运算😜】Convert a Number to Hexadecimal](#ConvertaNumbertoHexadecimal)
	* 1.193. [406. Queue Reconstruction by Height](#QueueReconstructionbyHeight)
	* 1.194. [408. Valid Word Abbreviation](#ValidWordAbbreviation)
	* 1.195. [409. 【回文🌈】Longest Palindrome](#LongestPalindrome)
	* 1.196. [410. Split Array Largest Sum](#SplitArrayLargestSum)
	* 1.197. [412. Fizz Buzz](#FizzBuzz)
	* 1.198. [413-【动态🚀规划】等差数列划分](#-1)
	* 1.199. [414. Third Maximum Number](#ThirdMaximumNumber)
	* 1.200. [415-Add Strings](#AddStrings)
	* 1.201. [416. 【动态🚀规划 + 背包 + dfs(startI)无for循环】Partition Equal Subset Sum](#dfsstartIforPartitionEqualSubsetSum)
		* 1.201.1. [相似题目：494题](#494)
	* 1.202. [417. 【构造🏰】Pacific Atlantic Water Flow](#PacificAtlanticWaterFlow)
	* 1.203. [419. Battleships in a Board](#BattleshipsinaBoard)
	* 1.204. [421 Maximum XOR of Two Numbers in an Array](#MaximumXORofTwoNumbersinanArray)
	* 1.205. [423 Reconstruct Original Digits from English](#ReconstructOriginalDigitsfromEnglish)
	* 1.206. [424. 替换后的最长重复字符 Longest Repeating Character Replacem](#LongestRepeatingCharacterReplacem)
	* 1.207. [429. N-ary Tree Level Order Traversal](#N-aryTreeLevelOrderTraversal)
	* 1.208. [430 Flatten a Multilevel Doubly Linked List](#FlattenaMultilevelDoublyLinkedList)
	* 1.209. [432. All O`one Data Structure](#AllOoneDataStructure)
	* 1.210. [435-Non-overlapping Intervals](#Non-overlappingIntervals)
	* 1.211. [436 Find Right Interval](#FindRightInterval)
	* 1.212. [437 【前缀和🎨】Path Sum III](#PathSumIII)
	* 1.213. [438. 【滑动窗口🔹】Find All Anagrams in a String](#FindAllAnagramsinaString)
	* 1.214. [441 Arranging Coins](#ArrangingCoins)
	* 1.215. [442 Find All Duplicates in an Array](#FindAllDuplicatesinanArray)
	* 1.216. [443. String Compression](#StringCompression)
	* 1.217. [445-Add Two Numbers II](#AddTwoNumbersII)
	* 1.218. [447. Number of Boomerangs](#NumberofBoomerangs)
	* 1.219. [448. Find All Numbers Disappeared in an Array](#FindAllNumbersDisappearedinanArray)
	* 1.220. [449. Serialize and Deserialize BST](#SerializeandDeserializeBST)
	* 1.221. [450. Delete Node in a BST](#DeleteNodeinaBST)
	* 1.222. [451 Sort Characters By Frequency](#SortCharactersByFrequency)
	* 1.223. [454 4Sum II](#SumII)
	* 1.224. [452. 【贪心🧡】Minimum Number of Arrows to Burst Balloons](#MinimumNumberofArrowstoBurstBalloons)
	* 1.225. [455-Assign Cookies](#AssignCookies)
	* 1.226. [456 132 Pattern](#Pattern)
	* 1.227. [458 Poor Pigs](#PoorPigs)
	* 1.228. [459 Repeated Substring Pattern](#RepeatedSubstringPattern)
	* 1.229. [460. 【构造🏰】LFU Cache / O(1)](#LFUCacheO1)
	* 1.230. [461 【位运算😜】Hamming Distance](#HammingDistance)
	* 1.231. [463 Island Perimeter](#IslandPerimeter)
	* 1.232. [464. Can I Win](#CanIWin)
	* 1.233. [466. 统计重复个数 Count The Repetitions](#CountTheRepetitions)
	* 1.234. [468 Validate IP Address](#ValidateIPAddress)
	* 1.235. [470. Implement Rand10() Using Rand7()](#ImplementRand10UsingRand7)
	* 1.236. [475. Heaters](#Heaters)
	* 1.237. [476. 【位运算😜】Number Complement](#NumberComplement)
	* 1.238. [477. 【位运算😜】Total Hamming Distance](#TotalHammingDistance)
	* 1.239. [478 Generate Random Point in a Circle](#GenerateRandomPointinaCircle)
	* 1.240. [480. 【滑动窗口🔹】Sliding Window Median](#SlidingWindowMedian)
	* 1.241. [484 Find Permutation](#FindPermutation)
	* 1.242. [485. Max Consecutive Ones](#MaxConsecutiveOnes)
	* 1.243. [486. Predict the Winner](#PredicttheWinner)
	* 1.244. [490 The Maze](#TheMaze)
	* 1.245. [494. 【动态🚀规划 + 背包 + dfs(startI)无for循环】Target Sum](#dfsstartIforTargetSum)
	* 1.246. [495 Teemo Attacking](#TeemoAttacking)
	* 1.247. [496. 下一个更大元素 I (Next Greater Element I)](#INextGreaterElementI)
	* 1.248. [497 Random Point in Non-overlapping](#RandomPointinNon-overlapping)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name=''></a>题目

###  1.1. <a name='SameTree'></a>100-Same Tree 

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1bJ411X7xH?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7ti?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vf4y1R7Ue?spm_id_from=333.999.0.0)

> python:

```py
self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif not p or not q:
            return False
        elif p.val != q.val:
            return False
        else:
            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

```py
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        return str(p)==str(q)
```



> scala

```scala
object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        if (p == null && q == null) {
        true
        } else if (p == null || q == null) {
        false
        } else if (p.value == q.value) {
        isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        } else {
        false
        }
    }
}


object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
     if (p!=null && q!=null) {
       p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
     } else {
       p == q
     }
   }
} 

object Solution {
    def isSameTree(p: TreeNode, q: TreeNode): Boolean = {
        (p,q) match {
          case (p,q) if (p!=null && q!=null) => p.value == q.value && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)
          case (p,q) => p==q
        }
    }
  }
```

###  1.2. <a name='Symmetrictree'></a>101-Symmetric tree

[哈哈哈](https://www.bilibili.com/video/BV1VJ41197KD?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eb?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xv41167z8?spm_id_from=333.999.0.0)

> Python 迭代：其实就是层序遍历，然后检查每一层是不是回文🌈数组

```py
class Solution(object):
    def isSymmetric(self, root):
        layer = [root]
        
        while(layer):
            nextLayer = []
            vals = []
            for node in layer:
                if not node # 有一种情况是[None]
                    vals.append(None)
                    continue
                nextLayer.append(node.left)
                nextLayer.append(node.right)
                
                vals.append(node.val)
                
            if vals != vals[::-1]:
                return False
            layer = nextLayer
            
        return True
```

> Python 递归：

```py
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def twoSym(node1, node2):
            if node1 and node2 and node1.val == node2.val: 
                return twoSym(node1.left, node2.right) and twoSym(node1.right, node2.left)
            elif not node1 and not node2:
                return True
            else:
                return False
        return twoSym(root.left, root.right)
```

> scala:

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def symmetric(nodeA: TreeNode, nodeB: TreeNode): Boolean = {
        if(nodeA == null && nodeB == null){
            true
        }else if(nodeA !=null && nodeB != null){
            if(nodeA.value != nodeB.value){
                false
            }else{
                symmetric(nodeA.left, nodeB.right) && symmetric(nodeA.right, nodeB.left)
            }
        }else{
            false
        }
    }
    
    def isSymmetric(root: TreeNode): Boolean = {
        if(root == null){
            true
        } else{
            symmetric(root.left, root.right)
        }
    }
}

```

###  1.3. <a name='BinaryTreeLevelOrderTraversal'></a>102-Binary Tree Level Order Traversal

[哈哈哈](https://www.bilibili.com/video/BV1W54y197Lc?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14T4y1u7Wk?spm_id_from=333.999.0.0)

> python queue

```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)): # 当前层的个数!!!
                node=queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res


from collections import deque
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []

        queue = deque([root]) 
        res = []
        
        while queue: 
            level = [] 
            for _ in range(len(queue)): 
                node = queue.popleft() 
                level.append(node.val) 
                if node.left:
                    queue.append(node.left) 
                if node.right:
                    queue.append(node.right) 
            res.append(level) 
        return res
```


> python 递归


```py
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []

        def bfs(node, level):
            if node: 
                if len(res) < level + 1:
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level+1)
                bfs(node.right, level+1)

        bfs(root, 0)
        return res

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        dic = collections.defaultdict(list)

        def bfs(node, level):
            if node:
                dic[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0) 
        return [*dic.values()]
```

> scala queue

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val buffer =  scala.collection.mutable.Queue[TreeNode]()
        val res =  scala.collection.mutable.ListBuffer[List[Int]]()

        if(root == null) return List[List[Int]]()
        buffer.enqueue(root)
	
        while(buffer.nonEmpty) {
          val cur = scala.collection.mutable.ListBuffer[Int]()
          for ( _ <- 0 until buffer.size) {
            val node = buffer.dequeue
            cur.append(node.value)
            if(node.left != null) buffer.enqueue(node.left)
            if(node.right != null) buffer.enqueue(node.right)
        }
        res += cur.toList
        }
        res.toList
    }
}
```

> scala 递归

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        val oderMap = scala.collection.mutable.Map[Int, List[Int]]()
        bfs(root, 1, oderMap)
        oderMap.values.toList
    }
    def bfs(node: TreeNode, level: Int, map: scala.collection.mutable.Map[Int, List[Int]]): Unit = {
        if (node != null) {
            val l = map.get(level)
                .map(_ :+ node.value)
                .getOrElse(List(node.value))

            map(level) = l
            bfs(node.left, level + 1, map)
            bfs(node.right, level + 1, map)
        }
    }
}
```

```scala
object Solution {
    def levelOrder(root: TreeNode): List[List[Int]] = {
        bfs(if(root == null) List() else List(root), List())
    }

    // @annotation.tailrec
    // @annotation.tailrec 告诉编译器，下面这个函数是递归的，在栈桢的管理上，希望编译器能所有优化。
    def bfs(queue: List[TreeNode], ans: List[List[Int]]): List[List[Int]] = {
        if(queue.isEmpty) ans
        else{
        bfs(queue.flatMap(n => List(n.left, n.right)).filter(_ != null), ans :+ queue.map(n => n.value))
        }
    }
}
```

###  1.4. <a name='BinaryTreeZigzagLevelOrderTraversal'></a>103. Binary Tree Zigzag Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1NE411M7Fm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15h411Z7h5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GA411W7NY?spm_id_from=333.999.0.0)

> python 队列

```py
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: 
            return []

        queue = [root]
        res = []
        indexflag = 1 
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        queue = [root]
        res = []
        indexflag = 1 
        while queue and queue[0]: # 或者
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            indexflag += 1 
            if not indexflag % 2: 
                res.append(level[:])
            else:
                res.append(level[::-1])
        return res

# python 双端duque
from collections import deque
class Solution:
    def zigzagLevelOrder(self, root):
        queue = deque([root])
        res = []
        flag = True # flag
        while queue and queue[0]:
            level = []
            for _ in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            if flag: # flag
                res.append(level)
            else:
                res.append(level[::-1])  # [::-1]反转
            flag = bool(1-flag) # flag
        return res
```

递归

```py
class Solution:
    def zigzagLevelOrder(self, root):
        res = []
        def bfs(node, level):
            if node:
                if level >= len(res):
                    res.append([])
                res[level].append(node.val)
                bfs(node.left, level + 1)
                bfs(node.right, level + 1)

        bfs(root, 0)
        for i in range(1, len(res), 2): # flag，各两个逆序
            res[i] = res[i][::-1]
        return res
```

###  1.5. <a name='MaximumDepthofBinary'></a>104-Maximum Depth of Binary

[哈哈哈](https://www.bilibili.com/video/BV1AJ411Q7xG?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7eK?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1u54y1D7Nx?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tK41137GM?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1
```

```scala
object Solution1 {
    def maxDepth(root: TreeNode): Int = {
        if (root == null) return 0
        math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    }
}

object Solution {
    def maxDepth(root: TreeNode): Int = root match {
        case null => 0
        case x: TreeNode => Math.max((1 + maxDepth(x.left)), (1 + maxDepth(x.right)))
    }
}

object Solution2 {
    def maxDepth(root: TreeNode): Int = {
        if(root == null) return 0
        var depth = 0
        val queue = scala.collection.mutable.Queue[TreeNode]()
        queue.enqueue(root)

        while(queue.nonEmpty) {
            depth += 1
            for(_ <- 0 until queue.size){
                val node = queue.dequeue
                if(node.left != null) queue.enqueue(node.left)
                if(node.right != null) queue.enqueue(node.right)
            }
        }   
        depth
    }
}
```

###  1.6. <a name='-1'></a>105-从前序与中序遍历序列构

[哈哈哈](https://www.bilibili.com/video/BV1uv411B73D?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1x54y1d7e8?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1ry4y1U7ZR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV14A411q7Nv?spm_id_from=333.999.0.0)

> PYTHON 递归

```py
class Solution:
    def buildTree(self, preorder, inorder):
        if inorder:
            root = TreeNode(preorder.pop(0))
            i = inorder.index(root.val)
            root.left = self.buildTree(preorder, inorder[: i])
            root.right = self.buildTree(preorder, inorder[i + 1:])
            return root

class Solution:
    def buildTree(self, preorder, inorder):
        if preorder: # 也可以
        if inorder:
          root = TreeNode(preorder.pop(0))
          i = inorder.index(root.val)
          root.left = self.buildTree(preorder[:i], inorder[:i])
          root.right = self.buildTree(preorder[i:], inorder[i+1:])
          return root

```

###  1.7. <a name='-1'></a>106-从中序与后序遍历序列构造二叉树

[哈哈哈](https://www.bilibili.com/video/BV1r5411W7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jh411Z7y8?spm_id_from=333.999.0.0)

```py
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if inorder:
            root = TreeNode(postorder.pop())
            i = inorder.index(root.val)
            root.left = self.buildTree(inorder[:i], postorder[:i])
            root.right = self.buildTree(inorder[i+1:], postorder[i:])
            return root
```

###  1.8. <a name='BinaryTreeLevelOrderTraversalII'></a>107-Binary Tree Level Order Traversal II

[哈哈哈](https://www.bilibili.com/video/BV1eJ411z7d6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1yK411n76R?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qA411i7P4?spm_id_from=333.999.0.0)


```py
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        res = []
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res[::-1]
```

###  1.9. <a name='ConvertSortedArraytoBinarySearchTree'></a>108 Convert Sorted Array to Binary Search Tree 

[花花酱](https://www.bilibili.com/video/BV1F7411H7tH?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1JJ411q74U?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7FR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wa411c7tS?spm_id_from=333.999.0.0)

> python

```py
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if nums:
            mid = len(nums) // 2
            root = TreeNode(nums[mid])
            root.left = self.sortedArrayToBST(nums[:mid])
            root.right = self.sortedArrayToBST(nums[mid+1:])
            return root
```

scala 中没有这种形式的写法 nums[:mid]，nums[mid+1:]

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    
    def formTree(nums: Array[Int], begin: Int, end: Int): TreeNode = {
        var mid = begin + Math.ceil((end - begin)/2).toInt
        TreeNode(
            nums(mid), 
            if(mid <= begin) null else formTree(nums, begin, mid-1), 
            if(mid >= end) null else formTree(nums, mid+1, end)
        )
    }
    
    def sortedArrayToBST(nums: Array[Int]): TreeNode = {
        if(nums.isEmpty){
            null
        }else{
            formTree(nums, 0, nums.size - 1)
        }
    }
}

```

###  1.10. <a name='-1'></a>109题. 有序链表转换二叉搜索树

https://www.bilibili.com/video/BV19a4y157U8?spm_id_from=333.999.0.0

https://www.bilibili.com/video/BV1ff4y197dS?spm_id_from=333.999.0.0

当递归的是一个链表`头`时，需要切断

```py
class Solution:
    def sortedListToBST(self, head) -> TreeNode:
        if not head:
            return None
        if not head.next:
            return TreeNode(head.val)

        fast = head
        slow = head
        pre =  head

        while fast and fast.next:
            pre = slow # pre切断
            slow = slow.next
            fast = fast.next.next
        mid = TreeNode(slow.val)
        # print(head.val,node.val,last.val)
        mid.right = self.sortedListToBST(slow.next) # 从mid+1到tail
        pre.next = None # pre切断
        mid.left = self.sortedListToBST(head) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
        return mid
```

https://www.bilibili.com/video/BV19K411T73P?p=2&spm_id_from=pageDriver

当递归的是一个链表`头尾`时，不需要切断

```py
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getMedian(head: ListNode, tail: ListNode) -> ListNode:
            fast = slow = head
            while fast != tail and fast.next != tail:
                fast = fast.next.next
                slow = slow.next
            return slow
        
        def buildTree(left: ListNode, right: ListNode) -> TreeNode:
            if left == right:
                return None
            mid = getMedian(left, right)
            root = TreeNode(mid.val)
            root.left = buildTree(left, mid) # 从head到mid-1，所以我们在findMid方程里面，需要对List进行切分
            root.right = buildTree(mid.next, right) # 从mid+1到tail
            return root
        
        return buildTree(head, None)
```

###  1.11. <a name='BalancedBinaryTree'></a>110-Balanced Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1NJ411v7b1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Lb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sV411b7hR?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def height(root: TreeNode) -> int:
            if not root:
                return 0
            return max(height(root.left), height(root.right)) + 1

        if not root:
            return True
        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)
        # 注意：左右两个子树也必须balanced


其实就是二叉树先序遍历和后序遍历的区别，每种遍历方式都有它的用武之地。

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        ans = True
        
        def postorder(root):
            nonlocal ans
            if not root or not ans:
                return 0
            leftH = postorder(root.left)
            rightH = postorder(root.right)
            if abs(leftH-rightH) > 1:
                ans = False
            return max(leftH, rightH) + 1
        
        postorder(root)
        return ans

必须用

nonlocal + ans

如下返回错误结果 postorder(root,bol)

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root:
            return True
        bol = True
        
        def postorder(root,bol):
            if not root or not bol:
                return 0
            leftH = postorder(root.left,bol)
            rightH = postorder(root.right,bol)
            if abs(leftH-rightH) > 1:
                bol = False
            return max(leftH, rightH) + 1
        
        postorder(root,bol)
        return bol
```

###  1.12. <a name='MinimumDepthofBinaryTree'></a>111-Minimum Depth of Binary Tree

[哈哈哈](https://www.bilibili.com/video/BV1E7411k7KY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7Vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1XZ4y1G7xM?spm_id_from=333.999.0.0)

递归

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root:
            if root.left and root.right:
                return 1+min(self.minDepth(root.left),self.minDepth(root.right))
            elif root.left:
                return 1+self.minDepth(root.left) #较高一层的值
            elif root.right:
                return 1+self.minDepth(root.right) #较高一层的值
            else:
                return 1
        else:
            return 0
```

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        # 如果 没有 root
        if not root:
            return 0
        # 如果 只有 root
        elif not root.left and not root.right:
            return 1
        else:
        # 如果 root 有 子树
            minDepth = float('inf')
            if root.left:
                minDepth = min(self.minDepth(root.left), minDepth) 
            if root.right:
                minDepth = min(self.minDepth(root.right), minDepth) 
            return minDepth + 1
```

队列

```py
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        que = collections.deque([(root, 1)]) # 注意这个写法：[(root, 1)] 的括号
        while que:
            node, depth = que.popleft()
            if not node.left and not node.right:
                return depth
            if node.left: 
                que.append((node.left, depth + 1)) # 注意这个写法：(node.left, depth + 1) 的括号
            if node.right:
                que.append((node.right, depth + 1))
        
        return 0
```

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        bfs(if(root == null) List() else List(root), 0)
    }
    
    @annotation.tailrec
    def bfs(queue: List[TreeNode], res: Int): Int = {
        if(queue.isEmpty) res
        // node has no child 
        else if(queue.exists(t => t.left == null && t.right == null)) res + 1
        else bfs(queue.flatMap(t => List(t.left, t.right)).filter(_ != null), res + 1)
    }
}

object Solution1 {
    def minDepth(root: TreeNode): Int = {
        if (root == null) return 0
        val left = minDepth(root.left) 
        val right = minDepth(root.right) 

        if (left == 0 || right == 0) left + right + 1 else math.min(left, right) + 1
        
    }
}

object Solution1_2 {
    def minDepth(root: TreeNode): Int = {
        if(root == null) 0
        else if(root.left == null) minDepth(root.right) + 1
        else if(root.right == null) minDepth(root.left) + 1
        else minDepth(root.right) + 1 min minDepth(root.left) + 1
    
    }
}
```

队列

```scala
object Solution {
    def minDepth(root: TreeNode): Int = {
        if(root == null) return 0
        val que = scala.collection.mutable.Queue[TreeNode]()
        var depth = 0
        var flag = true
        que.enqueue(root)
        
        while(que.nonEmpty && flag){
            depth += 1
            for(_ <- 0 until que.size; if flag){
                val node = que.dequeue
                if(node.left == null && node.right == null) flag = false
                else {
                    if(node.left != null) que.enqueue(node.left)
                    if(node.right != null) que.enqueue(node.right)
                } 
            } 
        }
        depth
        
    }
} 
```

###  1.13. <a name='PathSum'></a>112-Path Sum

[哈哈哈](https://www.bilibili.com/video/BV1T7411r7Yr?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1pb411e7r7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1uK411T7kX?spm_id_from=333.999.0.0)

递归

```py
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if root is None:
            return False
        if root.val==targetSum:
            return True
        return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)
```

```py
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que = collections.deque([(root, root.val)])
        while que:
            node, tmp = que.popleft()
            if not node.left and not node.right:
                if tmp == sum:
                    return True
                continue
            if node.left:
                que.append((node.left,node.left.val + tmp))
            if node.right:
                que.append((node.right,node.right.val + tmp))
        return False
```

###  1.14. <a name='-1'></a>113. 二叉树中和为某一值的路径

[哈哈哈](https://www.bilibili.com/video/BV1P54y1i73U?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1k54y177fu?spm_id_from=333.999.0.0)

```py
# 注意比较这两个写法
# 路径记忆，计算效率好像更😕
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        path = []
        
        def dfs(node, tsum):
            if not node:
                return
            
            path.append(node.val)
            tsum -= node.val # 对于每一个node，当前node的sum = 总和sum - root的值
            
            if not node.left and not node.right and tsum == 0: # 结束条件
                res.append(path[:])
            dfs(node.left, tsum)
            dfs(node.right, tsum)
            
            path.pop()
        
        dfs(root, targetSum)
        return res
```

```py
# 注意比较这两个写法
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        
        def dfs(node, path, tsum):
            
            if not node:
                return 
            
            tsum -= node.val # 对于每一个node，当前node的sum = 总和sum - root的值
            
            if not node.left and not node.right and tsum == 0: # 结束条件
                res.append(path + [node.val]) # 可以不需要深拷贝
                
            dfs(node.left, path + [node.val], tsum)
            dfs(node.right, path + [node.val], tsum)
        
        dfs(root, [], targetSum)
        return res

class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res=[]

        def dfs(node,path,tsum):

            if node is None:
                return

            if node.val == tsum and node.left is None and node.right is None:
                res.append(path[:] + [node.val])  # 需要深拷贝

            dfs(node.left,path + [node.val], tsum-node.val)
            dfs(node.right,path + [node.val], tsum-node.val)
            
        dfs(root,[],targetSum)
        return res
```

###  1.15. <a name='-1'></a>114题. 二叉树展开为链表

https://www.bilibili.com/video/BV1T7411A7S8?from=search&seid=15731266160913668837&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6tma3pncods0.png" width="80%">

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5csg54lu3lw0.png" width="50%">

递归

```py
class Solution(object):
    def flatten(self, root):
        if not root:
            return
        #把子树备份一下
        tmpleft = root.left
        tmpright = root.right
        root.left = None #记得把左子树置空
        #先把左右子树捋直
        self.flatten(tmpleft)
        self.flatten(tmpright)
        if tmpleft:
            root.right = tmpleft #把捋直的左子树放到右边
            while tmpleft.right: #找到现在右子树的最后一个node
                tmpleft = tmpleft.right 
            tmpleft.right = tmpright #左子树接上右子树
```

stack: 先看144题

```py
class Solution:
    def flatten(self, root: TreeNode) -> None:
        if not root:
            return
        
        stack = [root]
        pre = None # 穿针引线
        
        while stack:
            cur = stack.pop()
            if pre:
                pre.left = None # 穿针引线
                pre.right = cur # 穿针引线
            left, right = cur.left, cur.right
            if right:
                stack.append(right)
            if left:
                stack.append(left)
            pre = cur # 穿针引线

        return root

class Solution:
    def flatten(self, root: TreeNode) -> None:
        preorderList = list()
        stack = list()
        node = root

        while node or stack:
            while node:
                preorderList.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        
        n = len(preorderList)
        for i in range(1, n):
            prev, curr = preorderList[i - 1], preorderList[i] # 穿针引线
            prev.left = None # 穿针引线
            prev.right = curr # 穿针引线
```


###  1.16. <a name='DistinctSubsequences'></a>115. 【动态🚀规划】Distinct Subsequences

[花花酱](https://www.bilibili.com/video/BV1EW411d7PC?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV185411G7F6?spm_id_from=333.999.0.0)

```py
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        sN = len(s)
        tN = len(t)
        dp = [[0] * (tN+1) for _ in range(sN+1)]

        for i in range(sN+1):
            for j in range(tN+1):
                if j == 0:  
                    dp[i][j] = 1
                elif i == 0:  
                    dp[i][j] = 0
                elif s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[-1][-1]
Python3:

class SolutionDP2:
    def numDistinct(self, s: str, t: str) -> int:
        n1, n2 = len(s), len(t)
        if n1 < n2:
            return 0

        dp = [0 for _ in range(n2 + 1)]
        dp[0] = 1

        for i in range(1, n1 + 1):
            prev = dp[:] # 深拷贝一下
            end = i if i < n2 else n2 # 剪枝，保证s的长度大于等于t, 因为对于任意i，i > n1, dp[i] = 0, 没必要跟新状态。 
            for j in range(1, end + 1):
                if s[i - 1] == t[j - 1]:
                    dp[j] = prev[j - 1] + prev[j]
                else:
                    dp[j] = prev[j]
        return dp[-1]
```

###  1.17. <a name='PopulatingNextRightPointersinEachNode'></a>116. Populating Next Right Pointers in Each Node

[花花酱](https://www.bilibili.com/video/BV1b4411R7G4?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1zQ4y1M75t?spm_id_from=333.999.0.0)

```py
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        
        que = [root]
        while que:
            n = len(que)
            pre = Node(0) # 指针
            for _ in range(n):
                node = que.pop(0)
                if pre:
                    pre.next = node
                pre = node

                if node.left:
                    que.append(node.left)
                if node.right:
                    que.append(node.right)
        
        return root

class Solution:
    # 层次遍历
    def connect(self, root: 'Node') -> 'Node':
        if not root: return 
        que = deque([root])
        while que:
            n = len(que)
            for i in range(n):        # 每一层n固定
                cur = que.popleft()
                if i < n - 1:         # 只要不是最后一个，就连上
                    cur.next = que[0] # 只要不是最后一个，就连上
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            
        return root
```

```py
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if root:
            l,r=root.left,root.right
            while l:
                l.next=r
                l,r=l.right,r.left
            self.connect(root.left)
            self.connect(root.right)
        return root
```

###  1.18. <a name='PopulatingNextRightPointersinEa'></a>117 Populating Next Right Pointers in Ea (可跳过)

[小明](https://www.bilibili.com/video/BV1np4y1r7fQ?spm_id_from=333.999.0.0)

看不懂，懵逼了

```py
# 看不懂，懵逼了

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        dummy = Node()
        dummy.next = root
        while dummy.next:
            curp = dummy.next
            dummy.next = None
            pre = dummy
            while curp:
                for cur in [curp.left, curp.right]:
                    if cur:
                        pre.next = cur
                        pre = cur
                curp = curp.next
        return root

# python 非递归方法，常数空间，从顶到下，逐层连接
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        first = root # left_most表示当前层的最左边节点
        while first: # 每次循环连接当前层的下一层
            dummy = pre = Node(0) # head表示下一层的虚拟头部
            cur = first
            while cur : # 遍历当前层，将下一层连接
                if cur.left :
                    pre.next = cur.left
                    pre = pre.next
                if cur.right :
                    pre.next = cur.right
                    pre = pre.next
                cur = cur.next
            first = dummy.next
        return root
```


###  1.19. <a name='PascalsTriangle'></a>118-Pascal's Triangle

[哈哈哈](https://www.bilibili.com/video/BV1T741167KS?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Cb411e7tJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1D54y147NY?spm_id_from=333.999.0.0)

```py
class Solution:
    def generate(self, numRows):
        res = []
        for i in range(numRows):
            curlevel = [1]*(i+1)
            if i >= 2:
                for n in range(1,i):
                    curlevel[n] = pre[n-1]+pre[n]
                    # 头尾为1，中间的第j个为上一层的第j-1个和j个的和
            res += [curlevel]
            pre = curlevel
        return res
        
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = []
        for i in range(numRows):
            level = []
            for j in range(0, i + 1):
                if j == 0 or j == i:
                    level.append(1)
                else:
                    level.append(res[i - 1][j] + res[i - 1][j - 1])
            res.append(level)
        return res
```

```py
库函数重拳出击！
它本质上评估为n! /(k! *(n-k)! )它也被称为二项式系数
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        return [[comb(i, j) for j in range(i + 1)] for i in range(numRows)]
```

```scala
object Solution {
    def generate(numRows: Int): List[List[Int]] = {
        var output = List.empty[List[Int]]
        var curr = 1
        if(numRows == 0){
            output
        }else{
            while(curr <= numRows){
                curr match{
                    case 1 => output = List(List(1))
                    case _ => {
                        val prev = output(curr-2)
                        val begin = 0
                        val end = curr - 1
                        val row = 
                        (0 to curr-1)
                        .map(i => if(i == begin || i == end) 1 else prev(i)+prev(i-1))
                        .toList
                        
                        output = output :+ row
                    }
                }
                curr += 1
            }
        }
        output
    }
}

```

###  1.20. <a name='PascalsTriangleII'></a>119-Pascal's Triangle II

[哈哈哈](https://www.bilibili.com/video/BV187411B7Hj?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7hA?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ni4y1g7Lv?spm_id_from=333.999.0.0)

```py
class Solution3:
    def generate(self, rowIndex):
        for i in range(rowIndex + 1):
            # 用 1 先填充每行所有元素
            curlevel = [1] * (i + 1)
            # 由上一行循环生成当前行元素（除两端）
            for j in range(1, i):
                curlevel[j] = pre[j - 1] + pre[j]
            pre = curlevel
        return curlevel

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        res = [1]
        for i in range(rowIndex):
            res.append(0)
            j = i + 1
            while j > 0:
                res[j] = res[j] + res[j - 1]
                j -= 1
        return res
```

###  1.21. <a name='Triangle'></a>120 【动态🚀规划】Triangle

[小明](https://www.bilibili.com/video/BV1m54y1L7Af?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        i = len(triangle) - 2
        while i >= 0:
            subi = i
            while subi >= 0:
                triangle[i][subi] += min(triangle[i+1][subi],triangle[i+1][subi+1])
                subi -= 1
            i -= 1
        return triangle[0][0]
```

```scala
object Solution {
    def minimumTotal(triangle: List[List[Int]]): Int = {
        val depth = triangle.size
        val dp = triangle.last.toArray
        for(i <- (depth - 2) to 0 by -1; j <- triangle(i).indices) {
            dp(j) = triangle(i)(j) + (dp(j) min dp(j + 1)) 
        }
        dp(0)
    }
}
```

###  1.22. <a name='BestTimetoBuyandSellStock121-'></a>121. Best Time to Buy and Sell Stock  121-买卖股票的最佳时机

[花花酱](https://www.bilibili.com/video/BV1oW411C7UB?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1cZ4y1K7HP?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1D7411s7A1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7by?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16z4y1Z7jD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1hA411t76C?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        minprice = 1e9
        for price in prices:
            maxprofit = max(maxprofit,price - minprice)
            minprice = min(minprice,price)
        return maxprofit
```

```scala
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices.foldLeft((Int.MaxValue, 0)){
            case ((minPriceSoFar, maxProfit), price) => (minPriceSoFar min price, maxProfit max (price - minPriceSoFar))
        }._2
    }
}
```

###  1.23. <a name='II122-BestTimetoBuyandSellStockII'></a>122-【贪心🧡】买卖股票的最佳时机 II 122-Best Time to Buy and Sell Stock II

[哈哈哈](https://www.bilibili.com/video/BV12K411A7rL?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d7411x78d?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7iq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Fk4y1R7ve?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y1L7LG?spm_id_from=333.999.0.0)

```py
我的写法：

贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度O(n)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
                # preprice = 1e9 是错误的，比如[1,2,3,4,5] 会返回2，应该返回4
                preprice = price
            else:
                preprice = price
        return maxprofit

# 简化为
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        maxprofit = 0
        preprice = 1e9
        for price in prices:
            if price > preprice:
                maxprofit += price - preprice
            preprice = price
        return maxprofit
```

```py

其他写法：

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        return sum([prices[i+1]-prices[i] for i in range(len(prices)-1) if prices[i+1]-prices[i] > 0])



class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                ans += prices[i] - prices[i-1]
        return ans
```

```scala
/**
* my first commitment
* greedy alg
* time complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices.length > 1){
            prices.sliding(2).collect{ case arr: Array[Int] if arr(1) > arr(0)=> arr}
    .foldLeft(0){(sum, arr) => 
      sum + arr(1) - arr(0)}
        } else {
            0
        }
    }
}

/**
* greedy alg: one line pass
*/

object Solution1-2 {
  def maxProfit(prices: Array[Int]): Int = {
    if(prices.length > 1) prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum else 0
  }
}

//Alternate solution
object Solution {
    def maxProfit(prices: Array[Int]): Int = {
        prices
            .foldLeft(0,Int.MaxValue)((t, current) => (t._1 + 0.max(current-t._2), current))
            ._1
    }
}
 
  object Solution {
    def maxProfit(prices: Array[Int]): Int = {
      if (prices.isEmpty) return 0
      else (0 until prices.length-1).foldLeft(0)(
        (profit,i) =>{
          if (prices(i)<prices(i+1)) profit+prices(i+1)-prices(i) else profit
        }
      )
    }
  }

```

###  1.24. <a name='III'></a>123-买卖股票的最佳时机 III

[哈哈哈](https://www.bilibili.com/video/BV1Xp4y1k7aD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rk4y117z8?spm_id_from=333.999.0.0)

```py
# 我的写法：
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        profit1 = profit2 = 0
        buy1 = buy2 = prices[0]
        for i in range(1,n):
            # 实际上，是从卖出那天开始算，也就是第二天
            buy1 = min(buy1,prices[i])
            profit1 = max(profit1,prices[i]-buy1)
            buy2 = min(buy2,prices[i]-profit1)  # buy2[i]-profit1[i-1] 相当于一个虚拟的买入价格
            profit2 = max(profit2,prices[i]-buy2)
        return profit2

## 未进行空间优化
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy1 = [0] * n
        sell1 = [0] * n
        buy2 = [0] * n
        sell2 = [0] * n
        buy1[0] = buy2[0] = -prices[0]
        sell1[0] = sell2[0] = 0
        for i in range(1, n):
            buy1[i]  = max(buy1[i-1], -prices[i]) 
            sell1[i] = max(sell1[i-1], buy1[i-1] + prices[i])
            buy2[i]  = max(buy2[i-1], sell1[i-1] - prices[i])
            sell2[i] = max(sell2[i-1], buy2[i-1] + prices[i])
        return sell2[-1]
```

```scala
object Solution3{
    def maxProfit(prices: Array[Int]): Int = {
        val r = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case (acc, px) =>
                val (buy1, sell1, buy2, sell2) = acc
                val newBuy1 = buy1 max - px
                val newSell1 =  sell1 max (buy1 + px)
                val newBuy2 = buy2 max (sell1 - px)
                val newSell2 = sell2 max (buy2 + px)
                (newBuy1, newSell1, newBuy2, newSell2)
        }
        r._2 max r._4
    }
}

object Solution3-1 {
    def maxProfit(prices: Array[Int]): Int = {
        val (buy1, sell1, buy2, sell2) = prices.foldLeft((Int.MinValue, 0, Int.MinValue, 0)){
            case ((buy1, sell1, buy2, sell2), cost) =>
                (
                    buy1 max -cost,
                    sell1 max (buy1 + cost),
                    buy2 max (sell1 - cost),
                    sell2 max (buy2 + cost)
                )
        }
        sell1 max.sell2
    }
}
```

###  1.25. <a name='BinaryTreeMaximumPathSum'></a>124. Binary Tree Maximum Path Sum

[花花酱](https://www.bilibili.com/video/BV1ct411r7qw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CT4y1g7bR?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qT4y1J71C?spm_id_from=333.999.0.0)

```py
我的思考：
        # 有两种情况：
        # node.val 往上回收, 构成递归
        return max(left,right) + node.val
        # node.val 不往上回收, 左中右
        res = max(left+right + node.val, res)

class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        res = -1e9
        # left = right = 0
        def dfs(node) -> int:
            nonlocal res # 也可以写成 self.res
            if not node:
                return 0
            # if node.left:
            left = max(dfs(node.left), 0)     # 正负性：left 为负，就不回收
            # if node.right:
            right = max(dfs(node.right), 0)   # 正负性：right 为负，就不回收
            # 有两种情况：node.val 不往上回收, 左中右
            res = max(left + right + node.val, res)
            # 有两种情况：node.val 往上回收, 构成递归
            return max(left,right) + node.val # 正负性：node.val必须回收
        dfs(root)
        return res
```

```scala
object Solution1 {
    def maxPathSum(root: TreeNode): Int = {
        dfs(root)._1
    }

    def dfs(node: TreeNode): (Int, Int) = {
      if (node == null) return (Int.MinValue, 0)
      
      val (leftSoFar, leftEndingHere) = dfs(node.left)
      val (rightSoFar, rightEndingHere) = dfs(node.right)

      val maxSoFar = leftSoFar max rightSoFar max (node.value + leftEndingHere + rightEndingHere)

      val maxEndingHere = 0 max (node.value + (leftEndingHere max rightEndingHere))
      (maxSoFar, maxEndingHere)
    }
}
```

###  1.26. <a name='ValidPalindrome'></a>125 【回文🌈】Valid Palindrome

[哈哈哈](https://www.bilibili.com/video/BV1d7411n7cF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7ML?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17h411Z7ey?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

isalnum() 方法检测字符串是否由字母和数字组成。

isalpha() 方法检测字符串是否只由字母组成。

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left = 0
        right = len(s) - 1
        while left < right:
            # 易错点：if not s[left].isalnum(): 是不对的，因为存在连续多个“非数字的情况”
            while left < right and not s[left].isalnum(): 
                left += 1
            while left < right and not s[right].isalnum(): 
                right -= 1
            if s[left].lower() == s[right].lower():
                left += 1
                right -= 1
            else:
                return False
        return True
```

python牛逼的一行代码：

```py
class Solution:
    def isPalindrome(self, s: str) -> bool:
        sgood = "".join(ch.lower() for ch in s if ch.isalnum())
        return sgood == sgood[::-1]

class Solution:
    def isPalindrome(self, s):
        s = ''.join(filter(str.isalnum,s)).lower()
        return s==s[::-1]

练习一下正则

import re
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s=re.sub('[^a-zA-Z0-9]','',s)
        s=s.lower()
        return s==s[::-1]
```


```scala

/**
* two pointer comparison
* memo
*  1. alphanumeric = letters + numerals
* time complexity: O(2N)
* space complexity: O(N)
*/

object Solution1 {
    def isPalindrome(s: String): Boolean = {
      val newString = s.filter(_.isLetterOrDigit).toLowerCase
      isPalindrome(newString, 0, newString.length - 1)
    }
    @annotation.tailrec
    def isPalindrome(s: String, left: Int, right: Int): Boolean = {
      if (left > right) return true
      if (s(left) == s(right)) isPalindrome(s, left + 1, right - 1)
      else false
    }
}
```


###  1.27. <a name='bfsWordLadderII'></a>126. (bfs好难暂时放弃) Word Ladder II

[花花酱](https://www.bilibili.com/video/BV1yt411Y7gH?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV16K4y1j7hX?spm_id_from=333.999.0.0)

```py
# dfs
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList:
            return []

        allpath = []
        visited = {beginWord}

        def findWords(target,words):
            res = []
            for word in words:
                n = len(target)
                for i in range(n):
                    if target[i] == word[i]: 
                        n -= 1
                if n == 1: 
                    res.append(word)
            return res


        def dfs(path,middlelist):
            nonlocal allpath
            if not middlelist:
                return
            if endWord in middlelist:
                path.append(endWord)
                allpath.append(path)
                return 
            for item in middlelist:
              if item not in path:
                dfs(path+[item],findWords(item,wordList))
        dfs([beginWord],findWords(beginWord,wordList))
        return allpath
    
if __name__ == "__main__":
  s = Solution()
  res = s.findLadders("hit","cog",["hot","dot","dog","lot","log","cog"])
  print('res:',res)

# res: [['hit', 'hot', 'dot', 'dog', 'cog'], 
# ['hit', 'hot', 'dot', 'lot', 'log', 'cog'], 
# ['hit', 'hot', 'lot', 'dot', 'dog', 'cog'], 
# ['hit', 'hot', 'lot', 'log', 'cog']]
```

```py
import collections
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList):
        if endWord not in wordList:
            return []
        lookup = collections.defaultdict(list)
        L = len(beginWord)
        for word in wordList:
            for i in range(L):
                lookup[word[:i] + '*' + word[i+1:]].append(word)
        
        res = []
        que = [(beginWord, 1, [[beginWord]])] # 终点，长度，path
        visited = {beginWord:[[beginWord]]}
        mindepth = len(wordList) + 1  # 剪枝
        print(visited)
        while que:
            cur, depth, paths = que.pop(0)
            if depth > mindepth: continue  # 剪枝           
            for i in range(L):
                dummyword = cur[:i] + '*' + cur[i+1:]
                for word in lookup[dummyword]:
                    if word == endWord:
                        for path in paths:
                            mindepth = depth  # 剪枝
                            res.append(path + [endWord])
                    elif word not in visited:
                        newPaths = [path+[word] for path in paths]
                        visited[cur] = newPaths
                        que.append((word, depth+1, newPaths))

        return res
    
if __name__ == "__main__":
  s = Solution()
  res = s.findLadders("hit","cog",["hot","dot","dog","lot","log","cog"])
  print('res:',res)
```

```py
把单词到通配串的路径生成，再把通配串到单词的路径生成，
然后再单向宽搜，写双向就更复杂了，单向速度也马马虎虎吧，148ms。 py

import collections
class Solution:
    def findLadders(self, beginWord: str, endWord: str, wordList) :
        lookup = collections.defaultdict(list)
        for word in wordList + [beginWord]:
            w = [*word]
            for i, c in enumerate(word):
                w[i] = '.'
                dummyword = ''.join(w)
                lookup[dummyword].append(word)
                lookup[word].append(dummyword)
                w[i] = c
        if endWord in lookup:
            que, visited = {beginWord: [[beginWord]]}, {beginWord}
            while que:
                # que是达到的点与路径的映射
                if endWord in que:
                    return [*que[endWord]]
                tmp = collections.defaultdict(set)
                
                for i in que:
                    for dummyword in lookup[i]:
                        for w in lookup[dummyword]:
                            if w not in visited:
                                tmp[w].update((*path, w) for path in que[i]) #看不懂更新path路径😂
                que = tmp
                visited.update(que.keys())
        return []
```

###  1.28. <a name='WordLadder'></a>127. Word Ladder

[花花酱](https://www.bilibili.com/video/BV1yt411Y7Me?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1BK4y157k1?spm_id_from=333.999.0.0)

```py
(压根没想到用虚拟节点的方法，用了最蠢的遍历a-z的方法。没想到竟然能通过= =)

附上我的低效python代码，仅供参考。

from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList):
        lookup = set(wordList)
        visited = set(['beginWord'])
        queue = deque([(beginWord, 1)])
        while queue:
            pop, depth = queue.popleft()
            if pop == endWord:
                return depth
            for i in range(len(pop)):
                for j in range(97, 123):
                    char26word = pop[:i] + chr(j) + pop[i+1:]
                    if char26word not in visited and char26word in lookup:
                        queue.append((char26word, depth + 1))
                        visited.add(char26word)
        return 0
```

```py
还有个更巧妙的想法，将 word 的某一位改为 '*' 作为 word 的 key。

例如 hit 的 key 为 '*it'、'h*t'、'hi*'。

在 wordList 中找到 key 相同的单词，即是能转换的单词。

于是提前将 wordList 的单词按 key 存在哈希表中，就可以进一步减少搜索范围到 len(word)。

from collections import deque
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        lookup = defaultdict(list)
        genKey = lambda w: [w[:i] + '*' + w[i+1:] for i in range(len(w))]
        for word in wordList:
            for dummyword in genKey(word):
                lookup[dummyword].append(word)
        queue, visited = deque([(beginWord, 1)]), {beginWord}
        while queue:
            word, depth = queue.popleft()
            for dummyword in genKey(word):
                for nextword in lookup[dummyword]:
                    if nextword not in visited:
                        if nextword == endWord:
                            return depth+1
                        visited.add(nextword)
                        queue.append([nextword, depth+1])
        return 0
```

###  1.29. <a name='LongestConsecutiveSequence'></a>128. 【🍒并查集】Longest Consecutive Sequence

[花花酱](https://www.bilibili.com/video/BV14t411Y7cg?spm_id_from=333.999.0.0)

[一俩三四五](https://www.bilibili.com/video/BV1LJ41137r2?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

###  1.30. <a name='SumRoottoLeafNumbers'></a>129 Sum Root to Leaf Numbers

[小明](https://www.bilibili.com/video/BV1VK411H7o5?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        sums = 0
        def dfs(node,cur):
            nonlocal sums
            if not node:
                return
            else:
                cur = cur*10 + node.val
                if not node.left and not node.right: # 易错点：不要忽视了这种情况
                    sums += cur
                    return
                else:
                    dfs(node.right,cur)
                    dfs(node.left,cur)
        dfs(root,0)
        return sums # 在根节点处cur为0，而不是sums


其他写法：

class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        ans = 0
        
        def dfs(root, acc):
            nonlocal ans
            if not root.left and not root.right:
                ans += acc * 10 + root.val
                return
            if root.left:
                dfs(root.left, acc*10+root.val)
            if root.right:
                dfs(root.right, acc*10+root.val)
        dfs(root, 0)
        return ans

```

```py
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return 0

        sums = 0
        que = collections.deque([(root,root.val)])
        
        while que:
            node, num = que.popleft()
            left, right = node.left, node.right
            if not left and not right:
                sums += num
            else:
                if left:
                    que.append((left, num * 10 + left.val))
                if right:
                    que.append((right, num * 10 + right.val))
        return sums
```

###  1.31. <a name='SurroundedRegions130-'></a>130. 【🍒并查集】Surrounded Regions 130-被围绕的区域

[花花酱](https://www.bilibili.com/video/BV1dE411f7U4?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV18y4y1j7JH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pV411k7TH?spm_id_from=333.999.0.0)


```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        f = {}
        def find(x):
            f.setdefault(x,x)
            if f[x]!=x:
                f[x] = find(f[x])
            return f[x]
        def union(x,y):
            f[find(y)] = find(x)
        if not board or not board[0]:
            return
        row,col = len(board),len(board[0])
        dummy = row*col
        for i in range(row):
            for j in range(col):
                if board[i][j] == "O":
                    if i == 0 or i == row - 1 or j == 0 or j == col - 1:
                        union(i * col + j, dummy)
                    else:
                        for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                            if board[i + x][j + y] == "O":
                                union(i * col + j, (i + x) * col + (j + y))
                                
        for i in range(row):
            for j in range(col):
                if find(dummy) == find(i * col + j):
                    board[i][j] = "O"
                else:
                    board[i][j] = "X"
```


```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        m = len(board)
        n = len(board[0])
        que = collections.deque()

        for i in range(m):
            for j in range(n):
                if i==0 or i==m-1 or j==0 or j==n-1: # 易错点：m 和 n 不要写反了
                    if board[i][j] == 'O':
                        que.append((i,j))

        while que:
            x,y = que.popleft()
            board[x][y] = 'A'
            for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                # 易错点：x+dx 和 x 不要写反了
                if 0 <= x+dx < m-1 and 0 <= y+dy < n-1 and board[x+dx][y+dy] == 'O': # 易错点：'O'不要写成0
                    board[x+dx][y+dy] = 'A'
                    que.append((x+dx,y+dy))

        for i in range(m):
            for j in range(n):
                # 易错点：== 和 = 不要写反了
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                elif board[i][j] == 'A':
                    board[i][j] = 'O'

        return board
```

另一种写法

```py
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return
        
        n, m = len(board), len(board[0])

        def dfs(x, y):
            if not 0 <= x < n or not 0 <= y < m or board[x][y] != 'O':
                return
            
            board[x][y] = "A"
            dfs(x + 1, y)
            dfs(x - 1, y)
            dfs(x, y + 1)
            dfs(x, y - 1)
        
        for i in range(n):
            dfs(i, 0)
            dfs(i, m - 1)
        
        for i in range(m - 1):
            dfs(0, i)
            dfs(n - 1, i)
        
        for i in range(n):
            for j in range(m):
                if board[i][j] == "A":
                    board[i][j] = "O"
                elif board[i][j] == "O":
                    board[i][j] = "X"
```



###  1.32. <a name='-1'></a>131 【回文🌈】分割回文🌈串

[哈哈哈](https://www.bilibili.com/video/BV1dK411p7eU?spm_id_from=333.999.0.0)

```py
# 递归解法
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtrack(startIndex):
            if startIndex == len(s):
                res.append(path[:])
                return
            
            for end in range(startIndex, len(s)):
                seg = s[startIndex:end+1]
                if seg == seg[::-1]:
                    path.append(seg)
                    backtrack(end+1)
                    path.pop()
            
        path = []
        res = []
        backtrack(0)
        return res

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)

        res = []
        path = []

        @cache
        def isPalindrome(i: int, j: int) -> int:
            if i >= j:
                return 1
            return isPalindrome(i + 1, j - 1) if s[i] == s[j] else -1

        def backtrack(startIndex: int):
            if startIndex == n:
                res.append(path[:])
                return
            
            for end in range(startIndex, n):
                if isPalindrome(startIndex, end) == 1:
                    path.append(s[startIndex:end+1])
                    backtrack(end + 1)
                    path.pop()

        backtrack(0)
        isPalindrome.cache_clear()
        return res

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # ------------------------ 背一背 ------------------------
        n = len(s)
        isPalinDP = [[True] * n for _ in range(n)]
        
        for start in range(n - 1, -1, -1): # start 指向 倒数第二位, start 向前扫描
            for end in range(start + 1, n): # end 指向 倒数第一位, end 向后扫描
                isPalinDP[start][end] = (s[start] == s[end]) and isPalinDP[start + 1][end - 1] 
        # ------------------------ 背一背 ------------------------

        res = []
        path = []

        def backtrack(startIndex: int):
            if startIndex == n:
                res.append(path[:])
                return
            
            for end in range(startIndex, n):
                if isPalinDP[startIndex][end]:
                    path.append(s[startIndex:end+1])
                    backtrack(end + 1)
                    path.pop()

        backtrack(0)
        return res



class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def backtrack(start):
            if start == len(s):
                ans.append(tmp[:])
                return
            
            for end in range(start+1, len(s)+1):
                seg = s[start:end]
                if seg == seg[::-1]:
                    tmp.append(seg)
                    backtrack(end)
                    tmp.pop()
            
        tmp = []
        ans = []
        backtrack(0)
        return ans


```

```py

python3 用回溯递归的方法去试探每一种可能性 对于一个字符串s，

有len(s)种方法把它分成左右两个部分（分割方法看代码），

假如左侧的不是回文🌈，则舍弃这次尝试；

假如左侧的是回文🌈串，则把右侧的进行递归的分割，并返回右侧的分割的所有情况

class Solution:
    @cache
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        res = []
        if n == 0:
            res.append([])

        for i in range(1, n+1):
            if s[:i] != s[:i][::-1]:
                continue
            left = [s[:i]]
            rights = self.partition(s[i:])
            for right in rights:
                res.append(left+right)
        return res


class Solution(object):
    def partition(self, s):

        n = len(s)
        res = []

        
        if n == 0:
            return [[]]
        if n == 1:
            return [[s]]


        for i in range(1, n+1):
            if s[:i] != s[:i][::-1]:
                continue
            left = [s[:i]]
            rights = self.partition(s[i:])
            for right in rights:
                res.append(left+right)
        return res


不需要预处理，没有递归，然后代码简洁的动态🚀规划

我真牛逼

class Solution:
    def partition(self, s: str):
        
        n = len(s)
        res = [[s[0]]]
        
# 下一个位置的分割结果 = 前一个位置所有分割结果 + 当前位置的字母s[i]得到的结果 
        for char in s[1:]:
            for path in res[:]: # 一定要写成res[:],而不是res
                
# + 判断前一个位置每个分割结果中最后一个回文🌈串和当前字母s[i]是否组成回文🌈串得到的结果 --> 也就是偶数个回文🌈
                if len(path[-1]) == 1 and path[-1] == char:
                    res.append(path[:-1] + [char + char])
                    
# + 判断前一个位置每个分割结果中最后两个回文🌈串和当前字母s[i]是否组成回文🌈串得到的结果 --> 也就是奇数个回文🌈
                if len(path) > 1 and len(path[-2]) == 1 and path[-2] == char:
                    res.append(path[:-2] + [char + path[-1] + char])
                    
                path.append(char)
        return res
```

###  1.33. <a name='PalindromePartitioningII'></a>132. 【动态🚀规划 + 回文🌈】Palindrome Partitioning II

[花花酱](https://www.bilibili.com/video/BV1NJ411v7k9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1944y1C71s?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5d4nophqby00.webp" width="70%">

```py
输入
"aab"

[0, inf, inf]
[0, 0, inf]
[0, 0, 1]

class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        isPalinDP = [[True] * n for _ in range(n)]
        
        for start in range(n - 1, -1, -1): # start 指向 倒数第二位, start 向前扫描
            for end in range(start + 1, n): # end 指向 倒数第一位, end 向后扫描
                isPalinDP[start][end] = (s[start] == s[end]) and isPalinDP[start + 1][end - 1] 

        cutDP = [float("inf")] * n
        for endcut in range(n):
            # 如果前一小段是回文🌈
            if isPalinDP[0][endcut]:
                cutDP[endcut] = 0
            # 如果前一小段不是回文🌈，则从start开始继续拆分
            else:
                for startcut in range(endcut):
                    if isPalinDP[startcut + 1][endcut]:
                        cutDP[endcut] = min(cutDP[endcut], cutDP[startcut] + 1) # 动态转移，将 cutDP[start] + 1处的转移过来
        
        return cutDP[n - 1]
```

###  1.34. <a name='CloneGraph'></a>133. Clone Graph

[小梦想家](https://www.bilibili.com/video/BV1wA411T7SM?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV18i4y1c7FE?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV12K411A7Zb?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1hzav19bp1wg.png" width="70%">

https://www.bilibili.com/video/BV1Cy4y127Di?from=search&seid=15236791324980694232&spm_id_from=333.337.0.0

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6d4fzq5ov200.png)


```py
class Solution(object):

    def __init__(self):
        self.visited = {}

    def cloneGraph(self, node):
        """
        :type node: Node
        :rtype: Node
        """
        if not node:
            return node
        # 递归结束条件：
        # 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回
        if node in self.visited:
            return self.visited[node]
        # 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表
        cloneNode = Node(node.val, [])
        # 哈希表存储
        self.visited[node] = cloneNode
        # 遍历该节点的邻居并更新克隆节点的邻居列表
        if node.neighbors:
            cloneNode.neighbors = [self.cloneGraph(n) for n in node.neighbors] # 递归在这里，neighbors里面是😁
        return cloneNode
```

```py
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        def dfs(nod): # dfs的本质在于赋值
            VisitDic[nod] = Node(nod.val)
            # 对node的neighbors,如果在目录里面，返回这些邻居的值nod.val,否则dfs
            VisitDic[nod].neighbors = [dfs(n) if n not in VisitDic else VisitDic[n] for n in nod.neighbors] # 递归在这里，neighbors里面是😁
            return VisitDic[nod]
        VisitDic = {}
        return dfs(node) if node else None

# bfs模板加一个dict记录即可！

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        visited = {}
        def dfs(nod,visited):
            if not nod:
                return None # dfs 返回的是neighbors
            elif nod in visited:
                # 易错点：return nod
                return visited[nod]
            else:
                visited[nod] = Node(nod.val)
                for neigh in nod.neighbors:
                    visited[nod].neighbors.append(dfs(neigh,visited))
            return visited[nod]
        return dfs(node,visited) # 易错点：一定要返回
```

```py
类似的三种写法：

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        nodecp = Node(node.val)
        visited = {node:nodecp}
        stack = [node]
        while stack:
            tmp = stack.pop() #
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) # 😁 注意，append是字典内的neigh，也就是 Node(node.val)
        return nodecp

类似的三种写法：


class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        visited = {}
        visited[node] = Node(node.val)
        stack = [node]
        while stack:
            tmp = stack.pop() 
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) 
        return visited[node]

类似的三种写法：

class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node:
            return None
        # visited + stack 两步骤
        visited = {}
        stack = [node]
        while stack:
            tmp = stack.pop() 
            if tmp not in visited: # 这行必须要有
                visited[tmp] = Node(tmp.val)
            for neigh in tmp.neighbors:
                if neigh not in visited:
                    # visited + stack 两步骤
                    visited[neigh] = Node(neigh.val)
                    stack.append(neigh)
                visited[tmp].neighbors.append(visited[neigh]) 
        return visited[node]
```


###  1.35. <a name='GasStation'></a>134. Gas Station

[小梦想家](https://www.bilibili.com/video/BV1BC4y1472f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1754y1176F?spm_id_from=333.999.0.0)

```py
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        start = 0
        curSum = 0
        totalSum = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            if curSum < 0:
                curSum = 0
                start = i + 1
        if totalSum < 0: return -1
        return start
```

###  1.36. <a name='CopyListwithRandomPointer'></a>138 Copy List with Random Pointer

[小明](https://www.bilibili.com/video/BV1BN411R7a8?spm_id_from=333.999.0.0)

###  1.37. <a name='SingleNumber'></a>136 【位运算😜】Single Number

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7bf?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Sp4y1D7M3?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Qb411e7PU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pa4y1t7tr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1iC4y1a7Hz?spm_id_from=333.999.0.0)

```py
class Solution:
    def singleNumber(self, nums):
        a = 0
        for num in nums:
            a = a ^ num
        return a

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, nums)
```

```scala
object Solution {
    def singleNumber(nums: Array[Int]): Int = {
        nums.reduce(_^_)
    }
}
```

###  1.38. <a name='SingleNumberII'></a>137 【位运算😜】Single Number II

[小明](https://www.bilibili.com/video/BV1Hv411B7rd?spm_id_from=333.999.0.0)

方法二：依次确定每一个二进制位

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1ro27dupbn40.webp)

```py
细节：

需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，

那么可能会得到错误的答案。

这是因为「有符号整数类型」（即 int 类型）的第 31 个二进制位（即最高位）是补码意义下的符号位，对应着 -2^{31}

而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2^{31}

因此在某些语言（例如 Python ）中需要对最高位进行特殊判断。

时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围

空间复杂度：O(1)

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ans = 0
        for i in range(32):
            total = sum((num >> i) & 1 for num in nums)
            if total % 3:
                # Python 这里对于最高位需要特殊判断
                if i == 31:
                    ans -= (1 << i)
                else:
                    ans |= (1 << i)
        return ans

这个解法看不懂，放弃：


时间复杂度：O(nlogC)，其中 n 是数组的长度，C 是元素的数据范围

空间复杂度：O(1)

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        ones, twos = 0, 0
        for num in nums:
            ones = ones ^ num & ~ twos
            twos = twos ^ num & ~ ones
        return ones
```





###  1.39. <a name='WordBreak'></a>139 【动态🚀规划 + 背包】Word Break

[小明](https://www.bilibili.com/video/BV1p54y1k7vf?spm_id_from=333.999.0.0)

```py
# python 动态🚀规划

# 从 i = 0 开始分析：i = 0， 遍历 j in range(1, n+1)， 

# 即遍历所有以 s[0]开头的组合，把第一个单词可能的情况全部找出来。

# 此时相当于把打头的单词可能的情况全部找出来了。

# 然后基于第一个单词一个单词一个单词地接上去。

class Solution:
    def wordBreak(self, s, wordDict):
        n = len(s) 
        dp = [True] + [False]*n

        for end in range(1, n + 1):
            for start in range(end):
                if dp[start] and s[start: end] in wordDict:
                    dp[end] = True # 说明s[: i] 在wordDict中
                    break # 优化部分：剩下的切分点j不用再寻找了，也可以不写，像下方一样
        return dp[-1]

```

###  1.40. <a name='WordBreakII'></a>140 Word Break II

[小明](https://www.bilibili.com/video/BV1ht4y1X7DJ?spm_id_from=333.999.0.0)

```py
# 直接回溯过了，这是样例出问题了还是标错难度了。。。
class Solution(object):
    def wordBreak(self, s, wordDict):
        res = []
        
        # 也是左右🐧切
        def backtrack(s, path):
            # nonlocal res
            if len(s) == 0:
                res.append(path[1:])
                return

            n = len(s)
            for i in range(n):
                if s[:i+1] in cash:
                    backtrack(s[i+1:], path+" "+s[:i+1])
                    
        backtrack(s, "")
        return res

class Solution:
    def wordBreak(self, s, wordDict):
        # @lru_cache(None)
        def backtrack(index: int):
            if index == len(s):
                return [[]]
            res = []
            for i in range(index + 1, len(s) + 1):
                left = s[index:i]
                if left in wordSet:
                    rightBreaks = backtrack(i)
                    for right in rightBreaks:
                        res.append(right[:] + [left])
            return res
        
        wordSet = set(wordDict)
        breakList = backtrack(0)
        return [" ".join(words[::-1]) for words in breakList]

class Solution(object):
    def wordBreak(self, s, wordDict):
        memo = {len(s): ['']}
        def sentences(i):
            if i not in memo:
                memo[i] = [s[i:j] + (tail and ' ' + tail)
                           for j in range(i+1, len(s)+1)
                           if s[i:j] in wordDict
                           for tail in sentences(j)]
            return memo[i]
        return sentences(0)
```

###  1.41. <a name='LinkedListCycle'></a>141-Linked List Cycle

[哈哈哈](https://www.bilibili.com/video/BV1g7411a7ta?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1hb411H7XP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1KX4y157vh?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1PA411b7gq?spm_id_from=333.999.0.0)

```py
方法一：集合 如果发现节点已在集合内则说明存在环

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            visited.add(head)
            head = head.next
            if head in visited:
                return True
        return False

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        visited = set()
        while head:
            if head in visited:
                return True
            visited.add(head)
            head = head.next
        return False

感觉初始时把快慢指针都指向 head 反而更简洁：

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
        
```


```scala
object Solution1 {
    def hasCycle(head: ListNode): Boolean = {
        
        var cur = head
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        
        var res: Boolean = false
        while (cur != null && res != true) {

            if(visited.contains(cur))  
                res = true
            else {
                visited += cur
                cur = cur.next
            }
        }
        res
    }
}


object Solution3 {
    def hasCycle(head: ListNode): Boolean = {
        var fast = head
        var slow = head
        
        
        var result = false
        while (fast != null && fast.next != null && result != true) {
            fast = fast.next.next
            slow = slow.next
        
            if(fast == slow) result = true
        }
        result
    }
}

object Solution {
    def hasCycle(head: ListNode): Boolean = {
        
        if(head == null){
            false
        }else{
        
        var slow = head
        var fast = head.next
        var output = true
        
        import scala.util.control.Breaks._
        breakable{
            while(slow != fast){
                if(fast == null || fast.next == null){
                    output=false
                    break
                }
                slow = slow.next
                fast = fast.next.next
            }
        }
        output
    }
    }
}

/**
* two pointer - tail recursive
*/
object Solution {
    def hasCycle(head: ListNode): Boolean = {
        if(head != null && head.next != null) 
            _hasCycle(head.next.next, head.next)
        else false
    }
    
    @annotation.tailrec
    def _hasCycle(fast: ListNode, slow: ListNode): Boolean = {
        if(fast == null || fast.next == null || slow == null) return false
        else if(fast == slow) return true
        else _hasCycle(fast.next.next, slow.next)
    }
}
//Alternate solution: Slow & Fast pointer
```

###  1.42. <a name='LinkedListCycleII'></a>142 Linked List Cycle II

[小明](https://www.bilibili.com/video/BV1W5411L7AF?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV15e41147EY?spm_id_from=333.999.0.0)

```py
我这个都在一个循环中，简洁点

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow, res = head, head, head
        flag = False

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if flag: res = res.next

            if slow == fast: flag = True
            if flag and slow == res: return res
        return None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            # 如果相遇
            if slow == fast:
                p = head
                q = slow
                while p!=q:
                    p = p.next
                    q = q.next
                #你也可以return q
                return p

        return None
```

```py
在for循环与while循环中的else语句块

旨在循环正常遍历了所有内容或由于循环条件不成立而结束循环时执行，

如果for循环与while循环因为break退出，则不执行else语句块中的内容。

continue对else没影响。 

这样在while循环之后使用else代码块，就可以达到代码中使用flag的效果

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head:
            return None
        fast, slow = head,  head
        while slow.next and fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        else:
            return None
        
        slow = head
        while slow != fast:
             slow = slow.next
             fast = fast.next
        return slow

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        # 首先初始化快指针和慢指针，确保快指针走的路的长度是慢指针长度的2倍
        if head and head.next:
            fast = head.next.next
            slow = head.next
        else:
            return None  # 说明无环

        # 进行循环，首先让快指针和慢指针第一次相遇
        while fast:
            if fast != slow:

                # 快指针走两步
                if fast.next:
                    fast = fast.next.next
                else:
                    return None  # 说明无环

                # 慢指针走一步
                slow = slow.next
            else:
                detection = head
                while detection != slow:  # 此时由于slow和fast是一样的，用哪个都行
                    slow = slow.next
                    detection = detection.next

                return detection

```

```scala
object Solution {
    def detectCycle(head: ListNode): ListNode = {
        val visited = new scala.collection.mutable.HashSet[ListNode]()
        var cur = head
        
        var result: ListNode = null

        while (cur != null && result == null) {
            // println(result)
            if(visited.contains(cur))  
                result = cur
            else {
                visited += cur
                cur = cur.next
            }
        }
        result
        
    }
}

```

###  1.43. <a name='ReorderList'></a>143 Reorder List

[小明](https://www.bilibili.com/video/BV1Jf4y1Q7y7?spm_id_from=333.999.0.0)

###  1.44. <a name='Preorderwithstack'></a>144-Preorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1HT4y1G74i?spm_id_from=333.999.0.0)

###  1.45. <a name='BinaryTreePreorderTraversal'></a>144-Binary Tree Preorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7NZ?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Ch411Q74P?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1RD4y1D7C7?spm_id_from=333.999.0.0)


```py
Python递归

class Solution(object):
    def preorderTraversal(self, root):
        if not root:
            return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
```

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def dfs(node):
            if not node:
                return
            res.append(node.val)
            dfs(node.left)
            dfs(node.right)
        
        res = []
        dfs(root)
        return res
```

stack

```py
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        ans = []
        if not root:
            return ans
        stack = [root]
        while stack:
            node = stack.pop()
            ans.append(node.val)
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return ans
```


###  1.46. <a name='Postorderwithstack'></a>145-Postorder with stack

[哈哈哈](https://www.bilibili.com/video/BV1Ti4y187jL?spm_id_from=333.999.0.0)

###  1.47. <a name='BinaryTreePostorderTraversal'></a>145-Binary Tree Postorder Traversal

[哈哈哈](https://www.bilibili.com/video/BV1n7411D7ub?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1uv411h7Gc?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1xZ4y1H7uS?spm_id_from=333.999.0.0)

```py
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def postorder(root: TreeNode):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = []
        postorder(root)
        return res

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        from collections import deque
        res, que = [], deque()
        que.append(root) if root else None
        while que:
            tmp = que.pop()
            res.append(tmp.val)
            que.append(tmp.left) if tmp.left else None
            que.append(tmp.right) if tmp.right else None
        return res[::-1]

class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return list()
        
        res = list()
        stack = list()
        prev = None

        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            if not root.right or root.right == prev:
                res.append(root.val)
                prev = root
                root = None
            else:
                stack.append(root)
                root = root.right
        
        return res

```

###  1.48. <a name='LRUCache'></a>146 【构造🏰】LRU Cache 

[花花酱](https://www.bilibili.com/video/BV19b411c7ue?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7c6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1t7zj?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ZQ4y1A74H?spm_id_from=333.999.0.0)

这个functools.lru_cache(None)的底层是怎么做的呀？ 

```py
def lru(f):
    d={}
    def wrapper(*args):
        if args not in d:
            d[args]=f(*args)
        return d[args]
    return wrapper
```

加个前缀和预处理，时间减少一半：

```py 
# 利用 super().__init__()
class LRUCache(collections.OrderedDict):

    def __init__(self, capacity: int):
        # super() 继承 collections.OrderedDict
        super().__init__()
        self.capacity = capacity


    def get(self, key: int) -> int:
        # 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 
        if key not in self:
            return -1
        self.move_to_end(key)
        return self[key]

    def put(self, key: int, value: int) -> None:
        # 如果关键字 key 已经存在，则变更其数据值 value
        if key in self:
            self.move_to_end(key)
        # 如果不存在，则向缓存中插入该组 key-value
        self[key] = value
        # 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
        if len(self) > self.capacity:
            self.popitem(last=False)
```


```py
# 利用 self.cache = collections.OrderedDict()
class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = collections.OrderedDict()

    写法 1：无 move_to_end
    def get(self, key):
        # 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 
        if key in self.cache:
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
        return -1

    写法 2：有 move_to_end
    def get(self, key):
        if key in self.cache:
            self.cache.move_to_end(key)
            return self.cache[key]
        return -1

    写法 1：无 move_to_end
    def put(self, key, value):
        # 如果关键字 key 已经存在，则变更其数据值 value
        if key in self.cache:
            self.cache.pop(key)
        # 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
        if len(self.cache) == self.capacity:
            self.cache.popitem(last=False)
                
        # 如果不存在，则向缓存中插入该组 key-value
        self.cache[key] = value

    写法 2：有 move_to_end
    def put(self, key, value):
        # 如果关键字 key 已经存在，则变更其数据值 value
        if key in self.cache:
            self.cache.move_to_end(key)
        # 如果不存在，则向缓存中插入该组 key-value
        self.cache[key] = value
        # 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)

```

```scala

/**
* chosen solution
* build-in linkedHashMap
* time complexity: O(1)
*/
class LRUCache0(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
    cache.get(key) match {
        case Some(v) => 
            cache.remove(key)
            cache.put(key, v)
            v
        case None => -1
    }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}



/**
* build-in linkedHashMap
*/
class LRUCache3(_capacity: Int) {

  private val capacity = _capacity
  val cache = collection.mutable.LinkedHashMap[Int, Int]()

  def get(key: Int): Int = {
  /**
   *cache.get(key).map{
   *   value =>
   *     cache.remove(key)
   *     cache.update(key, value)
   *     value
   * }.getOrElse(-1)
   */
   cache.get(key) match {
            case Some(v) => 
                cache.remove(key)
                cache.put(key, v)
                v
            case None => -1
        }
  }

  def put(key: Int, value: Int): Unit = {
    cache.get(key) match {
      case Some(_) =>
        cache.remove(key)
        cache.update(key, value)

      case None =>
        if(cache.size >= capacity){
          cache.remove(cache.head._1)
        }
        cache.put(key, value)
    }
  }
}

```

```scala
import scala.collection.mutable._

  class LRUCache(_capacity: Int) {

    val hm = HashMap[Int, Int]()
    val lb = ListBuffer.empty[Int]
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key)
      } else {
        -1
      }

    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val i = lb.indexOf(key)  // could be slow? O(N)?
        lb.remove(i)
        lb += key
        hm(key) = value
      } else {
        if (hm.size == c) {
          val lk = lb.head
          hm.remove(lk)
          lb.remove(0)
        }
        hm(key) = value
        lb += key
      }
    }
  }


// test case
//  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
//  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]

//  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]
  class LRUCache3(_capacity: Int) {
    val hm = HashMap[Int, Node]()
    val dl = new DoublyLinkedList()
    val c = _capacity

    def get(key: Int): Int = {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v
      } else { // not found
        -1
      }
    }

    def put(key: Int, value: Int) {
      if (hm.contains(key)) {
        val node = hm(key)
        dl.erase(node)
        dl.push_front(node)
        node.v.v = value
      } else {
        if (hm.size == c) {
          val old = dl.tail
          if (old!=null) {
            dl.erase(old)
            hm.remove(old.v.k)
          }
        }
        val node = Node(KV(key,value),null,null)
        hm(key) = node
        dl.push_front(node)
      }
    }
  }
```

```scala
  class Test extends BaseExtension {
    def init {
      val lru = new LRUCache(2)
      lru.put(1,1)
      lru.put(2,2)
      println(lru.get(1) == 1)
    }

    val name = "146 LRU chache"
  }

//  ["LRUCache","put","put","get","put","get","put","get","get","get"]
//  [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
  class Test2 extends BaseExtension {
    def init {
      val lru = new LRUCache2(2)
      lru.put(2,1)
      lru.put(1,1)
      lru.put(2,3)
      lru.put(4,1)
      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }

  //  ["LRUCache","put","put","put","put","put","get","put","get","get","put","get","put","put","put","get","put","get","get","get","get","put","put","get","get","get","put","put","get","put","get","put","get","get","get","put","put","put","get","put","get","get","put","put","get","put","put","put","put","get","put","put","get","put","put","get","put","put","put","put","put","get","put","put","get","put","get","get","get","put","get","get","put","put","put","put","get","put","put","put","put","get","get","get","put","put","put","get","put","put","put","get","put","put","put","get","get","get","put","put","put","put","get","put","put","put","put","put","put","put"]
  //  [[10],[10,13],[3,17],[6,11],[10,5],[9,10],[13],[2,19],[2],[3],[5,25],[8],[9,22],[5,5],[1,30],[11],[9,12],[7],[5],[8],[9],[4,30],[9,3],[9],[10],[10],[6,14],[3,1],[3],[10,11],[8],[2,14],[1],[5],[4],[11,4],[12,24],[5,18],[13],[7,23],[8],[12],[3,27],[2,12],[5],[2,9],[13,4],[8,18],[1,7],[6],[9,29],[8,21],[5],[6,30],[1,12],[10],[4,15],[7,22],[11,26],[8,17],[9,29],[5],[3,4],[11,30],[12],[4,29],[3],[9],[6],[3,4],[1],[10],[3,29],[10,28],[1,20],[11,13],[3],[3,12],[3,8],[10,9],[3,26],[8],[7],[5],[13,17],[2,27],[11,15],[12],[9,19],[2,15],[3,16],[1],[12,17],[9,1],[6,19],[4],[5],[5],[8,1],[11,7],[5,2],[9,28],[1],[2,2],[7,4],[4,22],[7,24],[9,26],[13,28],[11,26]]
  //  [null,null,null,null,null,null,-1,null,19,17,null,-1,null,null,null,-1,null,-1,5,-1,12,null,null,3,5,5,null,null,1,null,-1,null,30,5,30,null,null,null,-1,null,-1,24,null,null,18,null,null,null,null,-1,null,null,18,null,null,-1,null,null,null,null,null,18,null,null,-1,null,4,29,30,null,12,-1,null,null,null,null,29,null,null,null,null,17,22,18,null,null,null,-1,null,null,null,20,null,null,null,-1,18,18,null,null,null,null,20,null,null,null,null,null,null,null]

  class Test3 extends BaseExtension {
    def init {
      val lru = new LRUCache3(10)
      lru.put(10,13)
      lru.put(3,17)
      lru.put(6,11)
      lru.put(10,5)
      lru.put(9,10)

      println(lru.get(1) == -1)
      println(lru.get(2) == 3)
    }
    val name = "146 LRU chache xxxx"
  }
```

###  1.49. <a name='InsertionSortList'></a>147 Insertion Sort List

[小明](https://www.bilibili.com/video/BV1F54y1k7oU?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Ti4y187pN?spm_id_from=333.999.0.0)

```py
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        dummy = ListNode(0)
        dummy.next = head
        tmp = head
        cur = head.next

        while cur:
            if tmp.val <= cur.val:
                tmp = tmp.next
            else:
                pre = dummy
                while pre.next.val <= cur.val:
                    pre = pre.next
                tmp.next = cur.next
                cur.next = pre.next
                pre.next = cur
            cur = tmp.next
        
        return dummy.next

class Solution(object):
    def insertionSortList(self, head):
        if head == None or head.next == None:
            return head

        dummy = ListNode(0)
        dummy.next = head

        tmp = head 
        cur = head.next

        while cur:
            pre = dummy
            while pre.next.val <= cur.val and pre != tmp:
                pre = pre.next
            if pre != tmp:
                tmp.next = cur.next
                cur.next = pre.next
                pre.next = cur
            tmp = cur
            cur = cur.next

        return dummy.next


# 菜鸡版 python
class Solution:
    def insertionSortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        cur = head.next
        dummy.next.next = None
        while cur:
            pre = dummy
            while pre.next and cur.val > pre.next.val:
                pre = pre.next
            tmp = cur.next
            cur.next = pre.next
            pre.next = cur
            cur = tmp
        return dummy.next
```

###  1.50. <a name='SortList'></a>148. Sort List

[花花酱](https://www.bilibili.com/video/BV1jW411d7z7?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK411A7Gm?spm_id_from=333.999.0.0)

```py
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1, head)
        sortlist = []
        while(head is not None):
            aft = head.next
            head.next = None
            sortlist.append(head)
            head = aft
        sortlist = sorted(sortlist, key=lambda x: x.val)
        n = len(sortlist)
        if n == 0:
            return None
        dummy.next = sortlist[0]
        for i in range(n-1):
            sortlist[i].next = sortlist[i+1]
        
        return dummy.next
```

```py
# py3 归并排序，递归实现。空间复杂度主要在递归栈深度：O( log(n) )，整个递归过程有点像后序遍历

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        mid=self.findmid(head)
        left=head # 指定左右
        right=mid.next # 指定左右
        mid.next=None # 断开链接
        l=self.sortList(left)
        r=self.sortList(right)
        return self.merge(l,r)

    def findmid(self,head):
        slow=head
        fast=head
        while fast.next and fast.next.next:
            slow=slow.next
            fast=fast.next.next
        return slow

    def merge(self,l,r):
        dummy=ListNode(None)
        cur=dummy
        while l and r:
            if l.val<=r.val:
                cur.next=l
                l=l.next # 下一个
            else:
                cur.next=r
                r=r.next # 下一个
            cur=cur.next # 下一个
        cur.next=l or r
        return dummy.next

        # 基本用法：
        # v = p1 or p2

        # 它完成的效果等同于：
        # if p1:
        #     v = p1
        # else:
        #     v = p2
```

###  1.51. <a name='MaxPointsonaLine'></a>149. Max Points on a Line

[花花酱](https://www.bilibili.com/video/BV1zb411u7WW?spm_id_from=333.999.0.0)

###  1.52. <a name='EvaluateReversePolishNotation'></a>150. Evaluate Reverse Polish Notation

[花花酱](https://www.bilibili.com/video/BV14f4y127K8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16B4y1P7Nx?spm_id_from=333.999.0.0)

```py
class Solution:
    def evalRPN(self, tokens):
        f1 = lambda a,b:a+b
        f2 = lambda a,b:a-b
        f3 = lambda a,b:a*b
        f4 = lambda a,b:int(a/b)
        maps = {'+':f1,'-':f2,'*':f3,'/':f4}
        stack = []
        for i in tokens:
            if i in maps:
                a = stack.pop()
                b = stack.pop()
                stack.append(maps[i](b,a))
            else:
                i = int(i)
                stack.append(i)
        return stack[-1]

class Solution:
    def evalRPN(self, tokens):
        stack = []
        for item in tokens:
            if item not in {"+", "-", "*", "/"}:
                stack.append(item)
            else:
                first_num, second_num = stack.pop(), stack.pop()
                stack.append(
                    int(eval(f'{second_num} {item} {first_num}'))   # 第一个出来的在运算符后面
                )
        return int(stack.pop()) # 如果一开始只有一个数，那么会是字符串形式的

class Solution:
    def evalRPN(self, tokens):
        """
        解题思路:数字入栈，算数符号出栈两个数字栈并计算，计算结果入栈
        """
        stack = []
        
        for item in tokens:

            if item not in ['+', '-', '*', '/']:
                stack.append(int(item))
            else:
                a = stack.pop()
                b = stack.pop()
                if item == '+': stack.append(a + b)
                elif item == '-': stack.append(b - a)
                elif item == '*': stack.append(a * b)
                elif item == '/': stack.append(int(b / float(a)))   # 注意如何取整
        return stack[0]
```

###  1.53. <a name='ReverseWordsinaString'></a>151. Reverse Words in a String

[小梦想家](https://www.bilibili.com/video/BV1Yb411i7g4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1rT4y1g7AJ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ei4y1V7yA?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(reversed(s.split()))
```

```py
class Solution:
    def reverseWords(self, s: str) -> str:
        left, right = 0, len(s) - 1
        # 去掉字符串开头的空白字符
        while left <= right and s[left] == ' ':
            left += 1
        
        # 去掉字符串末尾的空白字符
        while left <= right and s[right] == ' ':
            right -= 1
            
        que, word = collections.deque(), []
        # 将单词 push 到队列的头部
        while left <= right:
            if s[left] == ' ' and word:
                que.appendleft(''.join(word))
                word = []
            elif s[left] != ' ':
                word.append(s[left])
            left += 1
        que.appendleft(''.join(word))
        
        return ' '.join(que)
```

```py
一种没有用split 和reverse的方法[^1]

分三步:

先翻转整个数组
再翻转单个单词
清除多余空格
class Solution:
    def reverseWords(self, s: str) -> str:
        s = list(s)
        n = len(s)
        #print(s)
        
        # 翻转数组
        def reverse(s, i, j):
            while i < j:
                s[i], s[j] = s[j], s[i]
                i += 1
                j -= 1

        # 翻转单个单词
        def word_reverse(s):
            # 用双指针找到一个单词
            i = 0
            j = 0
            while i < n:
                # 找到一个单词首字母
                while i < n and s[i] == " ":
                    i += 1
                j = i
                # 找到一个单词末位置
                while j < n and s[j] != " ":
                    j += 1
                reverse(s, i, j - 1)
                i = j

        # 清除多余空格
        def clean_space(s):
            i = 0
            j = 0
            while j < n:
                # 找到一个单词
                while j < n and s[j] == " ":
                    j += 1
                # 单词朝前移
                while j < n and s[j] != " ":
                    s[i] = s[j]
                    i += 1
                    j += 1
                # 移动下一个单词
                while j < n and s[j] == " ":
                    j += 1
                if j < n:
                    s[i] = " "
                    i += 1
            return "".join(s[:i])

        reverse(s, 0, n - 1)
        #print(s)
        word_reverse(s)
        #print(s)
        return clean_space(s)
```



###  1.54. <a name='-1'></a>152 【动态🚀规划】乘积最大子数组

[哈哈哈](https://www.bilibili.com/video/BV12a4y1i76G?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1iK411K7yG?spm_id_from=333.999.0.0)

maxdp * num, mindp * num, num

```py
# 动态🚀规划：遍历时，每次分别存储 前i个中连续数组 [最大的乘积和] 和 [最小乘积和]

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums: return 
        res = nums[0]
        maxdp = nums[0]
        mindp = nums[0]
        for num in nums[1:]:
            maxdp, mindp = max(maxdp * num, mindp * num, num), min(maxdp * num, mindp * num, num)
            res = max(res, maxdp)
        return res

# 之所有存 [最小乘积和]，是因为 [最小乘积和] 如果是负数有可能遇到负数，

# 相乘后结果更大 Python
```

```scala

object Solution2-1 {
    def maxProduct(nums: Array[Int]): Int = {
        
        val (_, _, ans) = (1 until nums.length).foldLeft((nums.head, nums.head, nums.head)){
            case ((min, max, ans), idx) => 
                val a = nums(idx) * min 
                val b = nums(idx) * max
                val newMin = a min b min nums(idx)
                val newMax = a max b max nums(idx)
                (newMin, newMax, ans max newMax)
        }
        ans
    }
}


object Solution0 {
  def maxProduct(nums: Array[Int]): Int = {
    val dp = Array.ofDim[Int](nums.length, 2) // record each position n's max product( from 0 to n)
    var result = nums(0)
    dp(0)(0) = nums(0)
    dp(0)(1) = nums(0)

    /* 0 for min, 1 for max */
    for (i <- 1 until nums.length) {
      val a = dp(i - 1)(0) * nums(i)
      val b = dp(i - 1)(1) * nums(i)
      dp(i)(0) = nums(i) min a min b // record min
      dp(i)(1) = nums(i) max a max b // record max
      result = result max dp(i)(1)
    }
    result
  }
}


/**
* optimize above one
* don't copy subArray during transmit parameters
* time complexity： O(N^2)
*/
object Solution {
  def maxProduct(nums: Array[Int]): Int = {
    (1 to nums.length).map(n =>  _maxProduct(nums(n - 1), n, nums)).max
  }
  def _maxProduct(curr: Int, idx: Int, nums: Array[Int]): Int = {
      if(idx >= nums.length) return curr   
      curr max  _maxProduct( curr * nums(idx), idx + 1, nums)
  }

}




object Solution {
    def maxProduct(nums: Array[Int]): Int = {
        if (nums == null || nums.size == 0) {
            return 0;
        }
        val list: List[Int] = nums.toList
        val head: Int = list.head
        val tail: List[Int] = list.tail
        _MaxProduct(tail, head, head, head)
    }
    
    def _MaxProduct(nums: List[Int], min: Int, max: Int, result: Int): Int = nums match {
        case Nil => result
        case x :: xs => {
            val cur_min = math.min(x, math.min(x * max, x * min))
            val cur_max = math.max(x, math.max(x * max, x * min))
            _MaxProduct(xs, cur_min, cur_max, math.max(cur_max, result))
        }
    }
}
```

###  1.55. <a name='-1'></a>153-寻找旋转排序数组中的最小值

[哈哈哈](https://www.bilibili.com/video/BV1bT4y1w7yK?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1yK411L7rp?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMin(self, nums):
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == nums[right]:    # 此时 left 和 right 相等，直接返回
                return nums[right]
            elif nums[mid] < nums[right]:   # 比右界小，nums[mid] 可能是最小值，不能去掉
                right = mid
            else:                           # 比右界大，nums[mid] 肯定不会是最小值     
                left = mid + 1

        return 1000000    # 这里写什么都无所谓，正常情况下不会走到这里的

# 二分法

class Solution:
    def findMin(self, nums):
        l,r= 0,len(nums) -1
        while l < r:
            if nums[l] < nums[r]:
                return nums[l]
            mid = (l + r) // 2
            if nums[mid] >= nums[r]:
                l = mid +1
            else:  
                r = mid
        return nums[l]
```

```scala

/**
* my first commitment binary search
*/
object Solution1 {
    def findMin(nums: Array[Int]): Int = {
        search(nums, 0, nums.length - 1)
    }
  
    def search(nums: Array[Int], left: Int, right: Int): Int = {
      if (left > right) return nums(left)
      val mid = left + (right - left) / 2
      val leftAns = if (nums(mid) >= nums(left)){ // left part in order
        nums(left)
      } else {
        search(nums, left, mid - 1)
      }
      
      val rightAns = if (nums(mid) <= nums(right)) { // right part in order
        nums(mid)
      } else {
        search(nums, mid + 1, right)
      }
      
      leftAns min rightAns
    }
}
``` 

###  1.56. <a name='FindMinimuminRotatedSortedArr'></a>154 Find Minimum in Rotated Sorted Arr

[小明](https://www.bilibili.com/video/BV1ik4y1B7de?spm_id_from=333.999.0.0)

###  1.57. <a name='MinStack'></a>155-【构造🏰】Min Stack

[哈哈哈](https://www.bilibili.com/video/BV1H74118748?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1YK4y1r77W?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ja4y1Y7vY?spm_id_from=333.999.0.0)

   
关键在于  def getMi

```py
我认为这个解法是错误的：
class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = [math.inf]

    def push(self, x: int) -> None:
        self.stack.append(x)
        self.minStack.append(min(x, self.minStack[-1]))
        # 导致 min 被 append 多次

    def pop(self) -> None:
        self.stack.pop()
        self.minStack.pop()
        # 这样，当 min 被 pop 掉了，minStack 仍然存有 min

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]




class MinStack:

    def __init__(self):
        # 另外用一个stack，栈顶表示原栈里所有值的最小值
        self.minStack = []
        self.stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.minStack == [] or self.minStack[-1] >= val:
            self.minStack.append(val)
            
    这样速度更快一点点：
    def push(self, val: int) -> None:
        self.stack.append(val)
        if self.minStack == []:
            self.minStack.append(val)
            return
        if self.minStack[-1] >= val:
            self.minStack.append(val)

    def pop(self) -> None:
        if self.stack[-1] == self.minStack[-1]:
            self.minStack.pop()
        return self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]


    def getMin(self) -> int:
        return self.minStack[-1]        
```

```py
面试的时候被问到不能用额外空间，就去网上搜了下不用额外空间的做法。思路是栈里保存差值。

class MinStack:
    def __init__(self):

        self.diffstack = []
        self.mins = -1

    def push(self, x: int) -> None:
        if not self.diffstack:
            self.diffstack.append(0)
            self.mins = x
        else:
            diff = x-self.mins
            self.diffstack.append(diff)
            self.mins = self.mins if diff > 0 else x
            # mins 是会变化的

    def pop(self) -> None:
        if self.diffstack:
            diff = self.diffstack.pop()
            if diff < 0: 
                # [3,2,1,4] [0,-1,-1, 3]
                # mins = 3, 2, 1, 1
                top = self.mins # 第一步：顺序不能错
                self.mins = self.mins - diff # 第二步：如果 diff < 0, 那就需要还原 self.mins
            else:     # 如果 diff 一直都 > 0, 那就非常好
                top = self.mins + diff
            return top

    def top(self) -> int:
        return self.mins if self.diffstack[-1] < 0 else self.diffstack[-1] + self.mins

    def getMin(self) -> int:
        return self.mins if self.diffstack else -1
```


```scala
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var min = Int.MaxValue

    def push(x: Int) {
        stack = stack :+ x
        if(x < min){
            min = x
        }
    }

    def pop() {
        stack = stack.init
        min = Int.MaxValue
        stack.map(x => {
            if(x < min) min = x
        })
    }

    def top(): Int = {
        stack.last
    }

    def getMin(): Int = {
        min
    }

}

//替代解决方案：更快
//这里我们将元素添加到列表中而不是附加
//请注意，由于List实际上是一个LinkedList，因此处理列表的“头部”要容易得多
//还有另一个列表来维护列表的最小元素
class MinStack() {

    /** initialize your data structure here. */
    var stack = List.empty[Int]
    var mins = List.empty[Int]

    def push(x: Int) {
        //如果我们将第二个条件设为 x < mins.head，则此行失败
        //with NoSuchElementException: 空列表的头部
        //为什么？？？
        if(mins.isEmpty || mins.head >= x) mins = x +: mins
        stack = x +: stack
    }

    def pop() {
        if(mins.head == stack.head) mins = mins.tail
        stack = stack.tail
    }

    def top(): Int = {
        stack.head
    }

    def getMin(): Int = {
        mins.head
    }

}

```

###  1.58. <a name='IntersectionofTwoLinkedLists'></a>160-Intersection of Two Linked Lists

[哈哈哈](https://www.bilibili.com/video/BV1n741187X6?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1eb411H7uq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV18K4y1J7wx?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1np4y1y789?spm_id_from=333.999.0.0)

```py
## 1. 哈希表

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        listA = set()
        while headA:
            listA.add(headA)
            headA = headA.next
        while headB:
            if headB in listA:
                return headB
            headB = headB.next
        return None

# > 时间复杂度 $O(M+N)$, 空间复杂度 $O(M)$

## 2. 双指针

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        pa,pb = headA, headB
        while pa != pb:
            pa = pa.next if pa else headB
            pb = pb.next if pb else headA
        return pa

# > 时间复杂度 $O(M+N)$, 空间复杂度 $O(1)$
```

```py

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        lengthA,lengthB = 0,0
        curA,curB = headA,headB
        while(curA!=None): #求链表A的长度
            curA = curA.next
            lengthA +=1
        
        while(curB!=None): #求链表B的长度
            curB = curB.next
            lengthB +=1
        
        curA, curB = headA, headB

        if lengthB>lengthA: #让curA为最长链表的头，lenA为其长度
            lengthA, lengthB = lengthB, lengthA
            curA, curB = curB, curA

        gap = lengthA - lengthB #求长度差
        while(gap!=0): 
            curA = curA.next #让curA和curB在同一起点上
            gap -= 1
        
        while(curA!=None):
            if curA == curB:
                return curA
            else:
                curA = curA.next
                curB = curB.next
        return None
```



```scala
/**
 * Definition for singly-linked list.
 * class ListNode(var _x: Int = 0) {
 *   var next: ListNode = null
 *   var x: Int = _x
 * }
 */

object Solution {
    
    def getIntersectionNode(headA: ListNode, headB: ListNode): ListNode = {
        var ha = headA
        var hb = headB
        
        while(ha != hb){
            if(ha == null){
                ha = headB
            }else{
                ha = ha.next
            }
            
            if(hb == null){
                hb = headA
            }else{
                hb = hb.next
            }
        }
        
        ha
    }
}

```

###  1.59. <a name='FindPeakElement'></a>162. Find Peak Element

[小梦想家](https://www.bilibili.com/video/BV1Rb411n7dT?spm_id_from=333.999.0.0)

```py
# 努力接受了一下。就是想象一下峰顶在中间，那么左右两侧都是有序的，可根据mid和mid+1的值判断当前是在哪一侧，然后最后定位到峰值
class Solution(object):
    def findPeakElement(self, nums):
        l = 0 
        r = len(nums) - 1 

        while l <= r:
        	mid = (l + r) >> 1

        	if l == r : return l # 关键在于这里

        	if nums[mid] < nums[mid+1]: # 关键在于这里，背一背吧
        		l = mid + 1
        	else:
        		r = mid
```

###  1.60. <a name='CompareVersionNumbers'></a>165. Compare Version Numbers

[小梦想家](https://www.bilibili.com/video/BV19K4y1C7L3?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pk4y117dF?spm_id_from=333.999.0.0)

```py
简洁版

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        for x, y in zip_longest(version1.split('.'), version2.split('.'), fillvalue='0'):
            a, b = int(x), int(y)
            if a != b: return 1 if a > b else -1
        return 0 

```

```py
python 精简版

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1 = version1.split(".")
        v2 = version2.split(".")

        while v1 or v2:
            x = int(v1.pop(0)) if v1 else 0
            y = int(v2.pop(0)) if v2 else 0

            if x>y:
                return 1
            elif x<y:
                return -1
        return 0
```

###  1.61. <a name='FractiontoRecurringDecimal'></a>166. Fraction to Recurring Decimal

[小梦想家](https://www.bilibili.com/video/BV1Wb411e7PE?spm_id_from=333.999.0.0)

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # ----------情况一：没有余数----------
        if numerator % denominator == 0:
            return str(numerator // denominator)
        # ----------情况一：没有余数----------


        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        s = []

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if (numerator < 0) != (denominator < 0):
            s.append('-')
        # ----------------得到负数----------------
        # ----------------得到负数----------------


        # 整数部分
        numerator = abs(numerator)
        denominator = abs(denominator)
        integerPart = numerator // denominator
        s.append(str(integerPart))
        s.append('.')

        # 小数部分
        indexMap = {}
        remainder = numerator % denominator
        while remainder and remainder not in indexMap:
            indexMap[remainder] = len(s) 

            # 这里需要一个计数器，s的长度递增，所以用len(s)
            # 解法二中：
            # i = 0
            # i += 1
            # 也是可以的。
            # len(s) 可以直接指向 insertIndex-插入位置

            print("余数remainder: ",indexMap.keys())
            remainder *= 10
            s.append(str(remainder // denominator))
            remainder %= denominator
        if remainder:  # 有循环节
            insertIndex = indexMap[remainder]
            s.insert(insertIndex, '(') #左侧插入
            s.append(')')

        return ''.join(s)
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
```

```py
class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        dic = {}
        res = []

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if numerator*denominator<0:
            sign = "-"
        else:
            sign = ""
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator = abs(numerator)
        denominator = abs(denominator)
        intPart,res = divmod(numerator, denominator)


        # ----------情况一：没有余数----------
        if res==0:
            return sign + str(intPart)
        # ----------情况一：没有余数----------
        
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        res.append(str(intPart))
        res.append(".")

        dic[res]= len(res) # 是 2
        while res!=0:
            intPart,res = divmod(10*res,denominator)
            res.append(str(intPart))
            # 如果余数出现在字典中，加上（）并返回
            if res in dic:
                res.insert(dic[res],"(") #左侧插入
                res.append(")")     #右侧插入
                return sign + "".join(res)
            # 继续记录余数和(索引位置
            
            dic[res] = len(res) # i+=1
        # 如果余数为0
        return sign + "".join(res) 
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """
        # 处理整数部分
        ans = ""

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        if numerator * denominator < 0:
            ans += "-"
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart, res = divmod(numerator, denominator)
        # ans += f"{q}"
        ans += str(intPart)


        # ----------情况一：没有余数----------
        if 0 == res:
            return ans
        # ----------情况一：没有余数----------

        
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        ans += '.'
        # 小数部分：除法发现循环节
        index = len(ans)  # 小数点后一个位置
        numerator = res * 10  # 被除数增加十倍
        dic = {numerator: index}
        while True:
            intPart, res = divmod(numerator, denominator)
            ans += str(intPart)
            if res == 0:
                break
            numerator = res * 10
            if numerator in dic:  # 发现循环节
                return ans[:dic[numerator]] + f"({ans[dic[numerator]:]})" # 直接加括号（）
            dic[numerator] = index + 1  # 新被除数位置
            index += 1
        return ans
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------

class Solution:
    def fractionToDecimal(self, numerator, denominator):
        """
        :type numerator: int
        :type denominator: int
        :rtype: str
        """

        # ----------------得到负数----------------
        # ----------------得到负数----------------
        sign = "" if numerator * denominator >= 0 else "-"
        # ----------------得到负数----------------
        # ----------------得到负数----------------

        numerator, denominator = abs(numerator), abs(denominator)
        intPart = numerator // denominator

        # ----------情况一：没有余数----------
        if numerator % denominator == 0: return sign + str(intPart)
        # ----------情况一：没有余数----------

        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
        res, dic, index = numerator % denominator, {}, 3
        ans = [sign, str(intPart), "."]
        while res:
            if res not in dic:
                dic[res] = index
            else:
                ans.insert(dic[res], "(")
                ans.append(")")
                break
            res *= 10
            ans.append(str(res // denominator))
            res %= denominator
            index += 1
        return "".join(ans)
        # -----------情况二：有余数-----------
        # -----------情况二：有余数-----------
```

###  1.62. <a name='TwoSumII-Inputarrayissorted'></a>167-Two Sum II - Input array is sorted

[哈哈哈](https://www.bilibili.com/video/BV167411h7ou?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7id?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1VZ4y1M7eu?spm_id_from=333.999.0.0)

```py
python 3 有点二分法的味道

    # 双指针
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r =0, n-1 
        while l <= r:
            if numbers[l] + numbers[r] == target:
                return [l+1, r+1]
            elif numbers[l] + numbers[r] < target:
                l +=1
            else:
                r -=1
        return [-1, -1]

    # hasn表，利用hash表记录所有的差值
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        visited = dict()
        for index, num in enumerate(numbers):
            if num in visited:
                return [visited[num]+1, index+1]
            visited[target - num] = index
```

###  1.63. <a name='ExcelSheetColumnTitle'></a>168-Excel Sheet Column Title

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7FY?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H777?spm_id_from=333.999.0.0)

```py
## A的ascii码为65
# 又想了好久才知道在哪里减一。。
class Solution:
    def convertToTitle(self, n: int) -> str:
        res = ''
        while(n):
            n -= 1
            res = chr(n%26+65) + res
            n = n//26
        return res



class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        res = ""

        while columnNumber-1 >= 0:
            columnNumber -= 1
            res += chr(columnNumber % 26 + ord('A'))
            columnNumber //= 26
        return res[::-1]

class Solution(object):
    def convertToTitle(self, columnNumber):
        res = ''
        while columnNumber:
            columnNumber -= 1
            res = chr(columnNumber % 26 + 65) + res
            columnNumber = columnNumber // 26 
        return res
```

###  1.64. <a name='MajorityElement'></a>169. 【位运算😜】Majority Element

[花花酱](https://www.bilibili.com/video/BV1hb411c7bF?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7pW?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ff4y1U7Vn?spm_id_from=333.999.0.0)


![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.45eeyfyac6g0.webp)

```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        res = 0
        k = len(nums)//2
        for i in range(32):
            ones = 0
            for n in nums:
                ones += (n >> i) & 1
                if ones > k:
                    if i == 31:
                        res -= 1 << i
                    else:
                        res |= 1 << i
                    break
        return res
```

```py
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        return sorted(nums)[len(nums) // 2]

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        nums.sort()
        return nums[len(nums) // 2]


class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        counts = collections.Counter(nums)
        return max(counts.keys(), key=counts.get)

# 投票策略，半数以上获胜

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        count = 0
        candidate = None

        for vot in nums:
            if count == 0:
                candidate = vot
            count += (1 if vot == candidate else -1)

        return candidate
```

```scala
/**
* HashMap
* time complexity: O(N)
* space complexity: O(N)
*/

object Solution2 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.groupBy(identity).mapValues(_.length).maxBy(_._2)._1  
    }
}


/**
* sorting array and pick middle element
* time complexity O(NlogN)
*/

object Solution3 {
    def majorityElement(nums: Array[Int]): Int = {
        nums.sorted(Ordering.Int)(nums.length / 2)
    }
}
```


```scala

/**
* chosen solution
* 投票测量
* Boyer-Moore Voting Algorithm
* time complexity N(N)
* space complexity O(1)
*/
object Solution
    def majorityElement(nums: Array[Int]): Int = {
      var counter = 0
      var candidate = nums(0)
      for (idx <- 1 until nums.length) {
        val vot = nums(idx)
        if(candidate == vot)
          counter += 1
        else {
          if(counter == 0)
            candidate = vot
          else
            counter -= 1
        }
      }
      candidate
    }
}


object Solution1 {
  def majorityElement(nums: Array[Int]): Int = {
    var candidate = nums(0)
    var counter = 0
    candidate.foreach { vot =>
      if (candidate == vot) {
        counter += 1
      } else {
        counter -= 1
        if (counter == 0) {
          candidate = vot
          counter += 1
        }
      }
    }
    candidate
  }
}


//Alternate solution O(n) but NO EXTRA SPACE
object Solution {
    def majorityElement(nums: Array[Int]): Int = {     
        var candidate = nums.head
        var count = 0
        nums.foreach(vot => {
            if(count == 0) { 
                candidate = vot
                count = 0
            }
            if(vot == candidate) count+=1;
            else count-=1;
        })
        
        candidate
    }
}

```

###  1.65. <a name='ExcelSheetColumnNumber'></a>171. Excel Sheet Column Number

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7nT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1h541187Sv?spm_id_from=333.999.0.0)

```py
# python 从左到右遍历
        #26进制转10进制
class Solution:
def titleToNumber(self, columnTitle: str) -> int:
        res = 0
        for char in columnTitle:
            res *= 26
            res += ord(char) - ord('A') + 1 
        return res
```


```scala
//Alternate solution
object Solution {
    def titleToNumber(s: String): Int = 
        s.foldLeft(0)((acc, ch) => acc * 26 + (ch - 'A' + 1))
}

```

###  1.66. <a name='FactorialTrailingZeroes'></a>172-Factorial Trailing Zeroes

[哈哈哈](https://www.bilibili.com/video/BV1hE411n7TM?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7tS?spm_id_from=333.999.0.0)

```py
class Solution:
    def trailingZeroes(self, n: int) -> int:
        # Calculate n!
        factorial = 1
        for i in range(2, n + 1):
            factorial *= i
        # Count how many 0's are on the end.
        res = 0
        while factorial % 10 == 0:
            res += 1
            factorial //= 10
            
        return res



class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n > 0:
            n //= 5
            ans += n
        return ans


class Solution:
    def trailingZeroes(self, n: int) -> int:
        ans = 0
        while n >= 5:
            ans += n//5
            n = n//5
        return ans
```

```scala
object Solution {
    def trailingZeroes(n: Int): Int = {
        var count5 = 0
        var count2 = 0
        
        var temp = n
        while(temp>=5){
            count5 += temp/5
            temp = temp/5
        }
        
        temp = n
        while(temp>=2){
            count2 += temp/2
            temp = temp/2
        }
        
        if(count5 < count2) count5 else count2
    }
}

```

###  1.67. <a name='BinarySearchTreeIterator'></a>173 【构造🏰】Binary Search Tree Iterator

[小明](https://www.bilibili.com/video/BV1qK41137h1?spm_id_from=333.999.0.0)

```py
# next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。

class BSTIterator(object):

    def __init__(self, root):
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self):
        tmp = self.stack.pop()
        res = tmp.val

        tmp = tmp.right
        while tmp:
            self.stack.append(tmp)
            tmp = tmp.left
        return res

    def hasNext(self):
        # 直接写也可以：return self.stack 
        return self.stack != []



class BSTIterator(object):
    def __init__(self, root):
        self.stack = []
        self.pushAllLeft(root)
        

    def hasNext(self):
        return self.stack != []
        

    def next(self):
        tmp = self.stack.pop()
        self.pushAllLeft(tmp.right)
        return tmp.val
            
    def pushAllLeft(self, node):
        while node:
            self.stack.append(node)
            node = node.left
```

递归解法不符合题目：不能用递归 应该用迭代

###  1.68. <a name='DungeonGame'></a>174 Dungeon Game

[小明](https://www.bilibili.com/video/BV1TK411W7T1?spm_id_from=333.999.0.0)

###  1.69. <a name='LargestNumber'></a>179 Largest Number

[小明](https://www.bilibili.com/video/BV1mV411m7aN?spm_id_from=333.999.0.0)

```py
from functools import cmp_to_key
class Solution(object):
    def largestNumber(self, nums):
        # 比较函数
        def compare(a, b):
            return int(b + a) - int(a + b)
        nums = sorted([str(x) for x in nums], key=cmp_to_key(compare))
        return str(int(''.join(nums)))
```

```py
class Solution:
    def largestNumber(self, nums):
        # 第一步：定义比较函数，把最大的放左边
        # 第二步：排序
        # 第三步：返回结果
        def compare(x, y): return int(y+x) - int(x+y)
        nums = sorted(map(str, nums), key=cmp_to_key(compare))
        return "0" if nums[0]=="0" else "".join(nums)
```

```py
# 大小的比较不是常规的字符串比较
# 正常来说'30' > '3' 但是'303' < '330'
# 需要自己定义排序规则
import functools
class Solution:
    def largestNumber(self, nums):

        res = []
        for i in nums:
            res.append(str(i))

        def cmp(a,b):
            return 1 if (a+b) < (b+a) else -1
        res.sort(key=functools.cmp_to_key(cmp))
        return str(int(''.join(res)))
```

```py
class Solution:
    def largestNumber(self, nums):
        nums = sorted([str(x) for x in nums],reverse=True)
        for i in range(len(nums)-1):
            for j in range(i,len(nums)):
                if str(nums[i]) + str(nums[j]) < str(nums[j]) + str(nums[i]):
                    nums[i],nums[j] = nums[j],nums[i]
        return str(int(''.join(nums)))
```

###  1.70. <a name='ReverseWordsinaStringII'></a>186. Reverse Words in a String II 

[哈哈哈](https://www.bilibili.com/video/BV1GV411Z7fo?spm_id_from=333.999.0.0)

###  1.71. <a name='RepeatedDNASequences'></a>187. ★【位运算😜】【滑动窗口，dic】Repeated DNA Sequences

#### 类似567，但这里用了dic进行比较

[小明](https://www.bilibili.com/video/BV1mp4y1r7v5?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7cqchvpxojw0.webp)

时间复杂度：O(N)，其中 N 是字符串 s 的长度。

空间复杂度：O(N)。

```py


class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        if len(s) < 11: return []

        bins = { "A":  0,
              "C" : 1,
              "G":  2,
              "T":  3 }

        ans = []
        cntDIC = defaultdict(int) # record the appearance time

        x = 0
        for i in range(10): # 转换成二进制存储起来可以减小空间复杂度
            x += bins[s[i]] << (i * 2)
        cntDIC[x] = 1
        
        for i in range(10, len(s)):
            x >>= 2  # 滑动窗口
            x += bins[s[i]] << 18 # 滑动窗口

            cntDIC[x] = cntDIC[x] + 1
            if cntDIC[x] == 2:
                ans.append(s[i - 9:i + 1]) # find the result

        return ans

```

###  1.72. <a name='BestTimetoBuyandSellStockIV'></a>188 【动态🚀规划】Best Time to Buy and Sell Stock IV

[小明](https://www.bilibili.com/video/BV1f54y1k7cX?spm_id_from=333.999.0.0)

```py
# 背一背
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices:
            return 0

        buy = [prices[0]] * (k+1)
        sell = [0] * (k+1)
        for price in prices:
            for time in range(1,k+1): 
                # 对于每一个新来的价格，依 time 比较 and 更新
                buy[time-1] = min(buy[time-1],  price - sell[time-1])
                sell[time]  = max(sell[time], price - buy[time-1])
                # print('价格:',price,'次数:',time,'buy:',buy)
                # print('价格:',price,'次数:',time,'sell:',sell)
                
        return sell[k]


if __name__ == "__main__":   
	s = Solution()
	print(s.maxProfit(k = 2, prices = [3,2,6,5,0,3,-1,3]))

价格: 3 次数: 1 buy: [3, 3, '*']
价格: 3 次数: 1 sell: [0, 0, 0]
价格: 3 次数: 2 buy: [3, 3, '*']
价格: 3 次数: 2 sell: [0, 0, 0]
--------------------
价格: 2 次数: 1 buy: [2, 3, '*']
价格: 2 次数: 1 sell: [0, 0, 0]
价格: 2 次数: 2 buy: [2, 2, '*']
价格: 2 次数: 2 sell: [0, 0, 0]
--------------------
价格: 6 次数: 1 buy: [2, 2, '*']
价格: 6 次数: 1 sell: [0, 4, 0]
价格: 6 次数: 2 buy: [2, 2, '*']
价格: 6 次数: 2 sell: [0, 4, 4]
--------------------
价格: 5 次数: 1 buy: [2, 2, '*']
价格: 5 次数: 1 sell: [0, 4, 4]
价格: 5 次数: 2 buy: [2, 1, '*']
价格: 5 次数: 2 sell: [0, 4, 4]
--------------------
价格: 0 次数: 1 buy: [0, 1, '*']
价格: 0 次数: 1 sell: [0, 4, 4]
价格: 0 次数: 2 buy: [0, -4, '*']
价格: 0 次数: 2 sell: [0, 4, 4]
--------------------
价格: 3 次数: 1 buy: [0, -4, '*']
价格: 3 次数: 1 sell: [0, 4, 4]
价格: 3 次数: 2 buy: [0, -4, '*']
价格: 3 次数: 2 sell: [0, 4, 7]
--------------------
价格: -1 次数: 1 buy: [-1, -4, '*']
价格: -1 次数: 1 sell: [0, 4, 7]
价格: -1 次数: 2 buy: [-1, -5, '*']
价格: -1 次数: 2 sell: [0, 4, 7]
--------------------
价格: 3 次数: 1 buy: [-1, -5, '*']
价格: 3 次数: 1 sell: [0, 4, 7]
价格: 3 次数: 2 buy: [-1, -5, '*']
价格: 3 次数: 2 sell: [0, 4, 8]
--------------------
8


```




```scala
/**
* chosen solution
* dynamic programming
* memo 
*    1: using an 3-dim array to record previous state
*     dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's restrictions
*  space complexity: O(K),  worst case: O(N)N
*/ 
object Solution0 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
/**
* my first commitment
* dynamic programming
* memo 
*    1: using an 3-dim array to record all previous state
*         dp[state index][k times transaction][buy or sell]
*     dp definition: dp[i][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
*  time complexity: O(NK), N: the length of prices; k: transaction's constraint
*/
object Solution1 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum
    val profits = Array.ofDim[Int](prices.length, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val ii = (i + prices.length - 1) % prices.length
      profits(i)(j)(1) = profits(ii)(j)(1)  max ( profits(ii)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(i)(j)(0) = profits(ii)(j)(0)  max ( profits(ii)(j - 1)(1) - prices(i)) // buy
      else
        profits(i)(j)(0) = profits(ii)(j)(0)  max  - prices(i) // buy
    }

    profits(prices.length - 1).map(_.max).max
  }
}

/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/

object Solution1-2 {
  def maxProfit(k: Int, prices: Array[Int]): Int = {
    if(prices == null || prices.length < 2 || k < 1 ) return 0
    if(k * 2 >=  prices.length) return prices.sliding(2).collect{case arr if arr(1) > arr(0) => arr(1) - arr(0)}.sum


    val profits = Array.ofDim[Int](2, k, 2)

    for{
      i <- profits.indices
      j <- 0 until k
    }{
      profits(i)(j)(0) = Int.MinValue  // hold
      profits(i)(j)(1) = 0 // sell
    }

    for {
      i <- prices.indices
      j <- 0 until k
    } {
      val currentI = (i + 1) % 2
      val preciousI = i % 2
      profits(currentI)(j)(1) = profits(preciousI)(j)(1)  max ( profits(preciousI)(j)(0) + prices(i)) // sell
      if (j > 0)
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max ( profits(preciousI)(j - 1)(1) - prices(i)) // buy
      else
        profits(currentI)(j)(0) = profits(preciousI)(j)(0)  max  - prices(i) // buy
    }
    profits(prices.length % 2).map(_.max).max // prices.length % 2: decide the newest status index
  }

  private def debugProfits(profits: Array[Array[Array[Int]]]): Unit = {
        profits.zipWithIndex.foreach{
          case (p, i) =>
            println(s"status: $i")
            p.zipWithIndex.foreach{
            case (pp, j) =>
                println(s"transaction $j: hold: ${pp(0)}, sell: ${pp(1)}")
          }
            println(" ")
        }
  }
}
/**
* dp: decrease status array which only keep current and precious status
* memo
*    1. dp definition: dp[2][j][l] means the best profit we can have at i-th day using EXACT j transactions and with/without stocks in hand.
* time complexity: O(NK), N: the length of prices; k: transaction's constraint
* space complexity: O(K),  worst case: O(N)
*/
object Solution1-3 {
    def maxProfit(k: Int, prices: Array[Int]): Int = {
        if(prices == null || prices.length < 2 || k < 1 ) return 0
        val kk = if(2 * k > prices.length) prices.length / 2 else k
        
        val dp = Array.tabulate(2, kk, 2) {
            case (_, _, 0) => Int.MinValue
            case (_, _, 1) => 0
            case _ => 0
        }
        
        for(i <- prices.indices; j <- 0 until kk){
            val current = i & 1
            val previous = current ^1
            // 0 for buy, 1 for sell
            dp(current)(j)(1) = dp(previous)(j)(1) max (dp(previous)(j)(0) + prices(i))
            dp(current)(j)(0) = dp(previous)(j)(0) max {
                if(j == 0) -prices(i)
                else dp(previous)(j - 1)(1) - prices(i)
            }
            
        }
        
        dp((prices.length - 1) & 1).map(_(1)).max
        
    }
}
```

###  1.73. <a name='RotateArray'></a>189. Rotate Array 

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7Yy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N541177Bk?spm_id_from=333.999.0.0)

```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        r = k % len(nums)
        if r:
            nums[:] = nums[::-1]
            nums[:r] = nums[:r][::-1]
            nums[r:] = nums[r:][::-1]

class Solution:
    def rotate( nums, k):
        n = len(nums)
        k = k % n
        for _ in range(k):
            nums.insert(0,nums.pop())

class Solution:
    def rotate(self, A: List[int], k: int) -> None:
        def reverse(i, j):
            while i < j:
                A[i], A[j] = A[j], A[i]
                i += 1
                j -= 1
        n = len(A)
        k %= n
        reverse(0, n - 1)
        reverse(0, k - 1)
        reverse(k, n - 1)
```


```py
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        nums[: ] = nums[-k % len(nums): ] + nums[: -k % len(nums)]

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        nums[: ] = (nums[i] for i in range(-(k % len(nums)), len(nums) - k % len(nums)))
```

###  1.74. <a name='ReverseBits'></a>190. 【位运算😜】Reverse Bits

[花花酱](https://www.bilibili.com/video/BV1NJ411k7VP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qv411i7Wg?spm_id_from=333.999.0.0)

```py
class Solution:
    def reverseBits(self, n: int) -> int:
        ret = 0
        for i in range(32):
            ret = (ret << 1) + (n & 1)
            n >>= 1
        return ret

# 每次只对最低位进行操作，理论上效率高于对 31 的循环


 10001111011110101
 b & (-b) = 1
 b & (-b) = 100
 b & (-b) = 10000

这个解法很妙，好好体会

class Solution:
    def reverseBits(self, n: int) -> int:
        b = n & ((1 << 32) - 1)
        base = 1 << 31
        ans = 0
        while b:
            ans |=  base // (b & (-b)) # b & (-b)找到最后一个 1
            # ans |=  base 表示移动项
            b &= b-1 # 消掉最后一个1
        return ans    
```

字符串转整数

```py
class Solution:
    def reverseBits(self, n):
        return int(bin(n)[2:].zfill(32)[::-1],2)
        # print(bin(n)[2:])
        # print(bin(n))
        # 10100101000001111010011100
        # 0b 10100101000001111010011100
```


```scala
object Solution {
    // you need treat n as an unsigned value
    def reverseBits(x: Int): Int = {
        var binaryString = x.toBinaryString.toList
        
        var additional = (1 to (32 - binaryString.length)).map(_ => '0').toList
        
        binaryString = additional ++ binaryString
        
        val reversed = reverseBinary(binaryString, "")
        
        Integer.parseUnsignedInt(reversed.mkString, 2)
    }
    
    def reverseBinary(x: List[Char], str: String): String = x match{
        case Nil => str
        case x::xs => reverseBinary(xs, x + str)
    }
}

```

###  1.75. <a name='Numberof1Bits'></a>191 Number of 1 Bits

[小明](https://www.bilibili.com/video/BV1i5411J7SA?spm_id_from=333.999.0.0)

```py
class Solution:
    def hammingWeight(self, n: int) -> int:
        ret = sum(1 for i in range(32) if n & (1 << i)) 
        return ret

class Solution:
    def hammingWeight(self, n: int) -> int:
        return ('{:0b}'.format(n).count('1'))

class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')
#  python 输入的是10进制的 直接转str不行 可以试试 bin(n) 将10进制 转成 二进制然后 count
```

```py
# 从1开始，每次<<一位，与n做与运算，如果不为0，则该位为1
class Solution:
    def hammingWeight(self, n: int) -> int:

        res = 0
        while n:
            n &= n - 1
            res += 1
        return res

class Solution:
    def hammingWeight(self, n: int) -> int:
        a, res = 0, 0
        while a <= 32:
            if (1<<a)&n != 0:
                res += 1
            a += 1
        return res
```

```scala

// 使用位操作:x = x & (x -1)将最后一个非零pos设置为零  

//Alternate(需要理解这里发生了什么)和num, num-1  
// num & num-1返回最后一个SET位  
//交替位移位和计数1  

object Solution{
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        _hammingWeight(n, 0)
    }
    
    @annotation.tailrec
    def _hammingWeight(n: Int, counter: Int): Int = {
        if(n  == 0) counter
        else _hammingWeight(n & (n - 1), counter + 1 )
    }
}


object Solution0 {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {

        var mask = 1
        var counter = 0
        for (_ <- 0 to 32) {

            if ((n & mask) != 0) {
                counter += 1
            }
            mask  = mask << 1
        }
        counter
    }
}


def hammingWeight(n: Int): Int = {
        var count = 0
        var num   = n

        while (num != 0) {
            if ((num & 1) > 0) { count = count + 1 }
            num = num >>> 1
        }
    count
}

def hammingWeight(n: Int): Int = {
        var counter = 0
        var num = n         
        while (num != 0) {
            counter += 1
            num &= (num-1)                
        }
        counter
    }

```

```scala
object Solution {
    // you need treat n as an unsigned value
    def hammingWeight(n: Int): Int = {
        n.toBinaryString.toCharArray.filter(_ == '1').length
    }
}
```

###  1.76. <a name='HouseRobber198-'></a>198. 【动态🚀规划】House Robber 198-打家劫舍

[12:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1tW411676f?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1u64y1M7PA?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7hu?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gZ4y1N75c?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV18g4y1i7f9?spm_id_from=333.999.0.0)

```py
动态🚀规划，典型例题：
class Solution:
    def rob(self, nums: List[int]) -> int:
        dp0 = 0
        dp1 = 0
        for num in nums:
            dp0, dp1 = dp1, max(dp0 + num, dp1)
        return dp1
```


```scala
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else if(nums.length == 1){
            nums(0)
        }else if(nums.length == 2){
            Math.max(nums(0), nums(1))
        }else{
            Math.max(
                nums(0) + rob(nums.drop(2)),
                nums(1) + rob(nums.drop(3))
            )
        }
    }
}

//The above solution worked for small input arrays
//but had MEMORY LIMIT EXCEEDED for large input

//While using DP: we try to store values of repetitive calculations
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.length == 0){
            0
        }else{
            var dp = Array.fill(nums.length+1)(0)
            
            dp(0) = 0
            dp(1) = nums(0)
            (1 to nums.length-1).map(i => {
                dp(i+1) = Math.max(dp(i), dp(i-1) + nums(i))
            })
            
            dp(nums.length)
        }
    }
}

//Another way to do the same
object Solution {
    def rob(nums: Array[Int]): Int = {
        if(nums.isEmpty){
            0
        }else{
            var rob = nums(0)
            var no_rob = 0
            var prev = rob
            for(i <- 1 until nums.length){
                prev = rob
                rob = no_rob + nums(i)
                no_rob = Math.max(prev, no_rob)
                
            }
            Math.max(no_rob, rob)
        }
    }
}

```

###  1.77. <a name='BinaryTreeRightSideView'></a>199 Binary Tree Right Side View

[小明](https://www.bilibili.com/video/BV1854y1W7CB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xK4y1b7Wh?spm_id_from=333.999.0.0)

```py

class Solution:
    def rightSideView(self, root: TreeNode):
        dic, dfs = {}, lambda node, startI: node and (dic.__setitem__(startI, node.val) or dfs(node.left, startI + 1) or dfs(node.right, startI + 1))
        return dfs(root, 0) or [*dic.values()]
# __setitem__:每当属性被赋值的时候都会调用该方法，因此不能再该方法内赋值 self.name = value 会死循环
#  bfs 层序遍历，每次保留最后一个值stack

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root: return []
        ans = []
        stack = deque([root])
        while stack:
            for _ in range(len(stack)):
                node = stack.popleft()
                if node.left: stack.append(node.left)
                if node.right: stack.append(node.right)
            ans.append(node.val)
        return ans

# 基础方法，层次遍历：

class Solution:
    def rightSideView(self, root: TreeNode):
        res, level = [], root and [root]
        while level:
            res.append(level[-1].val)
            level = [right for tree in level for right in (tree.left, tree.right) if right]
        return res

# 老层序遍历了

class Solution:
    def rightSideView(self, root: TreeNode):
        if not root:
            return []
        res = []
        node = [root]
        while node:
            tmpNode = []
            for n in node:
                if n.left:
                    tmpNode.append(n.left)
                if n.right:
                    tmpNode.append(n.right)
            res.append(node[-1].val)
            node = tmpNode
        return res

# 递归

class Solution:
    def rightSideView(self, root: TreeNode):
        res = []
        def dfs(node, startIndex):
            if node:
                startIndex == len(res) and res.append(node.val)
                dfs(node.right, startIndex + 1)
                dfs(node.left, startIndex + 1)
        dfs(root, 0)
        return res
```

###  1.78. <a name='-1'></a>200 【🍒并查集】岛屿数量

[哈哈哈](https://www.bilibili.com/video/BV15K411p72j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Cg4y1i7dZ?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1KK4y1U7Ds?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1E64y1T7Nk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Np4y1977S?spm_id_from=333.999.0.0)

[一俩三四五](https://www.bilibili.com/video/BV114411q7sP?from=search&seid=1135814820928819139&spm_id_from=333.337.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3v3ayrrcjf60.png" width="50%">

```py
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        f = {}
        def find(x):
            f.setdefault(x,x)
            if f[x]!=x:
                f[x] = find(f[x])
            return f[x]
        def union(x,y):
            f[find(y)] = find(x)
            
        if not grid:
            return 0
        row,col =len(grid),len(grid[0])
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    for x, y in [[-1, 0], [0, -1]]:
                        tmp_i = i + x
                        tmp_j = j + y
                        if 0 <= tmp_i < row and 0 <= tmp_j < col and grid[tmp_i][tmp_j] == "1":
                            union(tmp_i * col + tmp_j, i * col + j)
        res = set()
        for i in range(row):
            for j in range(col):
                if grid[i][j] == "1":
                    res.add(find(col*i+j))
        return len(res)
```

```py
# dfs
from pprint import pprint
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m, n = len(grid), len(grid[0]) # 行列
        ans = 0
        # 就像是把岛屿一个个蚕食
        def dfs(i, j): 
            if 0 <= i < m and 0 <= j < n and grid[i][j] == '1':   # 补充边界条件，防止溢出
                grid[i][j] = '0' # dfs置为0
                dfs(i + 1, j)  # 遍历4个领域
                dfs(i - 1, j)  # 遍历4个领域
                dfs(i, j - 1)  # 遍历4个领域
                dfs(i, j + 1)  # 遍历4个领域

        for i in range(m): # 行列
            for j in range(n): # 行列
                if grid[i][j] == '1': # 如果grid[i][j]为1，则dfs
                    pprint(grid)
                    ans += 1
                    dfs(i, j)
        return ans

# 看了别人的代码，写的真美 ╮(╯_╰)╭ 啊

class Solution(object):
    def numIslands(self, grid):
        def dfs(gird, used, row, col, x, y):
            if gird[x][y] == '0' or used[x][y]:
                return 
            used[x][y] = True

            if x!= 0:
                dfs(grid, used, row,col, x-1,y)
            if x!= row -1 :
                dfs(grid, used, row,col, x+1, y)
            if y!= 0:
                dfs(grid, used, row,col, x, y-1)
            if y!= col - 1:
                dfs(grid, used, row,col, x, y+1)


        row = len(grid) # 行列
        col = len(grid[0]) if row else 0 # 行列

        used = [[0 for i in range(col)] for i in range(row)]

        count = 0
        for i in range(row): # 行列
            for j in range(col): # 行列
                if grid[i][j] == '1' and not used[i][j]: # 如果grid[i][j]为1，则dfs
                    dfs(grid,used,row,col,i,j)
                    count += 1
        return count

class Solution:
    def dfs(self, grid, r, c):
        grid[r][c] = 0
        nr, nc = len(grid), len(grid[0]) # 行列
        for x, y in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:
            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                self.dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid) # 行列
        if nr == 0:
            return 0
        nc = len(grid[0]) # 行列

        num_islands = 0
        for r in range(nr): # 行列
            for c in range(nc): # 行列
                if grid[r][c] == "1": # 如果grid[i][j]为1，则dfs
                    num_islands += 1
                    self.dfs(grid, r, c)
        
        return num_islands
```

```py
# 厉害的解法：Sink and count the islands.
class Solution(object):
    def numIslands(self, grid):
        def sink(i, j):
            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '1':
                grid[i][j] = '0'
                map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1))
                return 1
            return 0
        return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[0])))

```

```scala
/**
* chosen solution
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/

object Solution0 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}


/**
* my first commit
* dfs + floodfill
* time complexity: O(N * M) N is the grid length, M is the grid width
*/
object Solution1 {
    private val endLabel = '0'
    def numIslands(grid: Array[Array[Char]]): Int = {
        // val gridReplica = grid.map(_.clone).toArray
        val coords = for (i <- grid.indices; j <- grid(0).indices) yield (i, j)        
        coords.foldLeft(0){case (count, coord) => if(_dfs(grid, coord))  count + 1 else count}
        
    }
    
    def _dfs(grid: Array[Array[Char]], coord: (Int, Int)): Boolean = {
        val (row, col) = coord
        if(grid(row)(col) == endLabel) return false
        
        grid(row)(col) = endLabel
        getValidNeighbors(coord, (grid.length, grid(0).length)).foreach {
            case (nr, nc) if grid(nr)(nc) != endLabel => _dfs(grid, (nr, nc))
            case _ =>
        }
        true
    }
    
    private val getValidNeighbors = (coord: (Int, Int), shape: (Int, Int)) => {
        List(
            (coord._1 + 1, coord._2),
            (coord._1, coord._2 + 1),
            (coord._1 - 1, coord._2),
            (coord._1, coord._2 - 1)
        ).filter{case (row, col) => 0 <= row  && row < shape._1 && 0 <= col && col < shape._2}
    }
}

/**
* Union & Find 
* memo
*    1. without modify original grid's elements
* time complexity: O(N * M) both N M is the dimension of grid 
*     both union and find operation's amortized time complexity in UnionFind class are very very close to 1 but not 1
*/


object Solution {
  private val endLabel = '0'
  def numIslands(grid: Array[Array[Char]]): Int = {
    val unionFind = new UnionFind(grid)
    for(i <- grid.indices; j <- grid(0).indices)
      union((i, j), unionFind, grid)
    unionFind.counter

  }

  def union(coord: (Int, Int), unionFind: UnionFind, grid: Array[Array[Char]]): Unit = {
    val (row, col) = coord
    if(grid(row)(col) == endLabel) return

    neighbors(coord, (grid.length, grid(0).length)).foreach {
      case (nr, nc) if grid(nr)(nc) != endLabel  =>
        unionFind.union(coord, (nr, nc))
      case _ =>
    }
  }

  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{ case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}

```

###  1.79. <a name='BitwiseANDofNumbersRange'></a>201 【位运算😜】Bitwise AND of Numbers Range

[小明](https://www.bilibili.com/video/BV1dT4y1g75m?spm_id_from=333.999.0.0)


```py
时间复杂度：
log(n)

空间复杂度：
1

我们知道，数组的数字是连续的，
我们只要找出m,n的做左边起的最长相同的二进制头部即可呀。
```

```py
关键在于找规律：

当二进制位数不同时，一定为0     
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while m < n:
            # 抹去最右边的 1
            n = n & (n - 1)
        return n


只要找到规律，那么暴力法依然给力，核心思想是：
如果m与n在二进制下的位数不一样，那么必须得0，
然后只算m,n在二进制位数一样的情况下，来个暴力解法，就可以通过，而且速度不慢额，代码如下：

class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        if len(bin(m))<len(bin(n)):
            return 0
        else:
            temp=m
            for each in range(m+1,n+1,1):
                temp&=each
            return temp
```


```scala
  object Solution {
    def rangeBitwiseAnd(m: Int, n: Int): Int = {
      var count = 0
      var m1 = m
      var n1 = n
      while (m1!=n1) {
        m1 >>= 1
        n1 >>=1
        count+=1
      }
      m1<<count
    }
  }
```

###  1.80. <a name='HappyNumber'></a>202. 快乐数 Happy Number

[官方](https://www.bilibili.com/video/BV1Ca4y1v7Qr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CA41187LQ?spm_id_from=333.999.0.0)

判断是否成环，和之前的链表的题目类似

```py
如果他不是快乐数，
那么他肯定在某些数存在不停循环的过程，

class Solution:
    def isHappy(self, n: int) -> bool:
        res = []
        while 1:
            n = sum([ int(i)**2 for i in str(n)])
            if n == 1:
                return True
            else:
                if n not in res:
                    res.append(n)
                else:
                    return False

class Solution:
    def isHappy(self, n: int) -> bool:  
        def getNext(number):
            sqSum = 0
            while number > 0:
                number, digit = divmod(number, 10)
                sqSum += digit ** 2
            return sqSum

        slow = n
        fast = getNext(n)
        while fast != 1 and slow != fast:
            slow = getNext(slow)
            fast = getNext(getNext(fast))
        return fast == 1
```

```py
class Solution:
    def isHappy(self, n: int) -> bool:
        def getNext(n):
            sqSum = 0
            while n > 0:
                n, digit = divmod(n, 10)
                sqSum += digit ** 2
            return sqSum

        visited = set()
        while n != 1 and n not in visited:
            visited.add(n)
            n = getNext(n)

        return n == 1

class Solution:
    def isHappy(self, n: int) -> bool:
        def getNext(number):
            sqSum = 0
            
            # 从个位开始依次取，平方求和
            while number:
                sqSum += (number % 10) ** 2
                number = number // 10
            return sqSum
        # 记录中间结果
        visited = set()

        while True:
            n = getNext(n)
            if n == 1:
                return True
            # 如果中间结果重复出现，说明陷入死循环了，该数不是快乐数
            if n in visited:
                return False
            else:
                visited.add(n)


```

```scala
object Solution {
    
    def getDigitSquaresSum(num: Int) = {
        num.toString.map(_.asDigit).map(x => x*x).foldLeft(0)(_ + _)
    }
    
    def isHappy(n: Int): Boolean = {
        var num = n
        var set = scala.collection.mutable.HashSet.empty[Int]
        var flag = true
        while(flag){
            if(num == 1){
                flag = false
            }else if(set.contains(num)){
                flag = false
            }else{
                set.add(num)
                num = getDigitSquaresSum(num)
            }
        }
        
        num == 1
    }
}

```

```scala

  object Solution {
    def isHappy(n: Int): Boolean = {
      def next(x:Int): Int ={
        x.toString().map(e=> (e-'0')*(e-'0')).sum
      }

      def solve(x:Int, m:Set[Int]): Boolean = x match {
        case 1 => return true
        case x if m.contains(x) =>return false
        case x =>solve(next(x), m+x)
      }
      solve(n, Set[Int]())
    }
  }

```

###  1.81. <a name='RemoveLinkedListElements'></a>203. Remove Linked List Elements

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7bf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Yi4y137WA?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Sz411b7zw?spm_id_from=333.999.0.0)

```py
首先处理特殊情况

然后开始双指针，一前一后，一起走

当后面的节点值等于val时，前面指针不动，后面指针继续走，直到节点的值!=val

此时把前面指针的next指向后面节点，即把中间这些值为val的节点删除了

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        if head == None:  #处理[]
            return head
        while head != None and head.val == val:  #处理[7,7,7,7,1]
            head = head.next
        if head == None:  #处理[7,7,7,7]
            return head

        slow, fast = head, head.next
        while fast != None:
            if fast.val == val:
                while fast != None and fast.val == val:
                    fast = fast.next
                slow.next = fast
            else:
                slow = slow.next
                fast = fast.next
        return head
```

```py
class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        cur = head #操作对象是同一块内存 id(temp)=id(head)
        while cur:
            if cur.next and cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        if head and head.val == val: #头节点等于val的情况单独拿出来
            return head.next
        else:
            return head

class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy = ListNode(next=head) #添加一个虚拟节点
        cur = dummy
        while(cur.next!=None):
            if(cur.next.val == val):
                cur.next = cur.next.next #删除cur.next节点
            else:
                cur = cur.next
        return dummy.next


class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        dummy = ListNode(1)
        dummy.next = head
        cur = dummy
        while head:
            if head.val == val:
                cur.next = head.next
            else:
                cur = head
            head = head.next   
        return dummy.next
```

```scala
  object Solution {
    def removeElements(head: ListNode, `val`: Int): ListNode = {
      val dummy = ListNode(0)
      dummy.next = head
      var prev = dummy
      var cur = head
      while (cur!=null) {
        if (cur.x != `val`) {
          prev.next = cur
          prev = cur
        } else {
          prev.next = null
        }
        cur = cur.next
      }
      dummy.next
    }
  }
}

```

###  1.82. <a name='CountPrimes'></a>204-Count Primes

[哈哈哈](https://www.bilibili.com/video/BV167411w7Sf?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7cV?spm_id_from=333.999.0.0)

```py
# 埃氏筛代码重点理解一下j从i*i开始吧，

# 因为计算i*i之前就计算了i*2，i*3...,i*(i-1)。 

# 这题搜到一个非常牛逼的算法,叫做厄拉多塞筛法. 

# 比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,

# 然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,

# 然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,

# 再把5所有的倍数划去.以此类推.

# 代码的实现上用了非常好的技巧:

# 即i是从(2,int(n**0.5)+1)而非(2,n).这个技巧是可以验证的,

# 比如说求9以内的质数个数,那么只要划掉sqrt(9)以内的质数倍数,

# 剩下的即全为质数. 所以在划去倍数的时候也是从i*i开始划掉,而不是i+i.

class Solution:
    def countPrimes(self, n) -> int:
        if n < 3:
            return 0     
        else:
            # 首先生成了一个全部为1的列表
            isPrime = [1] * n
            # 因为0和1不是质数,所以列表的前两个位置赋值为0
            isPrime[0],isPrime[1] = 0,0
             # 此时从index = 2开始遍历,output[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引
             # 全部赋值为0. 此时output[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推.
            for i in range(2,int(n**0.5)+1): 
                if isPrime[i] == 1:
                    isPrime[i*i:n:i] = [0] * len(isPrime[i*i:n:i])
         # 最后output中的数字1表明该位置上的索引数为质数,然后求和即可.
        return sum(isPrime)

import math
from math import sqrt
class Solution(object):
    def countPrimes(self, n):
        isprime = [1]*n
        for i in range(2,int(sqrt(n))+1):
            if isprime[i]:
                for j in range(i*i,n,i):
                    isprime[j] = 0
        count = 0
        for i in range(2,n):
            if isprime[i]:count += 1
        return count

# 这个解法真是太赞了!又学到了很多~~~ 和大家分享一下
class Solution(object):
    def countPrimes(self, n):

        isPrime = [1 for i in range(n)]

        i = 2
        while i * i < n:
        	if isPrime[i]:
        		j = i * i 
        		while j < n :
        			isPrime[j] = 0
        			j += i
        	i += 1

        return sum(isPrime[2:])
```

```scala
object Solution {
    def countPrimes(n: Int): Int = {
        
        //Sieve of Eratosthenes
        
        var primeArray = Array.fill(n)(false)
        (2 until n).map(i => primeArray(i) = true)
        
        //We need to check for all numbers i, where i < sqrt(n)
        //To avoid doing sqrt operation again & again (since its expensive)
        //We can do i*i < n
        
        var i =2
        while(i*i < n){
            if(primeArray(i)){
                var j = i*i
                while(j < n){
                    primeArray(j) = false
                    j += i //because we are only checking multiple of i for each i in iteration
                }
            }
            i+=1
        }
        
        primeArray.filter(x => x).length
    }
}

```


###  1.83. <a name='isomorphicstrings'></a>205. isomorphic strings

[小梦想家](https://www.bilibili.com/video/BV1ab411H7ZS?spm_id_from=333.999.0.0)

```py
满足题目要求的同构字符串即两个字符串的字符之间是双射或者说一一对应的关系，假设s字符串对应的集合是S，t字符串对应的集合是T，则双射关系要求：

S的元素个数、T的元素个数、S与T之间的映射个数三者都相等，则只需要一行代码即可：

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) == len(set(zip(s,t)))

从评论区@StrayCamel 搬运更 Pythonic 的写法：

原回答：

补充一个python3

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        return len(set(s)) == len(set(t)) and len(set(s)) == len(set(zip(s, t)))
```

```py
例如字符串 adsds 和 opfpf

a 和 o 是映射关系 d 和 p 是映射关系 s 和 f 是映射关系 那么

adsds.index('a') ==  opfpf.index('o')
 adsds.index('d') ==  opfpf.index('p')
 adsds.index('s') ==  opfpf.index('f')

这三个是不是恒成立

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        n = len(s)
        for i in range(n):
            if s.index(s[i]) != t.index(t[i]):  # 两个字符在各自字符串中第一次出现的位置相同，表示可以重构
                return False
        else:
            return True
```

```py          
采用两个dict，互相指向，构成双射。发现了冲突，也就是一个字母可能对应了两个不同的字母，就说明两个字符串不是同构了。

class Solution(object):
    def isIsomorphic(self, s, t):
        if len(s) != len(t):
            return False
        
        lookup1 = dict()
        lookup2 = dict()
        for c1,c2 in zip(s,t):
            if (c1 in lookup1 and lookup1[c1] != c2) or (c2 in lookup2 and lookup2[c2] != c1) :
                return False
            lookup1[c1] = c2
            lookup2[c2] = c1        
        return True


class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(t) != len(s):
            return False
        lookup1 = {}
        lookup2 = {}
        for i in range(len(s)):
            c1, c2 = s[i], t[i]
            if c1 not in lookup1:
                lookup1[c1] = c2
            if c2 not in lookup2:
                lookup2[c2] = c1
            if lookup1[c1] != c2 or lookup2[c2] != c1:
                return False
        return True 

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        lookup1 = {}
        lookup2 = {}
        for c1, c2 in zip(s, t):
            # 这个get默认值用的好，满足了还没有完成配对字符出现的None值的情况
            if lookup1.get(c1, c2) != c2 or lookup2.get(c2, c1) != c1:
                return False
            lookup1[c1] = c2
            lookup2[c2] = c1
        return True


class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        if len(s) != len(t): return False

        dic = dict()
        for i in range(len(s)):
            if s[i] not in dic and t[i] not in dic.values():
                dic[s[i]]=t[i]
            elif s[i] in dic and dic[s[i]] == t[i]:
                pass
            else:return False
        return True
```

```scala
  object Solution {
    def isIsomorphic(s: String, t: String): Boolean = {
      val m:HashMap[Char,Char] = HashMap[Char,Char]()
      val n:HashMap[Char,Char] = HashMap[Char,Char]()

      s.indices.foreach(
        idx=>idx match {
          case idx if m.contains(s(idx)) && m(s(idx))!=t(idx) => return false
          case idx if n.contains(t(idx)) && n(t(idx))!=s(idx) => return false
          case idx =>{
            m(s(idx))=t(idx)
            n(t(idx))=s(idx)
          }
        }
      )
      true
    }
  }
```

###  1.84. <a name='ReverseLinkedList'></a>206-Reverse Linked List

[哈哈哈](https://www.bilibili.com/video/BV1Q7411V7zr?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV16Q4y1M767?spm_id_from=333.999.0.0)

```py
前置条件：迭代指针：p = head、结果指针：res = none

以1->2->3->4->5为例：

过程：

res:None

第一层循环

res:1->2->3->4->5 res = p

res:1->None res.next = res

p:2->3->4->5 p = p.next

第二层循环

res:2->3->4->5 res = p

res:2->1->None res.next = res

p:3->4->5 p = p.next

第三层循环

res:3->4->5 res = p

res:3->2->1->None res.next = res

p:4->5 p = p.next

第四层循环

res:4->5 res = p

res:4->3->2->1->None res.next = res

p:5 p = p.next

第五层循环

res:5 res = p

res:5->4->3->2->1->None res.next = res

p:None p = p.next

end...

class Solution:
    def reverseList(self, head):
        pre, res = head, None
        while pre:
            res = pre
            res.next = res
            pre = pre.next
        return res
```

```py
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        """ 还有一种方法，不需要使用首元结点 
            1 -> 2 -> 3 -> 4    可以依次逆序每个指针
            1 <- 2 <- 3 <- 4    4变为了新的表头
            和头插法一样， 需要注意改变节点指针的时候，不能影响到 遍历下一个元素
        """
        # 1. 首先需要一个指针p顺序遍历节点， 还需要pre 和 cur 指针用于反转
        pre = None
        tmp = cur = head
        while tmp:
            # 1. 更新cur为当前节点
            cur = tmp
            # 2. p指针后移
            tmp = tmp.next
            # 3. 做反转
            cur.next = pre
            # 4. 更新pre为当前节点
            pre = cur

        # 5. 重新定义 head指向链表末尾
        head = cur
        return head
```


```py

递归解法， 先写出 while循环的迭代解法，再推导到 迭代写法。好像容易理解一些
# 还可以 以递归的形式解决问题
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        """ 
            迭代解法中，每一步都是 重新指向next指针， 可以分治法，使用递归求解。找到最小子问题及终止条件
            需要调用递归栈， 空间效率要低很多。
        """
        # 1. 首先需要一个指针p顺序遍历节点， 还需要pre 和 cur 指针用于反转
        def reverse(pre, cur):
            # 当cur为None了， 说明pre指向最后的节点，返回作为新的头结点
            if not cur: 
                return pre
            next = cur.next
            cur.next = pre
            return reverse(cur, next)
        

        head = reverse(None, head)
        return head


class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        
        def reverse(pre,cur):
            if not cur:
                return pre
                
            tmp = cur.next
            cur.next = pre

            return reverse(cur,tmp)
        
        return reverse(None,head)
```




```scala
object Solution {
    def reverseList(head: ListNode): ListNode = {
        if(head == null || head.next == null){
            head
        } else{
            var p = reverseList(head.next)
            head.next.next = head
            head.next = null
            p
        }
    }
}

```
```scala
/**
* time complexity: O(n)
* space complexity: O(1) 
*/
object Solution0 {
    def reverseList(head: ListNode): ListNode = {        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        prev
    }
}

 /**
 * time complexity: O(n)
 * space complexity: O(1)
 */
object Solution1 {
    def reverseList(head: ListNode): ListNode = {
        
        var prev: ListNode = null
        var curr = head

        while (curr != null) {
            val hold = curr.next
            curr.next = prev
            prev = curr
            curr = hold
        }
        prev
    }
    
    def printNode(node: ListNode) {
        var n = node
        while(n != null) {
            print(s"${n.x} ")
            n = n.next
        }
    }
}


/** recursive version */

object Solution2 {
    def reverseList(head: ListNode): ListNode = {
        
        val curr:ListNode = null
        
        _reverseList(curr, head)
        
    }
    
    @annotation.tailrec
    def _reverseList(curr: ListNode, next: ListNode): ListNode = {
        if(next == null) {
            curr
        }else{
            val tmpNode = next.next
            next.next = curr
            _reverseList(next, tmpNode)
        }
    }
}

object Solution2-1 {
    def reverseList(head: ListNode): ListNode = {
        if(head == null) head
        else _reverseList(head)
        
    }
    
    def _reverseList(node: ListNode): ListNode = {
        if (node == null || node.next == null) {
            node
        }else {
            val newHead = _reverseList(node.next)
              // reversedHead 是返回原本的尾巴，若一開始輸入是 1 -> 2 -> 3 -> 4 -> 5  -> null , 那 reversedHead 就是 5
            // 每次 iteration 返回都是同一個 reversedHead 也就是 5
            node.next.next = node
            node.next = null
             // 每次迭代 改變的就是送進每個 function 的 listnode 的 next 與 next.next 指向
            newHead
        }
        
        
    }
}

```

###  1.85. <a name='-1'></a>207-课程表

[花花酱](https://www.bilibili.com/video/BV1Ut411a74a?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV19k4y1r76s?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1jz411B7UJ?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xp4y1Y7FJ?spm_id_from=333.999.0.0)

```py
class Solution(object):

    # 这里使用逆邻接表

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return True
        # 深度优先遍历，判断结点是否访问过
        # 这里要设置 3 个状态
        # 0 就对应 False ，表示结点没有访问过
        # 1 就对应 True ，表示结点已经访问过，在深度优先遍历结束以后才置为 1
        # 2 表示当前正在遍历的结点，如果在深度优先遍历的过程中，
        # 有遇到状态为 2 的结点，就表示这个图中存在环
        visited = [0 for _ in range(numCourses)]
        print("visited:", visited)

        # 逆邻接表，存的是每个结点的前驱结点的集合
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 在前，0 在后
        inverse_adj = [set() for _ in range(numCourses)]
        print("inverse_adj:",inverse_adj)
        for second, first in prerequisites:
            print("[first]:",first)
            print("[second]:",second)
            inverse_adj[second].add(first)
            print("inverse_adj表示在学习第[",second,"]节课前，要先学习:",inverse_adj[second])

        for i in range(numCourses):
            # 在遍历的过程中，如果发现有环，则dfs返回true，就退出
            if self.__dfs(i, inverse_adj, visited,1): # visited 初始化为 0
                return False
        return True

    def __dfs(self, vertex, inverse_adj, visited,depth):
        """
        注意：这个递归方法的返回值是返回是否有环
        :param vertex: 结点的索引
        :param inverse_adj: 逆邻接表，记录的是当前结点的前驱结点的集合
        :param visited: 记录了结点是否被访问过，2 表示当前正在 DFS 这个结点
        :return: 是否有环
        """
        # 结束条件：
        # 2 表示这个结点正在访问
        # 2 表示当前正在遍历的结点，如果在深度优先遍历的过程中，
            # -------------🎨很重要🎨-------------
        if visited[vertex] == 2:
            # 表示遇到环
            # 有遇到状态为 2 的结点，就表示这个图中存在环
            return True
            # -------------🎨很重要🎨-------------
        if visited[vertex] == 1: # 1 表示结点已经访问过，在深度优先遍历结束以后才置为 1
            return False

        print("第1步vertex:",vertex,"visited:", visited," depth:",depth)
        visited[vertex] = 2
        print("第2步vertex:",vertex,"visited:", visited," depth:",depth)
        for precursor in inverse_adj[vertex]: # 是个set()
            # 如果有环，就返回 True 表示有环
            # -------------🎨很重要🎨-------------
            if self.__dfs(precursor, inverse_adj, visited,depth+1):
                return True 
            # -------------🎨很重要🎨-------------
        print("第3步vertex:",vertex,"visited:", visited," depth:",depth)

        # 1 表示访问结束
        visited[vertex] = 1
        print("第4步vertex:",vertex,"visited:", visited," depth:",depth)
        return False

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        visited = [0] * numCourses
        result = list()
        valid = True

        for info in prerequisites:
            edges[info[1]].append(info[0])
        
        def dfs(u: int):
            nonlocal valid
            visited[u] = 1
            for v in edges[u]:
                if visited[v] == 0:
                    dfs(v)
                    if not valid:
                        return
                elif visited[v] == 1:
                    valid = False
                    return
            visited[u] = 2
            result.append(u)
        
        for i in range(numCourses):
            if valid and not visited[i]:
                dfs(i)
        
        return valid

class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """
        def dfs(i, colors, prerequisites):
        	colors[i] = 'G'
        	#print i, colors
        	for front, tail in prerequisites:
        		if tail == i:
        			if colors[front] == 'G':
        				return False
        			elif colors[front] == 'B':
        				continue
        			elif dfs(front, colors, prerequisites) == False:
        				return False
        	colors[i] = 'B'
        	return True

        colors = ['W' for i in range(numCourses)]
        for i in range(numCourses):
        	if colors[i] == 'W':
        		if dfs(i, colors, prerequisites) == False:
        			return False
        return True
```

```py
# python
from collections import defaultdict 
class Solution:
    def canFinish(self, numCourses, prerequisites):
        inde = defaultdict(lambda:0)  # keep track of indegree of a course
        g = defaultdict(list)          # digraph of courses 
        for t,f in prerequisites:
            g[f].append(t)
            inde[t]+=1
        inde0 = []                   # inde0 holds courses whose indegree is 0
        for i in range(numCourses):
            if inde[i]==0:
                inde0.append(i)      # initialize inde0
        for i in inde0:
            for j in g[i]:
                inde[j]-=1
                if inde[j]==0:
                    inde0.append(j)
        return len(inde0)==numCourses

class Solution:
    def canFinish(self, numCourses, prerequisites):
        edges = collections.defaultdict(list)
        indeg = [0] * numCourses

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])
        visited = 0

        while q:
            visited += 1
            u = q.popleft()
            for v in edges[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)

        return visited == numCourses

class Solution(object):

    # 思想：该方法的每一步总是输出当前无前趋（即入度为零）的顶点

    def canFinish(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return True
        # 入度数组，一开始全部为 0
        in_degrees = [0 for _ in range(numCourses)]
        # 邻接表
        adj = [set() for _ in range(numCourses)]

        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # [0,1] 表示 1 在先，0 在后
        # 注意：邻接表存放的是后继 successor 结点的集合
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)
        counter = 0
        while queue:
            top = queue.pop(0)
            counter += 1

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)

        return counter == numCourses
```

```scala

// new and apply
// Use the new keyword when you want to refer to a class's own constructor:
// 解法是 每个node(node)，1.它依赖的node个数(parent) 2.统计依赖它的node个数(son)，
// 一个node没有依赖其它节点，放入zeroInDegree
// 对zeroIndegree的node遍历，对每个依赖它的node都可以直接除去依赖


  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def canFinish(numCourses: Int, prerequisites: Array[Array[Int]]): Boolean = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum == numCourses
    }
  }

  class Test extends BaseExtension {
    def init {
      val input = Array(Array(0,1),Array(1,2))
      println(Solution.canFinish(3,input) == true)
      //println(lru.get(1) == 1)
    }

    val name = "207 course schedule"
  }

```

###  1.86. <a name='ImplementTriePrefixTree'></a>208. 【构造🏰】Implement Trie (Prefix Tree)

[花花酱](https://www.bilibili.com/video/BV1Ut411a74P?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Zz4y1R7j8?spm_id_from=333.999.0.0)

```py
# 简单版：直接用字典

# 写法一：

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.setdefault(c, {})
        r['#'] = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r: return False
            r = r[c]
        return r.get("#", False)

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r: return False
            r = r[c]
        return True

# 写法二：

class Trie:

    def __init__(self):
        self.root = {}


    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            if not r.get(c):
                r[c] = {}
            r = r[c]
        r['end'] = True


    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            try:
                r = r[c]
            except:
                return False
        return 'end' in r


    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            try:
                r = r[c]
            except:
                return False
        return True

# 写法三：

class Trie:

    def __init__(self):
        self.root = {}


    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            if c not in r:
                r[c] = {}
            r = r[c]
        r['end'] = True


    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r:
                return False
            r = r[c]
        return 'end' in r


    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r:
                return False
            r = r[c]
        return True
```

```scala
/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */

/**
* chosen solution
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie0() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}



/**
* my first commitment
*/
case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
}

class Trie1() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach { c =>

      val cIdx = c.asDigit - 'a'.asDigit
      if (node.childNode(cIdx) == null) {
        node.childNode(cIdx) = Node()
      }
      node = node(cIdx)
    }
    node.isWord = true

  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    val node = searchUtil(word)

    node != null && node.isWord

  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix) != null
  }


   private def searchUtil(s: String): Node = {
    var node = root
    var continue = true
    for {
      c <- s
      if continue
    } {
      val cIdx = c.asDigit - 'a'.asDigit
      if (node(cIdx) == null) {
        continue = false
      } 
      node = node(cIdx)
    }
    node
  }
}


/**
*  more elegant
*  Node with apply and update
*/

case class Node(childNode: Array[Node] = Array.ofDim[Node](26), var isWord: Boolean = false) {

  def apply(c: Char): Node = {
    this.apply(c.asDigit - 'a'.asDigit)
  }

  def apply(idx: Int): Node = {
    childNode(idx)
  }
  
  def update(idx: Int, node: Node): Unit = {
    childNode(idx) = node
  }

  def update(c: Char, node: Node): Unit = {
    this.update(c.asDigit - 'a'.asDigit, node)
  }
}
class Trie1-2() {

  /** Initialize your data structure here. */
  val root = Node()


  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach {
      case c if node(c) == null => 
        node(c) = Node()
        node = node(c)

      case c => node = node(c)
    }
    node.isWord = true
      
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }


  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach {
      case c if node(c) != null => node = node(c)
      case _ => return None
    }
    Some(node)
  }
  def traversal(): Unit = {
    val result = scala.collection.mutable.ListBuffer[String]()

    def _traversal(prefix: String, node: Node): Unit = {
      if (node.isWord) {
        result += prefix
      }
      node.childNode.zipWithIndex.foreach {
        case (n, idx) if n != null => _traversal(prefix + ('a' + idx).toChar, n)
        case _ =>
      }

    }

    _traversal("", root)
    result.foreach(s => println(s.mkString("")))

  }

}

/**
* Node implement by hashmap
*/
case class Node(next: scala.collection.mutable.Map[Char, Node] = scala.collection.mutable.Map(), var isWord: Boolean = false){
  def update(char: Char, node: Node): Unit = next(char) = node
  def apply(char: Char): Option[Node] = next.get(char)
}

class Trie2() {
  /** Initialize your data structure here. */
  val root = Node()

  /** Inserts a word into the trie. */
  def insert(word: String) {
    var node = root
    word.foreach{ c =>
      node(c) match {
        case Some(n) =>
          node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  /** Returns if the word is in the trie. */
  def search(word: String): Boolean = {
    searchUtil(word).exists(_.isWord)
  }

  /** Returns if there is any word in the trie that starts with the given prefix. */
  def startsWith(prefix: String): Boolean = {
    searchUtil(prefix).isDefined
  }

  private def searchUtil(s: String): Option[Node] = {
    var node = root

    s.foreach{ c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }

}
```

###  1.87. <a name='-1'></a>209-长度最小的子数组

[哈哈哈](https://www.bilibili.com/video/BV1JZ4y1N7Rt?spm_id_from=333.999.0.0)

###  1.88. <a name='CourseScheduleII210-II'></a>210. Course Schedule II 210-课程表II

[花花酱](https://www.bilibili.com/video/BV1gW411y7Kb?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ja4y147on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qt4y1X7oC?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kK411W7rL?spm_id_from=333.999.0.0)

```py
# 思路2：构建逆邻接表，实现深度优先遍历。思路其实也很简单，其实就是检测这个有向图中有没有环，只要存在环，课程就不能完成。

# 注意：这个深度优先遍历得通过逆邻接表实现，当访问一个结点的时候，应该递归访问它的前驱结点，直至前驱结点没有前驱结点为止。

# Python 代码：

class Solution(object):

    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return [i for i in range(numCourses)]

        # 逆邻接表
        inverse_adj = [set() for _ in range(numCourses)]
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 -> 0，这里要注意：不要弄反了
        for second, first in prerequisites:
            inverse_adj[second].add(first)

        visited = [0 for _ in range(numCourses)]
        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列

        res = []
        for i in range(numCourses):
            if self.__dfs(i,inverse_adj, visited, res,1):
                return []
        return res

    def __dfs(self, vertex, inverse_adj, visited, res,depth):
        """
        注意：这个递归方法的返回值是返回是否有环
        :param vertex: 结点的索引
        :param inverse_adj: 逆邻接表，记录的是当前结点的前驱结点的集合
        :param visited: 记录了结点是否被访问过，2 表示当前正在 DFS 这个结点
        :return: 是否有环
        """
        # 2 表示这个结点正在访问
        if visited[vertex] == 2:
            # DFS 的时候如果遇到一样的结点，就表示图中有环，课程任务便不能完成
            return True
        if visited[vertex] == 1:
            return False
        # 表示正在访问这个结点
        visited[vertex] = 2
        # 递归访问前驱结点
        for precursor in inverse_adj[vertex]:
            # 如果没有环，就返回 False，
            # 执行以后，逆拓扑序列就存在 res 中
            print(vertex,"的precursor:",precursor,"depth:",depth)
            if self.__dfs(precursor, inverse_adj, visited, res,depth+1):
                
                return True

        # 能走到这里，说明所有的前驱结点都访问完了，所以可以输出了
        # 并且将这个结点状态置为 1
        visited[vertex] = 1
        print("第4步vertex:",vertex,"visited:", visited," depth:",depth)
        # 先把 vertex 这个结点的所有前驱结点都输出之后，再输出自己
        res.append(vertex)
        print("visited置为1后,res才能append:",res,"depth:",depth)
        # 最后不要忘记返回 False 表示无环
        return False
```

```py
# 思路1：拓扑排序。构建的邻接表就是我们通常认识的邻接表，每一个结点存放的是后继结点的集合。

# 该方法的每一步总是输出当前无前趋（即入度为零）的顶点。

# 为避免每次选入度为 0 的顶点时扫描整个存储空间，可设置一个队列暂存所有入度为 0 的顶点。

# 具体做法如下：

# 1、在开始排序前，扫描对应的存储空间，将入度为 0 的顶点均入队列。

# 2、只要队列非空，就从队首取出入度为 0 的顶点，将这个顶点输出到结果集中，并且将这个顶点的所有邻接点的入度减 1，

# 在减 1 以后，发现这个邻接点的入度为 0 ，就继续入队。

# 最后检查结果集中的顶点个数是否和课程数相同即可。

# Python 代码：

class Solution(object):
    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int 课程门数
        :type prerequisites: List[List[int]] 课程与课程之间的关系
        :rtype: bool
        """
        # 课程的长度
        clen = len(prerequisites)
        if clen == 0:
            # 没有课程，当然可以完成课程的学习
            return [i for i in range(numCourses)]
        # 入度数组，一开始全部为 0
        in_degrees = [0 for _ in range(numCourses)]
        # 邻接表
        adj = [set() for _ in range(numCourses)]
        # 想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
        # 1 -> 0，这里要注意：不要弄反了
        for second, first in prerequisites:
            in_degrees[second] += 1
            adj[first].add(second)

        # print("in_degrees", in_degrees)
        # 首先遍历一遍，把所有入度为 0 的结点加入队列
        res = []
        queue = []
        for i in range(numCourses):
            if in_degrees[i] == 0:
                queue.append(i)

        while queue:
            top = queue.pop(0)
            res.append(top)

            for successor in adj[top]:
                in_degrees[successor] -= 1
                if in_degrees[successor] == 0:
                    queue.append(successor)
        if len(res) != numCourses:
            return []
        return res

# bfs 借助队列实现拓扑排序
from collections import deque
class Solution:
    def findOrder(self, numCourses, prerequisites):
        # 建图，以邻接表存储
        def buildGraph(numCourses, prerequisites):
            graph = []  # 邻接表
            indeg = [0] * numCourses  # 入度表

            for i in range(numCourses):  # 直接[[]]*numCourses建表有问题
                graph.append([])
            for side in prerequisites:
                a, b = side[1], side[0]  # 依赖关系b依赖a，就是a->b
                graph[a].append(b)
                indeg[b] += 1

            return graph, indeg

        graph, indeg = buildGraph(numCourses, prerequisites)
        res = []
        # print(graph)
        # print(indeg)
        
        # 将所有入度为 0 的节点放入队列中
        queue = deque()
        for i in range(numCourses):
            if indeg[i] == 0:
                queue.append(i)

        while queue:
            # 队首节点出队，放入答案中
            node = queue.popleft()
            res.append(node)
            # 将该节点相邻节点入度-1
            for neighbor in graph[node]:
                indeg[neighbor] -= 1
                # 相邻节点入度为 0 则入队
                if indeg[neighbor] == 0:
                    queue.append(neighbor)

        if len(res) != numCourses:  # 如果拓扑排序没排完，则说明有环，返回空
            return []
        return res

class Solution:
    def findOrder(self, numCourses, prerequisites):
        # 存储有向图
        edges = collections.defaultdict(list)
        # 存储每个节点的入度
        indeg = [0] * numCourses
        # 存储答案
        result = list()

        for info in prerequisites:
            edges[info[1]].append(info[0])
            indeg[info[0]] += 1
        
        # 将所有入度为 0 的节点放入队列中
        q = collections.deque([u for u in range(numCourses) if indeg[u] == 0])

        while q:
            # 从队首取出一个节点
            u = q.popleft()
            # 放入答案中
            result.append(u)
            for v in edges[u]:
                indeg[v] -= 1
                # 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
                if indeg[v] == 0:
                    q.append(v)

        if len(result) != numCourses:
            result = list()
        return result

# 写了个python 3 ，广度优先的，加了每一句的注释，仅供参考

class Solution:
    def findOrder(self, numCourses, prerequisites):
        p = prerequisites
        # 所有课程没有先后顺序，这里我读题一开始没理解
        if p == []:
            return [i for i in range(numCourses)]

        from collections import defaultdict, deque
        go = defaultdict(list)
        # come=defaultdict(list) 逆向邻接表，本例不需要
        # 记录每个节点的入度
        rudu = defaultdict(int)
        # 记录所有prerequisites 出现的课程
        total = set()
        # 这个集合中存着所有需要前导课的课程号
        you = set()

        for i in p:

            a, base = i
            # 由基础课base 能够到达的a
            go[base].append(a)
            # come[a].append(base)  本例不需要
            # 进入并去重
            total.add(a)
            total.add(base)

            rudu[a] += 1
            # 只要有入度就是有前导课
            you.add(a)

        # 所有必须学习的课
        first = set([j for j in range(numCourses)])
        # 找到那些与其他课程无关的课，先学习了。ff 是集合
        ff = first - total
        ans = [g for g in ff]

        # 构建了邻接表，入度字典，下面开始拓扑排序
        #====================================
        # 找到入度为0 的课程，他们是其他课程的前导课，c 是一个集合
        c = total - you
        # 前导课加入deque
        q = deque(c)
        while q:

            # 入度为0，拿出来
            x = q.popleft()
            ans.append(x)
            # 遍历所有以x 为前导课的课
            xlist = go[x]
            for j in xlist:

                # 入度减去一
                rudu[j] -= 1
                # 发现入度==0 ，进入队列
                if rudu[j] == 0:
                    q.append(j)

        return ans if len(ans) == numCourses else []
       
class Solution:
    def findOrder(self, numCourses, prerequisites):
        ##创建入度的列表，索引对应节点编号，若索引不能对应节点编号，需要创建字典
        indegree = [0]*numCourses
        for i in range(len(prerequisites)):
            indegree[prerequisites[i][0]] += 1
        queue = [] ##存放入度为0的节点
        for i in range(numCourses):
            if indegree[i] == 0:
                queue.append(i)
        ret = [] ##按顺序存放节点
        while len(queue) != 0:
            cur = queue.pop(0) ##出队入度为0的节点
            ret.append(cur)
            for edge in prerequisites:
                if edge[1] == cur:
                    indegree[edge[0]] -= 1 ##更新节点的入度
                    if indegree[edge[0]] == 0:
                        queue.append(edge[0]) ##将入度为0的节点入队
        return ret if len(ret) == numCourses else [] #若结果列表个数不等于课程数，表示存在环
```

```py
# 拓扑排序khan算法的py/go/rs三语言实现

class Solution:
    def findOrder(self, numCourses, prerequisites):
        t = [0] * numCourses
        d = [[] for _ in range(numCourses)]
        for i, j in prerequisites:
            t[i] += 1
            d[j].append(i)
        ans = [i for i, j in enumerate(t) if not j]
        for i in ans:
            for j in d[i]:
                t[j] -= 1
                not t[j] and ans.append(j)
        return len(ans) == numCourses and ans or []
```

```scala

import scala.collection.mutable.ArrayBuffer
// 与lc207类似，不过要给出顺序

  object Solution {
    def findOrder(numCourses: Int, prerequisites: Array[Array[Int]]): Array[Int] = {
      val inDegree = new Array[Int](numCourses)
      val neighbour = new Array[ArrayBuffer[Int]](numCourses).map(_=>new ArrayBuffer[Int]()) //必须初始化

      prerequisites.foreach(p=> {
        inDegree(p(0)) += 1
        neighbour(p(1)) += p(0)
      })

      val ans = ArrayBuffer[Int]()
      var zeroInDegree = inDegree.zipWithIndex.filter(_._1 == 0).map(_._2).toList
      var canFinshNum = zeroInDegree.length
      while (zeroInDegree.nonEmpty) {
        val cur = zeroInDegree.head
        ans += cur
        zeroInDegree = zeroInDegree.tail
        neighbour(cur).foreach(p=>{
          inDegree(p)-=1
          if (inDegree(p) == 0) {
            zeroInDegree :+= p
            canFinshNum+=1
          }
        })
      }
      canFinshNum match {
        case canFinshNum if canFinshNum == numCourses => ans.toArray
        case _ => Array()
      }
    }
  }

```

###  1.89. <a name='AddandSearchWord'></a>211 Add and Search Word

[小明](https://www.bilibili.com/video/BV1x5411a77S?spm_id_from=333.999.0.0)

###  1.90. <a name='WordSearchII'></a>212. 【构造🏰 + 困难】Word Search II

[花花酱](https://www.bilibili.com/video/BV184411d7i9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vi4y1G7NQ?spm_id_from=333.999.0.0)

```py
from collections import  defaultdict
class TrieNode:
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.isWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        r = self.root
        for c in word:
            r = r.children[c]
        r.isWord = True

    def search(self, word: str) -> bool:
        r = self.root
        for c in word:
            if c not in r.children:
                return False
            r = r.children[c]
        return r.isWord

    def startsWith(self, prefix: str) -> bool:
        r = self.root
        for c in prefix:
            if c not in r.children:
                return False
            r = r.children[c]
        return True
```

```py
from collections import defaultdict


class Trie:
    def __init__(self):
        self.children = defaultdict(Trie)
        self.word = ""

    def insert(self, word):
        cur = self
        for c in word:
            cur = cur.children[c]
        cur.is_word = True
        cur.word = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)
		
        def dfs(tries, x, y):
            # 递归的结束：tries.children不能站在board上
            if board[x][y] not in tries.children:
                return
            # 递归的开始：有一个tries.children能站在board上，那就是小c
            char = board[x][y]
            
            # 递归的找到目标: 就是charSon，只有charSon才能判断是否是个单词
            charSon = tries.children[char]
            if charSon.word:
                res.append(charSon.word)
                charSon.word = "" # 把单词删掉
                
            # 找到/没有找到递归的目标: 就是charSon的Son
            if charSon.children:
                board[x][y] = "#" # 把charSon的father走过的路径删掉,避免重复
                for newX, newY in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:
                    if 0 <= newX < m and 0 <= newY < n:
                        dfs(charSon, newX, newY)
                board[x][y] = char # 把charSon的father走过的路径恢复

            # 没有找到递归的目标: char 就是走不通的，char杀死
            if not charSon.children:
                tries.children.pop(char)

        res = []
        m, n = len(board), len(board[0])

        for i in range(m):
            for j in range(n):
                dfs(trie, i, j)

        return res
```


```py
这个答案为什么不对呢？？
# 如果把方向换成[[0,1], [1,0], [0,-1], [-1,0]]过不了：

# [["a","b","e"],["b","c","d"]]
# ["abcdeb"]

# 先检索abc（b用[0,1]）会记录这个结果不符合，再检索abc（b用[1,0]）会直接判断不行, lru_cache没法处理visited的差异


class Solution:

    def __init__(self):
        self.mark = set()

    def findWords(self, board: [[str]], words: [str]) -> [str]:
        m, n = len(board), len(board[0])
        res = set()
        @lru_cache(None)
        def dfs(x, y, ans):
            if ans in words:
                res.add(ans)
                return
            # 对于这样一个case，还是应该要继续的
            # [["o","a","b","n"],["o","t","a","e"],["a","h","k","r"],["a","f","l","v"]]
            # ["oa","oaa"]        
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                if 0 <= x + dx < m and 0 <= y + dy < n and (x + dx, y + dy) not in self.mark:
                    self.mark.add((x + dx, y + dy))
                    dfs(x + dx, y + dy, ans + board[x + dx][y + dy])
                    self.mark.remove((x + dx, y + dy))
        for i in range(m):
            for j in range(n):
                self.mark = set(board[i][j])
                dfs(i, j, board[i][j])
        return list(res)

if __name__ == "__main__":     
    s = Solution()
    board = [["a","b","c","e"],["z","z","d","z"],["z","z","c","z"],["z","a","b","z"]]
    words = ["abcdce"]
    print(s.findWords(board, words))
```

```scala

/**
* chosen solution
* tries + dfs + pruning
* memo
*   1. put all words into tries which is implemented by hashmap
*   2. DFS way searching all char in board composing a word and searching whether the word exists in tries
*   3. in dfs, we directly input the node from tries instead of tries itself 
*   4. pruning an edge after matching a word and its children couldn't represent a word
*/
import scala.collection.mutable
case class Node(next: mutable.Map[Char, Node] = mutable.Map.empty, var isWord: Boolean = false){
  def apply(char: Char): Option[Node] = next.get(char)
  def update(char: Char, node: Node): Unit = next(char) = node
}

class Tries(){
  val root = Node()
  def insert(word: String): Unit = {
    var node = root
    word.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None =>
          node(c) = Node()
          node = node(c).get
      }
    }
    node.isWord = true
  }

  def startsWith(prefix: String): Boolean = searchUtil(prefix).isDefined
  def search(word: String): Boolean =  searchUtil(word).exists(_.isWord)

  def searchUtil(s: String): Option[Node] = {
    var node = root
    s.foreach { c =>
      node(c) match {
        case Some(n) => node = n
        case None => return None
      }
    }
    Some(node)
  }
}


object Solution0 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


/**
* tries + dfs + pruning
* memo
*   1. a seenBoard to record which position was visited 
* time complexity: 
* 
*/

object Solution1-1 {
  val result = scala.collection.mutable.Set[String]()

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for{
      row <- board.indices
      col <- board(0).indices
    }{
      _dfs(board, Array.ofDim[Boolean](board.length, board(0).length), tries, "", (row, col))
    }

    result.toList
  }

  private def _dfs(board: Array[Array[Char]], seenBoard:Array[Array[Boolean]], tries: Trie, currentPrefix: String, currentIdx: (Int, Int)) {
    val (row, col) = currentIdx
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    if(tries.startsWith(newPrefix)){
      seenBoard(row)(col) = true
      getNextPosition(currentIdx, seenBoard).foreach{idx =>
        _dfs(board, seenBoard.map(_.clone()), tries, newPrefix, idx)
      }
    }
  }

  private def getNextPosition(currentIdx: (Int, Int), seenBoard: Array[Array[Boolean]]): Array[(Int, Int)] = {

    def check(row: Int, col: Int): Boolean = {
      if(row >= seenBoard.length || row < 0 || col >= seenBoard(0).length || col < 0 || seenBoard(row)(col))  false
      else true
    }
    val (row, col) = currentIdx
    val result = scala.collection.mutable.ArrayBuffer[(Int, Int)]()

    for{
      i <- -1 to 1
      j <- -1 to 1
    }{
      if((math.abs(i) + math.abs(j) == 1) && check(row + i, col + j)) result.append((row + i, col + j))
    }
    result.toArray
  }
}

/**
* simplify : without seen matrix
*/

object Solution1-2 {

  val result = scala.collection.mutable.Set[String]()
  private val inBounds = (shape: (Int, Int)) => (coord: (Int, Int)) => coord._1 < shape._1 && coord._1 >= 0 && coord._2 < shape._2 && coord._2 >= 0
  private val getNeighbors = (coord: (Int, Int), filter: ((Int, Int)) => Boolean) => {
    List(
      (coord._1 + 1, coord._2),
      (coord._1, coord._2 + 1),
      (coord._1 - 1, coord._2),
      (coord._1, coord._2 - 1)
    ).filter(filter)
  }

  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    result.clear()
    val tries = new Trie()
    tries.insert(words)
    for {
      row <- board.indices
      col <- board(0).indices
    } {
      _dfs(board, tries, "", (row, col))
    }
    result.toList
  }

  private def _dfs(board: Array[Array[Char]], tries: Trie, currentPrefix: String, coord: (Int, Int)) {

    val (row, col) = coord
    val newPrefix = currentPrefix + board(row)(col)

    if (tries.search(newPrefix))
      result += newPrefix

    val c = board(row)(col)
    board(row)(col) = '#'
    if (tries.startsWith(newPrefix)) {

      getNeighbors(coord, inBounds((board.length, board.head.length))(_))
        .foreach {
          case (nr, nc) if board(nr)(nc) != '#' =>
            _dfs(board, tries, newPrefix, (nr, nc))
          case _ =>
        }
    }
    board(row)(col) = c
  }
}


object Solution1-3 {
  private val visitedLabel = '#'
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Trie()
    words.foreach(tries.insert)
    dfs(tries, board)
  }


  def dfs(tries: Trie, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int) ,prePrefix: String, board: Array[Array[Char]], ret: scala.collection.mutable.HashSet[String]): Unit = {
      val currentChar =  board(coord._1)(coord._2)
      val newPrefix = prePrefix + currentChar
      if(tries.search(newPrefix)) ret += newPrefix
      /* pruning */
      if(tries.startsWith(newPrefix)){
        board(coord._1)(coord._2) = visitedLabel
        getAvailableCoords(coord, (board.length, board(0).length)).foreach {
          case (r, c) if board(r)(c) != visitedLabel => _dfs((r, c), newPrefix, board, ret)
          case _ =>
        }
        board(coord._1)(coord._2) = currentChar
      }
    }

    val coords = for(i <- board.indices; j <- board(0).indices) yield (i, j)
    val ret = scala.collection.mutable.HashSet[String]()
    coords.foreach(coord => _dfs(coord, "", board, ret))
    ret.toList

  }

  private val getAvailableCoords = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    List(
      (row + 1, col),
      (row, col + 1),
      (row - 1, col),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 &&  0 <= c && c < shape._2}
  }
}




object Solution2 {
  def findWords(board: Array[Array[Char]], words: Array[String]): List[String] = {
    val tries = new Tries()
    words.foreach(tries.insert)
    dfs(tries, board)
  }

  def dfs(tries: Tries, board: Array[Array[Char]]): List[String] = {
    def _dfs(coord: (Int, Int), currentString: String,  node: Node, ans: mutable.Set[String]): Unit = {
      val (row, col) = coord
      val char = board(row)(col)
      node(char) match {
        case Some(nextNode) =>
            val newString = currentString + char
            if(nextNode.isWord) ans += newString
            board(row)(col) = '#'
            neighbors(coord, (board.length, board(0).length)).foreach {
              case (nr, nc) if board(nr)(nc) != '#' => _dfs((nr, nc), newString, nextNode, ans)
              case _ =>
           }
          board(row)(col) = char
          /** pruning */
          if(nextNode.next.isEmpty) node.next.remove(char)

        case None =>
      }
    }
    val ans = mutable.Set[String]()
    for(i <- board.indices; j <- board(0).indices) {
      _dfs((i, j), "", tries.root, ans)
    }
    ans.toList
  }
  private val neighbors = (coord: (Int, Int), shape: (Int, Int)) => {
    val (row, col) = coord
    Seq(
      (row + 1, col),
      (row - 1, col),
      (row, col + 1),
      (row, col - 1)
    ).filter{case (r, c) => 0 <= r && r < shape._1 && 0 <= c && c < shape._2}
  }
}


```

###  1.91. <a name='HouseRobberII213-II'></a>213.【动态🚀规划】 House Robber II 213-打家劫舍II

[18:13 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Ea4y147oh?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1GD4y1d7DS?spm_id_from=333.999.0.0)

```py
# dp[i] = max(dp[i-2] + nums[i], dp[i-1])
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        # 易错点：注意特殊情况
        if n <= 2:
            return max(nums)

        dp1 = [0] * (n - 1)
        dp1[0] = nums[0]
        dp1[1] = max(nums[1],nums[0])
        for i in range(2, n - 1):
            dp1[i] = max(dp1[i-2] + nums[i], dp1[i-1])

        dp2 = [0] * (n - 1)
        dp2[0] = nums[1]
        dp2[1] = max(nums[1],nums[2])
        # 易错点：注意，根据递推式，这里不是，dp2[1] = nums[2]
        for i in range(2, n - 1):
            dp2[i] = max(dp2[i-2] + nums[i + 1], dp2[i-1])

        return max(dp1[-1],dp2[-1])

# 核心原则就是：第一个和最后一个不能同时抢。 
# 所以：要么不抢第一个，要么不抢最后一个。 
# 注意，不抢第一个的时候，最后一个可抢可不抢；
# 另一种情况同理 取两种情况中的最大值

降维以后：

# dp[i] = max(dp[i-2] + nums[i], dp[i-1])
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        # 易错点：注意特殊情况
        if n <= 2:
            return max(nums)

        def robrange(start,end):
            dp0 = 0
            dp1 = nums[start]
            for i in range(start + 1,end):
                dp1, dp0 = max(dp0 + nums[i], dp1), dp1
            return dp1
        # 也可以这么写：
        # def robrange(start,end):
        #     dp0 = 0
        #     dp1 = 0
        #     for num in nums[start:end]:
        #         dp1, dp0 = max(dp0 + num, dp1), dp1
        #     return dp1
        return max(robrange(0,n-1),robrange(1,n))
```

###  1.92. <a name='CombinationSumIII216-III'></a>216. Combination Sum III 216-组合总和 III

[花花酱](https://www.bilibili.com/video/BV14b411u7q8?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1SC4y1a7Vy?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gz4y1Z7CV?spm_id_from=333.999.0.0)

```py
# 枚举剪枝，dfs()!

class Solution(object):
    def combinationSum3(self, k, n):

        def dfs(startIndex, sum, path):
            if sum==0 and len(path)==k: res.append(path)
            if sum<=0: return
            
            for j in range(startIndex, 10):
                dfs(j, sum-j, path+[j])
        
        res = []
        dfs(1, n, [])
        return res

# 简单回溯

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []

        def dfs(startIndex, sum, path):
            if sum < 0:
                return

            if len(path) == k and sum == 0:
                res.append(path[:])
                return

            for i in range(startIndex, 10):
                path.append(i)
                dfs(i+1, sum - i, path)
                path.pop()
                    
        dfs(1, n, [])

        return res

class Solution(object):
    def combinationSum3(self, k, n):
        """
        :type k
        :type n
        :rtype: List[List[int]]
        """
        if not k or not n:
            return []
        
        res = []         
        def dfs(k, n, tmp, start):
            if n == 0 and k == 0:
                res.append(tmp[:])
                return
            if k <= 0 or n <= 0:
                return
            
            for i in range(start, 10):
                tmp.append(i)
                dfs(k - 1, n - i, tmp, i + 1)
                tmp.pop()
                    
        dfs(k, n, [], 1)       
        return res

from typing import List
class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        self.res = []
        cur = []
        def dfs(startI, k, n, path):
            if k == 0 and n == 0:
                self.res.append(path[:])
                return 
            elif n <= 0 or k == 0:
                return 
            for i in range(startI, 10):
                path.append(i)
                dfs(i+1, k-1, n-i, path)
                path.pop()
        dfs(1, k, n, cur)
        return self.res

# 闭包用的挺好，如果内层函数不止一处用到的话，不建议写成内层函数，我是这么认为的。
# 感觉大佬们写的代码都好长啊。

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        def dfs(startI:int,sums:int):
            nonlocal path
            if k == len(path):
                if sums == 0:
                    res.append(path[:])
                return
            
            if startI < 10 and sums > 0:
                #添加当前元素到组合序列
                path.append(startI)
                dfs(startI + 1,sums - startI)
                path.pop()
                dfs(startI + 1,sums)
        path, res = list(), list()
        dfs(1,n)
        return res
# 回溯的king

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []
        def dfs(path, startI):
            if len(path) == k and sum(path) == n:
                res.append(path)
                return
            for j in range(startI, 10):
                dfs(path+[j], j+1)
        dfs([], 1)
        return res

# 补一个python解法，击败98%，主要表现为剪枝

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        if n < 6: return []
        res = []
        def backtrack(num, path, k, n):
            if k == 0 and n == 0:
                res.append(path[:])
            if n < 0 or k < 0:
                return 
            for i in range(num, 10):
                if i > n:
                    break
                path.append(i)
                backtrack(i+1, path, k-1, n-i)
                path.pop()
            return 

        backtrack(1, [], k, n)
        return res

class Solution:
    def combinationSum3(self, k, n) -> List[List[int]]:
        res = []  #存放结果集
        path = []  #符合条件的结果
        def dfs(n,k,sums,startIndex):
            if sums > n: return  #剪枝操作
            if sums == n and len(path) == k:  #如果path.size() == k 但sum != n 直接返回
                return res.append(path[:])
            for i in range(startIndex,9-(k-len(path))+2):  #剪枝操作
                path.append(i)
                sums += i 
                dfs(n,k,sums,i+1)  #注意i+1调整startIndex
                sums -= i  #回溯
                path.pop()  #回溯
        
        dfs(n,k,0,1)
        return res

# 接近双百的逆向思维，先一次性总结512种所有的情况，之后筛选k和n符合的情况就行了，对于情况有限的直接枚举肯定最快

class Solution(object):
    def combinationSum3(self, k, n):
        def combine(n):
            if n==1:
                return [[1],[]]
            else:
                temp = combine(n-1)
                return [x+[n] for x in temp]+temp
        lookup = combine(9)
        res = combine(n)[]
        for path in lookup:
            if len(path)==k and sum(path)==n:
                res += [path]
        return res
```

###  1.93. <a name='ContainsDuplicate'></a>217. Contains Duplicate

[小梦想家](https://www.bilibili.com/video/BV1ab411H7Zw?spm_id_from=333.999.0.0)

```py
简单题。。。我觉得我又行了

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(nums) != len(set(nums))

人生苦短，我用Python

class Solution:
    def containsDuplicate(self, nums):
        return len(nums) - len(set(nums)) > 0

我竟然自己想出来了这种反人类的玩意儿 python：

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) < len(nums)
谁还不会一行呢

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return not (len(nums)==len(set(nums)))
```


```py
用哈希表存放元素，遍历nums

（1）如果数字不在哈希表中，说明该数字第一次出现，哈希表加入该数字

（2）如果数字存在哈希表中，说明该数字第二次出现，直接返回False

如果遍历完了，说明所有数字都只出现一次，那么返回True

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        numSet = set()
        for i in nums:
            if i in numSet:
                return True
            else:
                numSet.add(i)
        return False
```

```scala
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        var hashSet = scala.collection.mutable.HashSet.empty[Int]
        import scala.util.control.Breaks._
        var flag = false
        breakable{
            for(num <- nums){
                if(hashSet.contains(num)){
                        flag = true
                        break
                    }else{
                    hashSet.add(num)
                }
                }
            }
        flag
        }
    }
    
  
//Alternate (SCALA) solution
object Solution {
    def containsDuplicate(nums: Array[Int]): Boolean = {
        return nums.distinctBy(_.self).length != nums.length
    }
}

```

###  1.94. <a name='TheSkylineProblem'></a>218. The Skyline Problem

[花花酱](https://www.bilibili.com/video/BV1hb411c7Q4?spm_id_from=333.999.0.0)

###  1.95. <a name='ContainsDuplicateII'></a>219. Contains Duplicate II

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ga?spm_id_from=333.999.0.0)

###  1.96. <a name='ContainsDuplicateIII'></a>220 Contains Duplicate III

[小明](https://www.bilibili.com/video/BV19h41197iw?spm_id_from=333.999.0.0)

###  1.97. <a name='-1'></a>221-【动态🚀规划】最大正方形

[哈哈哈](https://www.bilibili.com/video/BV1XT4y137Gq?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16K411575r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1mA411q7Sw?spm_id_from=333.999.0.0)

```py
# 右下角的坐标为(x, y) ，那么(x - 1, y - 1)一定需要是一个square，
# 并且该点的左边全为1，上边也为1，按照这个进行理解变长的增加。
构建dp：
class Solution:
    def maximalSquare(self, matrix):
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * n for _ in range(m)]
        maxEdge = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    maxEdge = max(dp[i][j], res)
        return maxEdge * maxEdge

原地修改：
class Solution:
    def maximalSquare(self, matrix):
        maxEdge = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[i])):
                if i and j: # 这个写法妙啊，刚好就跳过了 i-1
                    if matrix[i][j] == "1":
                        matrix[i][j] = min(int(matrix[i-1][j-1]), int(matrix[i][j-1]), int(matrix[i-1][j])) + 1
                    else:
                        matrix[i][j] = 0
                maxEdge = max(maxEdge,int(matrix[i][j]))
        return maxEdge**2       
```

###  1.98. <a name='CountCompleteTreeNodes'></a>222. Count Complete Tree Nodes

[花花酱](https://www.bilibili.com/video/BV1n44y1E73D?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qz411i7bh?spm_id_from=333.999.0.0)

两种递归

```py
class Solution(object):
    def countNodes(self, root):
        if root == None:
        	return 0
        if root.left == None and root.right == None:
        	return 1
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)

class Solution(object):
    def countNodes(self, root):
        if not root:
            return 0
        lh, rh = self.getHeight(root.left), self.getHeight(root.right)
        if lh == rh:  # 左右子树高度相同，说明左子树必满 则节点数=左子树节点 + root节点(=1) + 递归找右子树
            return (pow(2, lh) - 1) + 1 + self.countNodes(root.right)
        else:  # 左子树比右子树高，说明右子树必满 同理
            return (pow(2, rh) - 1) + 1 + self.countNodes(root.left)

    def getHeight(self, root):
        ret = 0
        while root:
            ret += 1
            root = root.left
        return ret
# 相对来说，递归法利用公式更容易理解：
# 既然说了是 complete binary tree，那么必然有特性可用，
# complete binary tree的特性是除了最后一层，之前的就是perfect tree.
```

```py
# 完全二叉树的性质{根节点的左右子树至少有一个是满二叉树}， 
# 首先从根节点开始计算左右子树的高度，如果相等则为满二叉树，直接返回 
# 否则递归计算左右子树 
# Note：乍一看时间复杂度为O(N*logN)，
# 但是根据完全二叉树的性质,其子树中至少有一个满二叉树，
# 所以只会有一个递归会正真的执行下去 
# 查找深度的时间复杂度为logN,递归的深度为O(logN)，
# 所以总的时间复杂度为O(logN * logN)

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        left = right = 0
        tmp1 = tmp2 =  root

        # 求出树的深度
        while tmp1:
            left += 1
            tmp1 = tmp1.left
        while tmp2:
            right += 1
            tmp2 = tmp2.right

        # 利用树的深度
        if left == right:
            return 2 ** left - 1
        else:
            return 1 + self.countNodes(root.left) + self.countNodes(root.right)  #根据完全二叉树的性质，这两地递归真正执行的只有一个


# 所以寻找左子树的最左边的高度和右子树的最右边的node高度，
# 如果相同就是perfect tree，高度2^h - 1， 否则递归的来看左子树和右子树

class Solution(object):
    def countNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root == None:
        	return 0
        
        p, q = root,root

        leftHeight = 0
        rightHeight = 0

        while p:
        	p = p.left
        	leftHeight += 1

        while q:
        	q = q.right
        	rightHeight += 1

        if leftHeight == rightHeight:
        	return (int)(math.pow(2,leftHeight) - 1)
        else:
        	return 1 + self.countNodes(root.left) + self.countNodes(root.right)



# 我随便写了写，还准备修改，没想到一提交啪就通过了，很快啊！

class Solution(object):
    def countNodes(self, root):
        if not root: return 0
        depth=0
        
        def getDepth(root):
            nonlocal depth
            depth += 1
            if root.left:
                getDepth(root.left)
            else:
                return
            
        getDepth(root)
        ans=2**(depth-1)-1
        
        def dfs(node,path):
            nonlocal ans
            path.append(node)
            if node.left:
                dfs(node.left,path)
            if node.right:
                dfs(node.right,path)
            if not node.left and not node.right:
                if len(path)==depth:
                    ans+=1
            path.pop()
            
        dfs(root,[])
        return ans
```

###  1.99. <a name='RectangleArea'></a>223. Rectangle Area

[小梦想家](https://www.bilibili.com/video/BV1Ck4y1z7Hp?spm_id_from=333.999.0.0)

```py
class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        def overlapLength(a1, a2, b1, b2) -> int:
            return max(min(a2, b2) - max(a1, b1), 0)

        overlap = overlapLength(ax1, ax2, bx1, bx2) * overlapLength(ay1, ay2, by1, by2)

        areaA = (ax2 - ax1) * (ay2 - ay1)

        areaB = (bx2 - bx1) * (by2 - by1)

        return areaA + areaB - overlap
```

```py
class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        
        xx1 = max(ax1,bx1)
        yy1 = min(ay2,by2)
        xx2 = min(ax2,bx2)
        yy2 = max(ay1,by1)
        
        w = max(0,xx2- xx1)
        h = max(0,yy1 - yy2)

        area1 = (ax2- ax1) * (ay2- ay1)
        area2 = (bx2- bx1) * (by2- by1)
        return area1 + area2 -w * h

class Solution:
    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:
        area1 = (ax2 - ax1) * (ay2 - ay1)
        area2 = (bx2 - bx1) * (by2 - by1)
        overlapWidth = min(ax2, bx2) - max(ax1, bx1)
        overlapHeight = min(ay2, by2) - max(ay1, by1)
        overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0)
        return area1 + area2 - overlapArea
```

###  1.100. <a name='-1'></a>224
 
https://www.bilibili.com/video/BV1Nb4y1z7hG?from=search&seid=1882841343164929357&spm_id_from=333.337.0.0

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.71qtf391s5w0.png" width="40%">

```py
class Solution:
    def calculate(self, s: str) -> int:
        stack = [1]
        sign = 1
        i = 0
        res = 0
        while i < len(s):
            if s[i].isdigit():
                n = 0
                while i<len(s) and s[i].isdigit():
                    n = 10*n + int(s[i])
                    i += 1
                res += sign*n
            else:
                if s[i]=='+':   sign=stack[-1]
                elif s[i]=='-': sign=-stack[-1]
                elif s[i]=='(': stack.append(sign)
                elif s[i]==')': stack.pop()
                i += 1
        return res
```

###  1.101. <a name='ImplementStackusingQueues'></a>225-【构造🏰】Implement Stack using Queues

[哈哈哈](https://www.bilibili.com/video/BV1p741177pK?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XQ4y1h735?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ep4y1Y77j?spm_id_from=333.999.0.0)

```py



class MyStack:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.queue = collections.deque()


    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        n = len(self.queue)
        self.queue.append(x)
        for _ in range(n):
            self.queue.append(self.queue.popleft())


    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.queue.popleft()


    def top(self) -> int:
        """
        Get the top element.
        """
        return self.queue[0]


    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return not self.queue
```

以下两种写法，速度更快一点点，但是写法复杂

```py
q2当作缓存队列

class MyStack:

    def __init__(self):
        # q1和q2是两个队列
        ## 保证q1当中永远有元素
        ## 保证q2当中永远没有元素
        self.q1 = deque([])
        self.q2 = deque([])

    def push(self, x: int) -> None:
        self.q1.append(x)
        
    def pop(self) -> int:
        while len(self.q1) > 1:
            self.q2.append(self.q1.popleft())
        self.q1,self.q2 = self.q2, self.q1
        return self.q2.popleft()
        
        
    def top(self) -> int:
        return self.q1[-1]

    def empty(self) -> bool:
        return not self.q1

```

```scala
/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */


/**
* chosen solution
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack0() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}




 /**
 * my first commit
 * two queue version
 * time complexity: 
 *   push: O(1)
 *   pop: O(2n - 1)  n is the element in queue1
 *   top: O(2n - 1)
 */
class MyStack1() {

    /** Initialize your data structure here. */
    var queue1 = scala.collection.mutable.Queue[Int]()
    var queue2 = scala.collection.mutable.Queue[Int]()

    /** Push element x onto stack. */
    def push(x: Int) {
        queue1.enqueue(x)
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
       }
    
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        ret
        
    }

    /** Get the top element. */
    def top(): Int = {
        while(queue1.size > 1) {
           queue2.enqueue(queue1.dequeue)
        }
        val ret = if(queue1.isEmpty) -1 else queue1.dequeue
        val tmp = queue1
        queue1 = queue2
        queue2 = tmp
        queue1.enqueue(ret)
        ret
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty && queue2.isEmpty
    }

}

/**
* two queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack2() {

   import scala.collection.mutable.Queue
    /** Initialize your data structure here. */
    var queue1 = Queue.empty[Int] 


    /** Push element x onto stack. */
    def push(x: Int) {
        val queue2 = Queue(x)
        queue2.enqueueAll(queue1.dequeueAll(_ => true))
        queue1 = queue2
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
        if(queue1.isEmpty) -1 else queue1.dequeue
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }
}

/**
* one queue version
* time complexity
*   push: O(2n+1) n is the element in queue1
*   pop: O(1)
*   top: O(1)
*/
class MyStack3() {

    /** Initialize your data structure here. */
    val queue1 = scala.collection.mutable.Queue[Int]()


    /** Push element x onto stack. */
    def push(x: Int) {
        val iter = queue1.indices
        queue1.enqueue(x)
        (iter).foreach(e => queue1.enqueue(queue1.dequeue))
        
        
    }

    /** Removes the element on top of the stack and returns that element. */
    def pop(): Int = {
       if(queue1.nonEmpty) queue1.dequeue else -1
        
    }

    /** Get the top element. */
    def top(): Int = {
       queue1.headOption.getOrElse(-1)
    }

    /** Returns whether the stack is empty. */
    def empty(): Boolean = {
        queue1.isEmpty
    }

}

/**
* memo:
*   1. push entire old queue into a new queue without expanding all elements 
* time complexity:  
*     all operation are O(1) after being amortized
*   
* start  Queue()
* push1  Queue(1, Queue())
* push2  Queue(2, Queue(1, Queue()))
* push3  Queue(3, Queue(2, Queue(1, Queue())))
* push4  Queue(4, Queue(3, Queue(2, Queue(1, Queue()))))
* pop    Queue(3, Queue(2, Queue(1, Queue())))
* pop    Queue(2, Queue(1, Queue()))
*/

class MyStack4() {
  import scala.collection.mutable
  /** Initialize your data structure here. */
  var queue: mutable.Queue[Any] = mutable.Queue.empty[Any]

  /** Push element x onto stack. */
  def push(x: Int) {
    val queue2: mutable.Queue[Any] = mutable.Queue(x)
    queue2.enqueue(queue)
    queue = queue2

  }
  /** Removes the element on top of the stack and returns that element. */
  def pop(): Int = {

    if(queue.isEmpty) -1 else {
      val ret = queue.dequeue.asInstanceOf[Int]
      queue = queue.dequeue.asInstanceOf[mutable.Queue[Any]]
      ret
    }
  }
  /** Get the top element. */
  def top(): Int = {
    if(queue.isEmpty) -1 else queue.head.asInstanceOf[Int]
  }

  /** Returns whether the stack is empty. */
  def empty(): Boolean = {
    queue.size != 2
  }
}
```

###  1.102. <a name='-1'></a>226-翻转二叉树

[哈哈哈](https://www.bilibili.com/video/BV1Sh411R7B2?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73E?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FK411p7Co?spm_id_from=333.999.0.0)

```py
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left, root.right = right, left
        return root
```

```py
用队列做，每次都弹出第一个节点，然后判断

如果节点为叶子节点，那就什么都不做

如果不是叶子节点，那就有三种情况：

1.左节点和右节点都存在，此时把两个节点交换，然后把左右节点都重新加入队列

2.只有左节点，此时交换两个节点，然后把右节点重新加入队列

3.只有右节点，此时交换两个节点，然后把左节点重新加入队列

### 代码

class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if root == None:
            return root
        Q = deque([root])
        while Q:
            r = Q.popleft()
            if r.left or r.right:
                r.left, r.right = r.right, r.left
                if r.left and r.right:
                    Q.append(r.left)
                    Q.append(r.right)
                elif r.right and not r.left:
                    Q.append(r.right)
                else:
                    Q.append(r.left)
        return root
```

###  1.103. <a name='BasicCalculatorII'></a>227 Basic Calculator II

[小明](https://www.bilibili.com/video/BV1Qy4y167Ax?spm_id_from=333.999.0.0)

https://www.bilibili.com/video/BV1t4411c7m6?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

https://www.bilibili.com/video/BV1v54y1a74b?from=search&seid=14354850983862729610&spm_id_from=333.337.0.0

```py
class Solution:
    def calculate(self, s: str) -> int:
        n = len(s)
        stack = []
        op = '+'
        num = 0
        for i in range(n):
            if s[i] != ' ' and s[i].isdigit():
                num = num * 10 + ord(s[i]) - ord('0')
            if i == n - 1 or s[i] in '+-*/':
                if op == '+':
                    stack.append(num)
                elif op == '-':
                    stack.append(-num)
                elif op == '*':
                    stack.append(stack.pop() * num)
                else:
                    stack.append(int(stack.pop() / num))
                op = s[i]
                num = 0
        return sum(stack)

class Solution:
    def calculate(self, s: str) -> int:
        stack = []
        num, op = 0, "+"
        for i, c in enumerate(s):
            if c.isdigit():
                num = 10*num + int(c)
            if c in "+-*/" or i==len(s)-1:
                if op == "+":
                    stack.append(num)
                elif op == "-":
                    stack.append(-num)
                elif op == "*":
                    stack.append(stack.pop()*num)
                elif op == "/":
                    stack.append(int(stack.pop()/float(num)))
                num, op = 0, c
        return sum(stack)

# python里 -3/2==-2
# -3//2=-2，就是个坑
import operator
class Solution(object):
    def calculate(self, s):
        res = []
        opMap = {
            "+": lambda e: res.append(e),
            "-": lambda e: res.append(-e),
            "*": lambda e: res.append(e * res.pop()),
            "/": lambda e: res.append(int((res.pop()/e)))
            # "/": lambda e: a.append(int(operator.truediv(a.pop(), e)))
        }
        op = "+"
        num = 0
        for char in s+"+":
            if char.isdigit():
                num = num * 10 + int(char)
            elif char != " ":
                opMap[op](num)
                op = char
                num = 0
        return sum(res)
```

```py
# 本题不含括号和符号位，所以将 '/' 替换为 '//' 就可以直接调用 eval 了。
class Solution(object):
    def calculate(self, s):
        return eval(s.replace('/', '//'))
```

###  1.104. <a name='SummaryRanges'></a>228 Summary Ranges

[小明](https://www.bilibili.com/video/BV1Et4y1i7YZ?spm_id_from=333.999.0.0)

###  1.105. <a name='MajorityElementII'></a>229. Majority Element II 

[哈哈哈](https://www.bilibili.com/video/BV12z411B7rS?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nK411P7qR?spm_id_from=333.999.0.0)

```py
# 哈希统计

class Solution:
    def majorityElement(self, nums):
        lookup = defaultdict(int)
        res = []
        for num in nums:
            lookup[num] += 1
            if lookup[num] > len(nums) // 3:
                res.append(num)
        return list(set(res))


class Solution:
    def majorityElement(self, nums):
        lookup = {}
        res = []

        for num in nums:
            if num in lookup:
                lookup[num] += 1
            else:
                lookup[num] = 1
        for item in lookup.keys():
            if lookup[item] > len(nums)//3:
                res.append(item)

        return res
```


###  1.106. <a name='KthSmallestElementinaB'></a>230 Kth Smallest Element in a B

[小明](https://www.bilibili.com/video/BV1ha4y1i7dZ?spm_id_from=333.999.0.0)

```py
# 用yield来波骚操作

class Solution:
    def kthSmallest(self, root, k):

        def gen(r):
            if r is not None:
                yield from gen(r.left)
                yield r.val
                yield from gen(r.right)
        
        it = gen(root)
        for _ in range(k):
            ans = next(it)
        return ans

# 收藏一波，博主大大威武
# yield真是迭代优化利器

# 6得飞起！~ 来化简下助涨楼主骚气
class Solution:
    def kthSmallest(self, root, k):
        from itertools import chain, islice
        def gen(x): yield from chain(gen(x.left), [x.val], gen(x.right)) if x else ()
        return next(islice(gen(root), k - 1, k))
```

```py
# InOrder排序，输出
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        stack = []
        while root or stack: # stack一般都有
            while root: # 找到最深的节点，root在最深处的时候就为none
                stack.append(root)
                root = root.left
            root = stack.pop() # stack弹出最深处的节点
            k -= 1
            if k == 0:
                return root.val
            root = root.right #去右孩子看看

class Solution:
    def kthSmallest(self, root, k: int) -> int:
        queue = deque([])

        def inOrder(root):
            
            if not root: return
            helper(root.left)
            queue.append(root.val)
            helper(root.right)
            return

        inOrder(root)
        return queue[k - 1]
```


```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */

object Solution {
    def kthSmallest(root: TreeNode, k: Int): Int = {

      val stack = collection.mutable.Stack[TreeNode]()
      var node = root
      var counter = 0
      var ans = 0
      while ((counter <= k) && (node != null || stack.nonEmpty)) {
        while(node != null) {
          stack push node
          node = node.left
        }
        node = stack.pop
        
        counter += 1
        if (counter == 1 || counter <= k) {
          ans = node.value
        }
        
        node = node.right
        
      }
      ans
    }
}
/**
* my first commit
* inorder iterative template
* time complexity: O(H + K) => H is tree height, H + K = element in stack
*/

object Solution1 {
    def kthSmallest(root: TreeNode, k: Int): Int = {
        
        val stack = collection.mutable.Stack[TreeNode]()
        var node = root
        var counter = 0
        
        
        while(node != null || stack.nonEmpty) {
            while(node != null) {
                stack push node
                node = node.left
            }
            node = stack.pop
            counter += 1
            if(counter == k) return node.value
            else node = node.right
            
        }
        -1
    }
}

/**
* inorder traversal - recursive version
* time complexity: O(H + k)
*/

object Solution2-1 {
    import scala.collection.mutable
    def kthSmallest(root: TreeNode, k: Int): Int = {
        val ret = _kthSmallest(root, k, mutable.ListBuffer.empty)

        ret(k - 1)
    }
    
    def _kthSmallest(node: TreeNode, k:Int, l: mutable.ListBuffer[Int]): mutable.ListBuffer[Int]  = {
       if(node == null) l
       else {
           _kthSmallest(node.left, k, l)
           l += node.value
           if(l.size >= k) l  // shortcut
           else  _kthSmallest(node.right, k, l)  
       }
    }
}


/**
* a brilliant solution - inorder recursive traversal 
* memo:
*   1. using Either, right records numbers of visited node, left record the value when the condition is meet
* time complexity:
*      O(H + K) H is the height of the tree calculated by log(N) approximately
*/
object Solution2-2 {
  def go (node: TreeNode, k: Int) : Either[Int, Int] = {
     val r =for {
      numElementsLeft <- if (node.left == null) Right (0) else go(node.left, k)
      numElementsRight <- if (numElementsLeft + 1 == k) Left(node.value)
      else
        if (node.right == null) Right(0) else go(node.right, k - (numElementsLeft + 1))

    } yield numElementsLeft + numElementsRight + 1
      println(r)
      r

  }

  def kthSmallest(root: TreeNode, k: Int): Int = {
    go(root, k).left.get
  }
}

```



###  1.107. <a name='PowerofTwo'></a>231. 【位运算😜】Power of Two

[小梦想家](https://www.bilibili.com/video/BV1Yb411H73f?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rV411r7AL?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0


class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return bin(n).count('1') == 1 and n > 0



class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & -n) == n
```

```py
2147483648是整数范围内最大的2次幂，若n是2的幂，那么2147483648一定能整除它

class Solution(object):
    def isPowerOfTwo(self, n):
        return n > 0 and 2147483648 % n == 0

        
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        BIG = 1<<30 # 我试了一下，30,31,32都对
        return n > 0 and BIG % n == 0
```

```scala
/**
* time complexity  O(1)
*/
object Solution {
    def isPowerOfTwo(n: Int): Boolean = {
        n > 0 && (n & (n - 1) ) == 0
    }
}
```

###  1.108. <a name='ImplementQueueusingStacks'></a>232-【构造🏰】Implement Queue using Stacks

[哈哈哈](https://www.bilibili.com/video/BV1p741177pp?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Gf4y147Vj?spm_id_from=333.999.0.0)


```py
class MyQueue:

    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x):
        # 要把新来的元素压入
        while self.s1:
            self.s2.append(self.s1.pop())
        self.s2.append(x)
        while self.s2:
            self.s1.append(self.s2.pop())

    def pop(self):
        # 假装最后一个元素是开头
        return self.s1.pop() if self.s1 else None
        

    def peek(self):
        # 假装最后一个元素是开头
        return self.s1[-1] if self.s1 else None

    def empty(self):
        return False if self.s1 else True
```

```scala
/**
* using two stack to implement
* one for push, the other for pop
* time complexity amortized O(1) per operation
* space complexity
*/

class MyQueue() {

  /** Initialize your data structure here. */
  private val inputStack = scala.collection.mutable.ArrayStack[Int]()
  private val outputStack = scala.collection.mutable.ArrayStack[Int]()


  /** Push element x to the back of queue. */
  def push(x: Int) {
    inputStack.push(x)

  }

  /** Removes the element from in front of queue and returns that element. */
  def pop(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.pop()

  }

  /** Get the front element. */
  def peek(): Int = {
    if(outputStack.isEmpty) {
      while (inputStack.nonEmpty) {
        outputStack.push(inputStack.pop())
      }
    }
    if(outputStack.isEmpty) -1 else outputStack.head
  }

  /** Returns whether the queue is empty. */
  def empty(): Boolean = {
    outputStack.isEmpty && inputStack.isEmpty
  }

}

```

###  1.109. <a name='PalindromeLinkedList'></a>234. 【回文🌈】Palindrome Linked List

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7ML?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        vals = []
        current_node = head
        while current_node is not None:
            vals.append(current_node.val)
            current_node = current_node.next
        return vals == vals[::-1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Solution:
    def isPalindrome(self, head: ListNode) -> bool:

        self.front_pointer = head

        def recursively_check(current_node=head):
            if current_node is not None:
                if not recursively_check(current_node.next):
                    return False
                if self.front_pointer.val != current_node.val:
                    return False
                self.front_pointer = self.front_pointer.next
            return True

        return recursively_check()

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
秒啊，就是有可能数字太大
可以理解成字符串(链表)转数字，如果是回文🌈从前往后与从后往前得到的数字是一样的
虽然没有深入想，但是这个算法在经过证明之前，真心不敢用。有可能在特定测试例下失败
只有python 能做，只要用强制类型语言都会越界。
class Solution(object):

def isPalindrome(self, head):
    s1=0
    s2=0
    t=1

    while head!=None:
        s1=s1*10+head.val
        s2=s2+t*head.val
        t=t*10
        head=head.next
        
    return s1==s2
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
 
 /**
 * my first commitment
 *  using two pointer, one run 2 times faster than the other
 */
object Solution1 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null){
            true
        }else {
            var slowPre: ListNode = null
            var slow = head
            var fast = head

            while (fast != null && fast.next != null) {
                fast = fast.next.next

                val slowNext = slow.next
                slow.next = slowPre
                slowPre = slow
                slow = slowNext

            }

            fast match {
                case null => checkPalindrome(slowPre, slow)
                case _ => checkPalindrome(slowPre, slow.next)  // odd case
            }
            /**
                1 2 2 1 null
                s f
                    s   f  

                1 2 3 2 1 null
                s f   
                    s   f
            */
        }
       
                
    }
    def checkPalindrome(left: ListNode, right: ListNode): Boolean = {
        (left, right) match {
            case (null, null) => true
            case (l, r) if l != null && r != null && l.x == r.x => checkPalindrome(left.next, right.next)
            case _ => false   
        }
        
    }
    

    def printNode(node: ListNode) {
        var n = node
        
        while(n != null) {
            print(s"${n.x}\t")
            n = n.next
        }
    }
}


/**
* very brilliant solution
*/
object Solution2 {
    def isPalindrome(head: ListNode): Boolean = {
        if (head == null) {
            return true
        }
        var p = head
        var result = true
        def go(node: ListNode): Unit = {
            if (node.next != null) {
                go(node.next)
            }
            if (p.x != node.x) {
                result = false
            }
            p = p.next
        }
        go(head)
        result
    }
}
```

```scala
/**
 * Definition for singly-linked list.
 * class ListNode(_x: Int = 0, _next: ListNode = null) {
 *   var next: ListNode = _next
 *   var x: Int = _x
 * }
 */
object Solution {
    def isPalindrome(head: ListNode): Boolean = {
        var flag = true
        var rev = head
        var h = head
        def reverse(n: ListNode): Unit = {
            if(n == null){
                ()
            }else{
                reverse(n.next)
                val cond = n.x == h.x
                flag = flag && cond
                h = h.next
            }
        }
       
        reverse(rev)
        flag
    }
}

```

###  1.110. <a name='LowestCommonAncestorofaBinarySearchTree'></a>235. Lowest Common Ancestor of a Binary Search Tree

[小梦想家](https://www.bilibili.com/video/BV1Yb411H7VY?spm_id_from=333.999.0.0)

```py
class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        def getPath(root: TreeNode, target: TreeNode) -> List[TreeNode]:
            path = list()
            node = root
            while node != target:
                path.append(node)
                if target.val < node.val:
                    node = node.left
                else:
                    node = node.right
            path.append(node)
            return path
        
        path_p = getPath(root, p)
        path_q = getPath(root, q)
        ancestor = None
        for u, v in zip(path_p, path_q):
            if u == v:
                ancestor = u
            else:
                break
        
        return ancestor

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        ancestor = root
        while True:
            if p.val < ancestor.val and q.val < ancestor.val:
                ancestor = ancestor.left
            elif p.val > ancestor.val and q.val > ancestor.val:
                ancestor = ancestor.right
            else:
                break
        return ancestor

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python3 利用二叉搜索树的特点，如果p、q的值都小于root，

说明p q 肯定在root的左子树中；如果p q都大于root，

说明肯定在root的右子树中，如果一个在左一个在右 

则说明此时的root记为对应的最近公共祖先 //python3

太有道理了, 我竟然没当成搜索树来看待。

根据搜索树的特点，如果 p，q 值 都 < root 的值，就去左子树
根据搜索树的特点，如果 p，q 值 都 > root 的值，就去右子树
否则就是说分布在 root的左右子树中

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if p.val<root.val and q.val<root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        
        if p.val>root.val and q.val>root.val:
            
            return self.lowestCommonAncestor(root.right,p,q)
        
        return root
```

```py
递归法：

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root: return root  //中
        if root.val >p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left,p,q)  //左
        elif root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right,p,q)  //右
        else: return root

若p、q分别在某一节点的左右子树内，则该节点为最小公共祖先。

（对于二叉搜索树而言，即需满足该min(p,q)<=node.val<=max(p,q)）

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        r1=max(p.val,q.val)
        r2=min(p.val,q.val)
        while root :
            if root.val>=r2 and root.val<=r1:
                return root
            if root.val>r1:
                root=root.left
            else:
                root=root.right
        return root
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
* DFS 
* 
* exploit binary search three property:  right > parent value > left
* time complexity : O(N)
* space complexity: O(N)
*/
object Solution1 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }
  
  @annotation.tailrec
  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    (p, q) match {
      case (pp, qq) if p.value > node.value && q.value > node.value  && node != null => _lowestCommonAncestor(node.right, pp, qq)
      case (pp, qq) if p.value < node.value && q.value < node.value && node != null => _lowestCommonAncestor(node.left, pp, qq)
      case _ => node
    }
  }
}


/**
* iterative version
*/
object Solution1-2 {
    def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
      if(root == null) return root
      var node = root
      
      var condition = true
      while(condition && node != null){
        if(q.value > node.value && p.value > node.value)
          node = node.right
        else if (node.value > q.value && node.value > p.value)
          node = node.left
        else 
          condition = false
      }
      node
    }
}
```

###  1.111. <a name='-1'></a>236-二叉树的最近公共祖先

[哈哈哈](https://www.bilibili.com/video/BV1ov411172r?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV125411p7dr?spm_id_from=333.999.0.0)

```py
# 提供一个python3题解：

# 思路 ：这是我看过解释最清楚的youtube题解 需要听懂印度口音英语，但讲得非常好

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return 
        if root == p or root == q:
            return root 
        left = self.lowestCommonAncestor(root.left,p,q)
        right = self.lowestCommonAncestor(root.right,p,q)
        if left and right:
            return root 
        elif left and not right:
            return left 
        elif right and not left:
            return right 

# Python 超越99%执行速度的解法：而且也简短

class Solution:
    def lowestCommonAncestor(self, root, p, q) -> 'TreeNode':

        if root in (None,p,q):
            return root 

        L = self.lowestCommonAncestor(root.left,p,q)
        R = self.lowestCommonAncestor(root.right,p,q)

        return R if None==L else L if None==R else root

# 左子树或自己含p 就返回p，右子树或自己含q就返回q，左右子树返回一p一q则返回自己，
# 如果某子树返回了答案（另一子树必然返回None），
# 则返回答案，剩下就是两个子树都返回空，则返回空。 
# 经过逻辑化简：

# 先分析自己，自己是p,q,None中的一者，自然返回自己。
# 然后分析左右子树的返回值，如果其中一个是None，则返回另一个，
# 作为传递，无论是传递最终的答案，还是传递p和q。
# 如果左右子树返回p和q，当然返回root。 Python中的None即C/C++/Java 中的Null/null

# //递归
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q: return root  
        # //找到了节点p或者q，或者遇到空节点
        left = self.lowestCommonAncestor(root.left,p,q)  
        # //左
        right = self.lowestCommonAncestor(root.right,p,q)  
        # //右
        if left and right: return root  
        # //中: left和right不为空，root就是最近公共节点
        elif left and not right: return left  
        # //目标节点是通过left返回的
        elif not left and right: return right  
        # //目标节点是通过right返回的
        else: return None  
        # //没找到
```

```scala
/**
 * Definition for a binary tree node.
 * class TreeNode(var _value: Int) {
 *   var value: Int = _value
 *   var left: TreeNode = null
 *   var right: TreeNode = null
 * }
 */

/**
*  chosen solution
*  DFS with recursive
*  time complexity O(N), N is the number of node in the tree
*  space complexity O(N)
*/
object Solution0 {
  def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    _lowestCommonAncestor(root, p, q)
  }

  private def _lowestCommonAncestor(node: TreeNode, p: TreeNode, q: TreeNode): TreeNode = {
    if (node == null || node == p || node == q) return node
    /**
    *  1. if p and q are node 's child, return p q 's LCA 
    *  2.  if p and q are not node's child return null
    *  3. if p and q, only one of then ar node's child return that node (p or q)
    */
    val left = _lowestCommonAncestor(node.left, p, q)
    val right = _lowestCommonAncestor(node.right, p, q)

    (left, right) match {
      case (null, _) => right  // p and q are both not in left
      case (_, null) => left  // p and q are both not in right
      case (l, r) =>  node // only lowest common ancestor could return both non null node
      // p and q, one of then in left and the other one in right
    }
  }
}
```

###  1.112. <a name='DeleteNodeinaLinkedList'></a>237. Delete Node in a Linked List

[小梦想家](https://www.bilibili.com/video/BV1rv411h7Lv?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1ap4y1C7JP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vt4y1y7eM?spm_id_from=333.999.0.0)

```py
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next

```


```scala
object Solution {
    def deleteNode(node: ListNode): Unit = {
        node.x = node.next.x
        node.next = node.next.next 
    }
}

```

###  1.113. <a name='ProductofArrayExceptSelf'></a>238 【前缀和🎨】Product of Array Except Self

[小明](https://www.bilibili.com/video/BV1oT4y1G78Y?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV16z4y197oQ?spm_id_from=333.999.0.0)

```py
# 方法一：左右乘积列表
class Solution:
    def productExceptSelf(self, nums):
        n=len(nums)
        left=[1]*n
        right=[1]*n
        res=[]
        for i in range(1,n):
            left[i]=left[i-1]*nums[i-1]
        for i in range(n-2,-1,-1):
        # 等价于： for i in reversed(range(n - 1)):
            right[i]=right[i+1]*nums[i+1]
        for i in range(n):
            res.append(left[i]*right[i])
        return res 

# 方法二：空间复杂度 O(1)O(1) 的方法

# 思路
# 尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。
# 由于输出数组不算在空间复杂度内，那么我们可以将 L 或 R 数组用输出数组来计算。
# 先把输出数组当作 L 数组来计算，然后再动态构造 R 数组得到结果。
# 让我们来看看基于这个思想的算法。
      
# python 思想：前缀积，前缀积和前缀和🎨差不多
# 用一个数组来存储每一个数的左边的数的乘积，那么 ans[i] = ans[i-1]*nums[i]， 
# 第一个数左边没有数，认为ans[0] = 1。
# 再用一个数 R 来存储右边的数的乘积，
# 从后往前循环，ans乘以R就是左右数缀的乘积，同时更新R。
class Solution:
    def productExceptSelf(self, nums):
        n = len(nums)
        res = [1]*n
        right = 1
        for i in range(1, n):
            res[i] = res[i-1] * nums[i-1]
        for i in range(n-1, -1, -1):
        # 等价于： for i in reversed(range(n)):
            res[i] *= right
            right *= nums[i]
        return res
```

```scala
object Solution {

    //pre-compute prefix & suffix products in O(N) time and then multiply them
    def productExceptSelf(nums: Array[Int]): Array[Int] = {
        var prefix = Array.fill(nums.length)(1)
        var suffix = Array.fill(nums.length)(1)
        
        (1 until prefix.length).map(i => {
            prefix(i) = prefix(i-1)*nums(i-1)
        })
        
        (suffix.length-2 to 0 by -1).map(i => {
            suffix(i) = suffix(i+1)*nums(i+1)
        })
        
        (0 until nums.length).map(i => {
            nums(i) = prefix(i) * suffix(i)
        })
        nums
    }
}

```

###  1.114. <a name='SlidingWindowMaximum'></a>239. ★【最小堆🌵 + 滑动窗口🔹单调队列】Sliding Window Maximum

#### 不类似567，567类似187

[花花酱](https://www.bilibili.com/video/BV1WW411C763?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Bf4y1v758?spm_id_from=333.999.0.0)

这个窗口里面，每一个值都可能有用的

包含：

52343  k=4

- 新加入的值 3
- 将要被弹出的值 5
- 过去的最大值 5


```py
思路：

维护：最大值的pos、最接近右边的最大值的pos
# winQ []
# winQ [0]
# winQ [0, 1]
# winQ [0, 2]
# winQ [0, 3]

s = Solution()
print(s.maxSlidingWindow([5,2,3,4,3],4))
```

```py
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        winpos, maxnums = [], []

        for i, v in enumerate(nums):
            # 小于新加入的值全部弹出。最左端即为窗口最大值 
            while winpos and nums[winpos[-1]] <= v: 
                winpos.pop()
            winpos.append(i)

            # 弹出出界的left
            if i >= k and winpos[0] <= i - k: 
                winpos.pop(0)

            # 开始写入答案
            if i >= k - 1: 
                maxnums.append(nums[winpos[0]])
                
        return maxnums
        
# print(winpos)
# [1,3,-1,-3,5,3,6,7]
保证窗口内的值是递减的即可
# []
# [0]
# [1]
# [1, 2]
# [1, 2, 3]
# [4]
# [4, 5]
# [6]

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        winQ = deque()
        res = []
        for i, v in enumerate(nums):

            while winQ and nums[winQ[-1]] < v:
                winQ.pop()
            winQ.append(i)

            if i - k == winQ[0]:
                winQ.popleft()

            if i >= k - 1:
                res.append(nums[winQ[0]])

        return res
```

```py
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # 注意 Python 默认的优先队列是小根堆
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        ans = [-q[0][0]]
        for i in range(k, n):
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:
                heapq.heappop(q)
            ans.append(-q[0][0])
        
        return ans


class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        q = collections.deque()
        for i in range(k):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)

        ans = [nums[q[0]]]
        for i in range(k, n):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
            while q[0] <= i - k:
                q.popleft()
            ans.append(nums[q[0]])
        
        return ans

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        prefixMax, suffixMax = [0] * n, [0] * n
        for i in range(n):
            if i % k == 0:
                prefixMax[i] = nums[i]
            else:
                prefixMax[i] = max(prefixMax[i - 1], nums[i])
        for i in range(n - 1, -1, -1):
            if i == n - 1 or (i + 1) % k == 0:
                suffixMax[i] = nums[i]
            else:
                suffixMax[i] = max(suffixMax[i + 1], nums[i])

        ans = [max(suffixMax[i], prefixMax[i + k - 1]) for i in range(n - k + 1)]
        return ans

```

```scala

/**
* chosen solution 
* using  array deque (double side queue)  which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution0 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
        //you should always delete elements from right side
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* using max heap, may not AC
* pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)} : keep element's time complexity is O(K)
* time complexity: O(N log K)
*/

object Solution1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        var pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
        val rest = scala.collection.mutable.ArrayBuffer[Int]()
        
        nums.zipWithIndex.foreach{case (v: Int, idx: Int) => {
     
            pq += ((v, idx))
            
            /* keep the elements that is only larger than newest v and the nearest k */
            pq = pq.filter{case (_v: Int, _idx: Int) => (_v >= v) && (_idx > idx - k)}       

            if (idx + 1 >= k) {
                rest += pq.head._1
            }
          
        }}        
        rest.toArray
    }
}


/**
* may not AC
* fold left version, it is worst than for loop version
*/
object Solution1-2 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val pq = scala.collection.mutable.PriorityQueue.empty[(Int, Int)](Ordering.by(p  => p._1))
  val (_, rest, _) = nums.zipWithIndex.foldLeft((pq, Array.empty[Int], k)){
    (B, v_id) =>
      val (_pq, rest: Array[Int], _k) = B
      var newPq = _pq
      newPq += v_id
      if(v_id._2 + 1 >= k) {
        newPq = newPq.filter{case (_v:Int, _idx: Int) => (_v >= v_id._1) && (_idx > v_id._2 - k) }
          
         (newPq, rest :+ newPq.head._1, _k)
      }else {
         (newPq, rest, _k)
      }
     
  }
  rest
        
    }
}


/**
* using scala vector, due to scala vector is immutable, any operation about add update remove is generate a new vector
* so it's not a proper substitute for deque
*/

object Solution2 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    var windows = Vector.empty[Int]
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.head <= index - k)
        windows = windows.drop(1)

      while (windows.nonEmpty && nums(windows.last) <= value){
        windows = windows.dropRight(1)
      }
      windows = windows :+ index
      if (index + 1 >= k) {
        ret += nums(windows.head)
      }
    }
    ret.toArray
  }
}

/**
* using java array deque (double side queue) version which remove first/last element from collection is O(1)
* time complexity O(N)
*/
object Solution3 {
  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
    import java.util
    val windows = new util.ArrayDeque[Int]  // record nums index
    val ret = scala.collection.mutable.ArrayBuffer.empty[Int]

    nums.zipWithIndex.foreach { case (value: Int, index: Int) =>
      if (index >= k && windows.peekFirst() <= index - k) {
        // remove out of date element
        windows.removeFirst()
      }

      while (!windows.isEmpty && nums(windows.peekLast()) <= value) {
        // drop the element if  it is smaller than upcoming element
        windows.removeLast()
      }
      windows.add(index)
      if (index + 1 >= k) {
        ret += nums(windows.peekFirst())
      }
    }
    ret.toArray
  }
}

/**
* use scala build-in arrayDeque
*/
object Solution3-1 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
      val deque = collection.mutable.ArrayDeque[Int]()
      val ret = collection.mutable.ArrayBuffer.empty[Int]
      
      nums.indices.foreach { case idx =>

        val upcoming = nums(idx)
        if (idx >= k && deque.head <= (idx - k)){
          deque.dropInPlace(1)
        }

        while(deque.nonEmpty && nums(deque.last) <= upcoming) {
        // drop the element if  it is smaller than upcoming element
          deque.dropRightInPlace(1)
        }

        deque.append(idx)

        if(idx + 1  >= k) {
          ret += nums(deque.head)
        }
      }
      ret.toArray  
    }
}

/**
* brute force, not AC
*/
object Solution4 {
    def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {
        nums.sliding(k).map(_.max).toArray
    }
}
```

###  1.115. <a name='-1'></a>240. 二维数组的查找

[哈哈哈](https://www.bilibili.com/video/BV1dz411i7jC?spm_id_from=333.999.0.0)

```py
import bisect
class Solution:
    def searchMatrix(self, matrix, target):
        for row in matrix:
            idx = bisect.bisect_left(row, target)
            if idx < len(row) and row[idx] == target:
                return True
        return False
```

```py
class Solution(object):
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix:
            return False
        row = len(matrix)
        col = len(matrix[0]) if row else 0 
        m, n = 0, col - 1
        while m < row and n >= 0:
            if matrix[m][n] < target:
                m += 1
            elif matrix[m][n] > target:
                n -= 1
            else:
                return True
        return False

class Solution:
    def searchMatrix(self, matrix, target):
        for row in matrix:
            for element in row:
                if element == target:
                    return True
        return False

# 从右上角开始找，若目标小了就左移，目标大了就下移

class Solution:
    def searchMatrix(self, matrix, target):
        i,j=0,len(matrix[0])-1
        while i<len(matrix) and j>=0:
            if matrix[i][j]==target: return True
            if target<matrix[i][j]: j-=1
            elif target>matrix[i][j]: i+=1
        return False


class Solution:
    def searchMatrix(self, matrix, target):
        m,n=len(matrix),len(matrix[0])
        for i in range(m):
            for j in range(n):
                if matrix[i][j]<target:
                    continue
                elif matrix[i][j]==target:
                    return True 
                else:
                    if j==0:
                        return False 
                    else:
                        break
        return False
# （python）对每一行二分查找
# 分治法。

# 左下角的元素是这一行中最小的元素，同时又是这一列中最大的元素。比较左下角元素和目标：
# 若左下角元素等于目标，则找到
# 若左下角元素大于目标，则目标不可能存在于当前矩阵的最后一行，问题规模可以减小为在去掉最后一行的子矩阵中寻找目标
# 若左下角元素小于目标，则目标不可能存在于当前矩阵的第一列，问题规模可以减小为在去掉第一列的子矩阵中寻找目标
# 若最后矩阵减小为空，则说明不存在
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        if n == 0:
            return False

        i = m - 1
        j = 0
        while i >= 0 and j < n:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                j = j + 1
            else:
                i = i - 1
        return False
class Solution:
    def searchMatrix(self, matrix, target):
        row,col=len(matrix),len(matrix[0])
        for i in range(row):
            left,right=0,col-1
            while left<=right:
                mid=(left+right)//2
                if matrix[i][mid]==target:
                    return True
                elif matrix[i][mid]>target:
                    right=mid-1
                else:
                    left=mid+1
        return False 
```

###  1.116. <a name='ValidAnagram'></a>242. Valid Anagram 

[小梦想家](https://www.bilibili.com/video/BV1Db411s78v?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hV411i73u?spm_id_from=333.999.0.0)

```py
直接返回两个计数器是否相等即可

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)


class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        a = collections.Counter(s)
        b = collections.Counter(t)
        return True if a == b else False
```

```py
Python：

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        record = [0] * 26
        for i in range(len(s)):
            #并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[ord(s[i]) - ord("a")] += 1
        print(record)
        for i in range(len(t)):
            record[ord(t[i]) - ord("a")] -= 1
        for i in range(26):
            if record[i] != 0:
                #record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return False
        return True
Python写法二（没有使用数组作为哈希表，只是介绍defaultdict这样一种解题思路）：

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import defaultdict
        
        s_dict = defaultdict(int)
        t_dict = defaultdict(int)

        for x in s:
            s_dict[x] += 1
        
        for x in t:
            t_dict[x] += 1

        return s_dict == t_dict
```

```scala

/**
* chosen solution
* one line version
* time complexity: O(N)
*/

object Solution0 {
  def isAnagram(s: String, t: String): Boolean = {
   s.groupBy(identity).mapValues(_.length).toMap == t.groupBy(identity).mapValues(_.length).toMap  // toMap: transform MapView to Map

  }
}


/**
* my first commit
* time complexity: O(N)
*/

object Solution1 {
  def isAnagram(s: String, t: String): Boolean = {
    charCounter(s) equals charCounter(t)
  }
  private def charCounter(str: String): Map[Char, Int] = {
    str.foldLeft(collection.mutable.Map.empty[Char, Int]) {
      (map, s) =>
        map.get(s) match {
          case Some(e) =>
            map.update(s, e + 1)
            map
          case None =>
            map.update(s, 1)
            map
        }
    }.toMap
  }
}



```

```scala
//Time complexity( O(NlogN + N))
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        if(arr1.size != arr2.size){
            false
        } else{
            java.util.Arrays.sort(arr1)
            java.util.Arrays.sort(arr2)
            
            var flag = true
            import scala.util.control.Breaks._
            var index = 0
            breakable{
            while(index < arr1.size){
                if(arr1(index) != arr2(index)){
                    flag = false
                    break
                }
                index += 1
            }
            }
            flag
        }
    }
}

//Time complexity O(n)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        var arr1 = s.toArray
        var arr2 = t.toArray
        
        if(arr1.size != arr2.size){
            false
        } else{
            var map = scala.collection.mutable.Map.empty[Char, Int]
            for(elem <- arr1){
                map.get(elem) match{
                    case Some(count) => map += (elem -> (count+1))
                    case None => map += (elem -> 1)
                }
            }
            
            for(elem <- arr2){
                map.get(elem) match{
                    case Some(count) if count == 1 => map.remove(elem)
                    case Some(count) => map += (elem -> (count-1))
                    case None => ()
                }
            }
            
            if(map.keys.isEmpty) true else false
        }
    }
}

//One more: O(N)
object Solution {
    def isAnagram(s: String, t: String): Boolean = {
        if(s.size != t.size){
            false
        }else{
        var arr = Array.fill(26)(0)
        for(elem <- s){
            arr(elem - 'a') += 1
        }
        
        import scala.util.control.Breaks._
        var flag = true
        breakable{
        for(elem <- t){
            arr(elem - 'a') -= 1
            if(arr(elem - 'a') < 0){
                flag = false
                break
            }
        }
        }
        flag
    }
    }
}

```

###  1.117. <a name='ShortestWordDistance'></a>243. Shortest Word Distance

[小梦想家](https://www.bilibili.com/video/BV1Lb411x7Ae?spm_id_from=333.999.0.0)

###  1.118. <a name='StrobogrammaticNumber'></a>246. Strobogrammatic Number

[小梦想家](https://www.bilibili.com/video/BV14b411g7zD?spm_id_from=333.999.0.0)

###  1.119. <a name='-1'></a>257-二叉树的所有路径

[哈哈哈](https://www.bilibili.com/video/BV1rf4y1X7He?spm_id_from=333.999.0.0)

```py
class Solution:
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        def construct_paths(root, path):
            if root:
                path += str(root.val)
                if not root.left and not root.right:  # 当前节点是叶子节点
                    paths.append(path)  # 把路径加入到答案中
                else:
                    path += '->'  # 当前节点不是叶子节点，继续递归遍历
                    construct_paths(root.left, path)
                    construct_paths(root.right, path)

        paths = []
        construct_paths(root, '')
        return paths

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        paths = list()
        if not root:
            return paths

        node_queue = collections.deque([root])
        path_queue = collections.deque([str(root.val)])

        while node_queue:
            node = node_queue.popleft()
            path = path_queue.popleft()

            if not node.left and not node.right:
                paths.append(path)
            else:
                if node.left:
                    node_queue.append(node.left)
                    path_queue.append(path + '->' + str(node.left.val))
                
                if node.right:
                    node_queue.append(node.right)
                    path_queue.append(path + '->' + str(node.right.val))
        return paths

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python3 最好理解的递归实现

class Solution:
            
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root:
            return []
        if not root.left and not root.right:
            return [str(root.val)]
        paths = []
        if root.left:
            for i in self.binaryTreePaths(root.left):
                paths.append(str(root.val) + '->' + i)
        if root.right:
            for i in self.binaryTreePaths(root.right):
                paths.append(str(root.val) + '->' + i)
        return paths  
paths 递归每调用一次要创建一个以便给上一层遍历（叠加）
调用self.binaryTreePaths(root.left)得到的是左子树的全部路径，加入左子树为[1,2,3],那么得到的结果是[1,2],[1,3]两组，然后还要和根节点进行拼接，所以要用循环。
```

```scala
package com.zhourui.leetcode
import com.zhourui.codech._

//Given a binary tree, return all root-to-leaf paths.
//
//Note: A leaf is a node with no children.
//
//Example:
//
//Input:
//
//1
///   \
//2     3
//\
//5
//
//Output: ["1->2->5", "1->3"]
//
//Explanation: All root-to-leaf paths are: 1->2->5, 1->3

package lc0257 {

  import scala.collection.mutable.ArrayBuffer

  object Solution {
    def binaryTreePaths(root: TreeNode): List[String] = {
      val tmp = ArrayBuffer[Int]()
      val ret =ArrayBuffer[ArrayBuffer[Int]]()
      helper(root, tmp, ret)
      ret.toList.map({
        x=>x.mkString("->")
      })
    }

    def helper(node:TreeNode,tmp:ArrayBuffer[Int],ret:ArrayBuffer[ArrayBuffer[Int]]): Unit = {
      if (node==null) {
        return
      }

      tmp += node.value

      if (node.left == null && node.right==null) {
          ret += tmp.clone()
      } else {
        helper(node.left, tmp, ret)
        helper(node.right, tmp, ret)
      }
      tmp.remove(tmp.length-1)
    }
  }

  class Test extends BaseExtension {
    def init {
      val t1 = Tree.build(IndexedSeq("1","2 3","5 N N N"))
      println(Solution.binaryTreePaths(t1))
    }
    val name = "257 binary tree path"
  }
}

```

###  1.120. <a name='AddDigits'></a>258. Add Digits

[小梦想家](https://www.bilibili.com/video/BV1ub41137cm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1N54y1B7XU?spm_id_from=333.999.0.0)

```py
除了传统的单纯循环，还可以找规律。

假如一个三位数'abc'，其值大小为s1 = 100 * a + 10 * b + 1 * c，

经过一次各位相加后，变为s2 = a + b + c，减小的差值为(s1 -s2) = 99 * a + 9 * b，

差值可以被9整除，每一个循环都这样，缩小了9的倍数。

当num小于9，即只有一位时，直接返回num，

大于9时，如果能被9整除，则返回9

（因为不可能返回0也不可能返回两位数及以上的值），

如果不能被整除，就返回被9除的余数。

class Solution:
    def addDigits(self, num: int) -> int:
        if num > 9:
            num = num % 9
            if num == 0:
                return 9
        return num

class Solution:
    def addDigits(self, num: int) -> int:
        while num>9:
            num=sum([int(c) for c in str(num)])
        return num
```

```py
但对于Python来说，% 取余运算是对整体进行运算，结果是非负数，故 -10 % 9 = 8，所以上述逻辑在Python中有小瑕疵，需提前进行判断，代码如下：

class Solution:
    def addDigits(self, num: int) -> int:
        return (num - 1) % 9 + 1 if num >= 10 else num

class Solution:
    def addDigits(self, num: int) -> int:
        return num - int((num - 1) / 9) * 9
```

###  1.121. <a name='III-1'></a>260-【位运算😜】只出现一次的数字 III

[哈哈哈](https://www.bilibili.com/video/BV15Z4y1H7Sw?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK411J7dN?spm_id_from=333.999.0.0)

难点在于只出现一次的数字不止一个，

但是刚好有且只有两个

```py

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        freq = Counter(nums)
        return [num for num, occ in freq.items() if occ == 1]

```

```py
复杂度分析

时间复杂度：O(n)，其中 n 是数组 nums 的长度。

空间复杂度：O(1)。

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        xorsum = 0
        for num in nums:
            xorsum ^= num # 找到这两个数的差异
        
        lsb = xorsum & (-xorsum) # 找到这两个数的差异的最后一位1
        type1 = type2 = 0
        for num in nums:
            if num & lsb: # 这里只能用 &，来决num & lsb == 100 or 0
                type1 ^= num
            else:
                type2 ^= num
        
        return [type1, type2]


思路, 先全部异或一次, 得到的结果, 考察其的某个非0位(比如最高非0位), 那么只出现一次的两个数中, 在这个位上一个为0, 一个为1, 由此可以将数组中的元素分成两部分,重新遍历, 求两个异或值
```

###  1.122. <a name='UglyNumber'></a>263 Ugly Number

[花花酱](https://www.bilibili.com/video/BV11W411C7zd?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1Mb41157Pa?spm_id_from=333.999.0.0)

```py
class Solution:
    def isUgly(self, n: int) -> bool:
        # 特判，整数n为1时，即为丑数，返回true
        if n == 1:
            return True
        # 如果整数n为0时，直接返回false
        elif n == 0:
            return False

        # 对整数n判断是只包含质因数2、3、5
        while n != 1:
            if n % 2 == 0:
                n /= 2
            elif n % 3 == 0:
                n /= 3
            elif n % 5 == 0:
                n /= 5
            else:
                return False
        # 否则就为丑数，返回true
        return True


class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False

        factors = [2, 3, 5]
        for factor in factors:
            while n % factor == 0:
                n //= factor
        
        return n == 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/ugly-number/solution/chou-shu-by-leetcode-solution-fazd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
思路一：递归

class Solution:
    def isUgly(self, num: int) -> bool:
        if num == 0: return False
        if num == 1:return True
        if num % 2 == 0: return self.isUgly(num // 2)
        if num % 3 == 0: return self.isUgly(num // 3)
        if num % 5 == 0: return self.isUgly(num // 5)
        return False
思路二：迭代

class Solution:
    def isUgly(self, num: int) -> bool:
        for p in 2, 3, 5:
            while num % p == 0 < num:
                num //= p
        return num == 1

菜鸡想问问 num % p == 0 < num: 这里为啥要加一个<num呢？ 不加会超时，没搞懂原理😥
防止num为0时无限循环
```

###  1.123. <a name='UglyNumberII'></a>264. 【动态🚀规划 + 3指针】Ugly Number II

[花花酱](https://www.bilibili.com/video/BV1yW411C7Sm?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vT4y1775u?spm_id_from=333.999.0.0)

```py
# python 实习面试这道题挂了，但我就不懂了，第一次见这题目谁能想到3指针的方法？
# [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]
class Solution(object):
    def nthUglyNumber(self, n):
        res = [1]
        idx2 = 0
        idx3 = 0
        idx5 = 0
        for i in range(n-1):
            nxt = min(res[idx2]*2, res[idx3]*3, res[idx5]*5)
            res.append(nxt)
            print(res[idx2]*2, res[idx3]*3, res[idx5]*5, res)
            if nxt == res[idx2]*2:
                idx2 += 1
            if nxt == res[idx3]*3:
                idx3 += 1
            if nxt == res[idx5]*5:
                idx5 += 1
        return res[-1]

# 2 3 5 [1, 2]
# 4 3 5 [1, 2, 3]
# 4 6 5 [1, 2, 3, 4]
# 6 6 5 [1, 2, 3, 4, 5]
# 6 6 10 [1, 2, 3, 4, 5, 6]
# 8 9 10 [1, 2, 3, 4, 5, 6, 8]
# 10 9 10 [1, 2, 3, 4, 5, 6, 8, 9]
# 10 12 10 [1, 2, 3, 4, 5, 6, 8, 9, 10]
# 12 12 15 [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]

```

###  1.124. <a name='MissingNumber'></a>268 【位运算😜】Missing Number


[小明](https://www.bilibili.com/video/BV1LU4y1p7n7?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1caw225arjj4.webp)

```py
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        nums.sort()
        for i, num in enumerate(nums):
            if num != i:
                return i
        return len(nums)


class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        s = set(nums)
        for i in range(len(nums) + 1):
            if i not in s:
                return i




class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        total = n * (n + 1) // 2
        arrSum = sum(nums)
        return total - arrSum


```

```py
枚举法：
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        xor = len(nums)
        for i, num in enumerate(nums):
            xor ^= i
            xor ^= num
        return xor

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        xor = 0
        for i, num in enumerate(nums):
            xor ^= i ^ num
        return xor ^ len(nums)

进阶解法 用可能出现的所有数的和 - 实际出现的数的和 = 未出现的数 res

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = len(nums)
        # 用可能出现的所有数(n + range(n))的和 - 实际出现的数 nums 的和 = 未出现的数 res
        for i, num in enumerate(nums) :
            res += i - num
        return res
```

```py
（python）集合做差 O(n)

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        a=set(nums)
        b=set()
        for i in range(len(nums)+1):
            b.add(i)
        return list(b-a)[-1]

利用集合的方法时间复杂度更低一些，感谢提醒

开始不认真看题目以为求出所有，所以用两个集合求差集，然后发现结果只有一个数，就改了下

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        return list({i for i in range(0, len(nums)+1)} - set(nums))[0]
```

```py
（python）排序比较 O(n*logn)

class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        res = 0
        nums.sort()
        n = len(nums)
        for i in range(n):
            if res == nums[i]:
                res += 1
            else:
                return res 
        return n 

如果直接求和的最大的和为 49995000 未超出 int 的范围 


```

```scala
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        val idealSum = (size * (size + 1))/2
        
        val arraySum = nums.foldLeft(0)(_ + _) // can also use nums.sum
        
        idealSum - arraySum
    }
}

//Removing foldLeft improved time
object Solution {
    def missingNumber(nums: Array[Int]): Int = {
        val size = nums.size
        var idealSum = (size * (size + 1))/2
        
        for(num <- nums){
            idealSum -= num
        }

        idealSum
    }
}

```

###  1.125. <a name='ClosestBinarySearchTreeValue'></a>270. Closest Binary Search Tree Value

[哈哈哈](https://www.bilibili.com/video/BV1zy4y1a7mR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1fi4y1u7Sb?spm_id_from=333.999.0.0)

```py

```

```py

```

###  1.126. <a name='H-Index'></a>274 H-Index

[小明](https://www.bilibili.com/video/BV1ZV411z7Kx?spm_id_from=333.999.0.0)


###  1.127. <a name='FirstBadVersion'></a>278. First Bad Version

[小梦想家](https://www.bilibili.com/video/BV1rZ4y1P7YF?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1cQ4y1N7dc?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        left = 1
        right = n
        while left < right:
            mid = left + (right - left) // 2
            if isBadVersion(mid) == True:
                right = mid
            else:
                left = mid + 1
        return right
```

```py
class Solution:
    def firstBadVersion(self, n):
        if isBadVersion(1) == True:
            return 1
        else:

            left = 1
            right = n
            while right - left > 1:
                k = int((left + right) / 2)
                if isBadVersion(k) == False:
                    left = k
                else:
                    right = k
            return right
```

```scala
/* The isBadVersion API is defined in the parent class VersionControl.
      def isBadVersion(version: Int): Boolean = {} */



/**
* my first commitment
* binary search recursive version
* time complexity
*   log(n)
*/
class Solution1 extends VersionControl {
    def firstBadVersion(n: Int): Int = {
        search(1, n)
    }
  
    def search(left: Int, right: Int): Int  = {
      if (left > right) return -1
       /**
      * it's bad version from mid to n, we could keep right side a bad version
      * the we return left side index as left index equals to right index
      */
      if (left == right) return left
      
      val mid = left + (right - left) / 2
      if (isBadVersion(mid))
     
        search(left, mid) 
      else
        search(mid + 1, right)
    }
}

```

###  1.128. <a name='PerfectSquares'></a>279 【动态🚀规划 + 背包】Perfect Squares

[小明](https://www.bilibili.com/video/BV1r5411Y7MH?spm_id_from=333.999.0.0)

```py
# 动态🚀规划
        '''版本一，先遍历背包, 再遍历物品'''
        '''版本二， 先遍历物品, 再遍历背包'''
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [10e5] * (n + 1)
        dp[0] = 0
        # 也可以 sqrt = floor(n**0.5) 
        sqrt = ceil(n**0.5) 
        for i in range(sqrt + 1): # 易错点：必须要 sqrt+1 比如输入：n = 1
            num = i**2
            for j in range(num, n + 1):
                if j >= num:
                    dp[j] = min(dp[j], dp[j-num] + 1) 
        return dp[-1]
```

###  1.129. <a name='ExpressionAddOperators'></a>282. Expression Add Operators

[花花酱](https://www.bilibili.com/video/BV15W411C727?spm_id_from=333.999.0.0)

###  1.130. <a name='MoveZeros'></a>283. Move Zeros

[小梦想家](https://www.bilibili.com/video/BV1m441187Kt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ba4y1t7eK?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Wp4y1y7pT?spm_id_from=333.999.0.0)

```py
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        n = len(nums)
        left = right = 0
        while right < n:
            if nums[right] != 0:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
            right += 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

年轻人不讲五的~

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # way1: Time:19.38 Space:55.79
        n_zero = nums.count(0)  # O(n)
        while n_zero > 0:
            nums.remove(0)  # O(n)
            nums.append(0)  # O(1)
            n_zero -= 1

        # way2: Time:87.76 Space:28.35
        # key的值是bool，也就是只对0排序，非零的1，3，12不排序。
        # 用lambda x:x!=0 也一样。
        nums.sort(key=bool, reverse=True)

想到的第一个方法是用pop

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        j=0
        for i in range(len(nums)):
            if nums[j]==0:
                nums.pop(j)
                nums.append(0)
            else:
                j+=1
```

```py
直接遍历，后面补0，找到的0删除

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        i = 0
        while i < n:
            if nums[i] == 0:
                nums.append(0)
                del nums[i]
                i -=1
                n-=1
            i += 1

python3，三行搞定

时间复杂度分析 remove() ---> O(N) ，append() --> O(1) count()---> O(N)---- 整体= O(3N)

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        for i in range(nums.count(0)):
            nums.remove(0)
            nums.append(0)

Python 1行

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.sort(key=bool, reverse=True)

设置一个index，遇到不是0的数就和index位置的数交换，然后index加一，python：

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        index = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[index], nums[i] = nums[i], nums[index]
                index += 1

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow = 0
        for fast in range(len(nums)):
            if nums[fast] != 0:
                nums[slow] = nums[fast]
                slow += 1
        for i in range(slow, len(nums)):
            nums[i] = 0
```

```scala
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        var p1 = 0
        var p2 = 0
        while(p1 < nums.size && p2 < nums.size){
            if(nums(p1) == 0 && nums(p2) != 0 && p1<p2){
                nums(p1) = nums(p2)
                nums(p2) = 0
                p1 += 1
                p2 += 1
            } else if(nums(p1) != 0 && nums(p2) != 0){
                p1 += 1
            }else{
                p2 += 1
            }
        }
    }
}

//Alternate solution: calculate the number of shifts 
object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
        
        var zeroCount = 0
        //count of zero is amount character is shifted to left
        //from first zero position traverse array left
        for(a <- 0 to nums.size-1){   
            //count zeroes and shift when not zero
            if(nums(a) == 0){
                zeroCount = zeroCount + 1
            }else if(zeroCount>0){
                //shift left if not 0 by zeroCount
                nums(a-zeroCount) = nums(a)
                nums(a) = 0
            }
        }
    }
}

```

```scala
package com.zhourui.leetcode

package lc0283_movezero {
  object Solution {
    def moveZeroes(nums: Array[Int]): Unit = {
//      nums.foldLeft(0) {
//        case (w,b) => {
//          if (b!=0) {
//            nums(w) = b
//
//            w+1
//          } else w
//        }
//      }

      nums.indices.foldLeft(0) {
        case (acc, e) => {
          if (nums(e)!=0) {
            val tmp = nums(e)
            nums(e) = nums(acc)
            nums(acc) = tmp
            acc+1
          } else acc
        }
      }
    }
  }
}

/*
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int w = 0;
        for (int i = 0; i< nums.size(); i++) {
            if (nums[i]!=0) {
                swap(nums[w++], nums[i]);
            }
        }
    }
};
 */

```

###  1.131. <a name='PeekingIterator'></a>284 Peeking Iterator

[小明](https://www.bilibili.com/video/BV1LN411R7U7?spm_id_from=333.999.0.0)

###  1.132. <a name='FindtheDuplicateNumber'></a>287 Find the Duplicate Number

[小明](https://www.bilibili.com/video/BV1Ug4y1v7mF?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pz4y1X7qR?spm_id_from=333.999.0.0)

```py
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        #数组只能读 所以不能排序,不能swap数组下标
        #时间复杂度小于 O(n^2) 不能暴力
        #空间复杂度 O(1) 不能额外开辟数组
        
        ''' 1、暴力不符合题意
        for i in nums:
            count = 0
            for num in nums:
                if num == i:
                    count += 1
            if count > 1:
                return i
        return -1
        '''
        
        '''2、小于O(n^2) 二分查找
        我们不要考虑数组,只需要考虑 数字都在 1 到 n 之间
        示例 1:
        arr = [1,3,4,2,2] 此时数字在 1 — 5 之间

        mid = (1 + 5) / 2 = 3 arr小于等于的3有4个(1,2,2,3)，1到3中肯定有重复的值
        mid = (1 + 3) / 2 = 2 arr小于等于的2有3个(1,2,2)，1到2中肯定有重复的值
        mid = (1 + 2) / 2 = 1 arr小于等于的1有1个(1)，2到2中肯定有重复的值
        所以重复的数是 2 
        '''
        left = 1
        right = len(nums)
        while left < right:
            mid = int(left + (right - left)/2)
            cnt = 0
            for num in nums:
                if num <= mid:
                   cnt += 1
            if cnt <= mid:
                left = mid + 1
            else:
                right = mid
        return right

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        low, high = 1, len(nums) - 1
        while low <= high:
            mid = (low + high) >> 1
            cnt = sum(x <= mid for x in nums)
            if cnt > mid:
                high = mid - 1
            else:
                low = mid + 1

class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = {}
        # dic = dict()
        for n in nums:
            dic[n] = dic.get(n, 0) + 1
            print(dic)
            if dic[n] >= 2:
                return n
class Solution:
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        print(set(nums))
        return (sum(nums)-sum(set(nums)))//(len(nums) - len(set(nums)))
```

###  1.133. <a name='GameofLife'></a>289. Game of Life

[花花酱](https://www.bilibili.com/video/BV14W411d7ji?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1hp4y1B7D5?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1vz4y1R7DJ?spm_id_from=333.999.0.0)

```py
解题思路
思路，原地修改的前提是，数字特征值记录迭代前死活，本人的思路是校验奇偶，即定义：
活->活 1->1
活->死 1->3
死->活 0->2
死->死 0->0
只有死活转换的时候需要改变board值，也就是说：
board以前是活的时候，需要判断现在是否要死过去
board以前是死的时候，需要判断现在是否要活过来
检查原状态的时候，只需要%2即可知道原状态，&1和%2效果一样
计数函数，遍历九个格子，不能越界，不能原地比较：不能ij同时为0

作者：tangchuqi
链接：https://leetcode-cn.com/problems/game-of-life/solution/py3yuan-di-xiu-gai-jian-duan-gao-xiao-by-liu-xian-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        n,m=len(board),len(board[0])
        for i in range(n):
            for j in range(m):
                C=0
                for x in (-1,0,1):
                    for y in (-1,0,1):
                        if(x or y)and 0<=i+x<n and 0<=j+y<m and board[x+i][j+y]&1:C+=1
                if board[i][j]&1 and(C<2 or C>3):board[i][j]=3
                if board[i][j]&1==0 and C==3:board[i][j]=2
        for i in range(n):
            for j in range(m):
                board[i][j]=int(0<board[i][j]<3)

作者：tangchuqi
链接：https://leetcode-cn.com/problems/game-of-life/solution/py3yuan-di-xiu-gai-jian-duan-gao-xiao-by-liu-xian-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。、

board中只有0和1两种状态，只占用了int的最低位，我们可以把int的高位利用起来

第一次遍历board，当我们确定(i, j)位置的cell更新后的状态是存活，就把高位的值置为1
board[i][j] |= 2

第二次遍历board，把高位挪回低位
board[i][j] >>= 1

python

class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        offsets = ((-1, -1), (-1, 0), (-1, 1), (0, -1),
                   (0, 1), (1, -1), (1, 0), (1, 1))
        m, n = len(board), len(board[0])
        for i in range(m):
            for j in range(n):
                alive = 0
                for offset in offsets:
                    x, y = i + offset[0], j + offset[1]
                    if x >= 0 and x < m and y >= 0 and y < n:
                        alive += board[x][y] & 1
                if alive == 3 or alive == 2 and board[i][j]:
                    board[i][j] |= 2
        for i in range(m):
            for j in range(n):
                board[i][j] >>= 1

作者：DarkArmed
链接：https://leetcode-cn.com/problems/game-of-life/solution/pythonyuan-di-wei-yun-suan-ti-jie-by-darkarmed/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
# 生命在于调库

import numpy as np
from scipy import signal
class Solution:
    def gameOfLife(self, board):
        arr = np.array(board)
        mask = np.ones((3,3))
        mask[1, 1] = 0
        around = signal.convolve2d(arr, mask, mode='same')
        arr[around < 2] = 0
        arr[around == 3] = 1
        arr[around > 3] = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                board[i][j] = arr[i, j]

        return board

# 卷积法

from scipy.signal import convolve2d
import numpy as np
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """
        b=np.array(board)
        x=convolve2d(b,[[1,1,1],[1,10,1],[1,1,1]],'same')
        board[:]=b*(x//2==6)+(x==3)
        return board
```

```py
class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """

        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        rows = len(board)
        cols = len(board[0])

        # 从原数组复制一份到 copy_board 中
        copy_board = [[board[row][col] for col in range(cols)] for row in range(rows)]

        # 遍历面板每一个格子里的细胞
        for row in range(rows):
            for col in range(cols):

                # 对于每一个细胞统计其八个相邻位置里的活细胞数量
                live_neighbors = 0
                for neighbor in neighbors:

                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # 查看相邻的细胞是否是活细胞
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and (copy_board[r][c] == 1):
                        live_neighbors += 1

                # 规则 1 或规则 3        
                if copy_board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    board[row][col] = 0
                # 规则 4
                if copy_board[row][col] == 0 and live_neighbors == 3:
                    board[row][col] = 1
        return board

class Solution:
    def gameOfLife(self, board):
        """
        Do not return anything, modify board in-place instead.
        """

        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]

        rows = len(board)
        cols = len(board[0])

        # 遍历面板每一个格子里的细胞
        for row in range(rows):
            for col in range(cols):

                # 对于每一个细胞统计其八个相邻位置里的活细胞数量
                live_neighbors = 0
                for neighbor in neighbors:

                    # 相邻位置的坐标
                    r = (row + neighbor[0])
                    c = (col + neighbor[1])

                    # 查看相邻的细胞是否是活细胞
                    if (r < rows and r >= 0) and (c < cols and c >= 0) and abs(board[r][c]) == 1:
                        live_neighbors += 1

                # 规则 1 或规则 3 
                if board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):
                    # -1 代表这个细胞过去是活的现在死了
                    board[row][col] = -1
                # 规则 4
                if board[row][col] == 0 and live_neighbors == 3:
                    # 2 代表这个细胞过去是死的现在活了
                    board[row][col] = 2

        # 遍历 board 得到一次更新后的状态
        for row in range(rows):
            for col in range(cols):
                if board[row][col] > 0:
                    board[row][col] = 1
                else:
                    board[row][col] = 0
        return board

class Solution(object):
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        row = len(board)
        col = len(board[0]) if row else 0

        dx = [-1,-1,-1,0,1,1,1,0]
        dy = [-1,0,1,1,1,0,-1,-1]
    
        for i in range(row):
            for j in range(col):
                cnt = 0
                for k in range(8):
                    x, y = i + dx[k], j + dy[k]
                    if x >=0 and x < row and y >=0 and y < col and (board[x][y] == 1  or board[x][y] == 2):
                        cnt += 1

                if board[i][j] and (cnt < 2 or cnt > 3):
                    board[i][j] = 2
                elif board[i][j] == 0 and cnt == 3:
                    board[i][j] = 3

        for i in range(row):
            for j in range(col):
                board[i][j] %= 2
        return board
```

###  1.134. <a name='WordPattern'></a>290. Word Pattern

[小梦想家](https://www.bilibili.com/video/BV1d4411V7mi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1N7wD?spm_id_from=333.999.0.0)

```py
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        word2ch = dict()
        ch2word = dict()
        words = s.split()
        if len(pattern) != len(words):
            return False
        
        for ch, word in zip(pattern, words):
            if (word in word2ch and word2ch[word] != ch) or (ch in ch2word and ch2word[ch] != word):
                return False
            word2ch[word] = ch
            ch2word[ch] = word
    
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/word-pattern/solution/dan-ci-gui-lu-by-leetcode-solution-6vqv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

1.205题假设s与t长度相等，这道题需要处理pattern和s长度不一样的情况

2.本题需要将s分隔成单个单词

其它部分都一样，加两行代码即可，总共三行代码：

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        if len(pattern) != len(words): return False
        return len(set(pattern)) == len(set(words)) == len(set(zip(pattern,words)))

简答思路-->字典类型

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        d=dict()
        s=s.split()
        if len(pattern)!=len(s):return False

        for x in range(len(pattern)):
            if pattern[x] not in d and s[x] not in d.values():
                d[pattern[x]]=s[x]
            elif pattern[x] in d and  d[pattern[x]]==s[x]:
                pass
            else : return False
        return True
```


```py
两种思路： 思路一：哈希表双射，这个更快，就是两边的键按照顺序录入，但是值要进行交换，要是在对比过程中这个键出现过，但是值不同就为false

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s = s.split(' ')
        pi = {}; si = {}
        if len(pattern) != len(s): return False
        for i, j in zip(pattern, s):
            if (i in pi and pi[i] != j) or (j in si and si[j] != i): return False
            else: 
                pi[i] = j
                si[j] = i
        return True
思路二：这个思路是看评论区的，非常有意思，就是利用了index函数只返回第一个满足条件的索引的情况，然后进行比较

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        s = s.split(' ')
        pi = [pattern.index(i) for i in pattern]
        si = [s.index(i) for i in s]
        return True if pi == si else False

python3中一种比较讨巧的解法：

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        pi = []
        si = []
        for v in pattern:
            pi.append(pattern.index(v))
            
        ss = s.split(' ')
        for v in ss:
            si.append(ss.index(v))

        if si == pi:
            return True
        else:
            return False

在大佬的基础上简化一下代码

class Solution:
    def wordPattern(pattern, s):
        if len(s.split(' ')) != len(pattern):
            return False
        ss = s.split(' ')
        listP,listS = [pattern.index(i) for i in pattern],[ss.index(j) for j in ss]
        return listP == listS
```


###  1.135. <a name='SerializeandDeserializeBinaryTree'></a>297. Serialize and Deserialize Binary Tree

[花花酱](https://www.bilibili.com/video/BV1Hb411c7cr?spm_id_from=333.999.0.0)

###  1.136. <a name='BullsandCows'></a>299. Bulls and Cows

[小梦想家](https://www.bilibili.com/video/BV1M64y1M7aP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1bh411R7n4?spm_id_from=333.999.0.0)

```py
from collections import defaultdict
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        n = len(secret)
        s, g = defaultdict(int), defaultdict(int)
        a, b = 0, 0
        for i in range(n) :
            l,r = secret[i], guess[i]
            if l == r :
                a += 1
            else :
                s[l] += 1
                g[r] += 1
        for k,v in s.items() :
            b += min(v, g[k])
        return str(a) + 'A' + str(b) + 'B'

# python
#  你这甚至不如sort之后再一个一个匹配，算两遍不麻烦嘛
#  sort之后一一匹配相等元素对么，那你如何知道bull个数？
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        secret_list = list(secret)
        guess_list = list(guess)

        # 先遍历一遍统计bull
        bull = 0
        for i in range(len(secret_list)):
            if secret_list[i] == guess_list[i]:
                bull += 1
        
        # 再遍历统计一共有多少个相等的元素对
        cow = 0
        for ch in secret_list:
            if ch in guess_list:
                cow += 1
                guess_list.remove(ch)

        # cow - bull 即为真正的 cow
        return str(bull) + 'A' + str(cow-bull) + 'B'

# 做了两次才做出来，需要注意：

# 调整位置时，位置只能用一次 比如1123 1011 输出的是1A1B而不是1A2B

# 先计算公牛（数字和位置都匹配），比如1122 1222 输出的是 3A0B而不是3A1B

class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        a = b = 0
        hashmap = collections.Counter(secret)
        for x, y in zip(secret, guess):
            if x == y:
                a += 1
                hashmap[x] -= 1
        for x, y in zip(secret, guess):
            if x != y:
                if y in hashmap:
                    if hashmap[y] > 0:
                        b += 1
                    hashmap[y] -= 1
        return f'{a}A{b}B'

from collections import Counter
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bull = sum(secret[i] == guess[i] for i in range(len(secret)))
        cow = sum((Counter(secret) & Counter(guess)).values()) - bull
        return f'{bull}A{cow}B'

# 都这么短。。。。。
# 我Python还是用的不行啊
import operator
class Solution(object):
    def getHint(self, secret, guess):
        """
        :type secret: str
        :type guess: str
        :rtype: str
        """
        bull = sum(map(operator.eq, secret, guess))
        sa = collections.Counter(secret)
        sb = collections.Counter(guess)
        cow = sum((sa & sb).values()) - bull
        return str(bull) + 'A' + str(cow) + 'B'
```

###  1.137. <a name='LongestIncreasingSubsequence'></a>300 【动态🚀规划 + 二分】Longest Increasing Subsequence 最长上升子序列

[花花酱](https://www.bilibili.com/video/BV1Wf4y1y7ou?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1rT4y1ujV?spm_id_from=333.999.0.0)

动态规划： 时间复杂度为 O(n2)

```py

class Solution(object):
    def lengthOfLIS(self, nums):
        if not nums:
            return 0
        dp = [1 for i in range(len(nums))]
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[j]+1, dp[i])
        return max(dp)

```

贪心 + 二分查找

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6wjfuj0uqvo0.webp)

```py
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        res = []
        for num in nums:
            # bisect_left会把新的元素放在相等元素前面, 即原来值5的索引位置2
            i = bisect_left(res, num)
            if i == len(res):
                res.append(num)
            else:
                res[i] = num
        return len(res)
```

```scala
/**
* chosen answer
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution0 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}

/**
* brute force : not Ac
* memo:
* 1. each position have two choice :
*    1. take current value if currentIdx value > previousIdx value 
*    2. do not take current value
* time complexity: O(2^n)
*/
object Solution1 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        lengthOfLIS(nums, 0, -1)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int): Int = {
      if (currentIdx >= nums.length) return 0
      
      val taken = if (previousIdx == -1  ||  (nums(currentIdx) > nums(previousIdx))) {
        lengthOfLIS(nums, currentIdx + 1, currentIdx) + 1
      } else {
        0
      } 
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx)
      taken max nonTaken
    }
}

/**
* with memorized: we just fill the nxn dimension memory array
* time complexity: O(n^2)
* space complexity: O(n^2)
*/
object Solution1-2 {
    def lengthOfLIS(nums: Array[Int]): Int = {
      val memory = Array.fill[Int](nums.length, nums.length)(-1)
      lengthOfLIS(nums, 0, -1, memory)
    }
  
    def lengthOfLIS(nums: Array[Int], currentIdx: Int, previousIdx: Int, memory: Array[Array[Int]]): Int  = {
      // println(currentIdx, previousIdx)
      if (nums.length == currentIdx) return 0
      if (memory(currentIdx)(previousIdx + 1) != -1) return memory(currentIdx)(previousIdx + 1)
      
      val taken = if (previousIdx == -1 || nums(currentIdx) > nums(previousIdx)) {
        1 + lengthOfLIS(nums, currentIdx + 1, currentIdx, memory)
      } else {
        0
      }
      
      val nonTaken = lengthOfLIS(nums, currentIdx + 1, previousIdx, memory)
      
      memory(currentIdx)(previousIdx + 1) = taken max nonTaken
      
      memory(currentIdx)(previousIdx + 1) 
    }
  
  
}





/**
* dynamic programming 
* memo
*   1. dp[i] represent the max length including index i ending at index i
*   2. if nums[j] < nums[i] where j < i, we could increase 1 from dp[j]
*  time complexity: O(N^2)
*  space  complexity: O(N)
*/

object Solution3 {
    def lengthOfLIS(nums: Array[Int]): Int = {
        if(nums == null || nums.isEmpty) return 0
        val dp = Array.fill[Int](nums.length)(1) // record the LIS of 0 to i sub-array in nums while select i
        

        for(i <- nums.indices; j <- 0 until i) {
            if(nums(i) > nums(j)) {
                dp(i) = (dp(j) + 1) max dp(i)
            }
        }
        dp.max
        
    }
}
```

###  1.138. <a name='RemoveInvalidParentheses'></a>301. Remove Invalid Parentheses

[花花酱](https://www.bilibili.com/video/BV1VW411y7Xd?spm_id_from=333.999.0.0)

###  1.139. <a name='-1'></a>303 【构造🏰】区域和检索 - 数组不可变

[哈哈哈](https://www.bilibili.com/video/BV1RV411d76R?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV18441137fs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ho4y1U7wF?spm_id_from=333.999.0.0)

```py
class NumArray:

    def __init__(self, nums: List[int]):
        self.sums = [0]
        _sums = self.sums

        for num in nums:
            _sums.append(_sums[-1] + num)

    def sumRange(self, i: int, j: int) -> int:
        _sums = self.sums
        return _sums[j + 1] - _sums[i]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/range-sum-query-immutable/solution/qu-yu-he-jian-suo-shu-zu-bu-ke-bian-by-l-px41/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

居然没超时 233333333

class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums


    def sumRange(self, i: int, j: int) -> int:
        return sum(self.nums[i:j+1])

```

```py
Python3

菜鸟心得。

题目强调了多次调用，果然就是一个大坑，第一次尝试很淡定的写了对数组区域求和函数，妥妥的超时了。很不爽准备睡觉，结果洗漱时候灵感闪现，把前i个数求和放在nums[i-1]位置，这样答案不就是nums[j]-nums[i-1]了吗？瞬间应对多次调用🕶️

class NumArray:

    def __init__(self, nums: List[int]):
        self.nums = nums
        for i in range(len(self.nums)):
            if i > 0:
                self.nums[i] = self.nums[i]+self.nums[i-1]

    def sumRange(self, i: int, j: int) -> int:
        if i>0:
            return self.nums[j]-self.nums[i-1]
        else:
            return self.nums[j]
```

###  1.140. <a name='RangeSumQuery2D'></a>304. 【构造🏰】Range Sum Query 2D

[花花酱](https://www.bilibili.com/video/BV1Jb411k7LQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1R64y127jL?spm_id_from=333.999.0.0)

```py
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), (len(matrix[0]) if matrix else 0)
        self.sums = [[0] * (n + 1) for _ in range(m)]
        _sums = self.sums

        for i in range(m):
            for j in range(n):
                _sums[i][j + 1] = _sums[i][j] + matrix[i][j]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        _sums = self.sums

        total = sum(_sums[i][col2 + 1] - _sums[i][col1] for i in range(row1, row2 + 1))
        return total

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), (len(matrix[0]) if matrix else 0)
        self.sums = [[0] * (n + 1) for _ in range(m + 1)]
        _sums = self.sums

        for i in range(m):
            for j in range(n):
                _sums[i + 1][j + 1] = _sums[i][j + 1] + _sums[i + 1][j] - _sums[i][j] + matrix[i][j]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        _sums = self.sums

        return _sums[row2 + 1][col2 + 1] - _sums[row1][col2 + 1] - _sums[row2 + 1][col1] + _sums[row1][col1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/range-sum-query-2d-immutable/solution/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

直接切片不香吗？

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.matrix = matrix
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        res = 0
        for i in range(row1,row2+1):
            res += sum(self.matrix[i][col1:col2+1])
        return res

效率比较低，空间没有省下来，每次调用时间复杂度都是O(mn)，其中m = row2 - row1, n = col2 - col1。
```

```py
初中生路过，发现这一题跟学校教的因式分解 (A-B)^2 = A^2 - 2AB + B^2 很像，当中：

row2 和 col2 就是 A ,

row2 - row1 和 col2 - col1 就是 B

当然 (A-B)^2 = A^2 - 2AB + B^2 只在 row1 == col1 && row2 == col2 的情况下可用，严格来说应该是：

(A-B)(C-D) = AC - AD - BC + BD

class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        
        self.row = len(matrix)+1
        if self.row == 1: return
        self.col = len(matrix[0])+1
        
        self.matrix = [[0 for i in range(self.col)]] + [[0]+i for i in matrix]
        
        for i in range(1, self.row):
            for j in range(1, self.col):
                self.matrix[i][j] = self.matrix[i][j] + self.matrix[i-1][j] + self.matrix[i][j-1] - self.matrix[i-1][j-1]

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        
        if self.row == 0: return 0
        
        # 重点：(A-B)(C-D) = AC - AD - BC + BD
        return self.matrix[row2+1][col2+1] - self.matrix[row1][col2+1] - self.matrix[row2+1][col1] + self.matrix[row1][col1]
```

###  1.141. <a name='BestTimetoBuyandSellStockwithCooldown309-'></a>309. 【动态🚀规划】Best Time to Buy and Sell Stock with Cooldown 309-最佳买卖股票时机含冷冻期

[花花酱](https://www.bilibili.com/video/BV1qW411C7Xc?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1Vy4y1z7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13D4y1U7iU?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy = prices[0]
        lazy = 0
        profit = 0
        for price in prices:
            # 顺序不能错
            buy = min(buy, price - lazy)
            # buy <- lazy
            lazy = max(profit, lazy)
            # lazy <- profit
            profit = max(profit, price - buy)
        return max(lazy,profit)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy = prices[0]
        lazy = 0
        profit = 0
        for price in prices:
            # 顺序不能错
            buy = min(buy, price - lazy)
            # buy <- lazy
            lazy = max(profit, lazy)
            # lazy <- profit
            profit = price - buy
        return max(lazy,profit)


递推公式：
sell[i] = max(buy[i-1]+prices[i], sell[i-1]) (第一项表示第i天卖出，第二项表示第i天冷冻)
buy[i] = max(cool[i-1]-prices[i], buy[i-1]) （第一项表示第i天买进，第二项表示第i天冷冻）
cool[i] = max(sell[i-1], buy[i-1], cool[i-1])

```


```scala

/**
* my first commitment
* dynamic programming
* memo
*   1. dp definition: dp[i][j] means the best profit we can have at i-th day in state j of without holding / holding / cooldown 
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution1 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        /*
        * state definition
        * 0: without holding
        * 1: holding one
        * 2: sold than cooldown
        */
        val dp = Array.tabulate(prices.length, 3){
            case (0, 0) => 0
            case (0, 1) => -prices(0)
            case (0, 2) => 0
            case _ => 0
        }
        
        for(i <- 1 until prices.length) {
            dp(i)(0) = dp(i - 1)(0) max dp(i - 1)(2) // 0 -> 0 or 2 -> 0
            dp(i)(1) = dp(i - 1)(1) max (dp(i - 1)(0) - prices(i)) // 1 -> 1 or  0 -> 1
            dp(i)(2) = dp(i - 1)(1) + prices(i) // 1 -> 2
        }
        
        dp.last.max
    }
}

/**
* dynamic programming
* memo
*    ok! lets reduce the dp array size without keep all i-th state
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-2 {
    def maxProfit(prices: Array[Int]): Int = {
        if(prices == null || prices.isEmpty) return 0
        var withoutHold = 0
        var hold = Int.MinValue
        var coolDown = 0
        
        for(price <- prices) {
            val withoutHold_ = withoutHold  // keep value
            val hold_ = hold // keep value
            withoutHold = withoutHold max coolDown
            hold = hold max (withoutHold_ - price)
            coolDown = hold_ + price  
        }
        withoutHold max coolDown
    }
}

/**
* dynamic programming - function programming
* time complexity: O(N)
* space complexity: O(1)
*/
object Solution1-3 {
    def maxProfit(prices: Array[Int]): Int = {
        val (withoutHold, hold, cooldown) = prices.foldLeft(0, Int.MinValue, 0) {
            case ((withoutHold, hold, cooldown), cost) => 
             (
                 withoutHold max cooldown,
                 hold max (withoutHold - cost),
                 hold + cost      
             )
        }
        withoutHold max cooldown
    }
}
```

###  1.142. <a name='NumberofIsland'></a>305 【🍒并查集】Number of Island

[郭郭](https://www.bilibili.com/video/BV1pV41147SZ?from=search&seid=13286624680279107&spm_id_from=333.337.0.0)

###  1.143. <a name='MinimumHeightTrees'></a>310 Minimum Height Trees

[小明](https://www.bilibili.com/video/BV1eA411j7XQ?spm_id_from=333.999.0.0)

###  1.144. <a name='BurstBalloons'></a>312 Burst Balloons

[小明](https://www.bilibili.com/video/BV1Q64y1f7Vy?spm_id_from=333.999.0.0)

###  1.145. <a name='CountofSmallerNumbersAfterSelf'></a>315. Count of Smaller Numbers After Self

[花花酱](https://www.bilibili.com/video/BV1BW411C7TM?spm_id_from=333.999.0.0)

###  1.146. <a name='RemoveDuplicateLetters'></a>316 【贪心🧡】Remove Duplicate Letters

[小明](https://www.bilibili.com/video/BV1x54y1R7y7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Tz4y167pC?spm_id_from=333.999.0.0)

```py
# 思路是参考别人的，
# 如果数比栈顶小，而且栈顶在后面还有的话，
# 就弹出栈顶。
# python自带列表弹出和加入最后一个数都是很快的。
# 然后在前面加一个0，因为0比一切字母小，可以不用判空，方便很多

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        result = ["0"] # 初值不要为空，不然index为-1会报错
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            print("s[idx:]",s[idx:],"数量: ",s[idx:].count(result[-1]),"需要大于0,表示要把c删掉，必须后面还有c")
            if char not in result:
                while char < result[-1] and s[idx:].count(result[-1]) > 0:
                    result.pop(-1) # result 删除最后一位
                result.append(char)
        return "".join(result[1:])

# 递归贪心版本
class Solution(object):
    def removeDuplicateLetters(self, str):
        """
        :type s: str
        :rtype: str
        """
        print("-"*50)
        # 先按字典排序
        for char in sorted(set(str)):
            print("-"*20,char)
            suffix = str[str.index(char):]
            print(suffix)


            # 看余下的是否能组成所需的字母
            # if len(set(suffix)) == len(set(str)): 也可以
            if set(suffix) == set(str):
                return char + self.removeDuplicateLetters(suffix.replace(char, ''))
                # 逐步把char后面的char替换掉
        return ''

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = ''
        while s:
            print(list(map(s.rindex, set(s))))
            i = min(map(s.rindex, set(s)))
            c = min(s[:i+1])
            print(s[:i+1])
            result += c
            s = s[s.index(c):].replace(c, '')
            print(s)
        return result

class Solution(object):
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        rindex = {char: idx for idx, char in enumerate(s)}
        print("rindex",rindex)
        result = '' 
        for idx, char in enumerate(s):
            print("idx, char:",idx, char,"result: ",result)
            if char not in result:
                while char < result[-1:] and idx < rindex[result[-1:]]:
                    # 如果 char 比 最后一位result[-1:] 小
                    # result 删除最后一位
                    print("rindex[result[-1:]",rindex[result[-1:]])
                    result = result[:-1] 
                result += char
        return result

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        n = len(s)
        stack = [s[0]]
        for i in range(1,n):
            if s[i] not in stack and s[i]>stack[-1]:
                stack.append(s[i])
            elif s[i] not in stack:
                while stack and s[i]<stack[-1] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
        return "".join(stack)

class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = []
        n = len(s)
        for i in range(n):
            if s[i] in stack:
                continue
            else:
                while stack and stack[-1] > s[i] and stack[-1] in s[i+1:]:
                    stack.pop()
                stack.append(s[i])
            
        return "".join(stack)

# 思路三：栈
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        from collections import Counter
        c = Counter(s)
        stack = []
        existed = set()
        for a in s:
            # print(stack)
            if a not in existed:
            	# 判断后面还有没有该字母
                while stack and stack[-1] > a and c[stack[-1]] > 0:
                    existed.remove(stack.pop())
                stack.append(a)
                existed.add(a)
            c[a] -= 1
        return "".join(stack)

# 思路二：迭代
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        res = ""
        while s:
            # 从右往左找，找到最小位置的索引号
            loc = min(map(s.rindex, s))
            # 找该索引前面最小的字母
            a = min(s[:loc + 1])
            res += a
            s = s[s.index(a):].replace(a, "")
        return res
```

###  1.147. <a name='-1'></a>318【】

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.fgtvti63s9c.webp)

```py
class Solution:
    def maxProduct(self, words: List[str]) -> int:
        masks = [reduce(lambda a, b: a | (1 << (ord(b) - ord('a'))), word, 0) for word in words]
        return max((len(x[1]) * len(y[1]) for x, y in product(zip(masks, words), repeat=2) if x[0] & y[0] == 0), default=0)


class Solution:
    def maxProduct(self, words: List[str]) -> int:
        def hepler(s:str):
            res = 0 
            for i in s:
                res |= 1 << (ord(i)-97) # ord('a') = 97，将字符串转化为二进制
            return res

        cache = dict()
        for i in words:
            digit = hepler(i)
            cache[digit] = max(cache.get(digit, 0), len(i))

        k = list(cache.keys())
        n = len(k)
        res = 0
        for i in range(n):
            for j in range(i+1, n):
                if (k[i] & k[j]) == 0: # 没有相同位的判断
                    res = max(res, cache[k[i]]*cache[k[j]])
        return res
```

###  1.148. <a name='-1'></a>319

```py
class Solution(object):
    def bulbSwitch(self, n):
        """
        :type n: int
        :rtype: int
        """
        bulb = [1] * n # 实际上是从第一轮后，开始算起的，刚好n=0的情况符合
        print("bulb: ",bulb)
        for interval in range(2,n+1):
            for x in range(interval-1, n, interval): # 从第interval开始，间隔interval个
                # ---------切换开关---------
                bulb[x] = 1 if bulb[x] == 0 else 0
                print("bulb: ",bulb)
                # ---------切换开关---------
        return bulb.count(1)
```

###  1.149. <a name='CreateMaximumNumber'></a>321. Create Maximum Number

[花花酱](https://www.bilibili.com/video/BV11W411U7NR?spm_id_from=333.999.0.0)

###  1.150. <a name='dfsCoinChange'></a>322. 【动态🚀规划 + 背包 + dfs】Coin Change

[花花酱](https://www.bilibili.com/video/BV1SW411C7d1?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1tz4y1d7XM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ty4y187dh?spm_id_from=333.999.0.0)

```py
动态🚀规划

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 这道题的难点在于：dp数组的初始化
        dp = [10e9] * (amount + 1)
        dp[0] = 0

        for coin in coins:
            for i in range(coin, amount + 1):
                if i >= coin:
                    dp[i] = min(dp[i], dp[i-coin] + 1)
         # 这道题的难点在于：最后结果的输出
        return dp[-1] if dp[-1] != 10e9 else -1


class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [10e9] * (amount + 1)
        dp[0] = 0

        # 这道题 i 和 coin 倒是无所谓
        for i in range(1, amount + 1):
            for coin in coins:
                if i >= coin:
                    dp[i] = min(dp[i], dp[i-coin] + 1)
        return dp[-1] if dp[-1] != 10e9 else -1


# 方法一：记忆化搜索

class Solution:
    def coinChange(self, coins, amount):
        # @functools.lru_cache(amount)
        def dp(rem) -> int:
            if rem < 0: return -1
            if rem == 0: return 0
            mini = int(1e9)
            for coin in self.coins:
                res = dp(rem - coin)
                if res >= 0 and res < mini:
                    mini = res + 1
            return mini if mini < int(1e9) else -1

        self.coins = coins
        if amount < 1: return 0
        return dp(amount)




# BFS

class Solution:
    def coinChange(self, coins, amount):
        from collections import deque
        queue = deque([amount])
        step = 0
        visited = set()
        while queue:
            n = len(queue)
            for _ in range(n):
                tmp = queue.pop()
                if tmp == 0:
                    return step
                for coin in coins:
                    if tmp >= coin and tmp - coin not in visited:
                        visited.add(tmp - coin)
                        queue.appendleft(tmp - coin)
            step += 1
        return -1

# 宽度优先,速度飕飕的

class Solution:
    def coinChange(self, coins, amount):
        q = [[0, 0]]
        see = {0}
        while q:
            cur, cnt = q.pop(0)
            if cur == amount:
                return cnt
            for i in coins:
                t = cur + i
                if t <= amount and t not in see:
                    q.append([t, cnt + 1])
                    see.add(t)
        return -1
# 自顶向下

class Solution:
    def coinChange(self, coins, amount):
        import functools
        @functools.lru_cache(None)
        def helper(amount):
            if amount == 0:
                return 0
            return min(helper(amount - c) if amount - c >= 0 else float("inf") for c in coins) + 1
        res = helper(amount)
        return res if res != float("inf") else -1

# DFS

class Solution:
    def coinChange(self, coins, amount):
        coins.sort(reverse=True)
        self.res = float("inf")
        
        def dfs(i, num, amount):
            if amount == 0:
                self.res = min(self.res, num)
                return 
            for j in range(i, len(coins)):
                # 剩下的最大值都不够凑出来了
                if (self.res - num) * coins[j] < amount:
                    break
                if coins[j] > amount:
                    continue
                dfs(j, num + 1, amount - coins[j])
                
        for i in range(len(coins)):
            dfs(i, 0, amount)
            
        return self.res if self.res != float("inf") else -1
```

```scala
/**
* dynamic programming: bottom up
* time complexity: O(S * N), S is the amount, N is the coin denomination count
* space complexity: O(S)
*/

object Solution {
    def coinChange(coins: Array[Int], amount: Int): Int = {
         
        val dp = Array.fill[Int](amount + 1)(amount + 1) // record the minimum needed coins of each denominations

        dp(0) = 0
        for (i <- 1 to amount; denominations <- coins) {

            if(denominations <= i) {
                dp(i) = dp(i) min (dp(i - denominations) + 1)
            }        
        }
    
        if (dp.last > amount) -1 else dp.last
    }
}

```

###  1.151. <a name='-1'></a>324

```py
class Solution(object):
    def wiggleSort(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        nums.sort()
        half = len(nums[::2])
        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]
```

###  1.152. <a name='PowerofThree'></a>326. Power of Three

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7QC?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1h441137PM?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sZ4y1F7Lr?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        while n and n % 3 == 0:
            n //= 3
        return n == 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode-solution-hnap/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and 1162261467 % n == 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode-solution-hnap/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        # 一种是利用对数
        # fmod 是float求余 在math下
        return n>0 and fmod(log10(n) / log10(3), 1) == 0
        # 另一种方法是，因为在 int 范围内 3 的最大次方是 3^19 = 1162261467，
        # 如果 n 是 3 的整数次方，那么 1162261467 除以 n 的余数一定是零。
        # return n > 0 and 1162261467 % n == 0
 x*3 = x*(2+1) = x * 2 + x = (x<<1) + x

常规递归：

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n < 3:
            if n == 1: return True
            return False
        else:
            if n % 3 == 0:
                return self.isPowerOfThree(n//3)
            else:
                return False

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        b = 1
        while b < n:
            b = (b << 1) + b
        if b == n:
            return True
        return False
```

```py
？？？
这种在循环中递归的写法要怎么改呀？为何每次n=1然后return True之后n又变成了3开始递归，一直在无限循环

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        while n > 1 :
            if n % 3 != 0:
                return False
            else:
                self.isPowerOfThree(n//3)
        return True

你的else语句少了个return，而且判断条件也不太对，举个例子 n = 3 ，循环会进入else分支，但执行完 self.isPowerOfThree(n//3) （先不管执行结果）n没变化又进入下一轮循环，又进入else分支，这不就无限循环了？可以改成这样：

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n >= 1 :
            if n % 3 != 0:
                return n == 1
            else:
                return self.isPowerOfThree(n//3)
        return False
```

###  1.153. <a name='OddEvenLinkedList'></a>328. 奇偶链表 (Odd Even Linked List)

[洛阳](https://www.bilibili.com/video/BV1v64y1u7AH?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ag4y1B78z?spm_id_from=333.999.0.0)

```py
# 都是奇偶俩个链表然后合并的，我怎么就没想到。。 我直接想的就是快慢指针然后只把奇数节点拿出来插到前面。。。

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        if not head.next:
            return head
        if not head.next.next:
            return head
        p = head
        fast,slow = head.next.next,head
        fast_pre = head.next
        while fast:
            # 把当前fast(奇数)节点放在slow后面，记录fast_pre保证复原
            fast_pre.next,slow.next,fast.next= fast.next,fast,slow.next
            slow = slow.next
            fast_pre = fast_pre.next
            if not fast_pre or not fast_pre.next :
                break
            fast = fast_pre.next
        return head

# 双指针分别对应奇偶链，最后串起来：https://github.com/Brycexxx/leetcode/blob/master/oddEvenList.py

# Definition for singly-linked list.
class ListNode:
   def __init__(self, x):
       self.val = x
       self.next = None


class Solution:
   def oddEvenList(self, head: ListNode) -> ListNode:
       if head == None: return head
       point1, point2 = head, head.next
       p1, p2 = point1, point2
       while p2 != None and p2.next:
           p1.next = p1.next.next
           p2.next = p2.next.next
           p1 = p1.next
           p2 = p2.next
       p1.next = point2
       return point1

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        '''
        slow: 上一个奇数节点
        fast: 下一个奇数节点
        pre: 下一个奇数节点的前缀节点
        post: 上一个奇数节点的后缀节点
        '''
        slow, pre, fast = head, head.next, head.next.next
        while slow and fast:
            q = fast.next.next if fast.next else None
            post = slow.next
            pre.next = fast.next
            fast.next = post
            slow.next = fast
            slow, pre, fast = fast, pre.next, q
        return head


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        # 奇节点在偶节点之前
        if head == None:
            return None
        dummy_head_1 = ListNode(-1)
        dummy_head_2 = ListNode(-1)
        p1 = dummy_head_1  # 奇节点
        p2 = dummy_head_2  # 偶节点
        i = 1  # 题目要求第一个节点是奇节点
        while head:
            if i % 2 == 0:
                p2.next = head
                p2 = p2.next
                head = head.next
            else:
                p1.next = head
                p1 = p1.next
                head = head.next
            i += 1
        p2.next = None
        p1.next = dummy_head_2.next
        return dummy_head_1.next

class Solution:
    def oddEvenList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        
        evenHead = head.next
        odd, even = head, evenHead
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = evenHead
        return head

class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None:
            return head

        # odd used to keep track of the tail of odd nodes
        odd = oddHead = head
        # record how many swaps happend
        even = evenHead = head.next
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next 
            even = even.next
        odd.next = evenHead
        return head 
```

###  1.154. <a name='dfsLongestIncreasingPathinaMatrix'></a>329. 【动态🚀规划 + dfs】Longest Increasing Path in a Matrix

[花花酱](https://www.bilibili.com/video/BV1mW411d7q8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1VK4y1K7SX?spm_id_from=333.999.0.0)

动态🚀规划

```py
先预处理，对矩阵的值按从小到大排序，按大小顺序才能保证依赖的子问题都求解过了

dp[i][j]表示以matrix[i][j]结尾的最长递增长度

初始dp[i][j]都等于1
若matrix[i][j]四个方向有任意小于它，则可以更新dp[i][j] = max(dp[i][j], 1 + dp[r][c])

class Solution(object):
    def longestIncreasingPath(self, matrix):
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        lst = []
        for i in range(m):
            for j in range(n):
                lst.append((matrix[i][j], i, j))
        lst.sort()
        dp = [[0 for _ in range(n)] for _ in range(m)]
        for num, i, j in lst:
            dp[i][j] = 1
            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                r, c = i + di, j + dj
                if 0 <= r < m and 0 <= c < n:
                    if matrix[i][j] > matrix[r][c]:
                        dp[i][j] = max(dp[i][j], 1 + dp[r][c])
        return max([dp[i][j] for i in range(m) for j in range(n)])
```

```py
class Solution:
    
    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        @lru_cache(None)
        def dfs(row: int, column: int) -> int:
            best = 1
            for dx, dy in Solution.DIRS:
                newRow, newColumn = row + dx, column + dy
                if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[row][column]:
                    best = max(best, dfs(newRow, newColumn) + 1)
            return best

        ans = 0
        rows, columns = len(matrix), len(matrix[0])
        for i in range(rows):
            for j in range(columns):
                ans = max(ans, dfs(i, j))
        return ans


class Solution:

    DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix:
            return 0
        
        rows, columns = len(matrix), len(matrix[0])
        outdegrees = [[0] * columns for _ in range(rows)]
        queue = collections.deque()
        for i in range(rows):
            for j in range(columns):
                for dx, dy in Solution.DIRS:
                    newRow, newColumn = i + dx, j + dy
                    if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] > matrix[i][j]:
                        outdegrees[i][j] += 1
                if outdegrees[i][j] == 0:
                    queue.append((i, j))

        ans = 0
        while queue:
            ans += 1
            size = len(queue)
            for _ in range(size):
                row, column = queue.popleft()
                for dx, dy in Solution.DIRS:
                    newRow, newColumn = row + dx, column + dy
                    if 0 <= newRow < rows and 0 <= newColumn < columns and matrix[newRow][newColumn] < matrix[row][column]:
                        outdegrees[newRow][newColumn] -= 1
                        if outdegrees[newRow][newColumn] == 0:
                            queue.append((newRow, newColumn))
        
        return ans






```

```py
方法一：代码清晰

方法二：效率最高

方法三：代码简洁

class Solution:
    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]: return 0

        row = len(matrix)
        col = len(matrix[0])
        lookup = [[0] * col for _ in range(row)]

        def dfs(i, j):
            if lookup[i][j] != 0:
                return lookup[i][j]
            # 方法一
            res = 1
            for x, y in [[-1, 0], [1, 0], [0, 1], [0, -1]]:
                tmp_i = x + i
                tmp_j = y + j
                if 0 <= tmp_i < row and 0 <= tmp_j < col and \
                        matrix[tmp_i][tmp_j] > matrix[i][j]:
                    res = max(res, 1 + dfs(tmp_i, tmp_j))
            lookup[i][j] = max(res, lookup[i][j])
            # 方法二
            # val = matrix[i][j]
            # lookup[i][j] = 1 + max(
            #     dfs(i + 1, j) if 0 <= i + 1 < row and 0 <= j < col and matrix[i + 1][j] > val else 0,
            #     dfs(i - 1, j) if 0 <= i - 1 < row and 0 <= j < col and matrix[i - 1][j] > val else 0,
            #     dfs(i, j + 1) if 0 <= i < row and 0 <= j + 1 < col and matrix[i][j + 1] > val else 0,
            #     dfs(i, j - 1) if 0 <= i < row and 0 <= j - 1 < col and matrix[i][j - 1] > val else 0,
            # )
            # 方法三
            # lookup[i][j] = 1 + max(
            #     [dfs(i + x, y + j) for x, y in [[-1, 0], [1, 0], [0, 1], [0, -1]] \
            #      if 0 <= (i + x) < row and 0 <= (j + y) < col and matrix[i + x][j + y] > matrix[i][j]] or [0]
            # )
            
            return lookup[i][j]

        return max(dfs(i, j) for i in range(row) for j in range(col))
```

###  1.155. <a name='ReconstructItinerary'></a>332 Reconstruct Itinerary

[小明](https://www.bilibili.com/video/BV1qa4y1h7Ti?spm_id_from=333.999.0.0)

###  1.156. <a name='IncreasingTripletSubseque'></a>334 Increasing Triplet Subseque

[小明](https://www.bilibili.com/video/BV1Kr4y1F7m9?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        # m - min, sm - second min
        m, sm = float('inf'), float('inf')

        for num in nums:
        	print (m, sm)
        	if m >= num:
        		m = num
        	elif sm >= num:
        		sm = num
        	else:
        		return True
        return False


class Solution:
    def increasingTriplet(self, nums):
        n = len(nums)
        if n < 3:
            return False
        small, mid = max(nums), max(nums)
        for i in range(n):
            if nums[i] <= small:
                small = nums[i]
            elif nums[i] <= mid:
                mid = nums[i]
            elif nums[i] > mid:
                return True
        return False

# 循环遍历数组，不断更新数组内出现的最小值与最大值，如果出现的一个大于最大值的数，则表示存在长度为 3 的递增子序列。

class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        length = len(nums)
        if length < 3:
            return False
        
        min_num = float('inf')
        max_num = float('inf')
        
        for n in nums:
            if n < min_num:
                min_num = n
            elif min_num < n and n <= max_num:
                max_num = n
            elif n > max_num:
                return True
        
        return False
```

###  1.157. <a name='HouseRobberIII'></a>337 House Robber III

[小明](https://www.bilibili.com/video/BV1WD4y1X7JQ?spm_id_from=333.999.0.0)

```py
# 补充一个Python的：

class Solution:
    def rob(self, root: TreeNode) -> int:
        def _rob(root):
            if not root: return 0, 0
            
            ls, ln = _rob(root.left)  # 前一项表示根节点偷，后一项表示根节点不偷
            rs, rn = _rob(root.right) # 前一项表示根节点偷，后一项表示根节点不偷
            
            return root.val + ln + rn, max(ls, ln) + max(rs, rn) # 前一项表示根节点偷，后一项表示根节点不偷

        return max(_rob(root))
# ls表示偷左子树能带来的最大收益，ln表示不偷左子树能带来的最大收益，rs、rn同理

# 这个解法好像有点厉害

# 从root开始抢起来，最大能抢到的两个可能： 抢root和不抢root

# - rob_root = max(rob_L + rob_R , no_rob_L + no_nob_R + root.val)
# - no_rob_root = rob_L + rob_R


# 这个递归写起来就很厉害了


# ```
class Solution(object):
    def rob(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(root):
            if not root: return 0, 0
            rob_L, no_rob_L = dfs(root.left) # 前一项表示根节点偷，后一项表示根节点不偷
            rob_R, no_rob_R = dfs(root.right) # 前一项表示根节点偷，后一项表示根节点不偷
            return max(no_rob_R + no_rob_L + root.val , rob_L + rob_R), rob_L + rob_R # 前一项表示根节点偷，后一项表示根节点不偷
        return dfs(root)[0]

class Solution:
    def rob(self, root: TreeNode) -> int:
        result = self.rob_tree(root)
        return max(result[0], result[1])
    
    def rob_tree(self, node):
        if node is None:
            return (0, 0) # (偷当前节点金额，不偷当前节点金额)
        left = self.rob_tree(node.left)
        right = self.rob_tree(node.right)
        val1 = node.val + left[1] + right[1] # 偷当前节点，不能偷子节点
        val2 = max(left[0], left[1]) + max(right[0], right[1]) # 不偷当前节点，可偷可不偷子节点
        return (val1, val2)

class Solution:
    def rob(self, root: TreeNode) -> int:
        if root is None:
            return 0
        if root.left is None and root.right  is None:
            return root.val
        # 偷父节点
        val1 = root.val
        if root.left:
            val1 += self.rob(root.left.left) + self.rob(root.left.right)
        if root.right:
            val1 += self.rob(root.right.left) + self.rob(root.right.right)
        # 不偷父节点
        val2 = self.rob(root.left) + self.rob(root.right)
        return max(val1, val2)
```

###  1.158. <a name='CountingBits'></a>338 【动态规划 + 位运算😜】Counting Bits

[小明](https://www.bilibili.com/video/BV1VK411s7xi?spm_id_from=333.999.0.0)

```py
class Solution:
    def countBits(self, n: int) -> List[int]:
        def countOnes(x: int) -> int:
            ones = 0
            while x > 0:
                x &= (x - 1)
                ones += 1
            return ones
        
        bits = [countOnes(i) for i in range(n + 1)]
        return bits

动态规划 方法1：
class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        highBit = 0
        for i in range(1, n + 1):
            if i & (i - 1) == 0:
                highBit = i
            bits.append(bits[i - highBit] + 1) # 只去掉最右边的 1
        return bits

class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        for i in range(1, n + 1):
            bits.append(bits[i & (i - 1)] + 1) # 只去掉最右边的 1
        return bits

动态规划 方法二：
class Solution:
    def countBits(self, n: int) -> List[int]:
        bits = [0]
        for i in range(1, n + 1):
            bits.append(bits[i >> 1] + (i & 1)) # 最右边的 1 or 0
        return bits

class Solution:
    def countBits(self, num: int) -> List[int]:
        res=[0]
        for i in range(1,num+1):
            if i%2==0:
                res.append(res[i//2])
            else:
                res.append(res[i-1]+1)
        return res

```

```py
class Solution(object):
    def countBits(self, n):

        return [bin(i)[2:].count('1') for i in range(n+1)]
```


```scala

/**
* chosen solution
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution0 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}

object Solution1 {
    def countBits(num: Int): Array[Int] = {
        (0 to num).map(_counter).toArray
        
    }
    private def _counter(n: Int): Int = {
        var counter = 0
        var nn = n
        
        while(nn != 0) {
            counter += 1
            nn = nn & (nn - 1)
        }
        counter 
    }
}

/**
* DP + bit operation 
* using an array to record previous result, and current one just add 1 with previous calculated result
* complexity:
*   time complexity: O(N)
*   space complexity: O(N)
*/

object Solution2 {
    def countBits(num: Int): Array[Int] = {
        var arr = Array.ofDim[Int](num + 1)
        (1 to num).foreach{ n => 
            arr(n) = arr(n & (n -1 )) + 1
        }
        arr     
    }
    
}
```

###  1.159. <a name='PowerofFour'></a>342. 【位运算😜】Power of Four

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7D5?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1p5411a7h1?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and n % 3 == 1




class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n & 0xaaaaaaaa) == 0





class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and n & n - 1 == 0 and n & 0b1010101010101010101010101010101 == n

```

```py
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        while n > 1: n = n / 4
        return False if n != 1 else True 
```

###  1.160. <a name='-1'></a>343-整数拆分

[哈哈哈](https://www.bilibili.com/video/BV1Dp4y1U79P?spm_id_from=333.999.0.0)

###  1.161. <a name='ReverseString'></a>344. Reverse String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7Ha?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nC4y1a7DR?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1nQ4y1R7nH?spm_id_from=333.999.0.0)

```py
class Solution: 
    def reverseString(self, s: List[str]) -> None:

    """
    Do not return anything, modify s in-place instead.
    """
    i, j = 0, len(s) - 1
    while i<j:
        s[i],s[j]=s[j],s[i]
        i+=1
        j-=1
    return s

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        
        # 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(right//2)更低
        # 推荐该写法，更加通俗易懂
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

```py
class Solution:
    def reverseString(self, s):
        s.reverse()
        # s[:] = s[::-1]
        '''
        j = len(s)-1
        for i in range(len(s)//2):
            s[i],s[j] = s[j],s[i]
            j -= 1
       '''
```

```scala
object Solution {
    def reverseString(s: Array[Char]): Unit = {
        var begin = 0
        var end = s.length - 1
        while(begin < end){
            var temp = s(begin)
            s(begin) = s(end)
            s(end) = temp
            
            begin += 1
            end -= 1
        }
    }
}

```

###  1.162. <a name='ReverseVowelsofaString'></a>345. Reverse Vowels of a String

[小梦想家](https://www.bilibili.com/video/BV1Gx411o7JH?spm_id_from=333.999.0.0)

###  1.163. <a name='MovingAveragefromDataStream'></a>346 Moving Average from Data Stream

[小明](https://www.bilibili.com/video/BV1xV411m73u?spm_id_from=333.999.0.0)

###  1.164. <a name='TopKFrequentElements'></a>347. 【最小堆🌵】Top K Frequent Elements 

[花花酱](https://www.bilibili.com/video/BV1Mt411371T?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1sk4y1B7vj?spm_id_from=333.999.0.0)

```py
#时间复杂度：O(nlogk)
#空间复杂度：O(n)
import heapq
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #要统计元素出现频率
        map_ = {} #nums[i]:对应出现的次数
        for i in range(len(nums)):
            map_[nums[i]] = map_.get(nums[i], 0) + 1
        
        #对频率排序
        #定义一个小顶堆，大小为k
        pri_que = [] #小顶堆
        
        #用固定大小为k的小顶堆，扫面所有频率的数值
        for key, freq in map_.items():
            heapq.heappush(pri_que, (freq, key))
            if len(pri_que) > k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                heapq.heappop(pri_que)
        
        #找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组
        result = [0] * k
        for i in range(k-1, -1, -1):
            result[i] = heapq.heappop(pri_que)[1]
        return result
```

```py
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        dic = {}
        for n in nums:
            if n in dic:
                dic[n] += 1
            else:
                dic[n] = 1
        return [k for k, v in sorted(dic.items(), key=lambda item:item[1],reverse=True)][0:k]

python写了一个本以为时间很长结果击败了97%的代码（一开始都没想到优先队列【捂脸】）

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        sort_nums=sorted(Counter(nums).items(),reverse=True,key=lambda item:item[1])[:k]
        return list(zip(*sort_nums))[0]

Python一行搞定：

from collections import Counter

class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        return [item[0] for item in Counter(nums).most_common(k)]
```

```scala
object Solution {
    def topKFrequent(nums: Array[Int], k: Int): Array[Int] = {
        var hm = scala.collection.mutable.Map.empty[Int, Int]
        for(elem <- nums){
            hm.get(elem) match{
                case Some(count) => hm += (elem -> (count+1))
                case None => hm += (elem -> 1)
            }
        }
        
        // hm.toList.sortBy(x => (x._2)*(-1)).take(k).map(_._1).toArray
        // The above is a sorting approach. We can use Heap/PriorityQueue to achieve better time complexity
        
        import scala.math.Ordering.Implicits._
        
        def orderByFrequency(tup: (Int, Int)) = tup._2
        
        val pq = new scala.collection.mutable.PriorityQueue[(Int, Int)]()(Ordering.by(orderByFrequency))
        
        for(entry <- hm){
            pq.enqueue(entry)
        }
        
        println(pq)
        (1 to k).map(_ => pq.dequeue).map(_._1).toArray
        
    }
}

```

###  1.165. <a name='IntersectionofTwoArrays'></a>349. Intersection of Two Arrays

[小梦想家](https://www.bilibili.com/video/BV1zx411o7i1?spm_id_from=333.999.0.0)

###  1.166. <a name='IntersectionofTwoArraysII'></a>350. 【动态🚀规划 + 双指针 + 哈希表】Intersection of Two Arrays II 

[小梦想家](https://www.bilibili.com/video/BV1gx411X7q8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV165411879H?spm_id_from=333.999.0.0)

```py
"""
动态🚀规划：容易出错，最好别用
"""
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # 输入：
        # [2,1]
        # [1,2]
        # 输出：
        # [1]
        # 预期结果：
        # [1,2]
        # 所以必须要排序
        nums1.sort()
        nums2.sort()
        dp = [[[]] * (len(nums2) + 1) for _ in range(len(nums1) + 1)]
        # 错误写法：dp = [[] * (len(nums1) + 1) for _ in range(len(nums2) + 1)]

        for i in range(1, len(nums1)+1):
            for j in range(1, len(nums2)+1):
                if nums1[i-1] == nums2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + [nums1[i-1]] # 易错点：不能用append
                else:
                    # 精简的写法：dp[i][j] = max(dp[i][j-1], dp[i-1][j], key = len).copy()
                    if len(dp[i][j-1]) > len(dp[i-1][j]):
                        dp[i][j] = dp[i][j-1]  
                    else:
                        dp[i][j] = dp[i-1][j]
        return dp[-1][-1]

"""
排序后，再使用双指针
"""
class Solution:
    def intersect(self, nums1, nums2):
        nums1, nums2 = sorted(nums1), sorted(nums2)
        l1, l2 = 0, 0
        res = []
        while l1 < len(nums1) and l2 < len(nums2):
            if nums1[l1] == nums2[l2]:
                res.append(nums1[l1])
                l1 += 1
                l2 += 1
            elif nums1[l1] < nums2[l2]:
                l1 += 1
            else:
                l2 += 1
        return res     


"""
哈希表
"""
from collections import Counter
class Solution:
    def intersect(self, nums1, nums2):
        nums1 = Counter(nums1)
        res = []
        for i in nums2:
            if i in nums1 and nums1[i]:
                res.append(i)
                nums1[i] -= 1
        return res
```

```scala
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        
        val map1 = nums1.groupBy(identity).mapValues(_.length)
        val map2 = nums2.groupBy(identity).mapValues(_.length)
        
        val keys = map1.keySet intersect map2.keySet
        
        keys.map(key => {
            val count1 = map1.get(key).get
            val count2 = map2.get(key).get
            val count = if(count1 > count2) count2 else count1
            Array.fill(count)(key)
        }).toArray.flatten
    }
}


//Alternate solution to keep count in HashMap from 1st array & decrease from second array... whatever is left is intersection
object Solution {
    def intersect(nums1: Array[Int], nums2: Array[Int]): Array[Int] = {
        var map = scala.collection.mutable.Map.empty[Int, Int]
        var output = List.empty[Int]
        for(item <- nums1){
            map.get(item) match{
                case Some(count) => map += (item -> (count + 1))
                case None => map += (item -> 1)
            }
        }
        
        for(item <- nums2){
            map.get(item) match{
                case Some(count) => {
                    output = output :+ item
                    if(count - 1 == 0) map.remove(item) else map += (item -> (count - 1))
                }
                case None => map.remove(item)
            }
        }
        
        output.toArray
    }
}

```

###  1.167. <a name='351AndroidUnlockingPattern'></a> 351 【🍒并查集】Android Unlocking Pattern

[郭郭](https://www.bilibili.com/video/BV1Qq4y1r7WH?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

###  1.168. <a name='DesignTwitter'></a>355. 设计推特 Design Twitter

[官方](https://www.bilibili.com/video/BV1aQ4y1N72N?spm_id_from=333.999.0.0)

###  1.169. <a name='LoggerRateLimiter'></a>359 Logger Rate Limiter

[小明](https://www.bilibili.com/video/BV1k64y1F7dE?spm_id_from=333.999.0.0)

###  1.170. <a name='ValidPerfectSquare'></a>367. Valid Perfect Square

[小梦想家](https://www.bilibili.com/video/BV1Gx411X7Ke?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DT4y1377H?spm_id_from=333.999.0.0)

```py
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return float.is_integer(pow(num, 0.5))

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        x = 1
        square = 1
        while square <= num:
            if square == num:
                return True
            x += 1
            square = x * x
        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 0, num
        while left <= right:
            mid = (left + right) // 2
            square = mid * mid
            if square < num:
                left = mid + 1
            elif square > num:
                right = mid - 1
            else:
                return True
        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        x0 = num
        while True:
            x1 = (x0 + num / x0) / 2
            if x0 - x1 < 1e-6:
                break
            x0 = x1
        x0 = int(x0)
        return x0 * x0 == num

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-perfect-square/solution/you-xiao-de-wan-quan-ping-fang-shu-by-le-wkee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num**0.5 == int(num**0.5)

打表党大胜利

ans = [i**2 for i in range(46342)]
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return num in ans

python版二分法

class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        low=1
        high=num
        while high>=low:
            mid=(high+low)//2
            if mid*mid == num:
                return True
            elif mid*mid < num:
                low=mid+1
            elif mid*mid > num:
                high=mid-1
        return False
```

###  1.171. <a name='LargestDivisibleSubset'></a>368 Largest Divisible Subset

[小明](https://www.bilibili.com/video/BV15D4y1Q74b?spm_id_from=333.999.0.0)

###  1.172. <a name='-1'></a>371【位运算😜 + 有点难，再看看】

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6oayqs4ig3g0.webp)

```py
MAX = 1024
MAX_INT = 1023
class Solution:
    def getSum(self, a: int, b: int) -> int:
        """
        a 001
        b 010
        a^b 011
        -------
        a 010
        b 011
        a^b 001
        ===> 统计所有进位的1
        a^b^((a&b)<<1)
        -------
        a 010100
        b 011110
        a^b 001010
        所有进位 101010
        进位的异或还可能有进位!
        所以要使用循环or迭代处理
        -------
        负数补码总会提供最左的1，按位取反，要特殊处理负数
        Python需要要做整数的溢出
        既然数据范围是1000，那我们认定最大的整数是1024-1做溢出即可
        """
        def int_overflow(val):
            if not -MAX <= val <= MAX_INT:
                val = (val + MAX) % (2 * MAX) - MAX
            return val
        while b:
            a,b = int_overflow(a^b), int_overflow((a & b) << 1)
        return a

作者：himymBen
链接：https://leetcode-cn.com/problems/sum-of-two-integers/solution/pythonjava-wei-yun-suan-di-gui-or-die-da-7esn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
MASK1 = 0x100000000  # 2^32
minInt1000 = 0x80000000  # 2^31
maxInt0111 = 0X7FFFFFFF  # 2^31-1

class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            carry = ((a & b) << 1)
            a = (a ^ b) % MASK1
            b = carry
        return a if a <= maxInt0111 else ~((a % minInt1000) ^ maxInt0111)   

MM = 0xFFFFFFFF # 2^32-1
MASK1 = 0x100000000  # 2^32
minInt1000 = 0x80000000  # 2^31
maxInt0111 = 0X7FFFFFFF  # 2^31-1

class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            carry = ((a & b) << 1)
            a = (a ^ b) % MASK1
            b = carry
        return a if a <= maxInt0111 else ~ (a ^ MM)

MASK1 = 0x100000000  # 2^32
minInt1000 = 0x80000000  # 2^31
maxInt0111 = 0X7FFFFFFF  # 2^31-1

class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            carry = ((a & b) << 1)
            a = (a ^ b) % MASK1
            b = carry
        if a & minInt1000:  # 负数，也就是第31位有东西
            return ~((a ^ minInt1000) ^ maxInt0111)
        else:  # 正数，也就是第31位没有东西
            return a

MASK1 = 0x100000000  # 2^32
minInt1000 = 0x80000000  # 2^31
maxInt0111 = 0X7FFFFFFF  # 2^31-1

class Solution:
    def getSum(self, a: int, b: int) -> int:
        while b != 0:
            carry = ((a & b) << 1)
            a = (a ^ b) % MASK1
            b = carry
        return ~((a ^ minInt1000) ^ maxInt0111) if a & minInt1000 else a   

class Solution:
    def getSum(self, a: int, b: int) -> int:
        a &= 0xFFFFFFFF
        b &= 0xFFFFFFFF
        while b:
            carry = a & b
            a ^= b
            b = ((carry) << 1) & 0xFFFFFFFF
        return a if a < 0x80000000 else ~ (a ^ 0xFFFFFFFF)

Recursion

class Solution:
    def getSum(self, a: int, b: int) -> int:
        # 2 ^ 32
        MASK = 0x100000000
        MM = 0xFFFFFFFF
        MAX_INT = 0x7FFFFFFF
        MIN_INT = 0x80000000

        if 0 == b:
            return a if a <= MAX_INT else ~ (a ^ MM)

        carry = (a & b) << 1
        a = (a ^ b) % MASK
        b = carry        
        return self.getSum(a, b)
```

###  1.173. <a name='FindKPairswithSmallestSumsk'></a>373. Find K Pairs with Smallest Sums查找和最小的k对数字

[图灵](https://www.bilibili.com/video/BV1Mv4y1Z79v?spm_id_from=333.999.0.0)

###  1.174. <a name='GuessNumberHigherorLower'></a>374. Guess Number Higher or Lower

[小梦想家](https://www.bilibili.com/video/BV1Hx41197ou?spm_id_from=333.999.0.0)

###  1.175. <a name='-1'></a>376-摆动序列

[哈哈哈](https://www.bilibili.com/video/BV1sk4y167wV?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16X4y1376k?spm_id_from=333.999.0.0)

```py
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = [1] + [0] * (n - 1)
        down = [1] + [0] * (n - 1)
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up[i] = max(up[i - 1], down[i - 1] + 1)
                down[i] = down[i - 1]
            elif nums[i] < nums[i - 1]:
                up[i] = up[i - 1]
                down[i] = max(up[i - 1] + 1, down[i - 1])
            else:
                up[i] = up[i - 1]
                down[i] = down[i - 1]
        
        return max(up[n - 1], down[n - 1])

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = down = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up = max(up, down + 1)
            elif nums[i] < nums[i - 1]:
                down = max(up + 1, down)
        
        return max(up, down)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        up = down = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                up = down + 1
            elif nums[i] < nums[i - 1]:
                down = up + 1
        
        return max(up, down)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return n
        
        prevdiff = nums[1] - nums[0]
        ret = (2 if prevdiff != 0 else 1)
        for i in range(2, n):
            diff = nums[i] - nums[i - 1]
            if (diff > 0 and prevdiff <= 0) or (diff < 0 and prevdiff >= 0):
                ret += 1
                prevdiff = diff
        
        return ret

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
大佬的这个解法好强，利用摆动序列，波峰和波谷的差值最多为1的特点。一次遍历，常数空间。学不来学不来

class Solution:
    def wiggleMaxLength(self, nums):
        up ,down = 1,1
        if len(nums)<2:return len(nums)
        for i in range(1,len(nums)):
            if nums[i]>nums[i-1]:
                up = down+1
            if nums[i]<nums[i-1]:
                down = up+1
        return max(up,down)

Python：

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        preC,curC,res = 0,0,1  #题目里nums长度大于等于1，当长度为1时，其实到不了for循环里去，所以不用考虑nums长度
        for i in range(len(nums) - 1):
            curC = nums[i + 1] - nums[i]
            if curC * preC <= 0 and curC !=0:  #差值为0时，不算摆动
                res += 1
                preC = curC  #如果当前差值和上一个差值为一正一负时，才需要用当前差值替代上一个差值
        return res

单调子序列保留两个端点，重复子序列保留一个点，剩下的都是符合要求的

class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        arr=[nums[0]]
        for x in nums:
            if x!=arr[-1]:
                arr.append(x)
        if len(arr)<2:
            return len(arr)
        res=2
        for i in range(1,len(arr)-1):
            if arr[i-1]>arr[i]<arr[i+1] or arr[i-1]<arr[i]>arr[i+1]:
                res+=1
        return res
```



###  1.176. <a name='CombinationSumIV'></a>377. 【动态🚀规划】Combination Sum IV

####  1.176.1. <a name='416494377'></a>类似题目：416题，494题，不可以重复，377重复

[花花酱](https://www.bilibili.com/video/BV1gW411y7uz?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1zA411L7nu?spm_id_from=333.999.0.0)

```py
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0] * (target + 1)
        dp[0] = 1
        # 易错点：for i in range(nums[0], target+1): 不适用于 nums = [3,1,2,3]
        for i in range(1, target+1): # 一定要先target再num，这样才能有重复
            for num in nums:
                if i >= num:
                    dp[i] += dp[i - num]
        return dp[-1]
```

###  1.177. <a name='K'></a>378-【最小堆🌵】有序矩阵中第K小的元素

[哈哈哈](https://www.bilibili.com/video/BV1mT4y1w7u2?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1Zy4y127qr?spm_id_from=333.999.0.0)

```py
# 无脑暴力法一行版

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        return sorted(sum(matrix,[]))[k-1]
# 暴力pq一行
import heapq
class Solution(object):
    def kthSmallest(self, matrix, k):
        return heapq.nsmallest(k,sum(matrix,[]))[-1]
#  heapq一行
class Solution(object):
    def kthSmallest(self, matrix, k):
        return list(heapq.merge(*matrix))[k-1]

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        rec = sorted(sum(matrix, []))
        return rec[k - 1]

# 无脑暴力法优化版
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        l=heapq.nlargest(len(lis)-k+1,lis)
        return l[-1]
# 无脑暴力法
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        lis=[]
        for l in matrix:
            lis+=l
        lis.sort()
        return lis[k-1]
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k) -> int:
        n = len(matrix)
        pq = [(matrix[i][0], i, 0) for i in range(n)]
        heapq.heapify(pq)

        ret = 0
        for i in range(k - 1):
            num, x, y = heapq.heappop(pq)
            if y != n - 1:
                heapq.heappush(pq, (matrix[x][y + 1], x, y + 1))
        
        return heapq.heappop(pq)[0]
# binary search
# ```python
import bisect
class Solution(object):
    def kthSmallest(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k
        :rtype
        """
        l, r = matrix[0][0], matrix[-1][-1]
        while l <= r:
            mid = l + ((r - l) >> 2)
            if sum(bisect.bisect_right(row, mid) for row in matrix) < k:
                l = mid + 1
            else:
                r = mid - 1
        return l
```


###  1.178. <a name='InsertDeleteGetRandomO1'></a>380 Insert Delete GetRandom O(1)

[小明](https://www.bilibili.com/video/BV1Fg4y1q7Ru?spm_id_from=333.999.0.0)

###  1.179. <a name='LinkedListRandomNode'></a>382 Linked List Random Node

[小明](https://www.bilibili.com/video/BV1xZ4y1G7ie?spm_id_from=333.999.0.0)

###  1.180. <a name='RansomNote'></a>383 Ransom Note

[小明](https://www.bilibili.com/video/BV1GQ4y1N7Q5?spm_id_from=333.999.0.0)

###  1.181. <a name='-1'></a>386

```py
class Solution:
    def lexicalOrder(self, n):
        def dfs(num):
            if num > n:
                return
            ans.append(num)
            for nxt in range(num * 10, num * 10 + 10):
                dfs(nxt)

        ans = []
        for num in range(1, 10):
            dfs(num)
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(i: int = 1) -> None:
            if i > n:
                return
            for j in range(i, min(n + 1, (10 if i < 10 else i + 10))):
                ans.append(j)
                dfs(j * 10)
        ans = []
        dfs()
        return ans

class Solution:
    def lexicalOrder(self, n):
        def dfs(rec, i, n):
            if i > n: return -1
            rec.append(i);
            child = i * 10
            for j in range(10):
                if dfs(rec, child+j, n) == -1:break
            return
        rec = []
        for i in range(1, 10):
            dfs(rec, i, n)
        return rec
```

```py
class Solution:
    def lexicalOrder(self, n):
        return sorted(list(range(1,n+1)),key=lambda x:str(x))

class Solution:
    def lexicalOrder(self, n):
        return [int(j) for j in sorted([str(i) for i in range(1, n + 1)])]

# 字符串排序

class Solution:
    def lexicalOrder(self, n):
        l = sorted([str(i) for i in range(1, n + 1)])
        return [int(i) for i in l]
```

```py
class Solution:
    def lexicalOrder(self, n):
        orders = []
        stack = [(1, 8)]
        while len(stack) > 0:
            orders.append(stack[-1][0])
            (last, step) = stack.pop()
            if last+1 <= n and step > 0:
                stack.append((last+1, step-1))
            if last*10 <= n:
                stack.append((last*10, 9))
        return orders

class Solution:
    def lexicalOrder(self, n):
        ans = []
        num = 1
        while len(ans) < n:
            while num <= n:  # 不断进入下一层
                ans.append(num)
                num *= 10
            while num % 10 == 9 or num > n:  # 不断返回上一层
                num //= 10
            num += 1  # 遍历该层下一个数
        return ans

class Solution(object):
    def lexicalOrder(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        res = []
        cur = 1
        for i in range(n):
            res.append(cur)
            if (cur * 10 <= n):
                cur *= 10
            elif cur + 1 <= n and (cur + 1) % 10 != 0:
                cur += 1
            else:
                while (cur/10) % 10 == 9:
                    cur /= 10
                cur = cur / 10 + 1
        return res
```

###  1.182. <a name='FirstUniqueCharacterinaString'></a>387. First Unique Character in a String

[小梦想家](https://www.bilibili.com/video/BV1y4411A7d2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1b541147WU?spm_id_from=333.999.0.0)

```py
class Solution:
    def firstUniqChar(self, s: str) -> int:
        frequency = collections.Counter(s)
        for i, ch in enumerate(s):
            if frequency[ch] == 1:
                return i
        return -1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def firstUniqChar(self, s: str) -> int:
        position = dict()
        n = len(s)
        for i, ch in enumerate(s):
            if ch in position:
                position[ch] = -1
            else:
                position[ch] = i
        first = n
        for pos in position.values():
            if pos != -1 and pos < first:
                first = pos
        if first == n:
            first = -1
        return first
        遍历字符串，如果当前字符没出现过就用字典记录它在字符串中的位置，
        出现过了就把字典里的那条记录改成-1。然后找字典里位置最靠前的（而且不是-1的）那个字符。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def firstUniqChar(self, s: str) -> int:
        position = dict()
        q = collections.deque()
        n = len(s)
        for i, ch in enumerate(s):
            if ch not in position:
                position[ch] = i
                q.append((s[i], i))
            else:
                position[ch] = -1
                while q and position[q[0][0]] == -1:
                    q.popleft()
        return -1 if not q else q[0][1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
用一个哈希表存放字符中字符出现的次数

然后从头遍历，返回遇到的第一个出现次数为1的字符下标

如果遍历完都没有，就说明不存在，返回-1

from collections import Counter
class Solution:
    def firstUniqChar(self, s: str) -> int:
        sDict = Counter(s)
        for n in range(len(s)):
            if sDict[s[n]] == 1:
                return n
        return -1

python3行，第一次出现的位置和最后一次出现的位置相等

class Solution(object):
    def firstUniqChar(self, s): 
        for i in range(len(s)):
            if s.find(s[i])==s.rfind(s[i]):
                return i
        return -1

用字典记录已经查找过的字母
执行用时：44 ms, 在所有 Python3 提交中击败了99.25%的用户
class Solution:
    def firstUniqChar(self, s: str) -> int:
        d={}
        length=len(s)
        for i in range(length):
            if s[i] not in d:
                if s.find(s[i],i+1)==-1:return i
                d[s[i]]=None
        return -1

我的另外一种算法，执行用时：48 ms, 在所有 Python3 提交中击败了98.92%的用户

class Solution:
    def firstUniqChar(self, s: str) -> int:
        for k,v in collections.Counter(s).items():
            if v==1:
                return s.find(k)
        return -1
```

```scala
object Solution {
    def firstUniqChar(s: String): Int = {
        var map = scala.collection.mutable.Map.empty[Char, (Int, Int)]
        (0 to s.length-1).map(i =>
            map.get(s.charAt(i)) match{
                case Some(indexAndCount) => map += (s.charAt(i) -> (i, indexAndCount._2 + 1))
                case None => map += (s.charAt(i) -> (i, 1))
            }
        )
        map.toList.filter(x => x._2._2 == 1).map(_._2._1).sorted.headOption.getOrElse(-1)
    }
}

//Alternate/Better SCALA solution
object Solution {
    def firstUniqChar(s: String): Int = {
        val hmap =  s.toCharArray.groupBy(identity).mapValues(_.length)
        val uniqChar = s.toCharArray.zipWithIndex.find (p => hmap(p._1) == 1)
        if(uniqChar.nonEmpty) uniqChar.get._2 else -1 
    }
}

/**How the above solution works:
scala> val a = "akashs"
a: String = akashs

scala> a.toCharArray.groupBy(identity)
res0: scala.collection.immutable.Map[Char,Array[Char]] = Map(h -> Array(h), k -> Array(k), s -> Array(s, s), a -> Array(a, a))

scala> a.toCharArray.groupBy(identity).mapValues(_.length)
res1: scala.collection.immutable.Map[Char,Int] = Map(h -> 1, k -> 1, s -> 2, a -> 2)

scala> a.toCharArray.zipWithIndex
res2: Array[(Char, Int)] = Array((a,0), (k,1), (a,2), (s,3), (h,4), (s,5))

scala> a.toCharArray.zipWithIndex.find(x => res1(x._1) == 1)
res3: Option[(Char, Int)] = Some((k,1))
*/

```

###  1.183. <a name='FindtheDifference'></a>389. 【位运算😜】Find the Difference

[小梦想家](https://www.bilibili.com/video/BV1Et411K7jP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5j9pjpm6f080.webp)

```py
这应该是最简单的方法了吧

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        ret = 0
        for c in s + t:
            ret ^= ord(c)
        return chr(ret)

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        # 初始化 ans 为 0
        ans = 0
        # 对字符串 s 的字符进行异或
        for ch in s:
            ans ^= ord(ch)
        # 对字符串 t 的字符进行异或
        for ch in t:
            ans ^= ord(ch)
        # 最终结果转换为 ASCII 字符
        return chr(ans)
```

注意：Counter 和 count 的区别

```py

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return [x for x in t if t.count(x)-s.count(x)==1][0]   


class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        # t中字母一定多
        for c in t:
            if t.count(c)!=s.count(c):
                return c
        return ""

Counter是一个容器对象,主要的作用是用来统计散列对象,可以使用三种方式来初始化

参数里面参数可迭代对象 Counter("success")

传入关键字参数Counter((s=3,c=2,e=1,u=1))

传入字典 Counter({"s":3,"c"=2,"e"=1,"u"=1})

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return next(iter(Counter(t)-Counter(s)))
        
iter(xxx) 和 xxx.elements() 都是迭代器

Counter O(n)：

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return next((Counter(t)-Counter(s)).elements())

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return (collections.Counter(t) - collections.Counter(s)).popitem()[0] # 返回 ('e', 1)
```

注意：reduce 和 map 的 区别

https://zhuanlan.zhihu.com/p/77311224

```py
Python 1行 ASCII 和之差

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return chr(sum(map(ord, t)) - sum(map(ord, s)))

每一个字符都对应一个 ASCII 数字，那么那个不同的数字的 ASCII 码就等于 t 的所有字符码之和 - s 的
ord 函数将单个字符转换为 ASCII 码， chr相反

👆👆👆 py3 1行(列表生成器 and 生成器，这就是你py3写不到一行代码的差距 没说你)


位运算😜 O(n)：

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return chr(reduce(xor, map(ord, s + t)))

python reduce+lambda 一行。ord()取字符对应ascii码,chr()返回ascii码对应字符

class Solution(object):
    def findTheDifference(self, s, t):
        return reduce(lambda x,y: chr(ord(x) ^ ord(y)), s + t)
# sum1 = reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5
# sum2 = reduce(lambda x, y: x+y, [1,2,3,4,5])  # 使用 lambda 匿名函数
```




###  1.184. <a name='PerfectRectangle'></a>391. Perfect Rectangle

[花花酱](https://www.bilibili.com/video/BV184411c7cs?spm_id_from=333.999.0.0)

###  1.185. <a name='IsSubsequence'></a>392. 【动态🚀规划】Is Subsequence

[小梦想家](https://www.bilibili.com/video/BV1fg4y1q7eT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Za4y1a73v?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV19f4y197yS?spm_id_from=333.999.0.0)

动态🚀规划

```py
class Solution:
    def isSubsequence(self, t: str, s: str) -> bool:
        dp = [[False] * (len(s) + 1) for _ in range(len(t) + 1)]
        for j in range(len(s)+1):
            dp[0][j] = True
        for i in range(1, len(t)+1):
            for j in range(1, len(s)+1):
                if t[i-1] == s[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = dp[i][j-1]
        return dp[-1][-1]
```

```py
思路三：双指针

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i = 0
        j = 0
        while i < len(s) and j < len(t):
            # print(i, j)
            if s[i] == t[j]:
                i += 1
                j += 1
            else:
                j += 1    
        return i == len(s)

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        n, m = len(s), len(t)
        i = j = 0
        while i < n and j < m:
            if s[i] == t[j]:
                i += 1
            j += 1
        return i == n

```

```py

思路二：生成迭代器
简单粗暴.

class Solution(object):
    def isSubsequence(self, s, t):
        t = iter(t)
        return all(char in t for char in s) 


翻译了一下

class Solution(object):
    def isSubsequence(self, s, t):
        t = iter(t)
        res = []
        for c in s:
            if c in t:
                res.append(c)
            else:
                res.append(None)

        res = iter(res)
        return all(res)
```

###  1.186. <a name='UTF-8Validation'></a>393. UTF-8 Validation

[花花酱](https://www.bilibili.com/video/BV1SE411w7no?spm_id_from=333.999.0.0)

###  1.187. <a name='DecodeString'></a>394 Decode String

[小明](https://www.bilibili.com/video/BV145411V75E?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GZ4y1p7pE?spm_id_from=333.999.0.0)

```py
# 类似正则表达式
# 神仙神仙，看了半天才看明白，每次只匹配最里层的，
# 将匹配到的字符串自动分成数字和字母，然后用转换函数替换成新串，
# 替换完内层后再去替换外层，直到没有括号为止。函数式编程和正则表达式玩的好秀。
# 牛的，看了半天终于懂了，不过这里r的意思应该是取消python转义吧
import re

class Solution(object):
    def decodeString(self, s):
        """
        :type s: str
        :rtype: str
        """
        def f(m):
            print("m:",m)
            print("m.group(1):",m.group(1))
            print("m.group(2):",m.group(2))
            return int(m.group(1))* m.group(2)
        while '[' in s:
            s = re.sub(r'(\d+)\[([A-Za-z]*)\]', f, s)
        return s
```

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.1a1r7x6jdqww.png" width="50%">

```py
# 当前的 context 有两个值，一个是当前打印的串，一个是重复的数量。

# 我写了个状态机来解这个题目：

class Solution:
    def decodeString(self, s: str) -> str:
        res = ''       # 当前打印串
        count = 0   # 下一个 pattern 的数量
        stack = []
        for c in s:
            if ord('a') <= ord(c) <= ord('z'):
                res += c
            elif ord('0') <= ord(c) <= ord('9'):
                count = count * 10 + int(c)
            elif c == '[':
                stack.append((res, count))
                res = ''
                count = 0
            elif c == ']':
                ctx_res, ctx_count = stack.pop()
                res = ctx_res + res * ctx_count
        return res
class Solution:
    def decodeString(self, s: str) -> str:
        stk = []
        for ch in s:
            if ch == ']':
                sub = ''
                while stk[-1] != '[':
                    sub = stk.pop() + sub
                stk.pop()
                n = ''
                while stk and stk[-1].isdigit():
                    n = stk.pop() + n
                stk.append(int(n) * sub)
            else:
                stk.append(ch)
        return ''.join(stk)
# Python3简洁代码

# 本题核心思路是在栈里面每次存储两个信息, (左括号前的字符串, 左括号前的数字), 
# 比如abc3[def], 当遇到第一个左括号的时候，压入栈中的是("abc", 3), 
# 然后遍历括号里面的字符串def, 当遇到右括号的时候, 从栈里面弹出一个元素(s1, n1), 
# 得到新的字符串为s1+n1*"def", 也就是abcdefdefdef。对于括号里面嵌套的情况也是同样处理方式。
# 凡是遇到左括号就进行压栈处理，遇到右括号就弹出栈，栈中记录的元素很重要。
### 代码

class Solution:
    def decodeString(self, s: str) -> str:
        stack = []  # (str, int) 记录左括号之前的字符串和左括号外的上一个数字
        num = 0
        res = ""  # 实时记录当前可以提取出来的字符串
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c)
            elif c == "[":
                stack.append((res, num))
                res, num = "", 0
            elif c == "]":
                top = stack.pop()
                res = top[0] + res * top[1]
            else:
                res += c
        return res
```

###  1.188. <a name='LongestSubstringwithAtLeastK'></a>395 Longest Substring with At Least K

[小明](https://www.bilibili.com/video/BV1hD4y1X7rq?spm_id_from=333.999.0.0)

###  1.189. <a name='floydEvaluateDivision'></a>399. 【🍒并查集 + floyd 🌞】Evaluate Division

[花花酱](https://www.bilibili.com/video/BV1iW41167Nb?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1XU4y1s7Lk?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Ko4y1f7eK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1rZ4y1N7CW?spm_id_from=333.999.0.0)

[小旭](https://www.bilibili.com/video/BV1rt411h7oZ?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)


```py
这道题非常好,可以用的图的DFS 和 BFS来做.

首先,我们要把除法运算转化成图表示,比如a->b = 2.0 b->c = 3.0,a,b,c看出节点,相处所的值为权值.那么a/c = ?就是相当于,a->c <==> a->b->c = 2.0*3.0= 6,所以我们要把已知条件建图!

接下来,就是遍历方法,这里有两种方法,

一种是DFS,一种是BFS

这两种方法还是看代码一步一步理解较好!


# DFS
  def calcEquation(self, equations, values, queries):
        """
        :type equations: List[List[str]]
        :type values: List[float]
        :type queries: List[List[str]]
        :rtype: List[float]
        """
        from collections import defaultdict
        graph = defaultdict(set)
        weight = defaultdict()
        lookup = {}
        # 建图
        for idx, equ in enumerate(equations):
            graph[equ[0]].add(equ[1])
            graph[equ[1]].add(equ[0])
            weight[tuple(equ)] = values[idx]
            weight[(equ[1], equ[0])] = float(1 / values[idx])

        # 深度遍历(DFS)
        def dfs(start, end, vistied):
            # 当图中有此边,直接输出
            if (start, end) in weight:
                return weight[(start, end)]
            # 图中没有这个点
            if start not in graph or end not in graph:
                return 0
            # 已经访问过
            if start in vistied:
                return 0
            vistied.add(start)
            res = 0
            for tmp in graph[start]:
                res = (dfs(tmp, end, vistied) * weight[(start, tmp)])
                # 只要遍历到有一个不是0的解就跳出
                if res != 0:
                    # 添加此边,以后访问节省时间
                    weight[(start, end)] = res
                    break
            vistied.remove(start)
            return res

        res = []
        for que in queries:
            # 用集合记录是否已经访问节点
            tmp = dfs(que[0], que[1], set())
            if tmp == 0:
                tmp = -1.0
            res.append(tmp)
        return res
# BFS
    def calcEquation(self, equations, values, queries):
        from collections import defaultdict, deque
        graph = defaultdict(set)
        weight = defaultdict()
        lookup = {}
        # 建图
        for idx, equ in enumerate(equations):
            graph[equ[0]].add(equ[1])
            graph[equ[1]].add(equ[0])
            weight[tuple(equ)] = values[idx]
            weight[(equ[1], equ[0])] = float(1 / values[idx])
        res = []
        for start, end in queries:
            if (start, end) in weight:
                res.append(weight[(start, end)])
                continue
            if start not in graph or end not in graph:
                res.append(-1)
                continue
            if start == end:
                res.append(1.0)
                continue
            stack = deque()
            # 将从start点可以到达下一个节点压入栈内
            for tmp in graph[start]:
                stack.appendleft((tmp, weight[(start, tmp)]))
            # 记录访问节点
            visited = {start}
            # 为了跳出双循环
            flag = False
            while stack:
                c, w = stack.pop()
                if c == end:
                    flag = True
                    res.append(w)
                    break
                visited.add(c)
                for n in graph[c]:
                    if n not in visited:
                        weight[(start, n)] = w * weight[(c, n)]
                        stack.appendleft((n, w * weight[(c, n)]))
            if flag:
                continue
            res.append(-1.0)
        return res
```

```py
带权图上的广度优先搜索

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:

        """BFS
        1.将给定的条件存储成图的带权邻接表。给定a/b=2，存储成a:{b:2}和b:{a:0.5}
        2.给定查询x/y，使用广度优先遍历查询x到y的路径，结果res为路径上的权值乘积
        """
        self.graph = defaultdict(dict)
        def bfs(start, end):
            queue = deque()
            visited = set()
            queue.append([start, 1])
            visited.add(start)
            while queue:
                cur, weight = queue.pop()
                if cur == end:
                    return weight
                for key, val in self.graph[cur].items():
                    if key not in visited:
                        visited.add(key)
                        queue.append([key, val * weight])
            return -1
        for nodes, val in zip(equations, values):
            self.graph[nodes[0]][nodes[1]] = val
            self.graph[nodes[1]][nodes[0]] = 1 / val
        res = []
        for node1, node2 in queries:
            if node1 not in self.graph or node2 not in self.graph:
                res.append(-1)
            else:
                res.append(bfs(node1, node2))
        return res
```

```py
基于字典的Floyd算法，执行时间击败了98%

from collections import defaultdict

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        edges = defaultdict(dict)
        verts = set()

        for (a, b), c in zip(equations, values):
            verts.add(a)
            verts.add(b)

            edges[a][b] = c
            edges[b][a] = 1 / c

        for k in verts:
            ek = edges[k]
            for i in verts:
                if i == k:
                    continue

                ei = edges[i]
                for j in verts:
                    if k == j or i == j or j in ei:
                        continue
                
                    if k in ei and j in ek:
                        ei[j] = ei[k] * ek[j]

        rst = []
        for a, b in queries:
            if a in edges and b in edges[a]:
                rst.append(edges[a][b])
            elif a == b and a in verts and b in verts:
                rst.append(1)
            else:
                rst.append(-1)

        return rst
```

###  1.190. <a name='RemoveKDigits'></a>402 Remove K Digits

[小明](https://www.bilibili.com/video/BV1PV411C79X?spm_id_from=333.999.0.0)

###  1.191. <a name='SumofLeftLeaves'></a>404. Sum of Left Leaves

[小梦想家](https://www.bilibili.com/video/BV1Et411K7wa?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15a4y1779U?spm_id_from=333.999.0.0)

```py
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        isLeafNode = lambda node: not node.left and not node.right

        def dfs(node: TreeNode) -> int:
            ans = 0
            if node.left:
                ans += node.left.val if isLeafNode(node.left) else dfs(node.left)
            if node.right and not isLeafNode(node.right):
                ans += dfs(node.right)
            return ans
        
        return dfs(root) if root else 0

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sum-of-left-leaves/solution/zuo-xie-zi-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        isLeafNode = lambda node: not node.left and not node.right
        q = collections.deque([root])
        ans = 0

        while q:
            node = q.popleft()
            if node.left:
                if isLeafNode(node.left):
                    ans += node.left.val
                else:
                    q.append(node.left)
            if node.right:
                if not isLeafNode(node.right):
                    q.append(node.right)
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sum-of-left-leaves/solution/zuo-xie-zi-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if root==None:
            return 0
        if root.left and root.left.left==None and root.left.right==None:
            return root.left.val+self.sumOfLeftLeaves(root.right)
        else:
            return self.sumOfLeftLeaves(root.left)+self.sumOfLeftLeaves(root.right)

root.left 为null时，再调用self.sumOfLeftLeaves(root.left)是不是没有必要，虽然它返回0？

最后一个else不仅包括root.left为空的情况，还包括了有左子树但是左子树不是一个叶子的情况，所以那部分还是不能省掉吧。

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        self.res=0
        def dfs(root):
            if root.left:
                if not root.left.left and not root.left.right:
                    self.res+=root.left.val
                dfs(root.left)
            if root.right:
                dfs(root.right)
            return self.res
        return dfs(root)

dfs

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        def dfs(root, is_left):
            if not root: return 0
            if not root.left and not root.right and is_left: #leaf
                return root.val
            return dfs(root.left, 1) + dfs(root.right, 0)
        return dfs(root, 0)
bfs

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root: return 0
        Q,res = list(), 0
        Q.append((root,0))
        while len(Q)>0:
            node, is_left = Q.pop(0)
            if node.left:
                Q.append((node.left, 1))
            if node.right:
                Q.append((node.right, 0))
            if not node.left and not node.right and is_left:
                res+=node.val
        return res
```

###  1.192. <a name='ConvertaNumbertoHexadecimal'></a>405 【位运算😜】Convert a Number to Hexadecimal

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7ds?spm_id_from=333.999.0.0)

```py
三种方法

1.第一种库函数(汉明重量的题目也可以使用库函数)
2.第二种不用位运算😜，整除求余一顿操作，逆向取余，搞定
3.第三种使用位运算😜，把第二中的整除换做位移，求余换做与运算
详细思路看代码
代码

# 库函数作弊通过
class Solution:
    def toHex(self, num: int) -> str:
        return hex(num & 0xFFFFFFFF)[2:] # 0xFFFFFFFF 2 ^ 32 - 1
```

```py
学习大牛的思路，记下来慢慢
32位整数，每4位1个字节，一个字节转成16进制刚好是0—f之间的一个字符；最多需要转换8次，可能有几个“0”，最后去掉就是了。

直接 ans = []
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0:
            return "0"
        template = "0123456789abcdef"
        ans = []
        for _ in range(8):
            ans.append(template[num % 16])
            num //= 16
        ans.reverse()
        return "".join(ans).lstrip("0")

直接 result = ""

class Solution(object):
    def toHex(self, num):

        num = num & 0xffffffff
        result = ""
        lib = "0123456789abcdef"
        if num == 0:
            return "0"
        while num:
            result = lib[num % 16] + result # 一定要加在右边
            num //= 16

        return result

format的用法很多，值得深入学习

print((1 << 32) + (-32))
print(bin((1 << 32) + (-32)))
print(format(((1 << 32) + (-32)), '0o'))
print(format(((1 << 32) + (-32)), '0x'))
4294967264
0b11111111111111111111111111100000
37777777740
ffffffe0

class Solution:
    def toHex(self, num):

        if num < 0:
            num = (1 << 32) + num
        return format(num, '0x')
```

###  1.193. <a name='QueueReconstructionbyHeight'></a>406. Queue Reconstruction by Height 

[小明](https://www.bilibili.com/video/BV1xC4y1a72W?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV144411R7ch?spm_id_from=333.999.0.0)

```py
# 代码很简单，思路还不太好想

class Solution(object):
    def reconstructQueue(self, people):
        people = sorted(people, key=lambda x: (-x[0], x[1]))
        result = []
        for each in people:
            result.insert(each[1], each)
        return result

class Solution:
    def reconstructQueue(self, people):
        q = []
        for item in sorted(people, key=lambda x: (-x[0], x[1])):
            q.insert(item[1], item)
        return q

class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x:(-x[0], x[1]))
        res = []
        for p in people:
            res.insert(p[1], p)
        return res

class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x: (-x[0], x[1]))
        n = len(people)
        ans = list()
        for person in people:
            ans[person[1]:person[1]] = [person]
        return ans
```

###  1.194. <a name='ValidWordAbbreviation'></a>408. Valid Word Abbreviation

[小梦想家](https://www.bilibili.com/video/BV1A4411q74A?spm_id_from=333.999.0.0)

###  1.195. <a name='LongestPalindrome'></a>409. 【回文🌈】Longest Palindrome

[小梦想家](https://www.bilibili.com/video/BV1B441127W2?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV19C4y1479a?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Lk4y1z7PG?spm_id_from=333.999.0.0)

```py
class Solution:
    def longestPalindrome(self, s: str) -> int:
        ans = 0
        count = collections.Counter(s)
        for v in count.values():
            ans += v // 2 * 2
            if ans % 2 == 0 and v % 2 == 1:
                ans += 1
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-palindrome/solution/zui-chang-hui-wen-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
找出出现次数为偶数的求和，再找出所有奇数减一求和。因为奇数是可以拆成偶数使用的

class Solution:
    def longestPalindrome(self, s: str) -> int:
        dic = {}
        for i in s:
            if i not in dic:
                dic[i] = 0
            dic[i] += 1
        nums1 = []; nums2 = []
        for i in dic.values():
            if i%2 == 0: nums1.append(i)
            else: nums2.append(i - 1)
        a = sum(nums1) if nums1 != [] else 0
        b = sum(nums2) + 1 if nums2 != [] else 0
        return a + b

扣友们好，扣友们再见

class Solution:
    def longestPalindrome(self, s: str) -> int:
        flag = False
        res = 0
        for i in Counter(s).values():
            res += i//2*2
            if i % 2 != 0:
                flag = True       
        return res+1 if flag else res


python代码贴一下，速度打败75%，内存打败92%

class Solution:
    def longestPalindrome(self, s: str) -> int:
        cnt = [0] * 58 # 大写和小写字母之间隔了6个ASCII码
        for i in s:
            cnt[ord(i)-ord('A')] += 1
        ans = 0
        for j in cnt:
            ans += (j // 2) * 2
        return ans + int(ans < len(s)) # 如果ans比原字符串短，就说明可以拿一个字符做中心


直接统计s，最后按照字符数除以2向下取整乘以2，如果某一个字符出现奇数次，组合的回文🌈数加1；


class Solution:
    def longestPalindrome(self, s: str) -> int:
        from collections import Counter
        counter_s = Counter(s)
        ans = 0
        c = 0
        for key, value in counter_s.items():
            if value >= 2:
                ans += value // 2 * 2
            if value % 2 == 1:
                c = 1
        return ans + c
```



###  1.196. <a name='SplitArrayLargestSum'></a>410. Split Array Largest Sum

[花花酱](https://www.bilibili.com/video/BV14W411d7D4?spm_id_from=333.999.0.0)

###  1.197. <a name='FizzBuzz'></a>412. Fizz Buzz

[小梦想家](https://www.bilibili.com/video/BV1xE411R7yK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1tD4y1m76j?spm_id_from=333.999.0.0)

```py
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        ans = []
        for i in range(1, n + 1):
            s = ""
            if i % 3 == 0:
                s += "Fizz"
            if i % 5 == 0:
                s += "Buzz"
            if s == "":
                s = str(i)
            ans.append(s)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/fizz-buzz/solution/fizz-buzz-by-leetcode-solution-s0s5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python 3.10的解法 可惜目前不支持

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        res = []
        for i in range(1, n+1):
            match (i % 3 == 0), (i % 5 == 0):
                case True, True: res.append("Fizzbuzz")
                case True, _: res.append("Fizz")
                case _, True: res.append("Buzz")
                case _: res.append(i)
        return res
```

```py
一行流

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        return ['Fizz'*(not i%3)+'Buzz'*(not i%5) or str(i) for i in range(1,n+1)]

一行python完事

class Solution(object):
    def fizzBuzz(self, n):
        return ["FizzBuzz" if i % 15 == 0 else "Fizz" if i % 3 == 0 else "Buzz" if i % 5 == 0 else str(i) for i in range(1, n + 1)]
```

```scala
object Solution {
    def fizzBuzz(n: Int): List[String] = {
        (1 to n).map(num => {
            if(num%15 == 0)
                "FizzBuzz"
            else if(num%5 == 0)
                "Buzz"
            else if(num%3 == 0)
                "Fizz"
            else
                num.toString
        }).toList
    }
}

```

###  1.198. <a name='-1'></a>413-【动态🚀规划】等差数列划分

[哈哈哈](https://www.bilibili.com/video/BV13a4y1i7tR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV13f4y167YZ?spm_id_from=333.999.0.0)

```py
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        tmp = []
        for i in range(1,len(nums)):
            tmp.append(nums[i]-nums[i-1])
        
        dp = [0] * len(tmp)
        for i in range(1,len(tmp)):
            if tmp[i] == tmp[i-1]:
                dp[i] = 1 + dp[i-1]
        return sum(dp)

其他写法：

class Solution:
    def numberOfArithmeticSlices(self, nums):
        n = len(nums)
        dp = [0]*n
        for i in range(2,n):
            dp[i] = dp[i-1]+1 if nums[i]-nums[i-1]==nums[i-1]-nums[i-2] else 0
        return sum(dp)
```

###  1.199. <a name='ThirdMaximumNumber'></a>414. Third Maximum Number

[小梦想家](https://www.bilibili.com/video/BV1UE411X7k1?spm_id_from=333.999.0.0)

###  1.200. <a name='AddStrings'></a>415-Add Strings

[哈哈哈](https://www.bilibili.com/video/BV18E411n7Cy?spm_id_from=333.999.0.0)

###  1.201. <a name='dfsstartIforPartitionEqualSubsetSum'></a>416. 【动态🚀规划 + 背包 + dfs(startI)无for循环】Partition Equal Subset Sum

####  1.201.1. <a name='494'></a>相似题目：494题

[花花酱](https://www.bilibili.com/video/BV1AW411y7So?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DD4y1X7Cp?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1oZ4y1G7QY?spm_id_from=333.999.0.0)

“动态🚀规划” 的解法

```py
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 2:
            return False
        
        total = sum(nums)
        if total % 2 != 0:
            return False
        
        target = total // 2
        dp = [True] + [False] * target
        for i, num in enumerate(nums):
            for j in range(target, num - 1, -1):
                dp[j] |= dp[j - num]
                # dp[j] = dp[j] or dp[j-num]
        
        return dp[target]

根据494题修改的动态规划：

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        n = len(nums)
        # 求得新的目标
        sums = sum(nums)
        # 注意，需要排除掉一些特殊状况
        if sums % 2 == 1: return False
        bagSize = sums // 2
        # 构建dp，numLen在外围
        dp = [0] * (bagSize+1)
        # 赋值，dp的第一个元素
        dp[0] = 1
        for num in nums:
            for j in range(bagSize,num-1,-1):
                dp[j] += dp[j-num] # 对于没有当前num时的case + 有了num时bagSize-num的cas
        # 含义就是：
        # 对于1个num，bagsize的填满情况
        # 对弈2个num，bagsize的填满情况
        return dp[-1] != 0
```

```py
# python递归...

class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        # @lru_cache(None)
        def dp(i,N):                                #dp(i,N)返回nums[0...i]中且当前和为N的状态下，能否凑成和为target的结果
            if N>target or i<0:return False
            if N==target: return True
            # 这个很巧妙每次可以选择将nums[i]加进N，或者不将nums[i]加进N
            return dp(i-1, N+nums[i]) or dp(i-1,N)   

        if sum(nums)%2 != 0: return False              #目标和为奇数时不能分割成两个元素相等的子集
        target = sum(nums) // 2                         #原问题等价于将nums划分为元素和为nums一半的两个子集的划分方式是否存在
        return dp(len(nums)-1, 0)
```



###  1.202. <a name='PacificAtlanticWaterFlow'></a>417. 【构造🏰】Pacific Atlantic Water Flow

[花花酱](https://www.bilibili.com/video/BV1Kb411K7ty?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1by4y1h7ab?spm_id_from=333.999.0.0)

```py
class Solution:
    def bfs(self, heights: List[List[int]], src: List[List[int]], cnt: List[List[int]]) -> None:
        direction = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        m, n = len(heights), len(heights[0])
        visited = [[False] * n for _ in range(m)]
        from collections import deque
        q = deque(src)
        while q:
            x, y = q.popleft()
            for i, j in direction:
                row, col = x + i, y + j
                if 0 <= row < m and 0 <= col < n and not visited[row][col] and \
                    (x in (-1, m) or y in (-1, n) or heights[row][col] >= heights[x][y]):
                    visited[row][col] = True
                    cnt[row][col] += 1
                    q.append((row, col))
    
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        cnt = [[0] * n for _ in range(m)]
        # 1. 从太平洋逆流而上
        self.bfs(heights, [(-1, col) for col in range(n)] + [(row, -1) for row in range(m)], cnt)

        # 2. 从大西洋逆流而上
        self.bfs(heights, [(m, col) for col in range(n)] + [(row, n) for row in range(m)], cnt)
        # 3. 筛选出 cnt[row][col] = 2 的坐标
        return [[row, col] for row in range(m) for col in range(n) if cnt[row][col] == 2]
```

```py
Python 版本逆流而上

class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        res = []
        if not matrix or len(matrix) == 0:
            return res

        directions = [[0,1], [0,-1], [1, 0], [-1,0]]

        m = len(matrix)
        n = len(matrix[0])

        canP = [[0] * n for _ in range(m)]
        canA = [[0] * n for _ in range(m)]

        def dfs(row, col, ocean):
            if not ocean[row][col]:
                ocean[row][col] = 1
                for direction in directions:
                    x = row + direction[0]
                    y = col + direction[1]
                    if x >= m or x < 0  or y >= n or y < 0 or matrix[x][y] < matrix[row][col]:
                        continue
                    dfs(x, y, ocean)

        for i in range(m):
            dfs(i, 0, canP)
            dfs(i, n-1, canA)

        for j in range(n):
            dfs(0, j, canP)
            dfs(m-1, j, canA)

        for i in range(m):
            for j in range(n):
                if canA[i][j] and canP[i][j]:
                    res.append([i,j])
        return res

python 简洁解法

class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        m, n = len(heights), len(heights[0])
        A, B = set(), set()
        def dfs(i, j, vis):
            vis.add((i, j))
            for ni, nj in ((i+1, j), (i-1, j), (i, j-1), (i, j+1)):
                if -1<ni<m and -1<nj<n and heights[ni][nj]>=heights[i][j]\
                    and (ni, nj) not in vis:
                    dfs(ni, nj, vis)
        
        for i in range(m): dfs(i, 0, A);dfs(i, n-1, B)
        for j in range(n): dfs(0, j, A);dfs(m-1, j, B)
        return [list(i) for i in A&B]

python 多源 bfs

从第一行和第一列开始遍历非递减格子，即可得到所有能流到“太平洋”的格子。 同理从最后一行和最后一列遍历，得到所有能流到“太西洋”的格子，求交集即可。

class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        def bfs(A):
            queue, vis = deque(A), set(A)
            while queue:
                i, j = queue.popleft()
                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                    if 0<=x<m and 0<=y<n and (x, y) not in vis and heights[x][y]>=heights[i][j]:
                        queue.append((x, y))
                        vis.add((x, y))
            return vis

        m, n = len(heights), len(heights[0])
        A = {(0, j) for j in range(n)} | {(i, 0) for i in range(m)}
        B = {(m-1, j) for j in range(n)} | {(i, n-1) for i in range(m)}
        return [[i, j] for i, j in bfs(A) & bfs(B)]
```

###  1.203. <a name='BattleshipsinaBoard'></a>419. Battleships in a Board 

[小梦想家](https://www.bilibili.com/video/BV1TJ411j7QZ?spm_id_from=333.999.0.0)

###  1.204. <a name='MaximumXORofTwoNumbersinanArray'></a>421 Maximum XOR of Two Numbers in an Array

[小明](https://www.bilibili.com/video/BV1s64y1F7Wm?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMaximumXOR(self, nums):
        # 最高位的二进制位编号为 30
        HIGH_BIT = 30

        x = 0
        for k in range(HIGH_BIT, -1, -1):
            seen = set()
            # 将所有的 pre^k(a_j) 放入哈希表中
            for num in nums:
                # 如果只想保留从最高位开始到第 k 个二进制位为止的部分
                # 只需将其右移 k 位
                seen.add(num >> k)

            # 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分
            # 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1
            x_next = x * 2 + 1
            found = False
            
            # 枚举 i
            for num in nums:
                if x_next ^ (num >> k) in seen:
                    found = True
                    break

            if found:
                x = x_next
            else:
                # 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0
                # 即为 x = x*2
                x = x_next - 1
        
        return x

class Solution(object):
    def findMaximumXOR(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        answer = 0
        for i in range(32)[::-1]:
            answer <<= 1
            prefixes = {num >> i for num in nums}
            answer += any(answer^1 ^ p in prefixes for p in prefixes)
        return answer
```

###  1.205. <a name='ReconstructOriginalDigitsfromEnglish'></a>423 Reconstruct Original Digits from English

[小明](https://www.bilibili.com/video/BV1554y1h73S?spm_id_from=333.999.0.0)

###  1.206. <a name='LongestRepeatingCharacterReplacem'></a>424. 替换后的最长重复字符 Longest Repeating Character Replacem

[官方](https://www.bilibili.com/video/BV14r4y1K7rN?spm_id_from=333.999.0.0)

### 426【剑指36】. 将二叉搜索树转化为排序的双向链表【字节跳动】-
将一个 二叉搜索树 就地转化为一个 已排序的双向循环链表 。

对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

特别地，我们希望可以 就地 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

![](https://s3.bmp.ovh/imgs/2022/01/11d8ac60b4c3deb6.png)

```py
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return
        path = []
        def inorder(root):
            if not root: return 
            inorder(root.left)
            path.append(root)
            inorder(root.right)    
        inorder(root)
        for i in range(len(path)):
            path[i].left = path[i-1]
            path[i].right = path[(i+1)%len(path)]
        return path[0]
        
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        a, f = [], lambda r: r and (f(r.left) or a.append(r) or f(r.right))
        f(root)
        n = len(a)
        for i, r in enumerate(a):
            r.left, r.right = a[i - 1], a[i + 1 - n]
        return n and a[0] or None

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        def dfs(cur):
            if not cur: return
            dfs(cur.left) # 递归左子树
            if self.pre: # 修改节点引用
                self.pre.right, cur.left = cur, self.pre
            else: # 记录头节点
                self.head = cur
            self.pre = cur # 保存 cur
            dfs(cur.right) # 递归右子树
        
        if not root: return
        self.pre = None
        dfs(root)
        self.head.left, self.pre.right = self.pre, self.head
        return self.head

作者：jyd
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 思路:

其实就是左右节点指向改变，右节点指向下一个比它大的数，左节点指向比它小的数。又是二叉搜索树，自然想到中序遍历。

思路一：中序遍历（非递归和递归）

写法一：用栈(非递归)

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:return 
        # 当一个中间节点
        head = Node(-1, None, None)
        # 记录为先前节点,找到下一个节点才能串起来
        prev = head
        # 中序遍历的非递归
        stack = []
        p = root
        while p or stack:
            while p:
                stack.append(p)
                p = p.left
            p = stack.pop()
            # 改变左右方向
            prev.right = p
            p.left = prev
            # 改变先前节点
            prev = p
            p = p.right
        # 将head 删掉   
        head.right.left = prev
        prev.right = head.right
        return head.right
写法二：递归

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:return 
        # 当一个中间节点
        head = Node(-1, None, None)
        # 记录为先前节点,找到下一个节点才能串起来
        prev = head

        # 中序遍历的递归
        def inorder(root):
            nonlocal prev
            if not root:
                return 
            inorder(root.left)
            prev.right = root
            root.left = prev
            prev = prev.right
            inorder(root.right)
        
        inorder(root)
        # 将head 删掉   
        head.right.left = prev
        prev.right = head.right
        return head.right
思路二：分治

"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root: return
        left = self.treeToDoublyList(root.left)
        right = self.treeToDoublyList(root.right)
        root.left = root
        root.right = root
        return self.connect(self.connect(left, root), right)

    def connect(self, node1, node2):
        if not (node1 and node2):
            return node1 or node2
        tail1, tail2 = node1.left, node2.left
        tail1.right = node2
        node2.left = tail1
        tail2.right = node1
        node1.left = tail2
        return node1
```

```py
"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def myinorderTraversal(self, root: 'Node') -> 'Node':
        ''' traversal order:  right subtree -> root -> left subtree '''

        # conrer case
        if not root: return None

        sentinel = Node()    # 虚拟哨兵尾节点
        successor = sentinel # 后驱指针

        def inorder(r = root):
            nonlocal successor
            if not r: return
        
            inorder(r.right)
            # 不建议初学这么写
            r.right, successor.left, successor = successor, r, r
            inorder(r.left)

        inorder()
        successor.left = sentinel.left
        sentinel.left.right = successor
        return successor

    def inorderTraversal(self, root: 'Node') -> 'Node':
        ''' traversal order:  left subtree -> root -> right subtree '''

        # conrer case
        if not root: return None

        sentinel = Node()      # 虚拟哨兵头节点
        predecessor = sentinel # 前驱指针

        def inorder(r = root):
            nonlocal predecessor
            if not r: return
        
            inorder(r.left)
            # 不建议初学这么写
            predecessor.right, r.left, predecessor = r, predecessor, r
            inorder(r.right)

        inorder()
        sentinel.right.left = predecessor
        predecessor.right = sentinel.right
        return sentinel.right


    treeToDoublyList = myinorderTraversal
    # treeToDoublyList = inorderTraversal
```

```py
辅助栈

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        if not root:
            return root
        # 辅助栈        
        helper, start = [], None
        current, pre = root, None
        while len(helper) != 0 or current != None:
            if current != None:
                helper.append(current)
                current = current.left
            else:
                current = helper.pop()
                if pre != None:
                    current.left = pre
                    pre.right = current
                else:
                    start = current
                pre = current
                current = current.right
        start.left = pre
        pre.right = start
        return start

迭代

class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        # left : pre right: nex
        dummy = Node(None)
        p = dummy
        if not root:
            return root
        stack = [[root, False]]
        while stack:
            node, visited = stack.pop()
            if not visited:
                if node.right:
                    stack.append([node.right, False])
                stack.append([node, True])
                if node.left:
                    stack.append([node.left, False])
            else:
                node.left = p
                node.right = None
                p.right = node
                p = p.right
        head = dummy.right
        head.left = p
        p.right = head
        return head

def treeToDoublyList(self, root: 'Node') -> 'Node':
        pre = None
        head = None
        def inorder(root):
            nonlocal pre
            nonlocal head
            if not root:
                return 

            inorder(root.left)
            if pre:
                pre.right, root.left = root, pre
            else:
                head = root #第一个节点,bst最小的节点
            pre = root
            inorder(root.right)

        if not root:
            return
        inorder(root)
        pre.right, head.left = head, pre
        return head
```

###  1.207. <a name='N-aryTreeLevelOrderTraversal'></a>429. N-ary Tree Level Order Traversal

[小梦想家](https://www.bilibili.com/video/BV1CE411Q7BQ?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Uv411K77M?spm_id_from=333.999.0.0)

```py
def levelOrder(self, root: 'Node') -> List[List[int]]:
    if root is None:
        return []
    result = []
    queue = collections.deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            queue.extend(node.children)
        result.append(level)
    return result

作者：LeetCode
链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def levelOrder(self, root: 'Node') -> List[List[int]]:
    if root is None:
        return []        

    result = []
    previous_layer = [root]

    while previous_layer:
        current_layer = []
        result.append([])
        for node in previous_layer:
            result[-1].append(node.val)
            current_layer.extend(node.children)
        previous_layer = current_layer
    return result

作者：LeetCode
链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def levelOrder(self, root: 'Node') -> List[List[int]]:

    def traverse_node(node, level):
        if len(result) == level:
            result.append([])
        result[level].append(node.val)
        for child in node.children:
            traverse_node(child, level + 1)

    result = []

    if root is not None:
        traverse_node(root, 0)
    return result

作者：LeetCode
链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
Python版

思路一：DFS

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:

        res = []

        def dfs(root, depth):
            if not root: return 
            if len(res) <= depth:
                res.append([])
            res[depth].append(root.val)
            for ch in root.children:
                dfs(ch, depth+1)
        
        dfs(root, 0)
        return res
思路二：BFS

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:return []
        res = []
        
        def bfs(root):
            queue = [root]
            while queue:
                nxt = []
                tmp = []
                for node in queue:
                    tmp.append(node.val)
                    for ch in node.children:
                        nxt.append(ch)
                res.append(tmp)
                queue = nxt
        
        bfs(root)
        return res
```

###  1.208. <a name='FlattenaMultilevelDoublyLinkedList'></a>430 Flatten a Multilevel Doubly Linked List

[小明](https://www.bilibili.com/video/BV1754y1q7Kb?spm_id_from=333.999.0.0)

###  1.209. <a name='AllOoneDataStructure'></a>432. All O`one Data Structure

[花花酱](https://www.bilibili.com/video/BV1XW411d7qR?spm_id_from=333.999.0.0)

###  1.210. <a name='Non-overlappingIntervals'></a>435-Non-overlapping Intervals

[哈哈哈](https://www.bilibili.com/video/BV1i7411p7pv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ak4y1U7f8?spm_id_from=333.999.0.0)

```py
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0:
            return 0
        intervals.sort(key = lambda x:x[1])
        res = 0
        current = intervals[0][1]
        for i in intervals[1:]:
            if i[0] >= current:
                current = i[1]
            else:
                current = min(i[1], current)
                res += 1
        return res

# 最难想通的其实是根据哪个边界排序，看了题解里大佬的理解，

# 想象成参加活动，影响你参加更多活动的是活动的结束时间，

# 只有上一个活动结束了，才能参加下一个，

# 即上一个活动的结束时间要小于下一个活动的开始时间。


class Solution(object):
    def eraseOverlapIntervals(self, intervals):
  
        if not intervals:
            return 0
        intervals.sort(key=lambda x:x[1])
        l=len(intervals)
        count=1
        end=intervals[0][1]
        for i in range(1,l):
            if intervals[i][0]>=end:
                count+=1
                end=intervals[i][1]
        return l-count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0: return 0
        intervals.sort(key=lambda x: x[1])
        count = 1 # 记录非交叉区间的个数
        end = intervals[0][1] # 记录区间分割点
        for i in range(1, len(intervals)):
            if end <= intervals[i][0]:
                count += 1
                end = intervals[i][1]
        return len(intervals) - count

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort(key=lambda x: x[1])
        n = len(intervals)
        right = intervals[0][1]
        ans = 1

        for i in range(1, n):
            if intervals[i][0] >= right:
                ans += 1
                right = intervals[i][1]
        
        return n - ans

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        intervals.sort()
        n = len(intervals)
        f = [1]

        for i in range(1, n):
            f.append(max((f[j] for j in range(i) if intervals[j][1] <= intervals[i][0]), default=0) + 1)

        return n - max(f)
```


###  1.211. <a name='FindRightInterval'></a>436 Find Right Interval

[小明](https://www.bilibili.com/video/BV1YT4y1w7EP?spm_id_from=333.999.0.0)

###  1.212. <a name='PathSumIII'></a>437 【前缀和🎨】Path Sum III

[小明](https://www.bilibili.com/video/BV1tZ4y1M7JR?spm_id_from=333.999.0.0)

时间复杂度 O(n), 空间复杂度 O(n)

```py
def pathSum(self, root, sum):
    
    self.dicts = {0: 1}
    self.res = 0
    def helper(root, prefix_sum, sum):
        if not root:
            return 0
            
        prefix_sum += root.val
        
        if prefix_sum - sum in self.dicts:
            self.res += self.dicts[prefix_sum - sum]
            
        
        self.dicts[prefix_sum] = self.dicts.get(prefix_sum, 0) + 1
        
        helper(root.left, prefix_sum, sum)
        
        helper(root.right, prefix_sum, sum)
        
        # Note: 回到上一层时, 需要将当前的前缀和对应的路径数目减1      
        self.dicts[prefix_sum] -= 1
    
    helper(root, 0, sum)
    return res    
```

###  1.213. <a name='FindAllAnagramsinaString'></a>438. 【滑动窗口🔹】Find All Anagrams in a String

#### 类似567

[花花酱](https://www.bilibili.com/video/BV1iW411d7Nb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1254y1X7HV?spm_id_from=333.999.0.0)

```py
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        tarDIC = collections.Counter(p)
        ns = len(s)
        np = len(p)
        res = []
        for i in range(len(s)-len(p)+1):
            if collections.Counter(s[i:i+np]) == tarDIC:
                res.append(i)
        return res
```

```py
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        tarDIC = sorted(p)
        ns = len(s)
        np = len(p)
        res = []
        for i in range(len(s)-len(p)+1):
            if sorted(s[i:i+np]) == tarDIC:
                res.append(i)
        return res
```

```scala
/**
* chosen solution
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/
object Solution0 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }
    ret.toList
  }
}

/**
* my first commit
* sliding window + hashMap within windows
* time complexity: O(NM): N: s.length, M: p.length
*/

object Solution1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap

     s.sliding(p.length).zipWithIndex.filter{ case (c, _) => pMap == c.groupBy(identity).mapValues(_.length).toMap}.map(_._2).toList
  }
}


/**
* sliding window - two pointer template version
* two index to indicate range: left and right
* time complexity: O(N)
* space timeComplexity: O(N) : one hashMap
*/

object Solution2 {
  import scala.collection.mutable
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = mutable.Map.empty ++ p.groupBy(identity).mapValues(_.length).toMap
    val ret = scala.collection.mutable.ListBuffer[Int]()
    var left = 0
    var counter = pMap.size

    for(right <- s.indices) {  // right index

      pMap.get(s(right)) match {
        case Some(e) if e >= 1 =>  // e >=1 means the char exits in p
          pMap.update(s(right),  e - 1)
          counter -= 1  // match a char
        case Some(e) =>  // e <= 0 meas there would be duplicate char in s but p isn't
          pMap.update(s(right),  e - 1)
        case None =>
      }
      while(counter == 0) {
        if((right - left + 1) == p.length) ret += left
        pMap.get(leftChar) match {
            case Some(v) =>
                pMap.update(leftChar, v + 1)
                if(v == 0) counter += 1
            case None =>
        }
        left += 1
      }
    }

    ret.toList
  }
}

/**
* sliding window - two hashmap version
* using a mutable map storing current window's string element and amount
* time complexity: O(N)
* space complexity: O(2N) -> two hashMap
*/

object Solution2-1 {
  def findAnagrams(s: String, p: String): List[Int] = {
    val pMap = p.groupBy(identity).mapValues(_.length).toMap
    val sMap = scala.collection.mutable.Map[Char, Int]()
    val result = scala.collection.mutable.ListBuffer[Int]()

    for((char, right) <- s.zipWithIndex) {
      sMap.put(char, sMap.getOrElse(char, 0) + 1)

      if(right >= p.length) {
        val leftChar = s(right - p.length)
        sMap.get(leftChar) match {
          case Some(e) if e == 1 => sMap.remove(leftChar)
          case Some(e) => sMap.update(leftChar, e - 1)
          case _ =>
        }
      }
      if(pMap.equals(sMap)) result += (right - p.length + 1)
    }
    result.toList
  }
}

```

###  1.214. <a name='ArrangingCoins'></a>441 Arranging Coins

[小明](https://www.bilibili.com/video/BV1eV411k7rg?spm_id_from=333.999.0.0)

###  1.215. <a name='FindAllDuplicatesinanArray'></a>442 Find All Duplicates in an Array

[小明](https://www.bilibili.com/video/BV1Lh411d7AD?spm_id_from=333.999.0.0)

###  1.216. <a name='StringCompression'></a>443. String Compression

[小梦想家](https://www.bilibili.com/video/BV1rE411f7Ld?spm_id_from=333.999.0.0)

###  1.217. <a name='AddTwoNumbersII'></a>445-Add Two Numbers II

[哈哈哈](https://www.bilibili.com/video/BV1Qj411f7Qz?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Pt4y1m78o?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV17a4y1s7BG?spm_id_from=333.999.0.0)

```py
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        s1, s2 = [], []
        while l1:
            s1.append(l1.val)
            l1 = l1.next
        while l2:
            s2.append(l2.val)
            l2 = l2.next
        ans = None
        carry = 0
        while s1 or s2 or carry != 0:
            a = 0 if not s1 else s1.pop()
            b = 0 if not s2 else s2.pop()
            cur = a + b + carry
            carry = cur // 10
            cur %= 10
            curnode = ListNode(cur)
            curnode.next = ans
            ans = curnode
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/add-two-numbers-ii/solution/liang-shu-xiang-jia-ii-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

反正都是要遍历，直接遍历转成string取出来，相加完了再构造成链表即可。一遍过，代码很简洁。

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        num1, num2 = "", ""
        while l1:
            num1 += str(l1.val)
            l1 = l1.next
        while l2:
            num2 += str(l2.val)
            l2 = l2.next
        resNum = str(int(num1) + int(num2))
        root = ListNode(0)
        p = root
        for digit in resNum:
            p.next = ListNode(int(digit))
            p = p.next
        return root.next
```

```py
python不怕溢出

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        def f(node):
            num=0
            while node:
                num=num*10+node.val
                node=node.next
            return num
        class Node(ListNode):
            def __init__(self,y,x):
                super().__init__(x)
                self.next=y
        return functools.reduce(Node,map(int,reversed(str(f(l1)+f(l2)))),None)
```

###  1.218. <a name='NumberofBoomerangs'></a>447. Number of Boomerangs

[小梦想家](https://www.bilibili.com/video/BV1hE411o7V2?spm_id_from=333.999.0.0)

###  1.219. <a name='FindAllNumbersDisappearedinanArray'></a>448. Find All Numbers Disappeared in an Array

[小梦想家](https://www.bilibili.com/video/BV1SE411d7FM?spm_id_from=333.999.0.0)

###  1.220. <a name='SerializeandDeserializeBST'></a>449. Serialize and Deserialize BST

[花花酱](https://www.bilibili.com/video/BV1ab411c75V?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Ty4y1r7FT?spm_id_from=333.999.0.0)

```py
class Codec:
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return ' '.join(map(str, postorder(root)))

    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [int(x) for x in data.split(' ') if x]
        return helper()

作者：LeetCode
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Codec:
    def postorder(self, root):
        return self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else []
        
    def int_to_str(self, x):
        """
        Encodes integer to bytes string.
        """
        bytes = [chr(x >> (i * 8) & 0xff) for i in range(4)]
        bytes.reverse()
        bytes_str = ''.join(bytes)
        return bytes_str
        
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        lst = self.postorder(root)
        lst = [self.int_to_str(x) for x in lst]
        return 'ç'.join(map(str, lst))
    
    def str_to_int(self, bytes_str):
        """
        Decodes bytes string to integer.
        """
        result = 0
        for ch in bytes_str:
            result = result * 256 + ord(ch)
        return result
        
    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        data = [self.str_to_int(x) for x in data.split('ç') if x]
        return helper() 

作者：LeetCode
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Codec:
    def postorder(self, root):
        return self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else []
        
    def int_to_str(self, x):
        """
        Encodes integer to bytes string
        """
        bytes = [chr(x >> (i * 8) & 0xff) for i in range(4)]
        bytes.reverse()
        bytes_str = ''.join(bytes)
        return bytes_str
        
    def serialize(self, root):
        """
        Encodes a tree to a single string.
        """
        lst = [self.int_to_str(x) for x in self.postorder(root)]
        return ''.join(map(str, lst))
    
    def str_to_int(self, bytes_str):
        """
        Decodes bytes string to integer.
        """
        result = 0
        for ch in bytes_str:
            result = result * 256 + ord(ch)
        return result
        
    def deserialize(self, data):
        """
        Decodes your encoded data to tree.
        """
        def helper(lower = float('-inf'), upper = float('inf')):
            if not data or data[-1] < lower or data[-1] > upper:
                return None
            
            val = data.pop()
            root = TreeNode(val)
            root.right = helper(val, upper)
            root.left = helper(lower, val)
            return root
        
        n = len(data)
        # split data string into chunks of 4 bytes
        # and convert each chunk to int
        data = [self.str_to_int(data[4 * i : 4 * i + 4]) for i in range(n // 4)]
        return helper() 

作者：LeetCode
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-suo-shu-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

直接将其用先序遍历序列化，因为是二叉搜索树，所以排序后就是中序遍历，因此反序列化就转换成了105题的从先序与中序构造二叉树的问题。 时间超过100%。

class Codec:
    def serialize(self, root):
        def preorder(root):
            out = []
            if root:
                out += [str(root.val)]
                out += preorder(root.left)
                out += preorder(root.right)
            return out
        return ','.join(preorder(root))
        
    def deserialize(self, data):
        if not data:
            return None
        def buildTree(pre_o, in_o):
            if not pre_o:
                return None
            mid = pre_o[0]
            i = in_o.index(mid)
            root = TreeNode(mid)
            root.left = buildTree(pre_o[1:i + 1], in_o[:i])
            root.right = buildTree(pre_o[i + 1:], in_o[i + 1:])
            return root
        pre_o = list(map(int, data.split(',')))
        in_o = sorted(pre_o)
        return buildTree(pre_o, in_o)


```

```py
**先序:**

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        
        def preorder(root):
            if not root:
                res.append("#")
                return 
            res.append(str(root.val))
            preorder(root.left)
            preorder(root.right)
        preorder(root)
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        d = iter(data.split(","))
        def helper():
            tmp = next(d)
            # print(tmp)
            if tmp == "#":return 
            node = TreeNode(int(tmp))
            node.left = helper()
            node.right = helper()
            return node
        return helper()
**层序**

from collections import deque
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        
        res = []
        queue = deque()
        if root: queue.appendleft(root)
        while queue:
            tmp = queue.pop()
            if tmp:
                res.append(tmp.val)
                queue.appendleft(tmp.left)
                queue.appendleft(tmp.right)
            else:
                res.append("#")
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        data = iter(data.split(","))
        root = TreeNode(next(data))
        queue = deque([root])
        while queue:
            tmp = queue.pop()
            left_val = next(data)
            if left_val != "#":
                tmp.left = TreeNode(int(left_val))
                queue.appendleft(tmp.left)
            right_val = next(data)
            if right_val != "#":
                tmp.right = TreeNode(int(right_val))
                queue.appendleft(tmp.right)
        return root
```

###  1.221. <a name='DeleteNodeinaBST'></a>450. Delete Node in a BST

[花花酱](https://www.bilibili.com/video/BV1XW411d7yU?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1YK4y1h7Mw?spm_id_from=333.999.0.0)

```py
# python 极简递归

class Solution(object):
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        if not root: return None;
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        else:
            if not root.left or not root.right: # 出口就是
                root = root.left if root.left else root.right # 出口就是，删除root
            else:
                cur = root.right # 找到右子树最小值
                while cur.left: cur = cur.left # 找到右子树最小值
                root.val = cur.val # 找到右子树最小值 的值
                root.right = self.deleteNode(root.right, cur.val)  # 删除最小值
            
        return root;

# 不考虑平衡的话可以简单粗暴一些。

# 假如要删除的不是根节点，转为递归子问题。

# 假如删除的是根节点且左子树为空，返回右子树即可。

# 假如删除的是根节点且左子树非空，找到左子树中最大的节点（其必然是没有右子树的），

# 将根节点的右子树作为其右子树即可。

def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
    if not root:
        return None
    if root.val > key:
        root.left = self.deleteNode(root.left, key)
    elif root.val < key:
        root.right = self.deleteNode(root.right, key)
    elif not root.left:
        root = root.right
    else:
        p = root.left
        while p.right:
            p = p.right
        p.right = root.right
        root = root.left
    return root
```

```py
# 分享一个最高128ms，20.66%的沙比方法，原理就是打印除了key以外的排序树，然后生成一个只有右子树的排序树输出

class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        a=[]
        def f(r):
            if not r:return
            f(r.left)
            if r.val!=key:
                a.append(r.val)
            f(r.right)
        f(root)
        n=len(a)
        if not a:
            return 
        r=TreeNode(a[0])
        ans=r
        for i in range(1,n):
            r.right=TreeNode(a[i])
            r=r.right
        return ans
# 但这个复杂度不满足要求啊，虽然这个思路挺有意思
# 这实际就没实现删除节点这个功能，只是把结果找到了
```

###  1.222. <a name='SortCharactersByFrequency'></a>451 Sort Characters By Frequency

[小明](https://www.bilibili.com/video/BV18v411z7iy?spm_id_from=333.999.0.0)

###  1.223. <a name='SumII'></a>454 4Sum II

[小明](https://www.bilibili.com/video/BV1ny4y1D7UL?spm_id_from=333.999.0.0)

###  1.224. <a name='MinimumNumberofArrowstoBurstBalloons'></a>452. 【贪心🧡】Minimum Number of Arrows to Burst Balloons

[花花酱](https://www.bilibili.com/video/BV1bW411d77B?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1PZ4y1L7VM?spm_id_from=333.999.0.0)

```py
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        
        points.sort(key=lambda balloon: balloon[1])
        pos = points[0][1]
        ans = 1
        for balloon in points:
            if balloon[0] > pos:
                pos = balloon[1]
                ans += 1
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python3，啪的一下就过了，很快啊

什么贪心我不懂，求交集就完事儿了

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort()
        i = 1
        while i < len(points):
            (al, ar), (bl, br) = points[i - 1], points[i]
            if bl <= ar:
                points[i - 1] = bl, min(ar, br)
                points.pop(i)
            else:
                i += 1
        return len(points)

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if len(points) == 0: return 0
        points.sort(key=lambda x: x[0])
        result = 1
        for i in range(1, len(points)):
            if points[i][0] > points[i - 1][1]: # 气球i和气球i-1不挨着，注意这里不是>=
                result += 1     
            else:
                points[i][1] = min(points[i - 1][1], points[i][1]) # 更新重叠气球最小右边界
        return result

贪心，每次射箭尽量找气球有重叠的点。排序后，记录重叠区间，下一个气球有重叠就进一步取交集，不重叠就结果+1

class Solution(object):
    def findMinArrowShots(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        if len(points) == 0: return 0
        points = sorted(points, key=lambda x: x[0])

        start = points[0][0]
        end = points[0][1]
        res = 0

        for point in points:
            if point[0] <= end:
                start = max(point[0], start)
                end = min(point[1], end)
            else:
                res += 1
                start = point[0]
                end = point[1]
        return res + 1
```

```py
贪心

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: [x[0], x[1]])
        # print(points)
        if not points: return 0
        interval = [points[0][0], points[0][1]]
        res = 1
        for start, end in points[1:]:
            if start <= interval[1]: # 有交集
                interval[0] = start
                interval[1] = min(interval[1], end)
            else:
                res += 1
                interval[0] = start
                interval[1] = end
        return res
```

###  1.225. <a name='AssignCookies'></a>455-Assign Cookies

[哈哈哈](https://www.bilibili.com/video/BV157411s7b9?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1YE411r7UN?spm_id_from=333.999.0.0)

```py
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        n, m = len(g), len(s)
        i = j = count = 0

        while i < n and j < m:
            while j < m and g[i] > s[j]:
                j += 1
            if j < m:
                count += 1
            i += 1
            j += 1
        
        return count

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/assign-cookies/solution/fen-fa-bing-gan-by-leetcode-solution-50se/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        gg, ss, ans = 0, 0, 0
        while gg < len(g) and ss < len(s):
            if s[ss] >= g[gg]:
                ans += 1
                gg += 1
                ss += 1
            else:
                ss += 1
        return ans
```

```py
class Solution:
    # 思路1：优先考虑胃饼干
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        res = 0
        for i in range(len(s)):
            if res <len(g) and s[i] >= g[res]:  #小饼干先喂饱小胃口
                res += 1
        return res
class Solution:
    # 思路2：优先考虑胃口
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        start, count = len(s) - 1, 0
        for index in range(len(g) - 1, -1, -1): # 先喂饱大胃口
            if start >= 0 and g[index] <= s[start]: 
                start -= 1
                count += 1
        return count
```

###  1.226. <a name='Pattern'></a>456 132 Pattern

[小明](https://www.bilibili.com/video/BV18f4y1i734?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1SZ4y1x74J?spm_id_from=333.999.0.0)

```py
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        
        # 左侧最小值
        left_min = nums[0]
        # 右侧所有元素
        right_all = SortedList(nums[2:])
        
        for j in range(1, n - 1):
            if left_min < nums[j]:
                index = right_all.bisect_right(left_min)
                if index < len(right_all) and right_all[index] < nums[j]:
                    return True
            left_min = min(left_min, nums[j])
            right_all.remove(nums[j + 1])

        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        n = len(nums)
        candidate_k = [nums[n - 1]]
        max_k = float("-inf")

        for i in range(n - 2, -1, -1):
            if nums[i] < max_k:
                return True
            while candidate_k and nums[i] > candidate_k[-1]:
                max_k = candidate_k[-1]
                candidate_k.pop()
            if nums[i] > max_k:
                candidate_k.append(nums[i])

        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        candidate_i, candidate_j = [-nums[0]], [-nums[0]]

        for v in nums[1:]:
            idx_i = bisect.bisect_right(candidate_i, -v)
            idx_j = bisect.bisect_left(candidate_j, -v)
            if idx_i < idx_j:
                return True

            if v < -candidate_i[-1]:
                candidate_i.append(-v)
                candidate_j.append(-v)
            elif v > -candidate_j[-1]:
                last_i = -candidate_i[-1]
                while candidate_j and v > -candidate_j[-1]:
                    candidate_i.pop()
                    candidate_j.pop()
                candidate_i.append(-last_i)
                candidate_j.append(-v)

        return False

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-solution-ye89/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        stack = []                   # top is number "3"
        mmax = float('-inf')         # number "2"
        for n in nums[::-1]:         # look for number "1"
            if n < mmax: return True
            while stack and n > stack[-1]:
                mmax = stack.pop()
            stack.append(n)
        return False

class Solution:
    def find132pattern(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        stack = []
        _MIN = float('-inf')
        
        for i in range(len(nums)-1, -1, -1):
            if nums[i] < _MIN:
                return True
            while stack and nums[i] > stack[-1]:
                _MIN = stack.pop()
            stack.append(nums[i])
            
        return False

栈里是当前最大的数，设为max，min是max右边最大的数。只需要nums[i] < min则存在132模式。 我想问一下，能不能改成 正向遍历呢
不能， 因为要保证递减栈pop出的_MIN在原数组中下标要是最大的，先压入栈的数下标要最大，这个_MIN其实就是题目描述中的ak
```

###  1.227. <a name='PoorPigs'></a>458 Poor Pigs

[小明](https://www.bilibili.com/video/BV1g5411576M?spm_id_from=333.999.0.0)

###  1.228. <a name='RepeatedSubstringPattern'></a>459 Repeated Substring Pattern

[小明](https://www.bilibili.com/video/BV1Yt4y1S7XZ?spm_id_from=333.999.0.0)

###  1.229. <a name='LFUCacheO1'></a>460. 【构造🏰】LFU Cache / O(1)

[花花酱](https://www.bilibili.com/video/BV1gt411Y7PR?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1Xb411c7m7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kA41147t8?spm_id_from=333.999.0.0)

```py
官方方法二加了些注释
python代码中双向链表freqMap在后面插入tail.pre，删除在前面删head.nex，和题解说明相反

import collections
class Node:
	def __init__(self, key, val, pre=None, nex=None, freq=0):
		self.pre = pre
		self.nex = nex
		self.freq = freq			#当前节点使用频率
		self.val = val
		self.key = key
	
	#插入节点
	# self-> nex-> self.nex
	def insert(self, nex):
		nex.pre = self
		nex.nex = self.nex
		self.nex.pre = nex
		self.nex = nex

# 创建双向链表，包含值为0的head，tail
def create_linked_list():
	head = Node(0, 0)
	tail = Node(0, 0)
	head.nex = tail
	tail.pre = head
	return (head, tail)

class LFUCache:
	def __init__(self, capacity: int):
		self.capacity = capacity
		self.size = 0			#键值对总数
		self.minFreq = 0		#记录最小的频率，每次容量满了，删这个频率的head.nex
		self.freqMap = collections.defaultdict(create_linked_list)	#key是频率，值是一条双向链表的head, tail，最近操作的节点插入tail前面，则head.nex是最小使用频率的节点，删除时删head.nex
		self.keyMap = {}		#存储键值对，值是node 类型

	#双向链表中删除指定节点
	def delete(self, node):
		if node.pre:			#不是第一个节点，就需要删除，
			node.pre.nex = node.nex	#前后前接起来
			node.nex.pre = node.pre						
			if node.pre is self.freqMap[node.freq][0] and node.nex is self.freqMap[node.freq][-1]: #新的频率中已存在这个节点，且只有这个节点，那就直接把这个新频率删掉，方便后面插入最新数据
				self.freqMap.pop(node.freq)														   
		return node.key												
	
	#增加
	def increase(self, node):
		node.freq += 1			#当前节点频率+1
		self.delete(node)		#旧频率中，删除此节点
		self.freqMap[node.freq][-1].pre.insert(node)	#新频率中，tail节点前插入当前节点
		if node.freq == 1:		#出现频率为1的了，记录一下，下次容量满了先从这里删
			self.minFreq = 1
		elif self.minFreq == node.freq - 1:	#操作最小频率的节点时，从旧频率到新频率时需要检查下旧频率，只有head,tail就不可能从这里删数据了，那就需要把minFreq更新为新频率，下次从这里删
			head, tail = self.freqMap[node.freq - 1]
			if head.nex is tail:		#这个频率里没有实际节点，只有head,tail
				self.minFreq = node.freq#最小频率更新为节点当前频率

	def get(self, key: int) -> int:
		if key in self.keyMap:
			self.increase(self.keyMap[key])
			return self.keyMap[key].val
		return -1

	def put(self, key: int, value: int) -> None:
		if self.capacity != 0:
			if key in self.keyMap:		#有，更新value
				node = self.keyMap[key]
				node.val = value
			else:
				node = Node(key, value)	#没有，新建一个node
				self.keyMap[key] = node
				self.size += 1
			if self.size > self.capacity:	#大于容量
				self.size -= 1										
				deleted = self.delete(self.freqMap[self.minFreq][0].nex)#删除head.nex
				self.keyMap.pop(deleted)
			self.increase(node)





class Node:
    def __init__(self, key, val, pre=None, nex=None, freq=0):
        self.pre = pre
        self.nex = nex
        self.freq = freq
        self.val = val
        self.key = key
        
    def insert(self, nex):
        nex.pre = self
        nex.nex = self.nex
        self.nex.pre = nex
        self.nex = nex
    
def create_linked_list():
    head = Node(0, 0)
    tail = Node(0, 0)
    head.nex = tail
    tail.pre = head
    return (head, tail)

class LFUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.size = 0
        self.minFreq = 0
        self.freqMap = collections.defaultdict(create_linked_list)
        self.keyMap = {}

    def delete(self, node):
        if node.pre:
            node.pre.nex = node.nex
            node.nex.pre = node.pre
            if node.pre is self.freqMap[node.freq][0] and node.nex is self.freqMap[node.freq][-1]:
                self.freqMap.pop(node.freq)
        return node.key
        
    def increase(self, node):
        node.freq += 1
        self.delete(node)
        self.freqMap[node.freq][-1].pre.insert(node)
        if node.freq == 1:
            self.minFreq = 1
        elif self.minFreq == node.freq - 1:
            head, tail = self.freqMap[node.freq - 1]
            if head.nex is tail:
                self.minFreq = node.freq

    def get(self, key: int) -> int:
        if key in self.keyMap:
            self.increase(self.keyMap[key])
            return self.keyMap[key].val
        return -1

    def put(self, key: int, value: int) -> None:
        if self.capacity != 0:
            if key in self.keyMap:
                node = self.keyMap[key]
                node.val = value
            else:
                node = Node(key, value)
                self.keyMap[key] = node
                self.size += 1
            if self.size > self.capacity:
                self.size -= 1
                deleted = self.delete(self.freqMap[self.minFreq][0].nex)
                self.keyMap.pop(deleted)
            self.increase(node)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/lfu-cache/solution/lfuhuan-cun-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

也是用双向链表做的，改了好几处空指针异常的地方。这个零可恶心到我了
```

```py

```

###  1.230. <a name='HammingDistance'></a>461 【位运算😜】Hamming Distance

[小明](https://www.bilibili.com/video/BV1M5411Y79g?spm_id_from=333.999.0.0)

```py
用(x&d) ^ (y&d)来判断两个数二进制的某一位是否不同


class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        cnt, d = 0, 1
        for i in range(32):
            if (x&d) ^ (y&d) != 0:
                cnt += 1
            d <<= 1
        return cnt

作者：bluegreenred
链接：https://leetcode-cn.com/problems/hamming-distance/solution/461-yi-ming-ju-chi-python-wei-yun-suan-b-ru8t/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

思路和心得：

1.基本的位运算😜，注意数据范围

2.异或常考

python3

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        res = 0
        z = x ^ y
        for i in range(30, -1, -1):
            if (z >> i) & 1: 
                res += 1
        return res


位运算😜


class Solution:
    def hammingDistance(self, x, y):
        # 取异或值得到明汉值 0 相同 1 不同 1的个数就是明汉距离
        s = x ^ y
        ret = 0
        while s:
            # 依次位移明汉值 和1取与，1与1的1 就累加
            ret += s & 1
            s >>= 1
        return ret

内置函数

filter 的 函数 返回布尔值


class Solution:
    def hammingDistance(self, x, y):
        return len(list(filter(lambda x: x == '1', bin(x ^ y))))


先求异或，再送入func递归计算1的个数(LC191)

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        def func(n):
            return 0 if n <= 0 else 1 + func(n & (n-1))
        return func(x ^ y)
        

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        s = x ^ y
        res = 0
        while s:
            res += 1
            s ^= s & (-s)
            # 找到并消掉最后的那个1
        return res


class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        num = x ^ y
        count = 0
        while num:
            if num & 1 == 1:
                count += 1
            num = num >> 1
        return count



class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        res = 0
        z = x ^ y
        while z:
            res += 1
            z = z & (z-1)
        return res

```

###  1.231. <a name='IslandPerimeter'></a>463 Island Perimeter

[小明](https://www.bilibili.com/video/BV16V41167bF?spm_id_from=333.999.0.0)

###  1.232. <a name='CanIWin'></a>464. Can I Win

[花花酱](https://www.bilibili.com/video/BV1KW411o7m2?spm_id_from=333.999.0.0)

###  1.233. <a name='CountTheRepetitions'></a>466. 统计重复个数 Count The Repetitions

[官方](https://www.bilibili.com/video/BV1Qk4y1678m?spm_id_from=333.999.0.0)

###  1.234. <a name='ValidateIPAddress'></a>468 Validate IP Address

[小明](https://www.bilibili.com/video/BV1tg4y1q7Kq?spm_id_from=333.999.0.0)

###  1.235. <a name='ImplementRand10UsingRand7'></a>470. Implement Rand10() Using Rand7()

[花花酱](https://www.bilibili.com/video/BV1Ut411Z7KX?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AD4y1m7Qb?spm_id_from=333.999.0.0)

```py
class Solution:
    def rand10(self) -> int:
        while True:
            row = rand7()
            col = rand7()
            idx = (row - 1) * 7 + col
            if idx <= 40:
                return 1 + (idx - 1) % 10

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def rand10(self) -> int:
        while True:
            a = rand7()
            b = rand7()
            idx = (a - 1) * 7 + b
            if idx <= 40:
                return 1 + (idx - 1) % 10
            a = idx - 40
            b = rand7()
            # get uniform dist from 1 - 63
            idx = (a - 1) * 7 + b
            if idx <= 60:
                return 1 + (idx - 1) % 10
            a = idx - 60
            b = rand7()
            # get uniform dist from 1 - 21
            idx = (a - 1) * 7 + b
            if idx <= 20:
                return 1 + (idx - 1) % 10

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

最近刚在算法书看到这道题。。。。。。

class Solution:
    def rand10(self):
        while True:
            res = (rand7()-1)*7 + rand7()#构造1~49的均匀分布
            if res <= 40:#剔除大于40的值，1-40等概率出现。
                break
        return res%10+1#构造1-10的均匀分布

为什么res = (rand7()-1)*7 + rand7() 不写成res = (and7()* rand7(), 有什么区别吗
你想想6*7相乘，或者7*7相乘，能生成48吗，你说的这样只能生成乘法表那几个而不是1-49均匀的那几个
```

```py
class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        start=None
        while start==None:
            cur=rand7()
            if 1<=cur<=3:
                start=0
            if 4<=cur<=6:
                start=5
        while True:
            cur=rand7()
            if cur>5:
                continue
            else:
                return start+cur


感觉官方题解以及其他方法比较难以理解，看了其他人的思路后有所感悟。

我们可以先创造一个1-5的均匀分布，得到一个符合的结果x。

其次我们可以通过某种方法将这个1-5的均匀分布变为1-10的均匀分布。

方法如下所示：我们可以在生成一个数y，因为y是1-7的数字，

我们可以排除数字4，y为7继续生成一个数字，变为1-3以及5-7两个部分，

这样这两个部分只有3个数字，因为是等概率的，

如果在前部分， y = 0，如果为后部分y=5，因此可以创造出1-10的等概率分布。

class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        x = rand7()
        while x>5:
            x = rand7()
        y = rand7()
        while y == 4:
            y = rand7()
        if y < 4:
            y = 0
        else:
            y = 5
        return x+y
             
```

###  1.236. <a name='Heaters'></a>475. Heaters

[小梦想家](https://www.bilibili.com/video/BV1vJ41117VH?spm_id_from=333.999.0.0)

###  1.237. <a name='NumberComplement'></a>476. 【位运算😜】Number Complement

[花花酱](https://www.bilibili.com/video/BV1PW411y7mv?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.pvl104ml1dc.webp)

时间复杂度：O(log num)。找出 num 二进制表示最高位的 11 需要的时间为 O(log num)。

空间复杂度：O(1) 。


```py
class Solution:
    def findComplement(self, num: int) -> int:
        highbit = 0
        for i in range(1, 30 + 1):
            if num >= (1 << i):
                highbit = i
            else:
                break
        
        mask = (1 << (highbit + 1)) - 1
        return num ^ mask

```

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.7057rnkw8r40.webp)

```py
A = 1111
B = 1100
C = 0011

C = A ^ B
C = A - B

class Solution:
    def findComplement(self, num):
        val = len(bin(num)) - 2
        return num ^ ((1 << val) - 1)


由题可得，num与补数的和，转换为二进制，恰好为与num相同二进制位数的所有位值为1的二进制数：
num + num的步数 == 与num二进制相同位数的各位为1的二进制数

class Solution:
    def findComplement(self, num: int) -> int:
        val = len(bin(num)) - 2
        return (pow(2, val) - 1) - num

```

###  1.238. <a name='TotalHammingDistance'></a>477. 【位运算😜】Total Hamming Distance

[花花酱](https://www.bilibili.com/video/BV1SW411r78m?spm_id_from=333.999.0.0)

```py
# 第一想法就是暴力，直接超时
class Solution(object): # 此法超时
    def totalHammingDistance(self, nums):
        res = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                res += bin(nums[i] ^ nums[j]).count('1')
        return res

class Solution(object): # 此法超时
    def totalHammingDistance(self, nums):
        return sum(b.count('0') * b.count('1') for b in zip(*map('{:032b}'.format, nums)))
```

```py
这个方法妙啊！
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        s_nums = [bin(s)[2:].rjust(32, "0") for s in nums]
        res = 0
        for item in zip(*s_nums): # 字符串zip的时候要加星号
            res += item.count("1") * item.count("0")
        return res

class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        c0, c1, sm=0,0,0
        for i in range(31):
            c0 = c1 = 0
            for n in nums:
                if (n >> i) & 1:
                    c1 += 1 # count("1")
                else:
                    c0 += 1 # count("0")
            sm += c0 * c1
        return sm
```

###  1.239. <a name='GenerateRandomPointinaCircle'></a>478 Generate Random Point in a Circle

[小明](https://www.bilibili.com/video/BV1Nz4y127a1?spm_id_from=333.999.0.0)

###  1.240. <a name='SlidingWindowMedian'></a>480. ★【滑动窗口🔹中位数暴力】Sliding Window Median

[花花酱](https://www.bilibili.com/video/BV15W411C7iy?spm_id_from=333.999.0.0)


```py
import bisect

class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        median = lambda a: (a[(len(a)-1)//2] + a[len(a)//2]) / 2
        a = sorted(nums[:k])
        res = [median(a)]
        for i, j in zip(nums[:-k], nums[k:]):
            a.remove(i)
            bisect.insort_left(a, j)
            res.append(median(a))
        return res
```


```py
import bisect

class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        median = lambda a: (a[(len(a)-1)//2] + a[len(a)//2]) / 2
        a = sorted(nums[:k])
        res = [median(a)]
        for i, j in zip(nums[:-k], nums[k:]):
            a.pop(bisect.bisect_left(a, i))
            bisect.insort_left(a, j)
            res.append(median(a))
        return res

```



直接暴力求解

```py
class Solution:
    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
        res = []
        mididx, n = k//2, len(nums)
        for i in range(n-k+1):
            tmp = sorted(nums[i:i+k])
            mid = tmp[mididx] if k % 2 == 1 else 1.0*(tmp[mididx-1] + tmp[mididx])/2
            res.append(mid)
        return res

```

```py
import numpy as np
import scipy

class Solution(object):
    def medianSlidingWindow(self, nums, k):
        return [np.median(nums[i:i+k]) for i in range(len(nums)-k+1)]
```

###  1.241. <a name='FindPermutation'></a>484 Find Permutation

[小明](https://www.bilibili.com/video/BV1NT4y1L76i?spm_id_from=333.999.0.0)

###  1.242. <a name='MaxConsecutiveOnes'></a>485. Max Consecutive Ones

[小梦想家](https://www.bilibili.com/video/BV1zJ411R7SJ?spm_id_from=333.999.0.0)

###  1.243. <a name='PredicttheWinner'></a>486. Predict the Winner

[花花酱](https://www.bilibili.com/video/BV1kW411d7R2?spm_id_from=333.999.0.0)

###  1.244. <a name='TheMaze'></a>490 The Maze

[小明](https://www.bilibili.com/video/BV1az4y1f7Hn?spm_id_from=333.999.0.0)

###  1.245. <a name='dfsstartIforTargetSum'></a>494. 【动态🚀规划 + 背包 + dfs(startI)无for循环】Target Sum

[花花酱](https://www.bilibili.com/video/BV1WW411C7Mp?spm_id_from=333.999.0.0)

[花花酱 下](https://www.bilibili.com/video/BV1WW411C7Mr?spm_id_from=333.999.0.0)

0-1背包（二维动态规划）

```py
class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        # 求得新的目标
        sums = sum(nums)
        # 注意，需要排除掉一些特殊状况
        bagSize = sums + target
        # 也可以写成：bagSize = sums - target

        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2
        # 构建dp，numLen在外围
        dp = [[0] * (bagSize+1) for _ in range(n+1)]
        # 赋值，dp的第一个元素
        dp[0][0] = 1
        for i in range(1,n+1):
            num = nums[i-1] # 易错点: num = nums[i-1]单独提出来写，不容易出错
            for j in range(bagSize+1):
                if j-num >= 0: # 易错点: 这里必需要是>=
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-num]
                else:
                    dp[i][j] = dp[i-1][j]
#    [[1, 0, 0, 0, 0], 
#     [1, 1, 0, 0, 0], 
#     [1, 2, 1, 0, 0], 
#     [1, 3, 3, 1, 0], 
#     [1, 4, 6, 4, 1], 
#     [1, 5, 10, 10, 5]]
        return dp[-1][-1]
```

0-1背包（一维动态规划）

```py
class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        # 求得新的目标
        sums = sum(nums)
        # 注意，需要排除掉一些特殊状况
        bagSize = sums + target
        # 也可以写成：bagSize = sums - target
        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2
        # 构建dp，numLen在外围
        dp = [0] * (bagSize+1)
        # 赋值，dp的第一个元素
        dp[0] = 1
        for num in nums:
            for j in range(bagSize,num-1,-1):
                dp[j] += dp[j-num] # 对于没有当前num时的case + 有了num时bagSize-num的cas
        # 含义就是：
        # 对于1个num，bagsize的填满情况
        # 对弈2个num，bagsize的填满情况
        return dp[-1]

数字： 1 dp: [1, 0, 0, 0, 0]
数字： 1 dp: [1, 0, 0, 0, 0]
数字： 1 dp: [1, 0, 0, 0, 0]
数字： 1 dp: [1, 1, 0, 0, 0]
--------------------
数字： 1 dp: [1, 1, 0, 0, 0]
数字： 1 dp: [1, 1, 0, 0, 0]
数字： 1 dp: [1, 1, 1, 0, 0]
数字： 1 dp: [1, 2, 1, 0, 0]
--------------------
数字： 1 dp: [1, 2, 1, 0, 0]
数字： 1 dp: [1, 2, 1, 1, 0]
数字： 1 dp: [1, 2, 3, 1, 0]
数字： 1 dp: [1, 3, 3, 1, 0]
--------------------
数字： 1 dp: [1, 3, 3, 1, 1]
数字： 1 dp: [1, 3, 3, 4, 1]
数字： 1 dp: [1, 3, 6, 4, 1]
数字： 1 dp: [1, 4, 6, 4, 1]
--------------------
数字： 1 dp: [1, 4, 6, 4, 5]
数字： 1 dp: [1, 4, 6, 10, 5]
数字： 1 dp: [1, 4, 10, 10, 5]
数字： 1 dp: [1, 5, 10, 10, 5]
--------------------

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        n = len(nums)
        sums = sum(nums)
        bagSize = sums + target
        if bagSize % 2 == 1 or bagSize < 0:
            return 0
        bagSize = bagSize // 2

        @cache
        def dfs(startI,total):
            # 如果要写递归，那么这个递归的结束条件一定要背出来
            if startI == len(nums):
                return 1 if total == 0 else 0
            # 如果要写递归，那么这个递归的结束条件一定要背出来
            return dfs(startI+1,total-nums[startI]) + dfs(startI+1,total)

        return dfs(0,bagSize)

```

```py
# 思路

# 每个数，只有取正、取负数，这两种处理。因此可以做深度优先遍历，为了避免重复计算，加上记忆法。

# DFS 到 nums[i] 时，取正数，则要求后面的数，处理后的 next_target = current_target - nums[i];
# 取负数的处理同上，后续要处理的 next_target = current_target + nums[i]；
# 用 python 语法糖简单演示下：

class Solution:
    def findTargetSumWays(self, nums: List[int], target) -> int:
        # @lru_cache(None)
        def dfs(startIdx, sum) -> int:
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return dfs(startIdx + 1, sum - nums[startIdx]) + dfs(startIdx + 1, sum + nums[startIdx])

        return dfs(0, target)

# @lru_cache(None) 好神奇，瞬间提高效率
# 如果不用@lru_cache(None)，用这种方式会超时，Java的就不会啊
# 同样的解法，Java 不超时是因为 Java 运行速度比 Python 快得多。
# 而 Python 如果不用 lru_cache 或者显式的记忆数组存储 dfs 的结果，
# 大量重复计算会导致超时，因为 Python 运行速度慢

# DFS

class Solution:
    def findTargetSumWays(self, nums: List[int], V) -> int:
        def dfs(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum==0 else 0
            res = 0
            res += dfs(sum-nums[startIdx], startIdx+1)
            res += dfs(sum+nums[startIdx], startIdx+1)
            return res
        return dfs(V, 0)


# 递归，findSum(s, start_idx) 函数的意思是从start_index开始向后的子集合能有几种得到s的方法

class Solution(object):
    def findTargetSumWays(self, nums, S):
        def findSum(sum, startIdx):
            if startIdx == len(nums):
                return 1 if sum == 0 else 0
            return findSum(sum+nums[startIdx], startIdx+1) + findSum(sum-nums[startIdx], startIdx+1)
        return findSum(S, 0)
# 但是这样会超时，所以用cache 记一下

class Solution(object):
    def findTargetSumWays(self, nums, S):
        def findSum(s, start_idx):
            if start_idx == len(nums):
                return 1 if s == 0 else 0
            if (s, start_idx) not in cache:
                cache[(s, start_idx)] = findSum(s+nums[start_idx], start_idx+1) + findSum(s-nums[start_idx], start_idx+1)
            return cache[(s, start_idx)]
            
        cache = {}
        return findSum(S, 0)
```



###  1.246. <a name='TeemoAttacking'></a>495 Teemo Attacking

[小明](https://www.bilibili.com/video/BV1LK4y1Y75e?spm_id_from=333.999.0.0)

###  1.247. <a name='INextGreaterElementI'></a>496. 下一个更大元素 I (Next Greater Element I)

[洛阳](https://www.bilibili.com/video/BV1Ce411W7pW?spm_id_from=333.999.0.0)

###  1.248. <a name='RandomPointinNon-overlapping'></a>497 Random Point in Non-overlapping

[小明](https://www.bilibili.com/video/BV12K4y1Y7r6?spm_id_from=333.999.0.0)

