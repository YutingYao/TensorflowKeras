<!-- vscode-markdown-toc -->
* 1. [题目500+](#500)
	* 1.1. [500. Keyboard Row](#KeyboardRow)
	* 1.2. [503 【栈】Next Greater Element II](#NextGreaterElementII)
	* 1.3. [504-Base 7](#Base7)
	* 1.4. [509. 【动态🚀规划 + 递归】Fibonacci Number](#FibonacciNumber)
	* 1.5. [516. 【回文】【动态🚀规划】Longest Palindromic Subsequence](#LongestPalindromicSubsequence)
		* 1.5.1. [类似题目：1143. 最长公共子序列](#1143.)
	* 1.6. [518 Coin Change 2](#CoinChange2)
	* 1.7. [520. Detect Capital](#DetectCapital)
	* 1.8. [525. 【前缀和🎨】Contiguous Array](#ContiguousArray)
	* 1.9. [526 Beautiful Arrangement](#BeautifulArrangement)
	* 1.10. [528 Random Pick with Weight](#RandomPickwithWeight)
	* 1.11. [530. Minimum Absolute Difference in BST](#MinimumAbsoluteDifferenceinBST)
	* 1.12. [532 K-diff Pairs in an Array](#K-diffPairsinanArray)
	* 1.13. [535. Encode and Decode TinyURL](#EncodeandDecodeTinyURL)
	* 1.14. [537 Complex Number Multiplicatin](#ComplexNumberMultiplicatin)
	* 1.15. [538 Convert BST to Greater Tree](#ConvertBSTtoGreaterTree)
	* 1.16. [540. Single Element in a Sorted Array 540-有序数组中的单一元素](#SingleElementinaSortedArray540-)
	* 1.17. [542. 01 矩阵 01 Matrix](#Matrix)
	* 1.18. [543 Diameter of Binary Tree](#DiameterofBinaryTree)
	* 1.19. [546 Remove Boxes](#RemoveBoxes)
	* 1.20. [547 【🍒并查集】朋友圈](#)
	* 1.21. [554 Brick Wall](#BrickWall)
	* 1.22. [556 Next Greater Element III](#NextGreaterElementIII)
	* 1.23. [560. Subarray Sum Equals K 和为K的子数组](#SubarraySumEqualsKK)
	* 1.24. [563 Binary Tree Tilt](#BinaryTreeTilt)
	* 1.25. [565 【🍒并查集】Array Nesting](#ArrayNesting)
	* 1.26. [567. 【滑动窗口🔹】Permutation in String 567-字符串的排列](#PermutationinString567-)
	* 1.27. [572-另一个树的子树](#-1)
	* 1.28. [575 Distribute Candies](#DistributeCandies)
	* 1.29. [576. Out of Boundary Paths](#OutofBoundaryPaths)
	* 1.30. [581 Shortest Unsorted Continuous Suba](#ShortestUnsortedContinuousSuba)
	* 1.31. [589 N-ary Tree Preorder Traversal](#N-aryTreePreorderTraversal)
	* 1.32. [593 Valid Square](#ValidSquare)
	* 1.33. [594 Longest Harmonious Subsequence](#LongestHarmoniousSubsequence)
	* 1.34. [605 Can Place Flowers](#CanPlaceFlowers)
	* 1.35. [611](#-1)
	* 1.36. [621. Task Scheduler](#TaskScheduler)
	* 1.37. [622 Design Circular Queue](#DesignCircularQueue)
	* 1.38. [623 Add One Row to Tree](#AddOneRowtoTree)
	* 1.39. [633-Sum of Square Numbers](#SumofSquareNumbers)
	* 1.40. [636. Exclusive Time of Functions](#ExclusiveTimeofFunctions)
	* 1.41. [637 Average of Levels in Binary Tree](#AverageofLevelsinBinaryTree)
	* 1.42. [639. Decode Ways II](#DecodeWaysII)
	* 1.43. [643. Maximum Average Subarray I](#MaximumAverageSubarrayI)
	* 1.44. [645-错误的集合](#-1)
	* 1.45. [646-【动态🚀规划 + 贪心🧡】最长数对链](#-1)
	* 1.46. [647 【动态🚀规划 + 中心拓展】Palindromic Substrings](#PalindromicSubstrings)
	* 1.47. [650-只有两个键的键盘](#-1)
	* 1.48. [652. Find Duplicate Subtrees](#FindDuplicateSubtrees)
	* 1.49. [653. Two Sum IV](#TwoSumIV)
	* 1.50. [662. Maximum Width of Binary Tree](#MaximumWidthofBinaryTree)
	* 1.51. [667 Beautiful Arrangement II](#BeautifulArrangementII)
	* 1.52. [668. Kth Smallest Number in Multiplication Table](#KthSmallestNumberinMultiplicationTable)
	* 1.53. [669 Trim a Binary Search Tree](#TrimaBinarySearchTree)
	* 1.54. [673 Number of Longest Increasing Subse](#NumberofLongestIncreasingSubse)
	* 1.55. [678 Valid Parenthesis String](#ValidParenthesisString)
	* 1.56. [680-Valid Palindrome II](#ValidPalindromeII)
	* 1.57. [683. K Empty Slots](#KEmptySlots)
	* 1.58. [684. 【🍒并查集】Redundant Connection 684-冗余连接](#RedundantConnection684-)
	* 1.59. [685. 【🍒并查集】Redundant Connection II](#RedundantConnectionII)
	* 1.60. [687. Longest Univalue Path](#LongestUnivaluePath)
	* 1.61. [688. Knight Probability in Chessboard](#KnightProbabilityinChessboard)
	* 1.62. [690. Employee Importance](#EmployeeImportance)
	* 1.63. [692. Top K Frequent Words](#TopKFrequentWords)
	* 1.64. [693](#-1)
	* 1.65. [695-岛屿的最大面积](#-1)
	* 1.66. [696 Count Binary Substrings](#CountBinarySubstrings)
	* 1.67. [699. Falling Squares](#FallingSquares)
	* 1.68. [700 Search in a Binary Search Tree](#SearchinaBinarySearchTree)
	* 1.69. [701 Insert into a Binary Search Tree](#InsertintoaBinarySearchTree)
	* 1.70. [703. 【构造🏰 + 最小堆🌵】Kth Largest Element in a Stream数据流中的第K大元素](#KthLargestElementinaStreamK)
	* 1.71. [704.Binary Search二分查找](#BinarySearch)
	* 1.72. [705 Design HashSet](#DesignHashSet)
	* 1.73. [706. Design HashMap设计哈希映射](#DesignHashMap)
	* 1.74. [707. Design Linked List](#DesignLinkedList)
	* 1.75. [712. Minimum ASCII Delete Sum for Two Strings](#MinimumASCIIDeleteSumforTwoStrings)
	* 1.76. [713 Subarray Product Less Than K](#SubarrayProductLessThanK)
	* 1.77. [714 【动态🚀规划】买卖股票的最佳时机含手续费](#-1)
	* 1.78. [715. Range Module](#RangeModule)
	* 1.79. [719. Find K-th Smallest Pair Distance](#FindK-thSmallestPairDistance)
	* 1.80. [720. Longest Word in Dictionary](#LongestWordinDictionary)
	* 1.81. [721 【🍒并查集】Accounts Merge](#AccountsMerge)
	* 1.82. [724. Find Pivot Index](#FindPivotIndex)
	* 1.83. [725. Split Linked List in Parts](#SplitLinkedListinParts)
	* 1.84. [726. Number of Atoms](#NumberofAtoms)
	* 1.85. [730. Count Different Palindromic Subsequences](#CountDifferentPalindromicSubsequences)
	* 1.86. [732. My Calendar III](#MyCalendarIII)
	* 1.87. [733. 图像渲染 Flood Fill](#FloodFill)
	* 1.88. [735 Asteroid Collision](#AsteroidCollision)
	* 1.89. [737. Sentence Similarity II](#SentenceSimilarityII)
	* 1.90. [739-Daily Temperatures](#DailyTemperatures)
	* 1.91. [740. 【动态🚀规划】 Delete and Earn](#DeleteandEarn)
	* 1.92. [741. Cherry Pickup](#CherryPickup)
	* 1.93. [743. 【Dijkstra🚗】Network Delay Time](#DijkstraNetworkDelayTime)
	* 1.94. [745. Prefix and Suffix Search](#PrefixandSuffixSearch)
	* 1.95. [746. 【动态🚀规划】Min Cost Climbing Stairs](#MinCostClimbingStairs)
	* 1.96. [748. Shortest Completing Word](#ShortestCompletingWord)
	* 1.97. [752. Open the Lock](#OpentheLock)
	* 1.98. [763 Partition Labels](#PartitionLabels)
	* 1.99. [765. 【🍒并查集】情侣牵手 Couples Holding Hands](#CouplesHoldingHands)
	* 1.100. [769. Max Chunks To Make Sorted](#MaxChunksToMakeSorted)
	* 1.101. [771 Jewels and Stones](#JewelsandStones)
	* 1.102. [773. Sliding Puzzle](#SlidingPuzzle)
	* 1.103. [775. Global and Local Inversions](#GlobalandLocalInversions)
	* 1.104. [777](#-1)
	* 1.105. [778. 【Dijkstra🚗 + 🍒并查集】Swim in Rising Water](#DijkstraSwiminRisingWater)
	* 1.106. [784. Letter Case Permutation](#LetterCasePermutation)
	* 1.107. [785-判断二分图](#-1)
	* 1.108. [786. K-th Smallest Prime Fraction](#K-thSmallestPrimeFraction)
	* 1.109. [787. 【Dijkstra🚗 + 动态🚀规划 + 最小堆🌵】Cheapest Flights Within K Stops](#DijkstraCheapestFlightsWithinKStops)
	* 1.110. [790. Domino and Tromino Tiling](#DominoandTrominoTiling)
	* 1.111. [792. Number of Matching Subsequences](#NumberofMatchingSubsequences)
	* 1.112. [797 All Paths From Source to Target](#AllPathsFromSourcetoTarget)
	* 1.113. [799 Champagne Tower](#ChampagneTower)
	* 1.114. [801. Minimum Swaps To Make Sequences Increasing](#MinimumSwapsToMakeSequencesIncreasing)
	* 1.115. [803. 【🍒并查集】Bricks Falling When Hit](#BricksFallingWhenHit)
	* 1.116. [804 Unique Morse Code Words](#UniqueMorseCodeWords)
	* 1.117. [813. Largest Sum of Averages](#LargestSumofAverages)
	* 1.118. [815. Bus Routes](#BusRoutes)
	* 1.119. [817. Linked List Components](#LinkedListComponents)
	* 1.120. [818. Race Car (上)](#RaceCar)
	* 1.121. [821 Shortest Distance to a Character](#ShortestDistancetoaCharacter)
	* 1.122. [823. Binary Trees With Factors](#BinaryTreesWithFactors)
	* 1.123. [824 Goat Latin](#GoatLatin)
	* 1.124. [827. Making A Large Island](#MakingALargeIsland)
	* 1.125. [832 Flipping an Image](#FlippinganImage)
	* 1.126. [835 Image Overlap](#ImageOverlap)
	* 1.127. [837. 新 21 点 New 21 Game](#New21Game)
	* 1.128. [839 【🍒并查集】Similar String Groups](#SimilarStringGroups)
	* 1.129. [841 Keys and Rooms](#KeysandRooms)
	* 1.130. [842. Split Array into Fibonacci Sequence](#SplitArrayintoFibonacciSequence)
	* 1.131. [844 Backspace String Compare](#BackspaceStringCompare)
	* 1.132. [845 Longest Mountain in Array](#LongestMountaininArray)
	* 1.133. [847 Shortest Path Visiting All Nodes](#ShortestPathVisitingAllNodes)
	* 1.134. [849 Maximize Distance to Closest Person](#MaximizeDistancetoClosestPerson)
	* 1.135. [856. Score of Parentheses](#ScoreofParentheses)
	* 1.136. [858 Mirror Reflection](#MirrorReflection)
	* 1.137. [859 Buddy Strings](#BuddyStrings)
	* 1.138. [863. All Nodes Distance K in Binary Tree](#AllNodesDistanceKinBinaryTree)
	* 1.139. [864. Shortest Path to Get All Keys](#ShortestPathtoGetAllKeys)
	* 1.140. [869 Reordered Power of 2](#ReorderedPowerof2)
	* 1.141. [865. Smallest Subtree with all the Deepest Nodes](#SmallestSubtreewithalltheDeepestNodes)
	* 1.142. [871. Minimum Number of Refueling Stops](#MinimumNumberofRefuelingStops)
	* 1.143. [873. Length of Longest Fibonacci Subsequence](#LengthofLongestFibonacciSubsequence)
	* 1.144. [875.Koko Eating Bananas科科吃香蕉](#KokoEatingBananas)
	* 1.145. [876.Middle of the Linked List 链表的中间结点](#MiddleoftheLinkedList)
	* 1.146. [877 【二维动态🚀规划】Stone Game](#StoneGame)
	* 1.147. [879. Profitable Schemes](#ProfitableSchemes)
	* 1.148. [880 Decoded String at Index](#DecodedStringatIndex)
	* 1.149. [881 Boats to Save People](#BoatstoSavePeople)
	* 1.150. [882. Reachable Nodes In Subdivided Graph](#ReachableNodesInSubdividedGraph)
	* 1.151. [886. Possible Bipartition](#PossibleBipartition)
	* 1.152. [887. Super Egg Drop](#SuperEggDrop)
	* 1.153. [889. Construct Binary Tree from Preorder and Postorder](#ConstructBinaryTreefromPreorderandPostorder)
	* 1.154. [891. Sum of Subsequence Widths](#SumofSubsequenceWidths)
	* 1.155. [894. All Possible Full Binary Trees](#AllPossibleFullBinaryTrees)
	* 1.156. [895. Maximum Frequency Stack](#MaximumFrequencyStack)
	* 1.157. [898. Bitwise ORs of Subarrays](#BitwiseORsofSubarrays)
	* 1.158. [901. 【构造🏰】Online Stock Span](#OnlineStockSpan)
	* 1.159. [902 Numbers At Most N Given Digit Set](#NumbersAtMostNGivenDigitSet)
	* 1.160. [904-水果成篮](#-1)
	* 1.161. [905 Sort Array By Parity](#SortArrayByParity)
	* 1.162. [906 Super Palindromes](#SuperPalindromes)
	* 1.163. [909. Snakes and Ladders](#SnakesandLadders)
	* 1.164. [910 Smallest Range II](#SmallestRangeII)
	* 1.165. [916 Word Subsetse](#WordSubsetse)
	* 1.166. [918 Maximum Sum Circular Sub](#MaximumSumCircularSub)
	* 1.167. [923. 3Sum With Multiplicity](#SumWithMultiplicity)
	* 1.168. [926. Flip String to Monotone Increasing](#FlipStringtoMonotoneIncreasing)
	* 1.169. [930-【滑动窗口🔹 + 前缀和🎨】和相同的二元子数组](#-1)
	* 1.170. [933 Number of Recent Calls](#NumberofRecentCalls)
	* 1.171. [934. Shortest Bridge](#ShortestBridge)
	* 1.172. [936 Stamping The Sequence](#StampingTheSequence)
	* 1.173. [938 Range Sum of BST](#RangeSumofBST)
	* 1.174. [941 Valid Mountain Array](#ValidMountainArray)
	* 1.175. [943. Find the Shortest Superstring](#FindtheShortestSuperstring)
	* 1.176. [946-Python-栈的压入、弹出序列](#Python-)
	* 1.177. [946 Validate Stack Sequences](#ValidateStackSequences)
	* 1.178. [947. 【🍒并查集】移除最多的同行或同列石头 Most Stones Removed with Same](#MostStonesRemovedwithSame)
	* 1.179. [948 Bag of Tokens](#BagofTokens)
	* 1.180. [949 Largest Time for Given Digits](#LargestTimeforGivenDigits)
	* 1.181. [952 【🍒并查集】Largest Component Size by Commo](#LargestComponentSizebyCommo)
	* 1.182. [953 Verifying an Alien Dictionary](#VerifyinganAlienDictionary)
	* 1.183. [954 Array of Doubled Pairs](#ArrayofDoubledPairs)
	* 1.184. [959. 【🍒并查集】由斜杠划分区域 Regions Cut By Slashes](#RegionsCutBySlashes)
	* 1.185. [964. 【Dijkstra🚗】Least Operators to Express Number](#DijkstraLeastOperatorstoExpressNumber)
	* 1.186. [966 Vowel Spellchecker](#VowelSpellchecker)
	* 1.187. [967. Numbers With Same Consecutive Differences](#NumbersWithSameConsecutiveDifferences)
	* 1.188. [968 Binary Tree Cameras](#BinaryTreeCameras)
	* 1.189. [969 Pancake Sorting](#PancakeSorting)
	* 1.190. [971 Flip Binary Tree To Match Preorder](#FlipBinaryTreeToMatchPreorder)
	* 1.191. [973 K Closest Points to Origin](#KClosestPointstoOrigin)
	* 1.192. [974. 和可被 K 整除的子数组 Subarray Sums Divisible by K](#KSubarraySumsDivisiblebyK)
	* 1.193. [975. Odd Even Jump](#OddEvenJump)
	* 1.194. [976 Middle of the Linked List](#MiddleoftheLinkedList-1)
	* 1.195. [977 Squares of a Sorted Array](#SquaresofaSortedArray)
	* 1.196. [978. 最长湍流子数组 Longest Turbulent Subarray](#LongestTurbulentSubarray)
	* 1.197. [980. Unique Paths III](#UniquePathsIII)
	* 1.198. [983 【动态🚀规划 + 背包 + 递归】Minimum Cost For Tickets](#MinimumCostForTickets)
	* 1.199. [986 Interval List Intersections](#IntervalListIntersections)
	* 1.200. [987 Vertical Order Traversal of a Binary](#VerticalOrderTraversalofaBinary)
	* 1.201. [990. 【🍒并查集】等式方程的可满足性 Satisfiability of Equality Equations](#SatisfiabilityofEqualityEquations)
	* 1.202. [992 【滑动窗口🔹】K 个不同整数的子数组](#K)
	* 1.203. [993. 二叉树的堂兄弟节点](#-1)
	* 1.204. [994-腐烂的橘子](#-1)
	* 1.205. [993, 994, 995, 996](#-1)
	* 1.206. [997 Find the Town Judge](#FindtheTownJudge)
	* 1.207. [1000. Minimum Cost to Merge Stones](#MinimumCosttoMergeStones)
	* 1.208. [1001 Grid Illumination](#GridIllumination)
	* 1.209. [1004-最大连续1的个数 III](#III)
	* 1.210. [1007 Minimum Domino Rotations For Eq](#MinimumDominoRotationsForEq)
	* 1.211. [1008 Construct Binary Search Tree from](#ConstructBinarySearchTreefrom)
	* 1.212. [1009 Complement of Base 10 Integer](#ComplementofBase10Integer)
	* 1.213. [1010 Pairs of Songs With Total Durations](#PairsofSongsWithTotalDurations)
	* 1.214. [1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ](#PartitionArrayIntoThreePartsWithEqu)
	* 1.215. [1015 Smallest Integer Divisible by K](#SmallestIntegerDivisiblebyK)
	* 1.216. [1019. Next Greater Node In Linked List](#NextGreaterNodeInLinkedList)
	* 1.217. [1022 Sum of Root To Leaf Binary Numbers](#SumofRootToLeafBinaryNumbers)
	* 1.218. [1025,1026,1027,1028](#-1)
	* 1.219. [1024. Video Stitching](#VideoStitching)
	* 1.220. [1026 Maximum Difference Between Nod](#MaximumDifferenceBetweenNod)
	* 1.221. [1029 Two City Scheduling](#TwoCityScheduling)
	* 1.222. [1032 Stream of Characters](#StreamofCharacters)
	* 1.223. [1035 Uncrossed Lines](#UncrossedLines)
	* 1.224. [1041 Robot Bounded In Circle](#RobotBoundedInCircle)
	* 1.225. [1043. Partition Array for Maximum Sum](#PartitionArrayforMaximumSum)
	* 1.226. [1044 Longest Duplicate Substring](#LongestDuplicateSubstring)
	* 1.227. [1046 Last Stone Weight](#LastStoneWeight)
	* 1.228. [1048 Longest String Chain](#LongestStringChain)
	* 1.229. [1055.Shortest Way to Form String 形成字符串的最短路径](#ShortestWaytoFormString)
	* 1.230. [1091-二进制矩阵中的最短路径](#-1)
	* 1.231. [1094 Car Pooling](#CarPooling)
	* 1.232. [1095. Find in Mountain Array](#FindinMountainArray)
	* 1.233. [1105. Filling Bookcase Shelves](#FillingBookcaseShelves)
	* 1.234. [1106. Parsing A Boolean Expression](#ParsingABooleanExpression)
	* 1.235. [1110. Delete Nodes And Return Forest](#DeleteNodesAndReturnForest)
	* 1.236. [1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses](#MaximumNestingDepthofTwoValidParentheses)
	* 1.237. [1114 - 1115 - 1116 - 多线程 threading](#threading)
	* 1.238. [1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖](#LowestCommonAncestorofDeepestLeaves)
	* 1.239. [1124. Longest Well-Performing Interval](#LongestWell-PerformingInterval)
	* 1.240. [1125. Smallest Sufficient Team](#SmallestSufficientTeam)
	* 1.241. [1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs](#NumberofEquivalentDominoPairs)
	* 1.242. [1129. Shortest Path with Alternating Colors](#ShortestPathwithAlternatingColors)
	* 1.243. [1137. N-th Tribonacci Number](#N-thTribonacciNumber)
	* 1.244. [1140. Stone Game II](#StoneGameII)
	* 1.245. [1143 【二维动态🚀规划】Longest Common Subsequence](#LongestCommonSubsequence)
		* 1.245.1. [类似题目：516最长回文子序列](#516)
	* 1.246. [1145. Binary Tree Coloring Game](#BinaryTreeColoringGame)
	* 1.247. [1155. Number of Dice Rolls With Target Sum](#NumberofDiceRollsWithTargetSum)
	* 1.248. [1160. 拼写单词 Find Words That Can Be Formed by Characters](#FindWordsThatCanBeFormedbyCharacters)
	* 1.249. [1172. Dinner Plate Stacks](#DinnerPlateStacks)
	* 1.250. [1178. Number of Valid Words for Each Puzzle](#NumberofValidWordsforEachPuzzle)
	* 1.251. [1187. Make Array Strictly Increasing](#MakeArrayStrictlyIncreasing)
	* 1.252. [1191. K-Concatenation Maximum Sum](#K-ConcatenationMaximumSum)
	* 1.253. [1201. Ugly Number III](#UglyNumberIII)
	* 1.254. [1202. 【🍒并查集】Smallest String With Swaps](#SmallestStringWithSwaps)
	* 1.255. [1203. 项目管理 Sort Items by Groups Respecting Dependencies](#SortItemsbyGroupsRespectingDependencies)
	* 1.256. [1206. Design Skiplist](#DesignSkiplist)
	* 1.257. [1209 Remove All Adjacent Duplicates in](#RemoveAllAdjacentDuplicatesin)
	* 1.258. [1217 Minimum Cost to Move Chips](#MinimumCosttoMoveChips)
	* 1.259. [1218. Longest Arithmetic Subsequence of Given Difference](#LongestArithmeticSubsequenceofGivenDifference)
	* 1.260. [1220. Count Vowels Permutation](#CountVowelsPermutation)
	* 1.261. [1223 Dice Roll Simulation](#DiceRollSimulation)
	* 1.262. [1240 Tiling a Rectangle with the Fewest Squares](#TilingaRectanglewiththeFewestSquares)
	* 1.263. [1248-统计「优美子数组」](#-1)
	* 1.264. [1249 Minimum Remove to Make Valid Pare](#MinimumRemovetoMakeValidPare)
	* 1.265. [1252 1253 1254 1255](#-1)
	* 1.266. [1263. Minimum Moves to Move a Box to Their Target](#MinimumMovestoMoveaBoxtoTheirTarget)
	* 1.267. [1277. 【二维动态🚀规划】统计全为1的正方形子矩阵](#-1)
	* 1.268. [1278. Palindrome Partitioning III](#PalindromePartitioningIII)
	* 1.269. [1283 Find the Smallest Divisor Given a](#FindtheSmallestDivisorGivena)
	* 1.270. [1284. Minimum Number of Flips to Convert Binary Matrix](#MinimumNumberofFlipstoConvertBinaryMatrix)
	* 1.271. [1290. 二进制链表转整数 (Convert Binary Number in a Linked List](#ConvertBinaryNumberinaLinkedList)
	* 1.272. [1291 Sequential Digits](#SequentialDigits)
	* 1.273. [1293. Shortest Path in a Grid with Obstacles Elimination](#ShortestPathinaGridwithObstaclesElimination)
	* 1.274. [1296. Divide Array in Sets of K Consecutive Numbers](#DivideArrayinSetsofKConsecutiveNumbers)
	* 1.275. [1301. Number of Paths with Max Score](#NumberofPathswithMaxScore)
	* 1.276. [1302 Deepest Leaves Sum](#DeepestLeavesSum)
	* 1.277. [1305 All Elements in Two Binary Search](#AllElementsinTwoBinarySearch)
	* 1.278. [1306 Jump Game III](#JumpGameIII)
	* 1.279. [1310. XOR Queries of a Subarray](#XORQueriesofaSubarray)
	* 1.280. [1312. Minimum Insertion Steps to Make a String Palindrom](#MinimumInsertionStepstoMakeaStringPalindrom)
	* 1.281. [1319. 【🍒并查集】Number of Operations to Make Network Connected](#NumberofOperationstoMakeNetworkConnected)
	* 1.282. [1320. Minimum Distance to Type a Word Using Two Finger](#MinimumDistancetoTypeaWordUsingTwoFinger)
	* 1.283. [1329 Sort the Matrix Diagonally](#SorttheMatrixDiagonally)
	* 1.284. [1332 Remove Palindromic Subsequences](#RemovePalindromicSubsequences)
	* 1.285. [1334. 【Dijkstra🚗】Find the City With Smallest Number of Neighbors](#DijkstraFindtheCityWithSmallestNumberofNeighbors)
	* 1.286. [1335. Minimum Difficulty of a Job Schedule](#MinimumDifficultyofaJobSchedule)
	* 1.287. [1337 The K Weakest Rows in a Matrix](#TheKWeakestRowsinaMatrix)
	* 1.288. [1339 Maximum Product of Splitt](#MaximumProductofSplitt)
	* 1.289. [1340. 【动态🚀规划】Jump Game V](#JumpGameV)
	* 1.290. [1349. Maximum Students Taking Exam](#MaximumStudentsTakingExam)
	* 1.291. [1353. Maximum Number of Events That Can Be Attended](#MaximumNumberofEventsThatCanBeAttended)
	* 1.292. [1354. Construct Target Array With Multiple Sums](#ConstructTargetArrayWithMultipleSums)
	* 1.293. [1368. 【Dijkstra🚗】Minimum Cost to Make at Least One Valid Path](#DijkstraMinimumCosttoMakeatLeastOneValidPath)
	* 1.294. [1371. Find the Longest Substring Containing Vowels in Eve](#FindtheLongestSubstringContainingVowelsinEve)
	* 1.295. [1373. Maximum Sum BST in Binary Tree](#MaximumSumBSTinBinaryTree)
	* 1.296. [1377. Frog Position After T Seconds](#FrogPositionAfterTSeconds)
	* 1.297. [1379 Find Corresponding Node of Binary Tree in a Clone](#FindCorrespondingNodeofBinaryTreeinaClone)
	* 1.298. [1382. Balance a Binary Search Tree](#BalanceaBinarySearchTree)
	* 1.299. [1395. Count Number of Teams](#CountNumberofTeams)
	* 1.300. [1396 Design Underground System](#DesignUndergroundSystem)
	* 1.301. [1406. Stone Game III](#StoneGameIII)
	* 1.302. [1409. Queries on a Permutation With Key](#QueriesonaPermutationWithKey)
	* 1.303. [1416. Restore The Array](#RestoreTheArray)
	* 1.304. [1424. Diagonal Traverse II](#DiagonalTraverseII)
	* 1.305. [1425. Constrained Subset Sum](#ConstrainedSubsetSum)
	* 1.306. [1426  Counting Elements](#CountingElements)
	* 1.307. [1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie](#KidsWiththeGreatestNumberofCandie)
	* 1.308. [1437 Check If All 1's Are at Least Length](#CheckIfAll1sAreatLeastLength)
	* 1.309. [1438. Longest Continuous Subarray With Absolute](#LongestContinuousSubarrayWithAbsolute)
	* 1.310. [1441 Build an Array With Stack Operations](#BuildanArrayWithStackOperations)
	* 1.311. [1442. Count Triplets That Can Form Two Arrays of Equal](#CountTripletsThatCanFormTwoArraysofEqual)
	* 1.312. [1443. Minimum Time to Collect All Apples in a Tree](#MinimumTimetoCollectAllApplesinaTree)
	* 1.313. [1444. 【二维动态🚀规划 + 前缀和🎨 + 递归】Number of Ways of Cutting a Pizza](#NumberofWaysofCuttingaPizza)
	* 1.314. [1446 Consecutive Characters](#ConsecutiveCharacters)
	* 1.315. [1448 Count Good Nodes in Binary Tree](#CountGoodNodesinBinaryTree)
	* 1.316. [1449. 【背包 + 动态🚀规划】Form Largest Integer With Digits That Add](#FormLargestIntegerWithDigitsThatAdd)
	* 1.317. [1451 Rearrange Words in a Sentence](#RearrangeWordsinaSentence)
	* 1.318. [1453 Maximum Number of Darts Inside of a Circular Dartb](#MaximumNumberofDartsInsideofaCircularDartb)
	* 1.319. [1457 Pseudo-Palindromic Paths in a Bin](#Pseudo-PalindromicPathsinaBin)
	* 1.320. [1461 Check If a String Contains All Binar](#CheckIfaStringContainsAllBinar)
	* 1.321. [1463 Cherry Pickup II](#CherryPickupII)
	* 1.322. [1473. Paint House III](#PaintHouseIII)
	* 1.323. [1475. Final Prices With a Special Discount in a Sho](#FinalPricesWithaSpecialDiscountinaSho)
	* 1.324. [1483. Kth Ancestor of a Tree Node](#KthAncestorofaTreeNode)
	* 1.325. [1488. Avoid Flood in The City](#AvoidFloodinTheCity)
	* 1.326. [1489. 【🍒并查集】Find Critical and Pseudo-Critical Edges in](#FindCriticalandPseudo-CriticalEdgesin)
	* 1.327. [1492 The kth Factor of n](#ThekthFactorofn)
	* 1.328. [1493. Longest Subarray of 1's After Deleting One](#LongestSubarrayof1sAfterDeletingOne)
	* 1.329. [1499. Max Value of Equation](#MaxValueofEquation)
	* 1.330. [1502 Can Make Arithmetic Progression From Sequence](#CanMakeArithmeticProgressionFromSequence)
	* 1.331. [1503 Last Moment Before All Ants Fall Out of a Plank](#LastMomentBeforeAllAntsFallOutofaPlank)
	* 1.332. [1505. Minimum Possible Integer After at Most K Adjacent](#MinimumPossibleIntegerAfteratMostKAdjacent)
	* 1.333. [1508. Range Sum of Sorted Subarray Sums](#RangeSumofSortedSubarraySums)
	* 1.334. [1510 Stone Game IV](#StoneGameIV)
	* 1.335. [1514 【Dijkstra🚗】Path with Maximum Probability](#DijkstraPathwithMaximumProbability)
	* 1.336. [1515 Best Position for a Service Centre](#BestPositionforaServiceCentre)
	* 1.337. [1520. Maximum Number of Non-Overlapping Substrings](#MaximumNumberofNon-OverlappingSubstrings)
	* 1.338. [1530. Number of Good Leaf Nodes Pairs](#NumberofGoodLeafNodesPairs)
	* 1.339. [1531. String Compression II](#StringCompressionII)
	* 1.340. [1534 Count Good Triplets](#CountGoodTriplets)
	* 1.341. [1535 Find the Winner of an Array Game](#FindtheWinnerofanArrayGame)
	* 1.342. [1537. Get the Maximum Score](#GettheMaximumScore)
	* 1.343. [1539. Kth Missing Positive Number](#KthMissingPositiveNumber)
	* 1.344. [1542. Find Longest Awesome Substring](#FindLongestAwesomeSubstring)
	* 1.345. [1546. Maximum Number of Non-Overlapping Subarrays With Sum](#MaximumNumberofNon-OverlappingSubarraysWithSum)
	* 1.346. [1550. Three Consecutive Odds](#ThreeConsecutiveOdds)
	* 1.347. [1551 Minimum Operations to Make Array](#MinimumOperationstoMakeArray)
	* 1.348. [1553. Minimum Number of Days to Eat N Oranges](#MinimumNumberofDaystoEatNOranges)
	* 1.349. [1556. Thousand Separator](#ThousandSeparator)
	* 1.350. [1558. Minimum Numbers of Function Calls to Make Target](#MinimumNumbersofFunctionCallstoMakeTarget)
	* 1.351. [1563. Stone Game V](#StoneGameV)
	* 1.352. [1569. Number of Ways to Reorder Array to Get Sa](#NumberofWaystoReorderArraytoGetSa)
	* 1.353. [1573. Number of Ways to Split a String](#NumberofWaystoSplitaString)
	* 1.354. [1585. Check If String Is Transformable With](#CheckIfStringIsTransformableWith)
	* 1.355. [1593. Split a String Into the Max Number of Unique Substri](#SplitaStringIntotheMaxNumberofUniqueSubstri)
	* 1.356. [1595. Minimum Cost to Connect Two Groups of Points](#MinimumCosttoConnectTwoGroupsofPoints)
	* 1.357. [1621. Number of Sets of K Non-Overlapping Line](#NumberofSetsofKNon-OverlappingLine)
	* 1.358. [1631. 【Dijkstra🚗 + 最小堆🌵】Path With Minimum Effort](#DijkstraPathWithMinimumEffort)
	* 1.359. [1632 Rank Transform of a Matrix](#RankTransformofaMatrix)
	* 1.360. [1640 Check Array Formation Through](#CheckArrayFormationThrough)
	* 1.361. [1641 Count Sorted Vowel Strings](#CountSortedVowelStrings)
	* 1.362. [1642. Furthest Building You Can Reach](#FurthestBuildingYouCanReach)
	* 1.363. [1646 Get Maximum in Generated Array](#GetMaximuminGeneratedArray)
	* 1.364. [1648. Sell Diminishing-Valued Colored Balls](#SellDiminishing-ValuedColoredBalls)
	* 1.365. [1649 Create Sorted Array through Instru](#CreateSortedArraythroughInstru)
	* 1.366. [1655. Distribute Repeating Integers](#DistributeRepeatingIntegers)
	* 1.367. [1657 Determine if Two Strings Are Close](#DetermineifTwoStringsAreClose)
	* 1.368. [1658 Minimum Operations to Reduce X](#MinimumOperationstoReduceX)
	* 1.369. [1659. Maximize Grid Happiness](#MaximizeGridHappiness)
	* 1.370. [1662 Check If Two String Arrays are Equi](#CheckIfTwoStringArraysareEqui)
	* 1.371. [1663 Smallest String With A Given Numer](#SmallestStringWithAGivenNumer)
	* 1.372. [1673 Find the Most Competitive Subseq](#FindtheMostCompetitiveSubseq)
	* 1.373. [1674. Minimum Moves to Make Array Complement](#MinimumMovestoMakeArrayComplement)
	* 1.374. [1675. Minimize Deviation in Array](#MinimizeDeviationinArray)
	* 1.375. [1679 Max Number of K-Sum Pairs】](#MaxNumberofK-SumPairs)
	* 1.376. [1680 Concatenation of Consecutive Bina](#ConcatenationofConsecutiveBina)
	* 1.377. [1681. Minimum Incompatibility](#MinimumIncompatibility)
	* 1.378. [1690. Stone Game VII](#StoneGameVII)
	* 1.379. [1696. 【动态🚀规划 O(n-k) * 优先队列 O(1) + 最小堆🌵】 Jump Game VI](#On-kO1JumpGameVI)
	* 1.380. [1704 Determine if String Halves Are Alike](#DetermineifStringHalvesAreAlike)
	* 1.381. [1707. Maximum XOR With an Element From Array](#MaximumXORWithanElementFromArray)
	* 1.382. [1713. Minimum Operations to Make a Subsequence](#MinimumOperationstoMakeaSubsequence)
	* 1.383. [1721 Swapping Nodes in a Linked List](#SwappingNodesinaLinkedList)
	* 1.384. [1727. Largest Submatrix With Rearrangements](#LargestSubmatrixWithRearrangements)
	* 1.385. [1745. Palindrome Partitioning IV](#PalindromePartitioningIV)
	* 1.386. [1760. Minimum Limit of Balls in a Bag](#MinimumLimitofBallsinaBag)
	* 1.387. [1770. Maximum Score from Performing Multiplication](#MaximumScorefromPerformingMultiplication)
	* 1.388. [1771. Maximize Palindrome Length From Subsequences](#MaximizePalindromeLengthFromSubsequences)
	* 1.389. [1775. Equal Sum Arrays With Minimum Number of Operatio](#EqualSumArraysWithMinimumNumberofOperatio)
	* 1.390. [1786. 【Dijkstra🚗】 Number of Restricted Paths From First to Last Node](#DijkstraNumberofRestrictedPathsFromFirsttoLastNode)
	* 1.391. [1792. Maximum Average Pass Ratio](#MaximumAveragePassRatio)
	* 1.392. [1799. Maximize Score After N Operations](#MaximizeScoreAfterNOperations)
	* 1.393. [1815. Maximum Number of Groups Getting Fresh Donuts](#MaximumNumberofGroupsGettingFreshDonuts)
	* 1.394. [1838. Frequency of the Most Frequent Element](#FrequencyoftheMostFrequentElement)
	* 1.395. [1847. Closest Room](#ClosestRoom)
	* 1.396. [1872. Stone Game VIII](#StoneGameVIII)
	* 1.397. [ 1976. 【Dijkstra🚗】到达目的地的方案数](#1976.Dijkstra)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
##  1. <a name='500'></a>题目500+

###  1.1. <a name='KeyboardRow'></a>500. Keyboard Row

[小梦想家](https://www.bilibili.com/video/BV1vJ411X7BR?spm_id_from=333.999.0.0)

###  1.2. <a name='NextGreaterElementII'></a>503 【栈】Next Greater Element II

[哈哈哈](https://www.bilibili.com/video/BV197411L77N?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1k5411t7Pa?spm_id_from=333.999.0.0)


```py
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = nums[:]
        stack = []
        for idx, cur in sorted(enumerate(nums),key = lambda x: x[1]):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            stack.append(idx)
        
        while stack:
            res[stack[-1]] = -1
            stack.pop()
        
        return res
        
# 哭，我又理解错题目了
# 输入：
# [5,4,3,2,1]
# 输出：
# [-1,5,4,3,2]
# 预期结果：
# [-1,5,5,5,5]
```

```py
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = nums[:]
        stack = []
        # 双倍nums大法好
        for idx, cur in enumerate(nums + nums):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            if idx < len(nums): # 易错点：append(idx)是有条件的
                stack.append(idx)
        
        while stack:
            res[stack[-1]] = -1
            stack.pop()
        
        return res

更简单的写法:

class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        res = [-1] * len(nums)
        stack = []
        # 双倍nums大法好
        for idx, cur in enumerate(nums + nums):
            while stack and nums[stack[-1]] < cur:
                res[stack[-1]] = cur
                stack.pop()
            if idx < len(nums): # 易错点：append(idx)是有条件的
                stack.append(idx)
        return res


```



###  1.3. <a name='Base7'></a>504-Base 7

[哈哈哈](https://www.bilibili.com/video/BV1pj411f7o5?spm_id_from=333.999.0.0)

###  1.4. <a name='FibonacciNumber'></a>509. 【动态🚀规划 + 递归】Fibonacci Number

[1:30 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV15y4y147Re?spm_id_from=333.999.0.0)

```py
class Solution:
    def fib(self, n: int) -> int:
        a, b = 0, 1
        for i in range(n): 
            a, b = b, a + b # py的单行更新值
    	return a


# 递归实现
class Solution:
    @lru_cache
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)

    
class Solution:
    @cache
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)

# 记忆化递归
class Solution:
    def fib(self, n: int) -> int:
        dic = {}
        dic[0] = 0
        dic[1] = 1

        def helper(n):
            # 这个写法是错误的：if n == 0 or 1:
            if n <= 1:
                return n
            elif n in dic:
                return dic[n]
            else:
                dic[n] = helper(n - 1) + helper(n - 2)
                return dic[n]
        return helper(n)
```

```scala
/**
* chosen solution
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution0 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* iterative - bottom up with memorization
* time complexity O(N)
* space complexity O(N)
*/

object Solution1 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1
        (2 to N).foreach(n => cache(n) = cache(n -1) + cache(n -2))
        cache(N)
    }
}

/**
* iterative - bottom up with memorization
* only record n -1 and n -2 status
* time complexity O(N)
* space complexity O(1)
*/ 
object Solution1-2 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
            var a = 0
            var b = 1
            (1 until N).foreach{ n =>
                val c = a + b
                a = b
                b = c
            }
            b
        }
    }
}

/**
* recursive - top-down with memorization
* time complexity: O(N)
* space complexity: O(N)
*/
object Solution2 {
    def fib(N: Int): Int = {
        if(N <= 1) return N
        
        val cache = Array.ofDim[Int](N + 1)
        cache(0) = 0
        cache(1) = 1

        def _fib(n: Int):Int = {
            if(n <= 1) return n
            
            if(cache(n) != 0) cache(n)
            else {
                cache(n) = _fib(n-1) + _fib(n-2)
                cache(n)
            }
        }
        _fib(N)
        
    }
}



/**
* recursive version - top-down
* time complexity: O(2^N）
* space complexity: O(N)
*/

object Solution3 {
    def fib(N: Int): Int = {
        if (N <= 1) N
        else {
           fib(N - 1) + fib(N - 2)
        }
    }
}


```

###  1.5. <a name='LongestPalindromicSubsequence'></a>516. 【回文】【动态🚀规划】Longest Palindromic Subsequence

####  1.5.1. <a name='1143.'></a>类似题目：1143. 最长公共子序列

[花花酱](https://www.bilibili.com/video/BV18W411d7k2?spm_id_from=333.999.0.0)

```py
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        #dp 最长回文串个数
        n = len(s)
        #if not s or n < 2: return n

        dp = [[0] * n for _ in range(n)]
        for i in range(n):  # 从左 右 左下 计算：
            dp[i][i] = 1
        
        for stt in range(n-1,-1,-1):  # 不同的状态转移对应不同的loop
            for end in range(stt + 1, n): #[i,j]
                if s[stt] == s[end]:
                    dp[stt][end] = dp[stt+1][end-1] + 2
                else:
                    dp[stt][end] = max(dp[stt+1][end], dp[stt][end-1])
                    # 因为可以删除字符,所以可以像这样直接传递
        
        #print(dp)
        return dp[0][-1]
```

###  1.6. <a name='CoinChange2'></a>518 Coin Change 2

[小明](https://www.bilibili.com/video/BV1jC4y1a7YT?spm_id_from=333.999.0.0)

###  1.7. <a name='DetectCapital'></a>520. Detect Capital

[小梦想家](https://www.bilibili.com/video/BV1NJ41197da?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xT4y1j7G4?spm_id_from=333.999.0.0)

```py
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        # 若第 1 个字母为小写，则需额外判断第 2 个字母是否为小写
        if len(word) >= 2 and word[0].islower() and word[1].isupper():
            return False
        
        # 无论第 1 个字母是否大写，其他字母必须与第 2 个字母的大小写相同
        return all(word[i].islower() == word[1].islower() for i in range(2, len(word)))

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/detect-capital/solution/jian-ce-da-xie-zi-mu-by-leetcode-solutio-449z/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python3: 如果只有一个字母，返回true；如果全是大写，返回true，否则返回除了首字母外的字母是不是全是小写。

class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if len(word) == 1:
            return True
        if word.isupper():
            return True
        else:
            return word[1:].islower()
```

```py
嘻嘻，这应该是目前为止最简单的一题了

class Solution(object):
    def detectCapitalUse(self, word):
        """
        :type word: str
        :rtype: bool
        """
        if word == word.upper() or word == word.lower() or word == word.title():
            return True
        else:
            return False


class Solution:
    def detectCapitalUse(self, word: str) -> bool:
            return word.islower() or word.isupper() or word.istitle()
```

###  1.8. <a name='ContiguousArray'></a>525. 【前缀和🎨】Contiguous Array

[花花酱](https://www.bilibili.com/video/BV14W411d7SD?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV185411t7tu?spm_id_from=333.999.0.0)

```py
0变-1是精髓，sum_dct = {0:-1}是细节。

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        sum_dct = {0:-1}
        temp,res = 0,0
        for i in range(len(nums)):
            if nums[i] == 0:
                temp += -1
            else:
                temp += 1
            if temp not in sum_dct:
                sum_dct[temp] = i
            else:
                res = max(res,i-sum_dct[temp])
        return res
```

```py
说一下心路历程。

错误思路1：开始我以为是一个栈的思路，遇到0就push，1就pop，

然后什么时候stack空了就行了。 后来发现这个思路是错的，因为1）

如果1比0多久pop不出去了，2）这种思路只考虑到从第0位开始的子数组

错误思路2：因此我想到构建两个list，分别存1和0，比较什么时候上下两个数组len一样，

然后返回两个list长度总和，的这种方法只能解决上面提到的1）问题

正确思路： 转而我想到，竟然是栈的思维，何必用一个真的栈，

只要记录栈里面的元素数量即可（0push，1pop） 

因此我构建了一个记录栈长度数量的list，然后发现这玩意不说就是前缀和的思路嘛。 

然后我借鉴错误思路2的点，需要记录长度的话，

就是当栈里元素数量相等的时候，保留上下标（或者保留最大长度）， 最后找一下最大长度即可

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:        
        preSum = [0]
        presum_index = {0:[-1,-1]}
        for i in range(len(nums)):
            preSum.append(preSum[i]+1 if nums[i] == 1 else preSum[i]-1)
            presum_index[preSum[-1]] = presum_index.get(preSum[-1],[i,i])
            presum_index[preSum[-1]][1] = i
        res = 0
        for v in presum_index.values():
            res = max(v[1] - v[0],res)
        return res

然后，我去看了一下我的历史提交记录，发现这题我一年前解过，而且解法竟然比现在好。。。。。。这一年完全没有进步

一年前的代码:

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        front_hash = {}
        front_hash[0] = -1
        res = 0
        s = 0
        for i in range(len(nums)):
            s += 1 if nums[i] == 1 else -1
            if s in front_hash:
                res = max(res, i - front_hash[s])
            else:
                front_hash[s] = i
        return res

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        res = 0
        hmap = {0: -1}
        prefix = 0
        for index, num in enumerate(nums):
            if num == 0:
                prefix -= 1
            else:
                prefix += 1
            hmap[prefix] = hmap.get(prefix, index)
            res = max(res, index - hmap[prefix])
        return res
```


###  1.9. <a name='BeautifulArrangement'></a>526 Beautiful Arrangement

[小明](https://www.bilibili.com/video/BV1DK411M7QR?spm_id_from=333.999.0.0)

###  1.10. <a name='RandomPickwithWeight'></a>528 Random Pick with Weight

[小明](https://www.bilibili.com/video/BV1UV411r7MK?spm_id_from=333.999.0.0)

###  1.11. <a name='MinimumAbsoluteDifferenceinBST'></a>530. Minimum Absolute Difference in BST

[花花酱](https://www.bilibili.com/video/BV1fW411k7eT?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1FJ41147BB?spm_id_from=333.999.0.0)

```py
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        inorder = []
        def dfs(root):
            nonlocal inorder
            if not root:
                return 
            dfs(root.left)
            inorder.append(root.val)
            dfs(root.right) 
        dfs(root)
        return min([inorder[i]-inorder[i-1] for i in range(1,len(inorder))])

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        
        def inorder(node):
            if node:
                yield from inorder(node.left)
                yield node.val
                yield from inorder(node.right)

        pre, cur = tee(inorder(root))
        next(cur, None)
        return min(b-a for a, b in zip(pre, cur))
```

```py
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        self.res = float('inf')
        self.tmp = -1
        def dfs(root):
            if not root:
                return
            dfs(root.left)
            if self.tmp == -1:
                self.tmp = root.val
            else:
                self.res = min(self.res, abs(root.val - self.tmp))
                self.tmp = root.val
            dfs(root.right)
        dfs(root)
        return self.res

递归

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        ret = inf
        pre = None
        def dfs(node):
            nonlocal ret, pre
            if not node: return   
            dfs(node.left)
            if pre != None: ret = min(node.val - pre, ret)             
            pre = node.val
            dfs(node.right)                
        dfs(root)       
        return ret

class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        """解题思路：二叉搜索树的中序遍历是一个递增且无重复元素的序列"""
        path = []
        min_ = float('INF')  

        def traval(root):  # 中序遍历
            nonlocal path
            if not root: return

            traval(root.left)
            path.append(root.val)
            traval(root.right)

        
        traval(root)
        result = list(zip(path, path[1:]))   # 窗口大小为2，步长为1
        for i, j in result:
            if abs(j - i) < min_:
                min_ = abs(j - i)
        
        return min_
```

###  1.12. <a name='K-diffPairsinanArray'></a>532 K-diff Pairs in an Array

[小明](https://www.bilibili.com/video/BV1MV41127o1?spm_id_from=333.999.0.0)

###  1.13. <a name='EncodeandDecodeTinyURL'></a>535. Encode and Decode TinyURL

[小梦想家](https://www.bilibili.com/video/BV1hb411e7zp?spm_id_from=333.999.0.0)

###  1.14. <a name='ComplexNumberMultiplicatin'></a>537 Complex Number Multiplicatin

[小明](https://www.bilibili.com/video/BV1sP4y1p7Px?spm_id_from=333.999.0.0)

###  1.15. <a name='ConvertBSTtoGreaterTree'></a>538 Convert BST to Greater Tree

[小明](https://www.bilibili.com/video/BV1k541177bt?spm_id_from=333.999.0.0)

###  1.16. <a name='SingleElementinaSortedArray540-'></a>540. Single Element in a Sorted Array 540-有序数组中的单一元素

[花花酱](https://www.bilibili.com/video/BV1gW411y7N3?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1P64y1F7cd?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Tg4y1B7Va?spm_id_from=333.999.0.0)

```py
def singleNonDuplicate(self, nums: List[int]) -> int:
    for i in range(0, len(nums) - 2, 2):
        if nums[i] != nums[i + 1]:
            return nums[i]
    return nums[-1]

作者：LeetCode
链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def singleNonDuplicate(self, nums: List[int]) -> int:
    lo = 0
    hi = len(nums) - 1   
    while lo < hi:
        mid = lo + (hi - lo) // 2
        halves_are_even = (hi - mid) % 2 == 0
        if nums[mid + 1] == nums[mid]:
            if halves_are_even:
                lo = mid + 2
            else:
                hi = mid - 1
        elif nums[mid - 1] == nums[mid]:
            if halves_are_even:
                hi = mid - 2
            else:
                lo = mid + 1
        else:
            return nums[mid]
    return nums[lo]

作者：LeetCode
链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

def singleNonDuplicate(self, nums: List[int]) -> int:
    lo = 0
    hi = len(nums) - 1
    while lo < hi:
        mid = lo + (hi - lo) // 2
        if mid % 2 == 1:
            mid -= 1
        if nums[mid] == nums[mid + 1]:
            lo = mid + 2
        else:
            hi = mid
    return nums[lo]

作者：LeetCode
链接：https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/you-xu-shu-zu-zhong-de-dan-yi-yuan-su-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

这题一看就是考异或嘛，数组直接全部取异或就行了

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        t = nums[0]
        for i in range(1,len(nums)):
            t ^= nums[i]
        return t

异或的时间复杂度不符合要求啊
```

```py
二分法

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l, r = 0, len(nums)-1
        while l < r:
            m = l+((r-l) >> 1)
            if m % 2 == 1:
                m -= 1
            if nums[m] == nums[m+1]:
                l = m+2
            else:
                r = m-1
        return nums[l]
```

###  1.17. <a name='Matrix'></a>542. 01 矩阵 01 Matrix 

[官方](https://www.bilibili.com/video/BV1cZ4y1s727?spm_id_from=333.999.0.0)

###  1.18. <a name='DiameterofBinaryTree'></a>543 Diameter of Binary Tree

[小明](https://www.bilibili.com/video/BV12K4y1r78T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1qA411t7LR?spm_id_from=333.999.0.0)

```py
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 1
        def depth(node):
            # 访问到空节点了，返回0
            if not node:
                return 0
            # 左儿子为根的子树的深度
            L = depth(node.left)
            # 右儿子为根的子树的深度
            R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
            self.ans = max(self.ans, L + R + 1)
            # 返回该节点为根的子树的深度
            return max(L, R) + 1

        depth(root)
        return self.ans - 1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        max_len = 0
        def recur_func(root):
            nonlocal max_len
            if not root: return 0
            l_len = recur_func(root.left)
            r_len = recur_func(root.right)
            max_len = max(max_len, l_len + r_len)
            return max(l_len, r_len) + 1  # 每次返回左子树和右子树中长度最长的路径长度
            # 无论从左孩子返回还是右孩子返回，长度都要加1

        recur_func(root)
        return max_len

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        if not root:
            return 0
        self.res=0 #存储最长直径
        def dfs(root:TreeNode):# 记录每一个子树的深度
            if not root:
                return 0
            l= dfs(root.left)
            r= dfs(root.right)
            self.res=max(self.res,l+r)#存储当前节点与之前遍历节点的最长路径
            return max(l,r)+1 #返回当前子树的最长深度
        dfs(root)
        return self.res
```

```py
测试用例感觉有点问题,空树的路径定义为-1比较好

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
            def dfs(root):
                if not root:
                    return -1
                l,r=dfs(root.left),dfs(root.right)
                self.ans=max(self.ans,l+r+2)
                return max(l,r)+1
            self.ans=0
            dfs(root)
            return self.ans

类属性变量用的妙！
```

###  1.19. <a name='RemoveBoxes'></a>546 Remove Boxes

[花花酱](https://www.bilibili.com/video/BV11W411Z7jG?spm_id_from=333.999.0.0)

###  1.20. <a name=''></a>547 【🍒并查集 + dfs + 队列】朋友圈

[哈哈哈](https://www.bilibili.com/video/BV1Ta411F7rk?spm_id_from=333.999.0.0)

[郭郭](https://www.bilibili.com/video/BV1eX4y157jr?from=search&seid=13286624680279107242&spm_id_from=333.337.0.0)

🍒并查集

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def find(i: int) -> int:
            if parent[i] != i:
                parent[i] = find(parent[i])
            return parent[i]
        
        def union(i: int, j: int):
            parent[find(i)] = find(j)
        
        proN = len(isConnected)
        parent = list(range(proN))
        
        for i in range(proN):
            for j in range(i + 1, proN):
                if isConnected[i][j] == 1:
                    union(i, j)
        
        res = sum(parent[i] == i for i in range(proN))
        # 求出 i 就是 parent 的总和
        return res
```

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def dfs(i: int):
            for j in range(proN):
                if isConnected[i][j] == 1 and j not in visited:
                    visited.add(j)
                    dfs(j)
        
        proN = len(isConnected)
        visited = set()
        res = 0

        for i in range(proN):
            if i not in visited:
                dfs(i)
                res += 1
        
        return res
```

```py
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        proN = len(isConnected)
        visited = set()
        res = 0
        
        for i in range(proN):
            if i not in visited:
                peopleQ = collections.deque([i])
                while peopleQ:
                    peo = peopleQ.popleft()
                    visited.add(peo)
                    for fri in range(proN):
                        if isConnected[peo][fri] == 1 and fri not in visited:
                            peopleQ.append(fri)
                res += 1
        
        return res

不用递归，可以实现双100%：

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        candidates = set(range(1, len(isConnected)))
        # candidates就是not visited
        if not candidates:
            return 1
        res = 0
        peopleQ = [0]
        while candidates:
            while peopleQ:
                peo = peopleQ.pop()
                friends = [fri for fri in candidates if isConnected[peo][fri]]
                for i in friends:
                    peopleQ.append(i)
                    candidates.remove(i)
            res += 1
            if candidates:
                peopleQ = [list(candidates)[0]]
        return res
```

```scala


/**
* union & find: implement both union by rank and path compression
* time complexity : 
*   in union & find each op:
*           find: very very close to O(1) amortized
*           union: very very close to O(1) amortized
*   the entire ：
*       O(n + M), n is node size, M is the times we call Union operation which cause O(1) 
*       n (constructor) + M (call union times)
*/

object Solution1 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    unionFind.counter

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)
  var counter = M

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
    counter -= 1
  }
}

/**
* union & find: without counter in union&find to record current cluster
*       O(n + M + n), n is node size, M is the times we call Union operation which cause O(1) 
*       n (construct union & find ) + M (call union times)  + n (n time call findRoot)
*/
object Solution1-2 {
  def findCircleNum(M: Array[Array[Int]]): Int = {
    val unionFind = new UnionFind(M.length)

    for (i <- M.indices; j <- (i + 1) until M.length; if M(i)(j) == 1) {
      unionFind.union(i, j)
    }
    M.indices.map(unionFind.findRoot).distinct.size

  }
}

class UnionFind(M: Int) {
  val roots = Array.tabulate(M)(i => i)
  val rank = Array.tabulate(M)(i => 1)

  def findRoot(i: Int): Int = {

    var root = i
    while (root != roots(root)) {
      roots(root) = roots(roots(root))  // path compression
      root = roots(root)
    }
    root
  }

  def connected(a: Int, b: Int): Boolean = {
    findRoot(a) == findRoot(b)
  }

  def union(a: Int, b: Int) {
    val rootA = findRoot(a)
    val rootB = findRoot(b)

    if(rootA == rootB) return

    // union by rank
    if(rank(rootA) > rank(rootB)) {
      roots(rootB) = rootA
    }else if(rank(rootB) > rank(rootA)){
      roots(rootA) = rootB
    }else { // rank equal case
      roots(rootB) = rootA
      rank(rootA) += 1

    }
  }
}


```

###  1.21. <a name='BrickWall'></a>554 Brick Wall

[小明](https://www.bilibili.com/video/BV1mo4y1f7wc?spm_id_from=333.999.0.0)

###  1.22. <a name='NextGreaterElementIII'></a>556 Next Greater Element III

[小明](https://www.bilibili.com/video/BV19t4y167yb?spm_id_from=333.999.0.0)

###  1.23. <a name='SubarraySumEqualsKK'></a>560. Subarray Sum Equals K 和为K的子数组

[花花酱](https://www.bilibili.com/video/BV1XW411d71i?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1d54y127ri?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1vK4y1k7ku?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV13t4y1y7ya?spm_id_from=333.999.0.0)

```py
方法2 的 hashmap 初始化一开始没想通为啥是 {0: 1}，写成下面的形式感觉就好理解了

其实就是考虑 pre[i] == k 的这种情况

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        counter = dict()
        pre, ans = 0, 0
        for num in nums:
            pre += num
            if pre == k:
                ans += 1
            ans += counter.get(pre - k, 0)
            counter[pre] = counter.get(pre, 0) + 1
        return ans
```

```py
前序和也超时了

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        prefixsum=[0]*(len(nums)+1)
        for i in range(len(nums)):
            prefixsum[i+1] = prefixsum[i] + nums[i]
        count = 0
        for i in range(len(nums)):
            for j in range(i,len(nums)):
                if prefixsum[j+1] - prefixsum[i] == k:
                    count +=1
        return count 

class Solution:
    def subarraySum(self, nums: 'List[int]', k: 'int') -> 'int':
        sum, res, cul = 0, 0, {}
        cul[0] = 1
        for i in range(len(nums)):
            sum += nums[i]
            if sum - k in cul:
                res += cul[sum - k]
            if sum not in cul:
                cul[sum] = 0
            cul[sum] += 1
        return res
```

###  1.24. <a name='BinaryTreeTilt'></a>563 Binary Tree Tilt

[小明](https://www.bilibili.com/video/BV1KV41117ho?spm_id_from=333.999.0.0)

###  1.25. <a name='ArrayNesting'></a>565 【为什么不用🍒并查集？成环的🌈】Array Nesting

[郭郭](https://www.bilibili.com/video/BV11V411e7fv?from=search&seid=16576806175247069118&spm_id_from=333.337.0.0)

```py
class Solution(object):
	def arrayNesting(self, nums):
		r = 0
		for i in xrange(0, len(nums)):
			if nums[i] == -1:
				continue
			usedlist = set({})
			while i not in usedlist:
				usedlist.add(i)
				i = nums[i]
			r = max(r, len(usedlist))
			for i in usedlist:
				nums[i] = -1
		return r
```
题目类似于找最大环的长度

因为没有重复元素，所以每个元素都属于一个环，

每个环只计算一次，每个走过的元素置为-1（也可以置为负数）。

从开头遍历数组，如果该元素为-1则跳过

时间复杂度O（n），空间复杂度O（1）

```py
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums)):
            if nums[i] == -1:
                continue
            temp = 1
            path_index = i
            while nums[path_index] != i:
                nums[path_index], path_index = -1, nums[path_index]
                temp += 1
            nums[path_index] = -1
            res = max(temp, res)
        return res
```

```py
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        # 最大环问题
        # 环问题 快指针走2步, 慢指针走1步

        visited = [False]*len(nums) # 记录是否遍历过
        def measure_len(i):
            fast = slow = i
            ans = 0
            while True:
                fast = nums[nums[fast]]
                slow = nums[slow]
                visited[fast] = True
                visited[slow] = True
                ans += 1
                if fast == slow:
                    break
            
            return ans

        ans = 0
        for i in nums:
            if not visited[i]: # 如果没遍历过则进行查看 有 i 元素的环最大长度
                ans = max(ans, measure_len(i))

        return ans
```


###  1.26. <a name='PermutationinString567-'></a>567. 【滑动窗口🔹】Permutation in String 567-字符串的排列

[花花酱](https://www.bilibili.com/video/BV14W411d7g6?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1z54y1C7qB?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV175411E761?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1154y1X7qB?spm_id_from=333.999.0.0)

```py
觉得写的不错，Python的胸弟们点个赞支持一下，过了年就会有对象的~

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        '''
        思路：怎么判断s2的字串和s1的排列之一相等，假如排序的话，遍历s2的同时，每次都排序，总的时间复杂度太高了。
        因此，我们采用一个有序字典来比较，由于只包含小写字母，我们采用数组来模拟有序字典，
        这样判断s2的子串和s1的排列之一相等就很容易了。总的时间复杂度为O(n),n为s2的长度。
        空间复杂度为:O(26)*2 == O(1) 

        '''
        m1 = len(s1)
        m2 = len(s2)
        if m1 > m2:
            return False
        dic1 = [0]*26
        dic2 = [0]*26
        for i in range(m1):
            dic1[ord(s1[i])-ord('a')] += 1
            dic2[ord(s2[i])-ord('a')] += 1
        if dic1 == dic2:
            return True

        for i in range(m1,m2):
            dic2[ord(s2[i-m1])-ord('a')] -= 1
            dic2[ord(s2[i])-ord('a')] += 1
            if dic1 == dic2:
                return True
        return False
方法1：其实就是滑动窗口哈希表（更新边界法），对应上面的方法五
class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1) #s1的哈希表，实质是字典
        c2 = collections.Counter() #实例化一个counter类
        p = q = 0  #设定下标初始化为0，滑动窗口就是[p,q]
        #下面就是不断在s2上面进行滑动窗口，不断更新哈希表进行比较，这是采用的边界更新法哦，因此是方法五，而不是方法三
        #这里补充一下，为什么滑动窗口用while没用for，其实都是一样的，你也可以改成for
        #但是对于有些情况，就只能用while，比如在回溯算法里面，即循环变量需要频繁的加减，显然此题并不是
        #因此对于此题，用for也可以，整体来说while的应用场合更加广泛
        while q < l2:
            c2[s2[q]] += 1   #统计字典哈希表
            if c1 == c2:
                return True  #注意，这种结果性条件判断一定是写在前面
            q += 1           #s2滑动窗口，下标后移
            if q - p + 1 > l1:   #为什么有这个呢？因为第一个滑动窗口比较特殊，要先构造第一个完整的滑动窗口，后面才是更新边界
                c2[s2[p]] -= 1   #字典哈希表移除最前面的字符
                if c2[s2[p]] == 0:  #由于counter特性，如果value为0，就删除它
                #否则会出现s1的map没有a，但是s2的map的a为0，此时是成立的，但是导致了这两个map不相等，结果出错
                    del c2[s2[p]]
                p += 1     #最前面的下标右移动
        return False  #遍历所有滑动窗口过后，仍然没返回true，那就是不合题意
        
方法2：优化的滑动窗口（变量统计法），其实就是上面的方法六
class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1)
        c2 = collections.Counter()
        cnt = 0 #统计变量，全部26个字符，频率相同的个数，当cnt==s1字母的个数的时候，就是全部符合题意，返回真
        p = q = 0 #滑动窗口[p,q]
        while q < l2:
            c2[s2[q]] += 1
            if c1[s2[q]] == c2[s2[q]]: #对于遍历到的字母，如果出现次数相同
                cnt += 1               #统计变量+1
            if cnt == len(c1):         #判断结果写在前面，此时证明s2滑动窗口和s1全部字符相同，返回真
                return True
            q += 1                     #滑动窗口右移
            if q - p + 1 > l1:         #这是构造第一个滑动窗口的特殊判断，里面内容是维护边界滑动窗口
                if c1[s2[p]] == c2[s2[p]]:    #判断性的if写在前面，因为一旦频率变化，这个统计变量就减1
                    cnt -= 1
                c2[s2[p]] -= 1                #字典哈希表移除最前面的字符
                if c2[s2[p]] == 0:            #由于counter特性，如果value为0，必须删除它
                    del c2[s2[p]]
                p += 1                        #最前面的下标右移动
        return False

class Solution(object):
    def checkInclusion(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        l1, l2 = len(s1), len(s2)
        c1 = collections.Counter(s1)
        c2 = collections.Counter()
        cnt = 0 #统计变量，全部26个字符，频率相同的个数，当cnt==s1字母的个数的时候，就是全部符合题意，返回真
        p = q = 0 #滑动窗口[p,q]
        while q < l2:
            c2[s2[q]] += 1
            if c1[s2[q]] == c2[s2[q]]: #对于遍历到的字母，如果出现次数相同
                cnt += 1               #统计变量+1
            if cnt == len(c1):         #判断结果写在前面，此时证明s2滑动窗口和s1全部字符相同，返回真
                return True
            q += 1                     #滑动窗口右移
            if q - p + 1 > l1:         #这是构造第一个滑动窗口的特殊判断，里面内容是维护边界滑动窗口
                if c1[s2[p]] == c2[s2[p]]:    #判断性的if写在前面，因为一旦频率变化，这个统计变量就减1
                    cnt -= 1
                c2[s2[p]] -= 1                #字典哈希表移除最前面的字符
                if c2[s2[p]] == 0:            #由于counter特性，如果value为0，必须删除它
                    del c2[s2[p]]
                p += 1                        #最前面的下标右移动
        return False


```

```py

Python 92% 配注释。

思路为维护一个窗口，用mp2存放窗口内元素出现的次数。当mp2 == mp1，返回True；否则，返回False。

时间复杂度：O(n)

空间复杂度：O(2 * 26)渐进为O(1)，2 * 是因为两个字典。26是因为最多26个字母。

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        n = len(s2)
        mp1 = collections.Counter(s1)
        mp2 = collections.defaultdict(int)
        l = 0 # 左窗
        for r in range(n):
            ele = s2[r]
            if ele not in mp1: # 当r指向元素不在mp1里时，将mp2清空，重新下一轮记数。
                l = r + 1
                mp2 = collections.defaultdict(int) 
            else: # 如果r指向元素在mp1里，检查指向元素频率是否大于mp1内对应元素。如果是，一直移动窗口左侧。
                mp2[ele] += 1
                while mp2[ele] > mp1[ele]:
                    mp2[s2[l]] -= 1
                    l += 1
                if mp2 == mp1: return True
        return False
```

```scala


/**
* my first commitment: sliding window: hashcode with build-in sliding method
*/
object Solution1 {
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1Length = s1.length
      val s1Hash = s1.groupBy(identity).mapValues(_.length).toMap.hashCode

      s2.sliding(s1Length).exists(seq => seq.groupBy(identity).mapValues(_.length).toMap.hashCode == s1Hash)
    }
}


/**
* optimize from 1-1 : maintain sliding window and hashmap by my self
* time complexity: O(s1.length + s2.length)
* space complexity: O(s1.distinct.length)
*/
object Solution1-2 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val s1HashCode = s1.groupBy(identity).mapValues(_.length).toMap.hashCode
      val s2Map = mutable.Map.empty[Char, Int]
      
      (0 until s2.length).exists {
        case idx if idx < s1.length =>
          val char = s2(idx)
          mapIncrement(s2Map, char)
          s2Map.hashCode == s1HashCode
        case idx => 
          val rightChar = s2(idx)
          val leftChar = s2(idx - s1.length)
          mapIncrement(s2Map, rightChar)
          mapDecrement(s2Map, leftChar) 
          s2Map.hashCode == s1HashCode
      }
    }
    def mapIncrement(map: mutable.Map[Char, Int], char: Char): Unit = {
      map.get(char) match {
            case Some(v) => map.update(char, v + 1)
            case None => map.update(char, 1)
      }
    }
    def mapDecrement(map: mutable.Map[Char, Int], char: Char) = map.get(char) match {
      case Some(v) if v == 1 => map.remove(char)
      case Some(v) => map.update(char, v - 1)
      case None =>
    }
}

/**
* sliding windows: using only 1 map to record differential
* 1. if diff map is empty, s2 contains the permutation of s1
* 2. initial map with foreach instead of groupBy witch is time consuming
* time complexity (l1 + l2)
*/
object Solution1-3 {
    import collection.mutable
    def checkInclusion(s1: String, s2: String): Boolean = {
      val diffMap = mutable.Map.empty[Char, Int]
      s1.foreach(mapUpdate(diffMap, _, 1))
      
      (0 until s2.length).exists {case idx =>
        if (idx >= s1.length) {
          val leftChar = s2(idx - s1.length)
          mapUpdate(diffMap, leftChar, 1)
        }
        val rightChar = s2(idx)
        mapUpdate(diffMap, rightChar, -1)
        diffMap.isEmpty
      }
    }
    def mapUpdate(map: mutable.Map[Char, Int], char: Char, value: Int): Unit = {
      map.get(char) match {
            case Some(v) if v + value == 0 => map.remove(char)
            case Some(v) => map.update(char, v + value)
            case None => map.update(char, value)
      }
    }
}
```

###  1.27. <a name='-1'></a>572-另一个树的子树

[哈哈哈](https://www.bilibili.com/video/BV1cA411t7zD?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1wt4y197aB?spm_id_from=333.999.0.0)

```py
这题不可能是简单题

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        def dfs(A,B): # 函数的功能要明确，用来判断当前子树是否一致
            if not B and not A: # 如果同时为空，则子树一致
                return True
            if not A and B: # 一个为空，另一个不为空，则子树不一致
                return False
            if not B and A:
                return False
            if A.val != B.val: # 如果当前节点的值不相等，显然不一致
                return False
            return dfs(A.left, B.left) and dfs(A.right, B.right) # 递归去对照两个子树的左子树和右子树
        
        if not root or not subRoot:
            return False
        if root.val == subRoot.val:
            if dfs(root, subRoot):
                return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)
```

```py
python

class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        if not root or not subRoot: return False
        l = self.isSubtree(root.left, subRoot)
        r = self.isSubtree(root.right, subRoot)    
        def equal(root1, root2):
            if not root1 and not root2: return True
            elif not root1 or not root2: return False
            elif root1.val != root2.val: return False
            else: return equal(root1.left, root2.left) and equal(root1.right, root2.right)
        return equal(root, subRoot) or l or r
学习一下速度最快那几种方法之一:序列化（元组化）+字符串比较-----打败96%

class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        def toTup(t):#这个函数把树序列化为一个元组
            return (t.val,toTup(t.left),toTup(t.right)) if t else None
        return str(toTup(t)) in str(toTup(s))#把元组转化为字符串以方便比较
```

###  1.28. <a name='DistributeCandies'></a>575 Distribute Candies

[小明](https://www.bilibili.com/video/BV11i4y1T7Pr?spm_id_from=333.999.0.0)

###  1.29. <a name='OutofBoundaryPaths'></a>576. Out of Boundary Paths

[花花酱](https://www.bilibili.com/video/BV18W411d7Cf?spm_id_from=333.999.0.0)

###  1.30. <a name='ShortestUnsortedContinuousSuba'></a>581 Shortest Unsorted Continuous Suba

[小明](https://www.bilibili.com/video/BV1Y54y1h7Xa?spm_id_from=333.999.0.0)

###  1.31. <a name='N-aryTreePreorderTraversal'></a>589 N-ary Tree Preorder Traversal

[小明](https://www.bilibili.com/video/BV1io4y1f7qT?spm_id_from=333.999.0.0)

###  1.32. <a name='ValidSquare'></a>593 Valid Square

[小明](https://www.bilibili.com/video/BV1j5411V73U?spm_id_from=333.999.0.0)

###  1.33. <a name='LongestHarmoniousSubsequence'></a>594 Longest Harmonious Subsequence

[小明](https://www.bilibili.com/video/BV1Pp4y1p7ss?spm_id_from=333.999.0.0)

###  1.34. <a name='CanPlaceFlowers'></a>605 Can Place Flowers

[小明](https://www.bilibili.com/video/BV1Uz4y1k7xU?spm_id_from=333.999.0.0)

###  1.35. <a name='-1'></a>611

```py
# 双指针

class Solution:
    # 双指针
    def triangleNumber(self, nums):
        nums.sort()
        n = len(nums)
        count = 0
        for c in range(2, n):
            a, b = 0, c-1
            while a < b:
                if nums[a] + nums[b] <= nums[c]:
                    a += 1
                else:
                    count += b - a 
                    b -= 1
        return count

class Solution(object):
    def triangleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums = sorted(nums)[::-1]
        res = 0
        for i in range(len(nums)-2):
            j, k = i + 1, len(nums) - 1
            while j < k:
                if nums[k] + nums[j] > nums[i]:
                    res += k - j
                    j += 1                
                else:
                    k -= 1
        return res

class Solution:
    def triangleNumber(self, nums):
        nums.sort()
        res = 0
        # 从大到小遍历
        for i in range(len(nums) - 1, 1, -1):
            l, r = 0, i -1
            while l < r:
                # 只要较小的两个值之和大于最大的值，则一定可组成三角形
                if nums[l] + nums[r] > nums[i]:
                    #i, r 和从l到r-1都可组成三角形，个数为 (r-1) - l + 1 = r - l
                    res += (r-1) - l + 1
                    r -= 1
                else: l += 1
        return res

class Solution:
    def triangleNumber(self, nums):
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n):
            k = i
            for j in range(i + 1, n):
                while k + 1 < n and nums[k + 1] < nums[i] + nums[j]:
                    k += 1
                ans += max(k - j, 0)
        return ans

class Solution:
    def triangleNumber(self, nums):
        nums.sort()
        res = 0
        for k in range(len(nums)):
            i, j = 0, k - 1
            while i < j:
                if nums[i] + nums[j] > nums[k]:
                    res += j - i
                    j -= 1
                else:
                    i += 1
        return res
```

###  1.36. <a name='TaskScheduler'></a>621. Task Scheduler

[花花酱](https://www.bilibili.com/video/BV1Wt411Y7Y9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1LZ4y1M7Bg?spm_id_from=333.999.0.0)

```py
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = collections.Counter(tasks)

        # 任务总数
        m = len(freq)
        nextValid = [1] * m
        rest = list(freq.values())

        time = 0
        for i in range(len(tasks)):
            time += 1
            minNextValid = min(nextValid[j] for j in range(m) if rest[j] > 0)
            time = max(time, minNextValid)
            
            best = -1
            for j in range(m):
                if rest[j] and nextValid[j] <= time:
                    if best == -1 or rest[j] > rest[best]:
                        best = j
            
            nextValid[best] = time + n + 1
            rest[best] -= 1

        return time

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = collections.Counter(tasks)

        # 最多的执行次数
        maxExec = max(freq.values())
        # 具有最多执行次数的任务数量
        maxCount = sum(1 for v in freq.values() if v == maxExec)

        return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

最容易想明白的方法，每次都统计所有任务的数量然后降序排序，每次循环刷n+1个任务，即相应数组位置-1。再排序，再刷。直到第一个位置变成1就不这么操作。加上剩下为1的位置数目就大功告成

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        if n==0:
            return(len(tasks))
        timee = 0
        appearence = sorted(collections.Counter(tasks).values(), reverse=True)
        while appearence[0]>1:
            for i in range(n+1):
                if i < len(appearence):
                    appearence[i] = appearence[i]-1
            appearence = sorted(appearence,reverse = True)
            timee = timee+n+1
        print(appearence)
        last = collections.Counter(appearence)[1]
        return(timee+last)
        
妙！虽然桶思想容易理解且代码很简洁，但事先不容易想到，

这种排序思想是很容易想到的，但是排序思想编码不太容易，楼主代码写的很精妙简洁，

各种情况都包含在代码里了，牛逼！找不到一句废话，

唯一可以修改的地方是last= appearence.count(1)😝
```

```py
还是离不开Counter。简单解释一下：取次数最多的字母，两两之间加上n个间隔。

但是，如果有次数一样多的，还需要加1，加1不超过n次。再跟任务的总长度比较，取大的值就可以了。

from collections import Counter
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        l = len(tasks)
        if n == 0:
            return l
        c = Counter(tasks)
        m = c.most_common()
        ret = m[0][1] * (n + 1) - n
        for i in range(1, min(len(m), n)):
            if m[i][1] < m[0][1]:
                break
            ret += 1
        return max(ret, l)
```

###  1.37. <a name='DesignCircularQueue'></a>622 Design Circular Queue

[小明](https://www.bilibili.com/video/BV1kV411n7Uk?spm_id_from=333.999.0.0)

###  1.38. <a name='AddOneRowtoTree'></a>623 Add One Row to Tree

[小明](https://www.bilibili.com/video/BV1AK4y1U7ud?spm_id_from=333.999.0.0)

###  1.39. <a name='SumofSquareNumbers'></a>633-Sum of Square Numbers

[哈哈哈](https://www.bilibili.com/video/BV1a7411h7on?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qh411i7Yh?spm_id_from=333.999.0.0)

```py
又是Python不拥有姓名的一天

class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        if not c:
            return True
        # (a - b) ^ 2 + (a + b) ^ 2 = 2 (a ^ 2 + b ^ 2) = 2 * c
        while c % 2 == 0:
            c //= 2
        # 费马平方和定理
        if c % 4 == 3:
            return False
        sqrt = int(math.sqrt(c))
        for i in range(3, sqrt + 1, 4):
            count = 0
            while c % i == 0:
                c //= i
                count += 1
            if count % 2 != 0:
                return False
        return True
class Solution:
    def judgeSquareSum(self, c: int) -> bool:
        # 双指针解法
        i, j = 0, int(math.sqrt(c))
        while i <= j:
            res = i * i + j * j
            if res == c:
                return True
            elif res < c:
                i += 1
            else:
                j -= 1
        return False
```

```py
双指针

i 从 0 开始
j 从可取的最大数 int(math.sqrt(c)) 开始
total = i * i + j * j
total > c: j = j - 1，将 total 值减小
total < c: i = i + 1，将 total 值增大
total == c：返回 True
import math

class Solution(object):
    def judgeSquareSum(self, c):
        """
        :type c: int
        :rtype: bool
        """
        j = int(math.sqrt(c))
        i = 0
        while i <= j:
            total = i * i + j * j
            if total > c:
                j = j - 1
            elif total < c:
                i = i + 1
            else:
                return True
        return False
最大值应该是Math.sqrt(c/2)
最大值就是Math.sqrt(c)，c = a^2 + b^2，在b=0的时候，a就是Math.sqrt(c)，取Math.sqrt(c/2)会出错。
```

###  1.40. <a name='ExclusiveTimeofFunctions'></a>636. Exclusive Time of Functions

[花花酱](https://www.bilibili.com/video/BV1PW411o7Bh?spm_id_from=333.999.0.0)

###  1.41. <a name='AverageofLevelsinBinaryTree'></a>637 Average of Levels in Binary Tree

[小明](https://www.bilibili.com/video/BV1eb4y1976M?spm_id_from=333.999.0.0)

###  1.42. <a name='DecodeWaysII'></a>639. Decode Ways II

[花花酱](https://www.bilibili.com/video/BV1YW411r75q?spm_id_from=333.999.0.0)

###  1.43. <a name='MaximumAverageSubarrayI'></a>643. Maximum Average Subarray I

[小梦想家](https://www.bilibili.com/video/BV1dV411k7i6?spm_id_from=333.999.0.0)

###  1.44. <a name='-1'></a>645-错误的集合

[哈哈哈](https://www.bilibili.com/video/BV1az411e7zU?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pf4y1479j?spm_id_from=333.999.0.0)

```py
数学解题

class Solution:
    def findErrorNums(self, nums):
        ln, total = len(nums), sum(set(nums))
        return [sum(nums) - total, (1 + ln) * ln // 2 - total]
循环数组解题

class Solution:
    def findErrorNums(self, nums):
        ln = len(nums)
        repeat = lose = -1
        nums.sort()
        if nums[0] != 1:
            lose = 1
        elif nums[-1] != ln:
            lose = ln
        for i in range(1, ln):
            if nums[i] == nums[i - 1]:
                repeat = nums[i]
            if nums[i] - nums[i - 1] == 2:
                lose = nums[i] - 1
        return [repeat, lose]
哈希表解题

from collections import Counter

class Solution:
    def findErrorNums(self, nums):
        ln = len(nums)
        dic = Counter(nums)
        repeat = lose = -1
        for i in range(1, ln + 1):
            tmp = dic.get(i, 0)
            if tmp == 0:
                lose = i
            elif tmp == 2:
                repeat = i
        return [repeat, lose]
```

```py
在英文站抄的，很有意思

将1，n的bool初始为None

出现一次，变化为True

出现两次，变化为False

出现零次，仍为None

第一个['']是垫了一个，因为不是从零开始的

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        flag = [''] + [None] * len(nums)
        for each in nums:
            flag[each] = not flag[each]
        return [flag.index(False),flag.index(None)]



数学方法，求1+2...+N的和，nums唯一set()的和，和nums的和对应做减法直接得到结果

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        S = sum(set(nums))
        return [sum(nums)-S ,len(nums)*(len(nums)+1)//2-S]
        # len(nums)*(len(nums)+1)//2表示1+2+...+n = n*(n+1)/2, 减去 除了丢失数的和就是第二个结果
这题给我整抑郁了。。。。死磕遍历的方法不太行。。。

那就直接无脑算吧：

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        dup = sum(nums) - sum(set(nums))
        err = abs(sum(range(len(nums)+1)) - (sum(nums) - dup))
        return [dup, err]
```

###  1.45. <a name='-1'></a>646-【动态🚀规划 + 贪心🧡】最长数对链

[哈哈哈](https://www.bilibili.com/video/BV1rz411q7pZ?spm_id_from=333.999.0.0)

python3 贪心（按照右端点排序）（速度better）

```py
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort(key=lambda x: x[1])
        count = 0
        end = -float('inf')
        for i, p in enumerate(pairs):
            # print(p[0],end)
            # 易错点：题目容易理解错误
            # 当且仅当 b < c 时，数对(c, d) 才可以跟在 (a, b) 后面。
            if p[0] > end:
                count += 1
                end = p[1]
                # print('new end:',end)
        return count 
```

动态规划（按照左端点排序）

```py
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs = sorted(pairs, key=lambda x:x[0])
        dp = [1] * len(pairs)
        for cur in range(1, len(pairs)):
            for pre in range(cur):
                dp[cur] = max(dp[cur], dp[pre] + 1 if pairs[cur][0] > pairs[pre][1] else dp[pre])
        return dp[-1]

class Solution:
    def findLongestChain(self, pairs):
        pairs.sort(key=lambda x:x[0])
        dp = []
        for cur in range(len(pairs)):
            dp.append(1)
            for pre in range(cur):
                if pairs[cur][0] > pairs[pre][1]:
                    dp[cur] = max(dp[cur], dp[pre] + 1)
        return dp[-1]
```



###  1.46. <a name='PalindromicSubstrings'></a>647 【动态🚀规划 + 中心拓展】Palindromic Substrings

[小明](https://www.bilibili.com/video/BV1g54y1h7uv?spm_id_from=333.999.0.0)

```py
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        res = 0
        # 这个部分其实可以不写：
        # for i in range(n):
        #     dp[i][i]=1
        for i in range(n):
            for j in range(i, -1, -1):
                if s[i] == s[j] and (i - j <= 1 or dp[i - 1][j + 1]):
                    dp[i][j] = 1
                    res += 1
        return res



class Solution(object):
    def countSubstrings(self, s):
        '''
        双指针太暴力了吧
        '''
        cnt = 0
        for i in range(0,len(s)):
            for j in range(i+1,len(s)+1):
                if s[i:j] == s[i:j][::-1]:
                    cnt += 1
        return cnt
```

```py
# Python3中心扩展法非常简洁代码
# 直接利用中心扩展法, 依次计数找到的所有的回文子串即可；
# 无需在字符串中插入特殊字符, center中心位置从0到最后一个元素移动,
# 每次移动0.5, 表示移动到当前元素与下一个元素中间作为中心。
### 代码
from math import floor,ceil
class Solution:
    def countSubstrings(self, s: str) -> int:
        center = ans = 0
        while center < len(s):
            low, high = floor(center), ceil(center)
            while low >=0 and high < len(s) and s[low] == s[high]:
                low, high, ans = low-1, high+1, ans+1
            center += 0.5
        return ans
```

###  1.47. <a name='-1'></a>650-只有两个键的键盘

[哈哈哈](https://www.bilibili.com/video/BV1254y1z7ze?spm_id_from=333.999.0.0)

###  1.48. <a name='FindDuplicateSubtrees'></a>652. Find Duplicate Subtrees

[花花酱](https://www.bilibili.com/video/BV1cW411y7d1?spm_id_from=333.999.0.0)

###  1.49. <a name='TwoSumIV'></a>653. Two Sum IV

[小梦想家](https://www.bilibili.com/video/BV1Qz4y197h1?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1AQ4y117mc?spm_id_from=333.999.0.0)

```py
看了官方题解，写的很好，我补充python 3 中序遍历中，直接向外传值的一个解法。

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        a=set()
        find=0
        def dfs(r):
            nonlocal find
            if r:
                dfs(r.left)
                if k-r.val in a:find=1
                a.add(r.val)
                dfs(r.right)
        dfs(root)
        return True if find else False

优化，及时停止递归，

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        a=set()
        def dfs(r):
            if r is None:return False
            
            if k-r.val in a:
                return True
            a.add(r.val)
            return dfs(r.left) or dfs(r.right)

        return dfs(root)
层层递归返回值与 直接返回值，再次服了大神的代码

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root: return False
        bfs, s = [root], set()
        for i in bfs:
            v=i.val
            l=i.left
            r=i.right
            if k - v in s: return True
            s.add(v)
            if l: bfs.append(l)
            if r: bfs.append(r)
        return False
```

```py
DFS

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        def dfs(root, k):
            nonlocal ans
            if not root:
                return False
            if k - root.val in ans:
                return True
            ans.add(root.val)
            return dfs(root.left, k) or dfs(root.right, k)
        
        ans = set()
        return dfs(root, k) 
BFS

class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        ans = set()
        if not root:
            return False
        queue = [root]
        while queue:
            temp = queue.pop(0)
            if k - temp.val in ans:
                return True
            ans.add(temp.val)
            if temp.left:
                queue.append(temp.left)
            if temp.right:
                queue.append(temp.right)
        return False
```

###  1.50. <a name='MaximumWidthofBinaryTree'></a>662. Maximum Width of Binary Tree

[花花酱](https://www.bilibili.com/video/BV1cv411q7pb?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16a4y1h7fG?spm_id_from=333.999.0.0)

```py
def widthOfBinaryTree(self, root):
    queue = [(root, 0, 0)]
    cur_depth = left = ans = 0
    for node, depth, pos in queue:
        if node:
            queue.append((node.left, depth+1, pos*2))
            queue.append((node.right, depth+1, pos*2 + 1))
            if cur_depth != depth:
                cur_depth = depth
                left = pos
            ans = max(pos - left + 1, ans)

    return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

对第一种方法的改进：queue中无须记录层数信息

class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        queue = [(root,0)]
        res = 0
        while queue:
            arr = []
            for _ in range(len(queue)):
                node,pos = queue.pop(0)
                arr.append(pos)
                if node.left:
                    queue.append((node.left,pos*2))
                if node.right:
                    queue.append((node.right,pos*2+1))
            
            res = max(res,1+arr[-1]-arr[0])
        
        return res

不完善，没必要用arr装入节点序号。BFS 建议用双端队列。

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        from collections import deque
        if not root: return 0  # 孤儿树
        q = deque([(root, 1)])
        res = 0
        while q:
            res = max(res, q[-1][-1] - q[0][-1] + 1)  # 只能写在这里！否则不存在
            for _ in range(len(q)):
                node, val = q.popleft()
                if node.left:
                    q.append((node.left, val * 2))
                if node.right:
                    q.append((node.right, val * 2 + 1))
        return res

class Solution(object):
    def widthOfBinaryTree(self, root):
        self.ans = 0
        left = {}
        def dfs(node, depth = 0, pos = 0):
            if node:
                left.setdefault(depth, pos)
                self.ans = max(self.ans, pos - left[depth] + 1)
                dfs(node.left, depth + 1, pos * 2)
                dfs(node.right, depth + 1, pos * 2 + 1)

        dfs(root)
        return self.ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        max_width = 0
        queue = collections.deque([(root, 1)])
        while queue:
            max_width = max(max_width, queue[-1][1] - queue[0][1] + 1)
            for _ in range(len(queue)):
                node, idx = queue.popleft()

                if node.left:  queue.append((node.left,  idx * 2))
                if node.right: queue.append((node.right, idx * 2 + 1))

        return max_width
```

###  1.51. <a name='BeautifulArrangementII'></a>667 Beautiful Arrangement II

[小明](https://www.bilibili.com/video/BV1j54y1b7Br?spm_id_from=333.999.0.0)

###  1.52. <a name='KthSmallestNumberinMultiplicationTable'></a>668. Kth Smallest Number in Multiplication Table

[花花酱](https://www.bilibili.com/video/BV17W411C7ai?spm_id_from=333.999.0.0)

###  1.53. <a name='TrimaBinarySearchTree'></a>669 Trim a Binary Search Tree

[小明](https://www.bilibili.com/video/BV19y4y1J7fu?spm_id_from=333.999.0.0)

###  1.54. <a name='NumberofLongestIncreasingSubse'></a>673 Number of Longest Increasing Subse

[小明](https://www.bilibili.com/video/BV1gT4y1F7y3?spm_id_from=333.999.0.0)

###  1.55. <a name='ValidParenthesisString'></a>678 Valid Parenthesis String

[小明](https://www.bilibili.com/video/BV1ap4y1X7nu?spm_id_from=333.999.0.0)

###  1.56. <a name='ValidPalindromeII'></a>680-Valid Palindrome II

[哈哈哈](https://www.bilibili.com/video/BV167411h7x1?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV17i4y147xn?spm_id_from=333.999.0.0)

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def checkPalindrome(low, high):
            i, j = low, high
            while i < j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        low, high = 0, len(s) - 1
        while low < high:
            if s[low] == s[high]: 
                low += 1
                high -= 1
            else:
                return checkPalindrome(low + 1, high) or checkPalindrome(low, high - 1)
        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/valid-palindrome-ii/solution/yan-zheng-hui-wen-zi-fu-chuan-ii-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def validPalindrome(self, s: str, flag=False) -> bool:
        if s == s[::-1]:
            return True 
        start, end = 0, len(s) - 1
        while start < end:
            if s[start] == s[end]:
                start, end = start+1, end-1
            elif not flag:
                return self.validPalindrome(s[start+1:end+1], True) or self.validPalindrome(s[start:end], True)
            else:
                return False
        return True

class Solution:
    def validPalindrome(self, s):
        if s == s[::-1]:
            return True
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] == s[r]:
                l, r = l + 1, r - 1
            else:
                a = s[l + 1 : r + 1]
                b = s[l:r]
                return a == a[::-1] or b==b[::-1]
```

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        n = len(s)
        i = next((i for i in range(n>>1) if s[i] != s[~i]), -1)
        return i == -1 or s[i+1:n-i] == s[i+1:n-i][::-1] or s[i:n-i-1] == s[i:n-i-1][::-1]
```

###  1.57. <a name='KEmptySlots'></a>683. K Empty Slots

[花花酱](https://www.bilibili.com/video/BV1Jb411k7Yu?spm_id_from=333.999.0.0)

###  1.58. <a name='RedundantConnection684-'></a>684. 【🍒并查集】Redundant Connection 684-冗余连接

[花花酱](https://www.bilibili.com/video/BV1mt411J79j?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1oe411p7qF?spm_id_from=333.999.0.0)

[郭郭](https://www.bilibili.com/video/BV1oQ4y1U7dH?from=search&seid=13286624680279107242&spm_id_from=333.337.0.0)

```py
        # 🍒并查集元素初始化的三种写法
        p = list(range(len(edges) + 1))
        p = [i for i in range(len(edges) + 1)]
        p = [*range(len(edges) + 1)]     
```

```py
写法一：
class Solution:

    def __init__(self):
        self.size = 1005
        self.parent = list(range(self.size))

    def find(self, u):
        # while u != self.parent[u]:
        #     u = self.parent[u]
        # return u
        # 下面，这个更快一点
        if u != self.parent[u]: 
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        self.parent[self.find(u)] = self.find(v)


    def isConnected(self, u, v ):
        return self.find(u) == self.find(v)

    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        for x, y in edges:
            if self.isConnected(x, y) :
                return [x, y]
            else :
                self.union(x, y)
        return []
        # for i in range(len(edges)):
        #     if self.isConnected(edges[i][0], edges[i][1]) :
        #         return edges[i]
        #     else :
        #         self.union(edges[i][0], edges[i][1])
        # return []

写法二：用dic
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = {}
        
        def find(x):
            # 这一行很关键，如果键不存在于字典中，将会添加x并将值设为默认值。
            parent.setdefault(x,x)
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
    
        def union(x,y):
            if find(x) != find(y):
                parent[find(y)] = find(x)

        # 如果遍历边的过程中，发现两个点已经成环了，这时就可以输出了。
        for x, y in edges:
            if find(x) == find(y):
                return [x, y]
            else:
                union(x,y)  #检查集合，领导节点是否相同，如果集合不同就合并     

写法三：用list

class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = list(range(n + 1))

        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x: int, y: int):
            parent[find(x)] = find(y)

        for node1, node2 in edges:
            if find(node1) != find(node2):
                union(node1, node2)
            else:
                return [node1, node2]
        
        return []

写法四：不推荐

利用py集合特性也可以做🍒并查集，本质上没有区别，不过不用递归了，其实就是靠字典实现的🍒并查集

parent[x] |= parent[y]：

{1} {2}
{1, 2} {2}
--------------------
{1, 2} {3}
{1, 2, 3} {3}
--------------------

class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        parent = {i: {i} for i in range(1, len(edges) + 1)}  
        #🍒并查集初始化，{1: {1}, 2: {2}, 3: {3}, 4: {4}}
        for x, y in edges:
            if parent[x] is not parent[y]:    #如果两个集合地址不一样
                parent[x] |= parent[y]        #合并集合
                for z in parent[y]:
                    parent[z] = parent[x]     #修改元素集合标记的指针地址
            else:
                return [x, y]
```

###  1.59. <a name='RedundantConnectionII'></a>685. 【🍒并查集 + hard】Redundant Connection II

[花花酱](https://www.bilibili.com/video/BV1St411J7Ur?spm_id_from=333.999.0.0)

```py
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
    
    def union(self, x: int, y: int):
        self.parent[self.find(x)] = self.find(y)
    
    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        uf = UnionFind(n + 1)
        parent = list(range(n + 1))
        error = -1
        cycle = -1
        for i, (x, y) in enumerate(edges):
            if parent[y] != y:
                error = i
            else:
                parent[y] = x
                if uf.find(x) == uf.find(y):
                    cycle = i
                else:
                    uf.union(x, y)

        if error < 0:
            return [edges[cycle][0], edges[cycle][1]]
        else:
            errorEdge = edges[error]
            if cycle >= 0:
                return [parent[errorEdge[1]], errorEdge[1]]
            else:
                return [errorEdge[0], errorEdge[1]]



class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        def find(f,x):
            f.setdefault(x,x)
            if f[x] != x:
                f[x] = find(f,f[x])
            return f[x]
        def cycle(graph):
            f = {}
            for x,y in graph:
                if find(f,x) == find(f,y):
                    return True
                else:
                    f[find(f,y)] = find(f,x)
        indegree = {i:0 for i in range(1,len(edges)+1)}
        tmp = 0
        for i,j in edges:
            indegree[j] += 1
            if indegree[j] == 2:
                tmp = j
                break
        if tmp == 0:
            f = {}
            for x,y in edges:
                if find(f,x) == find(f,y):
                    return [x,y]
                else:
                    f[find(f,y)] = find(f,x)
        else:
            for x,y in edges[::-1]:
                if y == tmp:
                    if not cycle(edges[:edges.index([x,y])]+edges[edges.index([x,y])+1:]) :
                        return [x,y]
```

###  1.60. <a name='LongestUnivaluePath'></a>687. Longest Univalue Path

[花花酱](https://www.bilibili.com/video/BV1wt411r7Pr?spm_id_from=333.999.0.0)

###  1.61. <a name='KnightProbabilityinChessboard'></a>688. Knight Probability in Chessboard

[花花酱](https://www.bilibili.com/video/BV1Hb411c7mu?spm_id_from=333.999.0.0)

###  1.62. <a name='EmployeeImportance'></a>690. Employee Importance

[花花酱](https://www.bilibili.com/video/BV1Ut411J7uC?spm_id_from=333.999.0.0)

###  1.63. <a name='TopKFrequentWords'></a>692. Top K Frequent Words

[花花酱](https://www.bilibili.com/video/BV1Mt41137eL?spm_id_from=333.999.0.0)

###  1.64. <a name='-1'></a>693

```py
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while n:
            prenum = (n//2) & 1 # 背一背，和16进制差不多
            nownum = n%2
            if prenum == nownum:
                return False
            n>>=1
        return True

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        while n:
            x = n & 1 # 如果两个相应位都为1,则该位的结果为1
            n>>=1 # 把">>"左边的运算数的各二进位全部右移1位
            y = n & 1
            if x==y:
                return False
        return True

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        tmp = str(bin(n))[2:]
        res = [tmp[i] != tmp[i-1] for i in range(1, len(tmp))]
        return all(res)

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        return not ('11' in str(bin(n)) or '00' in str(bin(n)))

class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        return not('11' in bin(n) or '00' in bin(n))

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        n = str(bin(n))[2:]
        for i in range(0, len(n)-1):
            if n[i] == n[i+1]:
                return False
        return True

# bin()本身返回的就是字符串

class Solution(object):
    def hasAlternatingBits(self, n):
        """
        :type n: int
        :rtype: bool
        """
        b = n >> 1
        res = bin(b^n)[2:]
        if '0' in res:
            return False
        else:
            return True
```

###  1.65. <a name='-1'></a>695-岛屿的最大面积

[哈哈哈](https://www.bilibili.com/video/BV1s54y1B77k?spm_id_from=333.999.0.0)

[哈哈哈](https://www.bilibili.com/video/BV1wz4y1R7e6?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1k64y1c798?spm_id_from=333.999.0.0)

```py
class Solution:
    def dfs(self, grid, cur_i, cur_j) -> int:
        if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
            return 0
        grid[cur_i][cur_j] = 0
        ans = 1
        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            next_i, next_j = cur_i + di, cur_j + dj
            ans += self.dfs(grid, next_i, next_j)
        return ans

    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                ans = max(self.dfs(grid, i, j), ans)
        return ans


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                cur = 0
                stack = [(i, j)]
                while stack:
                    cur_i, cur_j = stack.pop()
                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
                        continue
                    cur += 1
                    grid[cur_i][cur_j] = 0
                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        next_i, next_j = cur_i + di, cur_j + dj
                        stack.append((next_i, next_j))
                ans = max(ans, cur)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        ans = 0
        for i, l in enumerate(grid):
            for j, n in enumerate(l):
                cur = 0
                q = collections.deque([(i, j)])
                while q:
                    cur_i, cur_j = q.popleft()
                    if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:
                        continue
                    cur += 1
                    grid[cur_i][cur_j] = 0
                    for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
                        next_i, next_j = cur_i + di, cur_j + dj
                        q.append((next_i, next_j))
                ans = max(ans, cur)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/max-area-of-island/solution/dao-yu-de-zui-da-mian-ji-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python dfs 和 union find dfs

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        
        def dfs(i, j):
            grid[i][j] = 0
            ans = 1
            for r, c in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= r < m and 0 <= c < n and grid[r][c] == 1:
                    ans += dfs(r, c)
            return ans
        
        res = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    res = max(res, dfs(i, j))
        return res
union find 首先将grid中的每一个点都当作一个set， 如果这个点的元素为1， 则set的大小为1， 如果这个点的元素为0， 则set的大小为0； 遍历grid中的每一个点v，如果v的元素为1， 则判断v右边的点v_r和下面的v_d点是否为1， 如果是， 则将v_r/v_d点放进点v的set中， 同时用num来更新这个set的大小。

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        
        def find(v):
            if parent[v] != v:
                return find(parent[v])
            return parent[v]
        
        def union(v1, v2):
            r1 = find(v1)
            r2 = find(v2)
            if r1 != r2:
                parent[r2] = r1
                num[r1] += num[r2]
        
        m, n = len(grid), len(grid[0])
        parent = [i*n+j for i in range(m) for j in range(n)]
        num = [0] * (m * n)
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    v = i*n+j
                    num[v] = 1
                    if 0 <= i + 1 < m and grid[i + 1][j]:
                        num[v+n] = 1
                        union(v, v+n)
                    if 0 <= j + 1 < n and grid[i][j + 1]:
                        num[v+1] = 1
                        union(v, v+1)
        return max(num)
```

```py
最开始用两层递归，一层找岛屿，一层计算面积，时间直接爆炸 后来直接用两个for循环遍历列表来找岛屿，再用递归计算面积，速度非常快

执行用时：56 ms, 在所有 Python3 提交中击败了94.56%的用户
内存消耗：16.7 MB, 在所有 Python3 提交中击败了67.66%的用户
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        self.grid = grid
        self.ans = 0
        self.ans2 = 0
        self.height = len(grid)
        self.width  = len(grid[0])

        for i in range(self.height):  #直接for循环遍历即可，不用递归
            for j in range(self.width):
                if self.grid[i][j] == 1:
                    self.grid[i][j] = 0
                    self.dfs(i, j)
                    self.ans = max(self.ans, self.ans2)
                    self.ans2 = 0    
                    
        return self.ans        


    def dfs(self, i, j):  #从一个点开始找附近的所有岛屿，并且把找到的岛屿标记为海水
        self.grid[i][j] = 0
        self.ans2 += 1
        if j+1 < self.width and self.grid[i][j+1] == 1: #往右
            self.dfs(i, j+1)
        if j-1 >= 0 and self.grid[i][j-1] == 1:   #往左
            self.dfs(i, j-1)
        if i+1 < self.height and self.grid[i+1][j] == 1:   #往上
            self.dfs(i+1, j)
        if i-1 >= 0 and self.grid[i-1][j] == 1:   #往下
            self.dfs(i-1, j)
```

###  1.66. <a name='CountBinarySubstrings'></a>696 Count Binary Substrings

[小明](https://www.bilibili.com/video/BV14p4y1b7nV?spm_id_from=333.999.0.0)

###  1.67. <a name='FallingSquares'></a>699. Falling Squares

[花花酱](https://www.bilibili.com/video/BV1Lt41137EM?spm_id_from=333.999.0.0)

###  1.68. <a name='SearchinaBinarySearchTree'></a>700 Search in a Binary Search Tree

[小明](https://www.bilibili.com/video/BV14z411e76U?spm_id_from=333.999.0.0)

###  1.69. <a name='InsertintoaBinarySearchTree'></a>701 Insert into a Binary Search Tree

[小明](https://www.bilibili.com/video/BV1q54y1k76s?spm_id_from=333.999.0.0)

###  1.70. <a name='KthLargestElementinaStreamK'></a>703. 【构造🏰 + 最小堆🌵】Kth Largest Element in a Stream数据流中的第K大元素

[图灵](https://www.bilibili.com/video/BV1g5411w7o8?spm_id_from=333.999.0.0)

```py
方法一：直接降序排序，然后取第k个元素返回，add时每次都再排序一次，这样时间复杂度为O(k*logk)

# 1.直接排序
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.nums = nums
        self.k = k
        self.nums.sort(reverse = True)
        while len(self.nums) > k:
            self.nums.pop()

    def add(self, val: int) -> int:
        self.nums.append(val)
        self.nums.sort(reverse = True)
        if len(self.nums) > self.k:
            self.nums.pop()
        return self.nums[-1]
方法二：使用小顶堆实现的优先队列，Python 中标准库 heapq 就是小顶堆，时间复杂度降低为O(k)

# 2.小顶堆
import heapq
class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.pool = nums
        heapq.heapify(self.pool)
        self.k = k
        while len(self.pool) > k:
            heapq.heappop(self.pool)

    def add(self, val: int) -> int:
        if len(self.pool) < self.k:
            heapq.heappush(self.pool, val)
        elif val > self.pool[0]:
            heapq.heapreplace(self.pool, val)
        return self.pool[0]
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.k = k
        self.queue = []
        for n in nums: self.add(n)

    def add(self, val: int) -> int:
        if len(self.queue) < self.k:
            heapq.heappush(self.queue, val)
        elif val > self.queue[0]:
            heapq.heapreplace(self.queue, val)
        return self.queue[0]



python 3
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.nums = nums
        heapq.heapify(self.nums)
        self.k = k


    def add(self, val: int) -> int:
        heapq.heappush(self.nums, val)
        while len(self.nums) > self.k:
            heapq.heappop(self.nums)
        return self.nums[0]
```

```py
一顿操作猛如虎，一看击败百分五

class KthLargest:
    def __init__(self, k: int, nums: List[int]):
        self.k = k
        t = sorted(nums)
        t = t[::-1]
        self.arr = t[:k]

    def add(self, val: int) -> int:
        for i in range(min(self.k, len(self.arr))):
            if self.arr[i] < val:
                self.arr.insert(i, val)
                break
        else:
            self.arr.append(val)
        return self.arr[self.k - 1]
```

```scala
/**
* using min heap
*/
class KthLargest(_k: Int, _nums: Array[Int]) {
    private val pq = scala.collection.mutable.PriorityQueue.empty[Int](Ordering[Int].reverse)
    val k = _k
    _nums.foreach(add)


    def add(`val`: Int): Int = {
        if (pq.size < k)
            /* if only add one element at once, += is more effective than enqueue op */
            pq += `val`
            // pq.enqueue(`val`)
        else if(pq.head < `val`){
            pq.dequeue
            pq += `val`
            // pq.enqueue(`val`)
        }
        // println(pq.clone.dequeueAll)
        pq.head
               
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(`val`)
 */
```

###  1.71. <a name='BinarySearch'></a>704.Binary Search二分查找

[图灵](https://www.bilibili.com/video/BV1Dh411v7yT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1qa4y157E4?spm_id_from=333.999.0.0)

```py
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        low, high = 0, len(nums) - 1
        while low <= high:
            mid = (high - low) // 2 + low
            num = nums[mid]
            if num == target:
                return mid
            elif num > target:
                high = mid - 1
            else:
                low = mid + 1
        return -1

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
对不起没忍住

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if target in nums :
            return nums.index(target)
        else:
            return -1
（版本一）左闭右闭区间

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            middle = (left + right) // 2

            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle - 1
            else:
                return middle
        return -1
（版本二）左闭右开区间

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left,right  =0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid+1
            elif nums[mid] > target:
                right = mid
            else:
                return mid
        return -1
```

```scala
object Solution {
    def search(nums: Array[Int], target: Int): Int = {
        nums.lastIndexOf(target)
    }
}

/**
* my first commitment:
* time complexity: O(logn)
*/

object Solution1 {
    def search(nums: Array[Int], target: Int): Int = {
      var left = 0
      var right = nums.length - 1
      var ans = -1
      while(ans == -1 && left <= right) {
        println(left, right)
        val mid: Int = left  + (right - left) / 2
        if(nums(mid) == target){
          ans = mid
        } else if(target > nums(mid)) {
          left = mid + 1
        } else {
          right = mid - 1
        }
 
      }
      ans
    }
}

/**
* recursive version
*/
object Solution1-2 {
    def search(nums: Array[Int], target: Int): Int = {
        search(nums, target, 0, nums.length - 1)
    }
  
    @annotation.tailrec
    def search(nums: Array[Int], target: Int, left: Int, right: Int): Int = {
      if(left > right) return -1
      
      val mid = left + (right - left) / 2
      if (nums(mid) == target) 
        mid
      else if (target > nums(mid))
        search(nums, target, mid + 1, right)
      else 
        search(nums, target, left, right - 1)
      
    }
}
```

###  1.72. <a name='DesignHashSet'></a>705 Design HashSet

[小明](https://www.bilibili.com/video/BV1hV411z73p?spm_id_from=333.999.0.0)

###  1.73. <a name='DesignHashMap'></a>706. Design HashMap设计哈希映射

[图灵](https://www.bilibili.com/video/BV1Ho4y1Q7cr?spm_id_from=333.999.0.0)

###  1.74. <a name='DesignLinkedList'></a>707. Design Linked List

[花花酱](https://www.bilibili.com/video/BV1yW411Z7dV?spm_id_from=333.999.0.0)

###  1.75. <a name='MinimumASCIIDeleteSumforTwoStrings'></a>712. Minimum ASCII Delete Sum for Two Strings

[花花酱](https://www.bilibili.com/video/BV17W411d7m2?spm_id_from=333.999.0.0)

###  1.76. <a name='SubarrayProductLessThanK'></a>713 Subarray Product Less Than K

[小明](https://www.bilibili.com/video/BV1T5411j7tC?spm_id_from=333.999.0.0)

###  1.77. <a name='-1'></a>714 【动态🚀规划】买卖股票的最佳时机含手续费

[哈哈哈](https://www.bilibili.com/video/BV1WK4y1E7mP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1t54y187Qy?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        buy = prices[0]
        profit = 0
        for i in range(1,n):
            buy = min(buy, prices[i]-profit)
            profit = max(profit, prices[i] - buy - fee)
        return profit
```

```scala
/**
* dynamic programming: only create an array keeping holding and un-holding
* time complexity: O(N)
* space complexity:  O(1)
*/
object Solution1-1 {
    def maxProfit(prices: Array[Int], fee: Int): Int = {
        if(prices == null || prices.isEmpty) return 0
        val dp = Array.ofDim[Int](2)
        dp(0) = 0
        dp(1) = -prices(0)
        // 0 un-holding, 1 holding
        for(i <- 1 until prices.length){
        /*
        * it may causes a problem here, because we overwrite the previous dp(0) by new state i value and dp(1) would utilizes dp(0) which was overwritten 
        */
            dp(0) = dp(0) max (dp(1) + prices(i) - fee)
            dp(1) = dp(1) max (dp(0) - prices(i))
        }
        dp(0)
    }
}
```

###  1.78. <a name='RangeModule'></a>715. Range Module

[花花酱](https://www.bilibili.com/video/BV1jt411379W?spm_id_from=333.999.0.0)

###  1.79. <a name='FindK-thSmallestPairDistance'></a>719. Find K-th Smallest Pair Distance

[花花酱](https://www.bilibili.com/video/BV1zb411u7iP?spm_id_from=333.999.0.0)

###  1.80. <a name='LongestWordinDictionary'></a>720. Longest Word in Dictionary

[花花酱](https://www.bilibili.com/video/BV1vW411r75D?spm_id_from=333.999.0.0)

###  1.81. <a name='AccountsMerge'></a>721 【🍒并查集】Accounts Merge

[edo](https://www.bilibili.com/video/BV1wK4y1p7f1?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

```py
import heapq
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        def find(x):
            f.setdefault(x,x)
            while x != f[x]:
                f[x] = f[f[x]]
                x = f[x]
            return x
            
        def union(i, j):
            rooti = find(i)
            rootj = find(j)
            if rootj != rooti:
                f[rootj] = rooti
        f = {}
        for i in range(len(accounts)):
            for mail in accounts[i][1:]:
                union(i, mail)

        res = defaultdict(list)
        for mail, name in f.items():
            if type(mail) == str:
                heappush(res[find(name)], mail)
        ans = [[] for _ in range(len(res))]
        index = 0
        for name, mail in res.items():
            ans[index].append(accounts[name][0])
            while mail:
                ans[index].append(heappop(mail))
            index += 1
        return ans
```

```py
class Solution:
    """并查集"""
    '''
    root 存放accounts里面每个节点的parent
    mail 存放每个邮箱地址的第一次出现parent
    '''
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        root = [i for i in range(len(accounts))]
        mail = {}
        
        # 并查集find
        def find(i):
            if root[i] != i:
                return find(root[i])
            return root[i]
        
        
        for i in range(len(accounts)):
            for email in accounts[i][1:]:
                if email not in mail:
                    mail[email] = i
                else:
                    # 通过find找到i的最终parent，然后将parent的parent改写为mail通过find找到的parent
                    # 由于mail里存放的节点的父节点也可能被更新所以要通过find找到最终parent
                    
                    root[find(i)] = find(mail[email])
        
        # 存放子账户
        delt = set()
        for i in range(len(root)):
            if root[i] != i:
                # 通过find找到i的最终parent，然后把i添加进最终parent
                accounts[find(root[i])].extend(accounts[i][1:])
                delt.add(i)
        # 筛选出不含子账户的最终账户存入result
        result = []
        for i in range(len(accounts)):
            if i not in delt:
                result.append(accounts[i][:1]+sorted(list(set(accounts[i][1:]))))
        return result
```

```py
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))

    def union(self, index1: int, index2: int):
        self.parent[self.find(index2)] = self.find(index1)

    def find(self, index: int) -> int:
        if self.parent[index] != index:
            self.parent[index] = self.find(self.parent[index])
        return self.parent[index]

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        emailToIndex = dict()
        emailToName = dict()

        for account in accounts:
            name = account[0]
            for email in account[1:]:
                if email not in emailToIndex:
                    emailToIndex[email] = len(emailToIndex)
                    emailToName[email] = name
        
        uf = UnionFind(len(emailToIndex))
        for account in accounts:
            firstIndex = emailToIndex[account[1]]
            for email in account[2:]:
                uf.union(firstIndex, emailToIndex[email])
        
        indexToEmails = collections.defaultdict(list)
        for email, index in emailToIndex.items():
            index = uf.find(index)
            indexToEmails[index].append(email)
        
        ans = list()
        for emails in indexToEmails.values():
            ans.append([emailToName[emails[0]]] + sorted(emails))
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/accounts-merge/solution/zhang-hu-he-bing-by-leetcode-solution-3dyq/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        belongs = collections.defaultdict(list)
        for i, j in enumerate(accounts):
            for email in j[1:]:
                belongs[email].append(i)
        emial_visited = set()
        id_visited = set()
        def dfs(id):
            if id in id_visited:
                return
            id_visited.add(id)
            for email in accounts[id][1:]:
                if email in emial_visited:
                    continue
                emial_visited.add(email)
                ans[-1].append(email)
                for i in belongs[email]:
                    dfs(i)
        ans = []
        for i in range(len(accounts)):
            if i not in id_visited:
                ans.append(accounts[i][:1])
                dfs(i)
        for i in range(len(ans)):
            ans[i] = ans[i][:1] + sorted(ans[i][1:])
        return ans
```

```py
Python并查集解法

from collections import defaultdict
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        dic = {}
        email2name = {}
        def find(x):
            if x != dic.setdefault(x, x):
                dic[x] = find(dic[x])
            return dic[x]
        for it in accounts:
            email2name[it[1]] = it[0] # 记录一下第一个邮件地址对应的用户名
            root = find(it[1]) # find(it[1])这步不能少，因为有可能出现没有it[2]的情况
            for mail in it[2:]:
                dic[find(mail)] = root # 将所有的邮件地址归并到第一个邮件地址上
        # 返回处理
        ret = defaultdict(list)
        for key in dic: # 这点我之前不是很熟悉，可以通过遍历dic的方法查看所有在并查集中注册的元素！
            ret[find(key)].append(key) # 这里不能写成ret[dic[key]]，因为find()的过程也是更新dic字典的过程
        return [[email2name[k]] + sorted(v) for k, v in ret.items()]
附上Python的DFS解法

from collections import defaultdict
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        # 先构建网站之间的关系图
        dic = defaultdict(set)
        for it in accounts:
            for i in range(1, len(it)):
                dic[it[i]] |= set(it[1:i] + it[i+1:])
        # DFS算法，目标是通过DFS以及关系图dic将与mail相关联的所有网站都汇总起来
        seen = set()
        def dfs(mail):
            if mail in seen:
                return set()
            ret = {mail}
            seen.add(mail)
            for t in dic[mail]:
                ret |= dfs(t)
            return ret
        # 主函数
        ret = []
        for it in accounts:
            if it[1] not in seen:
                ret.append([it[0]] + sorted(dfs(it[1])))
        return ret
```

###  1.82. <a name='FindPivotIndex'></a>724. Find Pivot Index

[花花酱](https://www.bilibili.com/video/BV1KW411S7nG?spm_id_from=333.999.0.0)

###  1.83. <a name='SplitLinkedListinParts'></a>725. Split Linked List in Parts

[花花酱](https://www.bilibili.com/video/BV1KW411S7ti?spm_id_from=333.999.0.0)

###  1.84. <a name='NumberofAtoms'></a>726. Number of Atoms

[花花酱](https://www.bilibili.com/video/BV11W411U7KT?spm_id_from=333.999.0.0)

###  1.85. <a name='CountDifferentPalindromicSubsequences'></a>730. Count Different Palindromic Subsequences

[花花酱](https://www.bilibili.com/video/BV12W41167vQ?spm_id_from=333.999.0.0)

###  1.86. <a name='MyCalendarIII'></a>732. My Calendar III

[花花酱](https://www.bilibili.com/video/BV1fW411k75b?spm_id_from=333.999.0.0)

###  1.87. <a name='FloodFill'></a>733. 图像渲染 Flood Fill

[花花酱](https://www.bilibili.com/video/BV1yW41167S4?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1fp4y1v7Pn?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1HZ4y1p7vH?spm_id_from=333.999.0.0)

```py
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        currColor = image[sr][sc]
        if currColor == newColor:
            return image
        
        n, m = len(image), len(image[0])
        que = collections.deque([(sr, sc)])
        image[sr][sc] = newColor
        while que:
            x, y = que.popleft()
            for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:
                    que.append((mx, my))
                    image[mx][my] = newColor
        
        return image

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        n, m = len(image), len(image[0])
        currColor = image[sr][sc]

        def dfs(x: int, y: int):
            if image[x][y] == currColor:
                image[x][y] = newColor
                for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                    if 0 <= mx < n and 0 <= my < m and image[mx][my] == currColor:
                        dfs(mx, my)

        if currColor != newColor:
            dfs(sr, sc)
        return image

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
python :深度优先搜索+递归；注意测试里面有一组比较恶心，就是初始位置的颜色如果和newcolor 一样，就不对image进行操作，直接反回image

class Solution(object):
    def floodFill(self, image, sr, sc, newColor):
        """
        :type image: List[List[int]]
        :type sr: int
        :type sc: int
        :type newColor: int
        :rtype: List[List[int]]
        """
        #up\down\left\right = u\p\l\r
        color = image[sr][sc]
        row = len(image) #行数
        col = len(image[0]) #列数
        if color == newColor:
            #测试试例比较恶心：image = [[0,0,0],[0,1,1]]; sr=1;sc=1;newColor=1
            return image 

        def DFS(r,c):#深度优先搜索函数，用于递归
            if image[r][c] == color:
                image[r][c] = newColor
                if r-1>=0 :
                    DFS(r-1,c)
                if r+1<row:
                    DFS(r+1,c)
                if c-1>=0:
                    DFS(r,c-1)
                if c+1<col:
                    DFS(r,c+1)
        
        DFS(sr,sc)
        return image
```

###  1.88. <a name='AsteroidCollision'></a>735 Asteroid Collision

[小明](https://www.bilibili.com/video/BV1jT4y1F76n?spm_id_from=333.999.0.0)

###  1.89. <a name='SentenceSimilarityII'></a>737. Sentence Similarity II

[花花酱](https://www.bilibili.com/video/BV1qW41167iB?spm_id_from=333.999.0.0)

###  1.90. <a name='DailyTemperatures'></a>739-Daily Temperatures

[哈哈哈](https://www.bilibili.com/video/BV1Q7411L7w8?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ov411z7rM?spm_id_from=333.999.0.0)

```py
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        ans, nxt, big = [0] * n, dict(), 10**9
        for i in range(n - 1, -1, -1):
            warmer_index = min(nxt.get(t, big) for t in range(temperatures[i] + 1, 102))
            if warmer_index != big:
                ans[i] = warmer_index - i
            nxt[temperatures[i]] = i
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        length = len(temperatures)
        ans = [0] * length
        stack = []
        for i in range(length):
            temperature = temperatures[i]
            while stack and temperature > temperatures[stack[-1]]:
                prev_index = stack.pop()
                ans[prev_index] = i - prev_index
            stack.append(i)
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

这种题我始终更喜欢KMP，空间复杂度更低哟

时间复杂度O(n)

空间复杂度O(1)

该思路由KMP中失配数组的构造演变而来。假设ans[i]记录了i位置上的答案（向右找多少个比自己大），则求ans[i]时，我先看一眼i+1位置，如果T[i+1]比我大，那得了，答案就是它了。

否则我要找的位置至少是比T[i+1]大，那么当然我就看一看ans[i+1]

class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        n=len(T)
        ans=[0]*n
        for i in range(n-2,-1,-1):
            now=i+1
            while T[now]<=T[i]:
                if ans[now]:
                    now+=ans[now]
                else:
                    break
            else:
                ans[i]=now-i
        return ans
```

```py
维护递减栈，后入栈的元素总比栈顶元素小。

比对当前元素与栈顶元素的大小
若当前元素 < 栈顶元素：入栈
若当前元素 > 栈顶元素：弹出栈顶元素，记录两者下标差值即为所求天数
这里用栈记录的是 T 的下标。

class Solution(object):
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        stack = list()
        t_length = len(T)
        res_list = [0 for _ in range(t_length)]
        
        for key, value in enumerate(T):     
            if stack:
                while stack and T[stack[-1]] < value:
                    res_list[stack[-1]] = key - stack[-1]
                    stack.pop()
            stack.append(key)
        return res_list

Python：

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        answer = [0]*len(temperatures)
        stack = [0]
        for i in range(1,len(temperatures)):
            # 情况一和情况二
            if temperatures[i]<=temperatures[stack[-1]]:
                stack.append(i)
            # 情况三
            else:
                while len(stack) != 0 and temperatures[i]>temperatures[stack[-1]]:
                    answer[stack[-1]]=i-stack[-1]
                    stack.pop()
                stack.append(i)
            
        return answer
```

###  1.91. <a name='DeleteandEarn'></a>740. 【动态🚀规划】 Delete and Earn

[24:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1xW41167b5?spm_id_from=333.999.0.0)

```py
别人的写法：
class Solution(object):
    def deleteAndEarn(self, nums):
        dp = [0] * 10001
        for num in nums:
            dp[num] += num
        for i in range(2, 10001):
            dp[i] = max(dp[i]+dp[i-2], dp[i-1])
        return dp[-1]

我的修改：
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        n = max(nums)
        dp = [0] * (n + 1)

        for num in nums:
            dp[num] += num 
        
        start = max(2, min(nums))
        for i in range(start, n + 1):
            # 易错点：不是这个dp[i] += max(dp[i-2], dp[i-1])
            dp[i] = max(dp[i-2] + dp[i], dp[i-1])
        return dp[-1]

使用计数器：
from collections import Counter
class Solution:
    def deleteAndEarn(self, nums):
        count = Counter(nums)
        # print(count): Counter({3: 1, 4: 1, 2: 1})
        key = sorted(count)
        # print(key): [2, 3, 4]
        n = len(key)
        dp = [0]*(1+n) # dp[i] 表示的是在[tmp[0],...tmp[i-1]]能获得的最大点数
        dp[1] = key[0] * count[key[0]]

        for i in range(2, 1+n):
            if key[i-1] - key[i-2] == 1:
                dp[i] = max(dp[i-1], dp[i-2] + key[i-1] * count[key[i-1]])
            if key[i-1] - key[i-2] > 1:
                dp[i] = dp[i-1] + key[i-1] * count[key[i-1]]
        return dp[-1]
```

###  1.92. <a name='CherryPickup'></a>741. Cherry Pickup

[花花酱](https://www.bilibili.com/video/BV1tW41167jy?spm_id_from=333.999.0.0)

###  1.93. <a name='DijkstraNetworkDelayTime'></a>743. 【Dijkstra🚗】Network Delay Time

[花花酱](https://www.bilibili.com/video/BV1UW411r7S8?spm_id_from=333.999.0.0)

[熊羊一锅鲜](https://www.bilibili.com/video/BV1E341187W6?from=search&seid=4056121790831106424&spm_id_from=333.337.0.0)

###  1.94. <a name='PrefixandSuffixSearch'></a>745. Prefix and Suffix Search

[花花酱](https://www.bilibili.com/video/BV1TW411k7PY?spm_id_from=333.999.0.0)

###  1.95. <a name='MinCostClimbingStairs'></a>746. 【动态🚀规划】Min Cost Climbing Stairs

[7:45 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1VW411y7Dq?spm_id_from=333.999.0.0)

```py
# [10,15,20,10]
# dp(0) dp(1) dp(2)              dp(3)                              dp(4)
# 0       0     10
#                    20 + 10       | 15 + 0           10 + ?          | 20 + ？
#                    cost(2)+dp(2) | cost(1)+dp(1)    cost(3) + dp(3) | cost(2) + dp(2)
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp = [0] * (n+1)
        for i in range(2,n+1):
            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
        return dp[-1]

空间优化：
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp1 = dp0 = 0
        for i in range(2,n+1):
            dp = min(dp1 + cost[i-1], dp0 + cost[i-2])
            dp1, dp0 = dp, dp1
        return dp

或者返回到达 cost[-1], cost[-2] 的较小值

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        for i in range(2, len(cost)):
            cost[i] += min(cost[i-1], cost[i-2])
        return min(cost[-1], cost[-2])

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost))
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, len(cost)):
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
        return min(dp[len(cost) - 1], dp[len(cost) - 2])
```

###  1.96. <a name='ShortestCompletingWord'></a>748. Shortest Completing Word

[花花酱](https://www.bilibili.com/video/BV15W411y7sJ?spm_id_from=333.999.0.0)

###  1.97. <a name='OpentheLock'></a>752. Open the Lock

[花花酱](https://www.bilibili.com/video/BV1NW411y74z?spm_id_from=333.999.0.0)

###  1.98. <a name='PartitionLabels'></a>763 Partition Labels

[小明](https://www.bilibili.com/video/BV1Ca4y177LW?spm_id_from=333.999.0.0)

###  1.99. <a name='CouplesHoldingHands'></a>765. 【🍒并查集 + 困难】情侣牵手 Couples Holding Hands

[官方](https://www.bilibili.com/video/BV1pv411Y7wX?spm_id_from=333.999.0.0)

```py
扒掉你的并查集皮，哈希表真香。

class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        # 使用哈希表维护字符索引，每次遍历一对交换
        d = {num: idx for idx, num in enumerate(row)}
        cnt = 0
        for i in range(0, len(row), 2):
            flag = -1 if row[i] & 1 else 1
            if row[i+1] != row[i] + flag:  # 当前是奇数/偶数
                row[i+1], row[d[row[i]+flag]] = row[d[row[i]+flag]], row[i+1]
                x, y = row[i+1], row[d[row[i]+flag]]
                d[x], d[y] = d[y], d[x]
                cnt += 1
        return cnt
```

```py
本来想随便写下先试错的，结果居然直接过了还是100%。。。虽然100%但还是要烧了你们。。

class Solution(object):
    def minSwapsCouples(self, row):
        """
        每两个座位成一对，假定左边的人都是合法的不变，如果TA右边的人与TA匹配则
        跳过，不匹配则找到TA的匹配对象的与TA右边的人交换。
        """
        def find_another(n):
            if n % 2 == 0:
                return n + 1
            else:
                return n - 1

        c = 0
        for i in range(0, len(row), 2):
            p1 = row[i]
            p2 = find_another(p1)
            if row[i+1] != p2:
                j = row.index(p2)
                row[i+1], row[j] = row[j], row[i+1]
                c += 1

        return c
```

###  1.100. <a name='MaxChunksToMakeSorted'></a>769. Max Chunks To Make Sorted

[花花酱](https://www.bilibili.com/video/BV1LW411C7nD?spm_id_from=333.999.0.0)

###  1.101. <a name='JewelsandStones'></a>771 Jewels and Stones

[小明](https://www.bilibili.com/video/BV1RC4y1W7yH?spm_id_from=333.999.0.0)

###  1.102. <a name='SlidingPuzzle'></a>773. Sliding Puzzle

[花花酱](https://www.bilibili.com/video/BV1PW411o7g4?spm_id_from=333.999.0.0)

###  1.103. <a name='GlobalandLocalInversions'></a>775. Global and Local Inversions

[花花酱](https://www.bilibili.com/video/BV1JW411d75t?spm_id_from=333.999.0.0)

###  1.104. <a name='-1'></a>777

```py
# LR不能互相穿过
# R只能右移
# L只能左移
class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        # -----------去掉X,两个字符串应该相等-----------
        s = start.replace('X','')
        if s != end.replace('X',''):
            return False
        # -----------去掉X,两个字符串应该相等-----------

        # start中R的索引要小于等于end的
        # start中L的索引要大于等于end的
        d1 = [index for index,char in enumerate(start) if char !='X']
        d2 = [index for index,char in enumerate(end) if char !='X']


        for index,char in enumerate(s):
            # R 则start大于end的都是False
            if char == 'R' and d1[index] > d2[index]:
                return False
            if char == 'L' and d1[index] < d2[index]:
                return False

        return True

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        start = [(index, char) for index, char in enumerate(start) if char in ["L", "R"]]
        end = [(index, char) for index, char in enumerate(end) if char in ["L", "R"]]
        return len(start) == len(end) and all(c1 == c2 == "L" and i1 >= i2 or c1 == c2 == "R" and i1 <= i2 for (i1, c1), (i2, c2) in zip(start, end))

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        start_id = []
        print("enumerate: ", list(enumerate(start)))
        for i, c in enumerate(start):
            if c in ['L', 'R']:
                start_id.append((i, c))
                
        end_id = []
        for i, c in enumerate(end):
            if c in ['L', 'R']:
                end_id.append((i, c))
                
        if len(start_id) != len(end_id):
            return False
        
        for (i1, c1), (i2, c2) in zip(start_id, end_id):
            print("list(zipped): ",list(zip(start_id, end_id)))
            if c1 != c2:
                return False
            if c1 == c2 == 'L' and i1 < i2:
                return False
            if c1 == c2 == 'R' and i1 > i2:
                return False
        return True

class Solution:
    def canTransform(self, start, end):
        judge = lambda idxStart,idxEnd,f : len(idxStart)==len(idxEnd) and all(f(x,y) for x,y in zip(idxStart,idxEnd)) # f(x,y)是 lambda x,y
        # start和end 长度相等，且不能有 false
        # 如果满足if条件，则返回i
        gen = lambda string,char : [i for i in string if i in char] # char是'LR'
        # 如果满足if条件，则返回i
        genIdx = lambda string,char : [i for i in range(len(string)) if string[i] in char] # char是'L'或者 'R'
        return len(start)==len(end) and\
               gen(start,'LR')==gen(end,'LR') and \
               judge(genIdx(start,'L'),genIdx(end,'L'),lambda x,y:x>=y) and\
               judge(genIdx(start,'R'),genIdx(end,'R'),lambda x,y:x<=y)
```

###  1.105. <a name='DijkstraSwiminRisingWater'></a>778. 【Dijkstra🚗 + 🍒并查集 + 困难】Swim in Rising Water

[花花酱](https://www.bilibili.com/video/BV1ab411k7TH?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1kv4y1f7to?spm_id_from=333.999.0.0)

[一俩三四五](https://www.bilibili.com/video/BV1MJ411g7LM?from=search&seid=4056121790831106424&spm_id_from=333.337.0.0)

```py
# 可以背一背
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        #两点的边长为两点中最大的高度。建立一个边长集合，升序排序。
        n = len(grid)
        edges = []
        for i in range(n):
            for j in range(n):
                ID = i * n + j
                if i < n-1:
                    edges.append([max(grid[i][j],grid[i+1][j]),ID,ID+n])
                if j < n-1:
                    edges.append([max(grid[i][j],grid[i][j+1]),ID,ID+1])
        edges.sort()
        
        #🍒并查集初始化
        parent={i:i for i in range(n*n)}
        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        def union(x,y):
            parent[find(x)] = find(y)
        
        #从小到大遍历加入每一条边，如果加入一条边后，首尾联通，那么返回加入的边长
        for level, start, end in edges:
            union(start, end)
            if find(0) == find((n*n)-1):
                return level
        return 0
```

###  1.106. <a name='LetterCasePermutation'></a>784. Letter Case Permutation

[花花酱](https://www.bilibili.com/video/BV1wW411o7WK?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Sv411a7Gx?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def letterCasePermutation(self, S):
        ans = [[]]

        for char in S:
            n = len(ans)
            if char.isalpha():
                for i in xrange(n):
                    ans.append(ans[i][:])
                    ans[i].append(char.lower())
                    ans[n+i].append(char.upper())
            else:
                for i in xrange(n):
                    ans[i].append(char)

        return map("".join, ans)

作者：LeetCode
链接：https://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def letterCasePermutation(self, S):
        B = sum(letter.isalpha() for letter in S)
        ans = []

        for bits in xrange(1 << B):
            b = 0
            word = []
            for letter in S:
                if letter.isalpha():
                    if (bits >> b) & 1:
                        word.append(letter.lower())
                    else:
                        word.append(letter.upper())

                    b += 1
                else:
                    word.append(letter)

            ans.append("".join(word))
        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

from typing import List
from itertools import product

# S 的长度不超过12。


class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        available = [set([char.lower(), char.upper()]) for char in s]
        return [''.join(t) for t in product(*available)]
class Solution(object):
    def letterCasePermutation(self, S):
        f = lambda x: (x.lower(), x.upper()) if x.isalpha() else x
        return map("".join, itertools.product(*map(f, S)))

作者：LeetCode
链接：https://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

BitMap Bitmap法，字符串S的长度为l， 则总共会有 2** l种结果，换成二进制就是0 ~ 2 **l - 1个数，
对于每个数，如果某个位上是0， 就放小写；是1， 就放大写。

class Solution(object):
    def letterCasePermutation(self, S):
        l = len(S)
        n = 2 ** l
        res = list()
        if l == 0:
            res.append("")
        for i in range(0, n): #得到0 ~ 2 ** l 的每个数
            temp = ""

            for j in range(0, l):
                if ((2 ** j) &i) == 0:#当前位是0， 放小写
                    temp += S[j].lower()
                else: #放大写
                    temp += S[j].upper()
            if temp not in res:
                res.append(temp)
        return res

以前竟然还没写出来，今天随机到这一题，报仇雪恨了，其实很简单啊，不信你看，击败98%

class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        res = ['']
        for c in s:
            if c in 'abcdefghijkmlnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
                res = [r+c.lower() for r in res] + [r+c.upper() for r in res]
            else:
                res = [r+c for r in res]
        return res

这不比官方的好懂

def letterCasePermutation(s):
    result = [s]
    for i in range(len(s)):
        if s[i]>='a' and s[i]<='z':  
            length = len(result)  # 遍历到length，就是上一个字符串对应的长度
            for j in range(length):
                result.append(result[j][0:i]+s[i].upper()+result[j][i+1:])
        elif s[i]>='A' and s[i]<='Z':
            length = len(result)
            for j in range(length):
                result.append(result[j][0:i]+s[i].lower()+result[j][i+1:])
    return result
```

```py

```

###  1.107. <a name='-1'></a>785-判断二分图

[哈哈哈](https://www.bilibili.com/video/BV1KQ4y1N72Z?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV11r4y1P7Wr?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1254y1i7Ut?spm_id_from=333.999.0.0)

```py
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        UNCOLORED, RED, GREEN = 0, 1, 2
        color = [UNCOLORED] * n
        valid = True

        def dfs(node: int, c: int):
            nonlocal valid
            color[node] = c
            cNei = (GREEN if c == RED else RED)
            for neighbor in graph[node]:
                if color[neighbor] == UNCOLORED:
                    dfs(neighbor, cNei)
                    if not valid:
                        return
                elif color[neighbor] != cNei:
                    valid = False
                    return

        for i in range(n):
            if color[i] == UNCOLORED:
                dfs(i, RED)
                if not valid:
                    break
        
        return valid


作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        UNCOLORED, RED, GREEN = 0, 1, 2
        color = [UNCOLORED] * n
        
        for i in range(n):
            if color[i] == UNCOLORED:
                q = collections.deque([i])
                color[i] = RED
                while q:
                    node = q.popleft()
                    cNei = (GREEN if color[node] == RED else RED)
                    for neighbor in graph[node]:
                        if color[neighbor] == UNCOLORED:
                            q.append(neighbor)
                            color[neighbor] = cNei
                        elif color[neighbor] != cNei:
                            return False

        return True

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
visited -1没访问过 0 1代表color

DFS版本

class Solution(object):
    def isBipartite(self, graph):
        """
        :type graph: List[List[int]]
        :rtype: bool
        """
        n = len(graph)
        visited = [-1] * n
        for i in range(n):
            if visited[i] == -1:
                if not self.dfs(graph, i, 0, visited):
                    return False
        return True

    def dfs(self, graph, v, color, visited):
        visited[v] = color
        for i in graph[v]:
            if visited[i] == -1:
                if not self.dfs(graph, i, 1 - color, visited):
                    return False
            elif visited[i] == color:
                return False
        return True
BFS版本

class Solution(object):
    def isBipartite(self, graph):
        n = len(graph)
        visited = [-1] * n
        for i in range(n):
            if visited[i] == -1:
                if not self.bfs(graph, i, 0, visited):
                    return False
        return True

    def bfs(self, graph, v, color, visited):
        visited[v], queue = color, [v]
        while queue:
            node = queue.pop(0)
            for i in graph[node]:
                if visited[i] == -1:
                    visited[i] = 1 - visited[node]
                    queue.append(i)
                elif visited[i] == visited[node]:
                    return False
        return True
```

###  1.108. <a name='K-thSmallestPrimeFraction'></a>786. K-th Smallest Prime Fraction

[花花酱](https://www.bilibili.com/video/BV1AW411o7oi?spm_id_from=333.999.0.0)

###  1.109. <a name='DijkstraCheapestFlightsWithinKStops'></a>787. 【Dijkstra🚗 + 动态🚀规划 + 最小堆🌵】Cheapest Flights Within K Stops

[花花酱](https://www.bilibili.com/video/BV13W411o7wc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1DZ4y1H7oH?spm_id_from=333.999.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.5kql1xc5ggs0.webp)

```py
class Solution:
    # Dijkstra🚗+剪枝
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        if src == dst:
            return 0
        graph = collections.defaultdict(list)
        for start, t, p in flights:
            graph[start].append((t, p))
        dist = {src: 0}
        queue = [(0, src, 0)]
        while queue:
            price, start, interval = queue.pop(0)
            if interval > k:
                break
            for end, p in graph[start]:
                if price + p < dist.get(end, float("inf")):
                    dist[end] = price + p
                    queue.append((price + p, end, interval + 1))
        return -1 if dist.get(dst, float("inf")) == float("inf") else dist[dst]

# from xiaoming

import heapq
class Solution:
    # Dijkstra🚗+剪枝
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        if src == dst:
            return 0
        graph = collections.defaultdict(list)
        for f, t, p in flights:
            graph[f].append((t, p))
        dist = {}
        queue = [(0, src, 0)]
        while queue:
            price, start, interval = heapq.heappop(queue)
            # 这个部分很重要，一定要k+1
            if interval > k+1:
                continue
            if start == dst:
                return price
            for end, p in graph[start]:
                # 这一步剪枝很重要
                if price + p < dist.get((end,interval+1), float("inf")):
                    heapq.heappush(queue, (price + p, end, interval + 1))
                    dist[(end,interval+1)] = price + p
                # print(dist)
                # {(1, 1): 100}
                # {(1, 1): 100, (2, 1): 500}
                # {(1, 1): 100, (2, 1): 500, (2, 2): 200}
        return -1 
```

py 动态🚀规划

```py
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        dp = [float('inf') for _ in range(n)]
        dp[src] = 0
        for _ in range(K+1):
            tmp = dp[:]
            for start, end, cost in flights:
                dp[end] = min(dp[end],tmp[start] + cost)
                # print(dp)
                # [0, 100, inf]
                # [0, 100, inf]
                # [0, 100, 500]
                # [0, 100, 500]
                # [0, 100, 200]
                # [0, 100, 200]
        return dp[dst] if dp[dst] != float('inf') else -1

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        dp = [[float("inf")] * n for _ in range(k + 2)]
        dp[0][src] = 0
        for t in range(1, k + 2):
            for start, end, cost in flights:
                dp[t][end] = min(dp[t][end], dp[t - 1][start] + cost)
        
        res = min(dp[t][dst] for t in range(1, k + 2))
        return -1 if res == float("inf") else res

class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        tmp = [float("inf")] * n
        tmp[src] = 0
        res = float("inf")
        for _ in range(1, k + 2):
            dp = [float("inf")] * n
            for j, i, cost in flights:
                dp[i] = min(dp[i], tmp[j] + cost)
            tmp = dp
            res = min(res, tmp[dst])
        
        return -1 if res == float("inf") else res

```



###  1.110. <a name='DominoandTrominoTiling'></a>790. Domino and Tromino Tiling

[花花酱](https://www.bilibili.com/video/BV13W411o7AW?spm_id_from=333.999.0.0)

###  1.111. <a name='NumberofMatchingSubsequences'></a>792. Number of Matching Subsequences

[花花酱](https://www.bilibili.com/video/BV13W411o7Af?spm_id_from=333.999.0.0)

###  1.112. <a name='AllPathsFromSourcetoTarget'></a>797 All Paths From Source to Target

[小明](https://www.bilibili.com/video/BV1qa4y1E7sg?spm_id_from=333.999.0.0)

###  1.113. <a name='ChampagneTower'></a>799 Champagne Tower

[小明](https://www.bilibili.com/video/BV1Da411A7u5?spm_id_from=333.999.0.0)

###  1.114. <a name='MinimumSwapsToMakeSequencesIncreasing'></a>801. Minimum Swaps To Make Sequences Increasing

[花花酱](https://www.bilibili.com/video/BV1FW411o7tL?spm_id_from=333.999.0.0) 

###  1.115. <a name='BricksFallingWhenHit'></a>803. 【🍒并查集 + 困难】Bricks Falling When Hit 

[花花酱](https://www.bilibili.com/video/BV13W411o7kA?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Xv411W74B?spm_id_from=333.999.0.0)

```py
class Solution:
    def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -> List[int]:
        def getSit2Idx(n, x, y):
            return x * n + y

        m, n = len(grid), len(grid[0])
        size = m * n
        u = self.UnionFind(size + 1)
        tmp = copy.deepcopy(grid)

        for x, y in hits:
            tmp[x][y] = 0

        for column in range(n):
            if tmp[0][column] == 1:
                u.union(column, size)
        
        for row in range(1, m):
            for column in range(n):
                if tmp[row][column] == 1:
                    if row - 1 >= 0 and tmp[row - 1][column] == 1:
                        u.union(getSit2Idx(n, row - 1, column), getSit2Idx(n, row, column))
                    if column - 1 >= 0 and tmp[row][column - 1] == 1:
                        u.union(getSit2Idx(n, row, column - 1), getSit2Idx(n, row, column))

        dx, dy, ans = [0, 0, -1, 1], [-1, 1, 0, 0], []
        for x, y in hits[::-1]:
            if grid[x][y] == 0: 
                ans.insert(0, 0)
                continue
            original = u.getSize(size)
            if x == 0: u.union(y, size)
            for i in range(4):
                offsetX, offsetY = x + dx[i], y + dy[i]
                if 0 <= offsetX < m and 0 <= offsetY < n and tmp[offsetX][offsetY]:
                    a, b = getSit2Idx(n, x, y), getSit2Idx(n, offsetX, offsetY)
                    u.union(a, b)
            current = u.getSize(size)
            ans.insert(0, max(0, current - original - 1))
            tmp[x][y] = 1
        return ans

    class UnionFind:
        def __init__(self, n):
            self.parents = {}
            self.total = [1 for _ in range(n)]
            for i in range(n):
                self.parents[i] = i

        
        def find(self, x):
            original = self.parents[x]
            if original != x:
                original = self.find(original)
                self.parents[x] = original
            return original


        def union(self, x, y):
            rootX, rootY = self.find(x), self.find(y)
            if rootX != rootY:
                self.parents[rootX] = self.parents[rootY]
                self.total[rootY] += self.total[rootX]

        
        def getSize(self, idx):
            return self.total[self.find(idx)]
```

```py

```

###  1.116. <a name='UniqueMorseCodeWords'></a>804 Unique Morse Code Words

[小明](https://www.bilibili.com/video/BV1RD4y1Q7AM?spm_id_from=333.999.0.0)

###  1.117. <a name='LargestSumofAverages'></a>813. Largest Sum of Averages

[花花酱](https://www.bilibili.com/video/BV1XW411d7RB?spm_id_from=333.999.0.0)

###  1.118. <a name='BusRoutes'></a>815. Bus Routes

[花花酱](https://www.bilibili.com/video/BV1QW411d794?spm_id_from=333.999.0.0)

###  1.119. <a name='LinkedListComponents'></a>817. Linked List Components

[花花酱](https://www.bilibili.com/video/BV1cW411o7Eu?spm_id_from=333.999.0.0)

###  1.120. <a name='RaceCar'></a>818. Race Car (上)

[花花酱](https://www.bilibili.com/video/BV1cW411o7Tb?spm_id_from=333.999.0.0)

###  1.121. <a name='ShortestDistancetoaCharacter'></a>821 Shortest Distance to a Character

[小明](https://www.bilibili.com/video/BV1gy4y1Y784?spm_id_from=333.999.0.0)

###  1.122. <a name='BinaryTreesWithFactors'></a>823. Binary Trees With Factors

[花花酱](https://www.bilibili.com/video/BV1CW411d7RX?spm_id_from=333.999.0.0)

###  1.123. <a name='GoatLatin'></a>824 Goat Latin

[小明](https://www.bilibili.com/video/BV1Th411o782?spm_id_from=333.999.0.0)

###  1.124. <a name='MakingALargeIsland'></a>827. Making A Large Island

[花花酱](https://www.bilibili.com/video/BV1mW411d7rc?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Cg4117727?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def largestIsland(self, grid):
        N = len(grid)

        def check(r, c):
            seen = {(r, c)}
            stack = [(r, c)]
            while stack:
                r, c = stack.pop()
                for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):
                    if (nr, nc) not in seen and 0 <= nr < N and 0 <= nc < N and grid[nr][nc]:
                        stack.append((nr, nc))
                        seen.add((nr, nc))
            return len(seen)

        ans = 0
        has_zero = False
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == 0:
                    has_zero = True
                    grid[r][c] = 1
                    ans = max(ans, check(r, c))
                    grid[r][c] = 0

        return ans if has_zero else N*N

作者：LeetCode
链接：https://leetcode-cn.com/problems/making-a-large-island/solution/zui-da-ren-gong-dao-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def largestIsland(self, grid):
        N = len(grid)

        def neighbors(r, c):
            for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if 0 <= nr < N and 0 <= nc < N:
                    yield nr, nc

        def dfs(r, c, index):
            ans = 1
            grid[r][c] = index
            for nr, nc in neighbors(r, c):
                if grid[nr][nc] == 1:
                    ans += dfs(nr, nc, index)
            return ans

        area = {}
        index = 2
        for r in xrange(N):
            for c in xrange(N):
                if grid[r][c] == 1:
                    area[index] = dfs(r, c, index)
                    index += 1

        ans = max(area.values() or [0])
        for r in xrange(N):
            for c in xrange(N):
                if grid[r][c] == 0:
                    seen = {grid[nr][nc] for nr, nc in neighbors(r, c) if grid[nr][nc] > 1}
                    ans = max(ans, 1 + sum(area[i] for i in seen))
        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/making-a-large-island/solution/zui-da-ren-gong-dao-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py

```

###  1.125. <a name='FlippinganImage'></a>832 Flipping an Image

[小明](https://www.bilibili.com/video/BV1q54y1r7f3?spm_id_from=333.999.0.0)

###  1.126. <a name='ImageOverlap'></a>835 Image Overlap

[小明](https://www.bilibili.com/video/BV1NK4y1a7Yf?spm_id_from=333.999.0.0)

###  1.127. <a name='New21Game'></a>837. 新 21 点 New 21 Game

[官方](https://www.bilibili.com/video/BV1Sz4y197cA?spm_id_from=333.999.0.0)

###  1.128. <a name='SimilarStringGroups'></a>839 【🍒并查集】Similar String Groups

[edo](https://www.bilibili.com/video/BV1jA411L7BY?from=search&seid=13338604369462419980&spm_id_from=333.337.0.0)

[郭郭](https://www.bilibili.com/video/BV1E64y1b7xd?from=search&seid=13286624680279107242&spm_id_from=333.337.0.0)

![image](https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.6owto1xqj040.webp)

```py
class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        def similarity(s, t):
            ans = 0
            for i in range(len(s)):
                if s[i] != t[i]:
                    ans += 1
                if ans > 2: return False
            return ans == 2 or ans == 0
        def dfs(graph, i, visit):
            visit.add(i)
            for v in graph[i]:
                if v not in visit:
                    dfs(graph, v, visit)
        n = len(strs)
        graph = defaultdict(set)
        for i in range(n):
            for j in range(i + 1, n):
                if similarity(strs[i], strs[j]):
                    graph[i].add(j)
                    graph[j].add(i)
        ans = 0
        visit = set()
        for i in range(n):
            if i not in visit:
                ans += 1
                dfs(graph, i, visit)
        return ans
```

```py
class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        n=len(strs)
        parent=list(range(n))
        size=[1]*n
        nSet=n

        def find(a):
            if parent[a]!=a:
                parent[a]=find(parent[a])
            return parent[a]

        def union(a,b):
            a,b=find(a),find(b)
            if a==b: return False
            if size[a]<size[b]:
                a,b=b,a
            parent[b]=a
            size[a]+=size[b]
            nonlocal nSet
            nSet-=1
            return True

        l=len(strs[0])
        for i in range(n-1):
            for j in range(i+1,n):
                diff=None
                for k in range(l):
                    c1,c2=strs[i][k],strs[j][k]
                    if c1!=c2:
                        if diff is None:
                            diff=(c1,c2)
                        elif diff==(c2,c1):
                            diff=0
                        else: break
                else:
                    union(i,j)
        return nSet
```

```py
class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        n, m = len(strs), len(strs[0])
        uf = UnionFind(n)
        for i in range(n):
            for j in range(i + 1, n):
                count = 0
                for k in range(m):
                    if strs[i][k] != strs[j][k]:
                        count += 1
                        if count > 2:
                            break
                if count in {0, 2}:
                    uf.union(i, j)
        return uf.count


class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.count = n

    def find(self, x):
        if self.parent[x] == x:
            return x
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        x, y = self.find(x), self.find(y)
        if x != y:
            self.parent[x] = y
            self.count -= 1

作者：T-RexInTheBronx
链接：https://leetcode-cn.com/problems/similar-string-groups/solution/python3-shi-yong-bing-cha-ji-ji-lu-lian-clfgm/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        n = len(strs)
        f = list(range(n))

        def find(x: int) -> int:
            if f[x] == x:
                return x
            f[x] = find(f[x])
            return f[x]
        
        def check(a: str, b: str) -> bool:
            num = 0
            for ac, bc in zip(a, b):
                if ac != bc:
                    num += 1
                    if num > 2:
                        return False
            return True
        
        for i in range(n):
            for j in range(i + 1, n):
                fi, fj = find(i), find(j)
                if fi == fj:
                    continue
                if check(strs[i], strs[j]):
                    f[fi] = fj
        
        ret = sum(1 for i in range(n) if f[i] == i)
        return ret

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/similar-string-groups/solution/xiang-si-zi-fu-chuan-zu-by-leetcode-solu-8jt9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

###  1.129. <a name='KeysandRooms'></a>841 Keys and Rooms

[小明](https://www.bilibili.com/video/BV1Wb4y1Q7hE?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1HK411F7JQ?spm_id_from=333.999.0.0)

```py
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        def dfs(x: int):
            vis.add(x)
            nonlocal num
            num += 1
            for it in rooms[x]:
                if it not in vis:
                    dfs(it)
        
        n = len(rooms)
        num = 0
        vis = set()
        dfs(0)
        return num == n

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        num = 0
        vis = {0}
        que = collections.deque([0])

        while que:
            x = que.popleft()
            num += 1
            for it in rooms[x]:
                if it not in vis:
                    vis.add(it)
                    que.append(it)
        
        return num == n

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/keys-and-rooms/solution/yao-chi-he-fang-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

DFS可以用栈实现。

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        cnt = len(rooms)
        seen = [False] * cnt
        stack = [0, ]
        while stack:
            nxt = stack.pop()
            if not seen[nxt]:
                seen[nxt] = True
                cnt -= 1
                stack.extend(rooms[nxt])
        return cnt == 0
```

```py
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        n = len(rooms)
        vis = [False] * n
        def dfs(st):
            vis[st] = True
            for ano in rooms[st]:
                if not vis[ano]:
                    dfs(ano)
        dfs(0)
        return all(vis)
dfs

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        vst = set()
        def f(key):
            vst.add(key)
            [f(k) for k in rooms[key] if k not in vst]
        return f(0) or len(vst) == len(rooms)
bfs

class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        que, vst = [0], {0}
        for key in que:
            for k in filter(lambda k: k not in vst, rooms[key]):
                que += [k]
                vst |= {k}
        return len(vst) == len(rooms)
class Solution:
    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        keys = [0]*len(rooms)
        def dfs(i):
            keys[i] = 1
            [dfs(key) for key in rooms[i] if keys[key]==0]
        dfs(0)
        return all(i==1 for i in keys)


class Solution:

    def dfs(self, key: int, rooms: List[List[int]]  , visited : List[bool] ) :
        if visited[key] :
            return

        visited[key] = True
        keys = rooms[key]
        for i in range(len(keys)) :
            # 深度优先搜索遍历
            self.dfs(keys[i], rooms, visited)

    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        visited = [False for i in range(len(rooms))]

        self.dfs(0, rooms, visited)

        # 检查是否都访问到了
        for i in range(len(visited)):
            if not visited[i] :
                return False
        return True

dfs 不需要那个 计数呀

class Solution:
    def canVisitAllRooms(self, rooms):
        def dfs(x: int):
            vis.add(x)
            for it in rooms[x]:
                if it not in vis:
                    dfs(it)
        
        n = len(rooms)
        vis = set()
        dfs(0)
        return len(vis) == n
```

###  1.130. <a name='SplitArrayintoFibonacciSequence'></a>842. Split Array into Fibonacci Sequence

[花花酱](https://www.bilibili.com/video/BV1ZJ411H7t4?spm_id_from=333.999.0.0)

###  1.131. <a name='BackspaceStringCompare'></a>844 Backspace String Compare

[小明](https://www.bilibili.com/video/BV1aC4y1s7LK?spm_id_from=333.999.0.0)

###  1.132. <a name='LongestMountaininArray'></a>845 Longest Mountain in Array

[小明](https://www.bilibili.com/video/BV1zi4y1L7yV?spm_id_from=333.999.0.0)

###  1.133. <a name='ShortestPathVisitingAllNodes'></a>847 Shortest Path Visiting All Nodes

[花花酱](https://www.bilibili.com/video/BV1hW411d7MU?spm_id_from=333.999.0.0)

###  1.134. <a name='MaximizeDistancetoClosestPerson'></a>849 Maximize Distance to Closest Person

[小明](https://www.bilibili.com/video/BV1ZZ4y1G7iT?spm_id_from=333.999.0.0)

###  1.135. <a name='ScoreofParentheses'></a>856. Score of Parentheses

[花花酱](https://www.bilibili.com/video/BV1bW411d7gp?spm_id_from=333.999.0.0)

###  1.136. <a name='MirrorReflection'></a>858 Mirror Reflection

[小明](https://www.bilibili.com/video/BV1av411r7MW?spm_id_from=333.999.0.0)

###  1.137. <a name='BuddyStrings'></a>859 Buddy Strings

[小明](https://www.bilibili.com/video/BV1nz4y1o7Wo?spm_id_from=333.999.0.0)

###  1.138. <a name='AllNodesDistanceKinBinaryTree'></a>863. All Nodes Distance K in Binary Tree

[花花酱](https://www.bilibili.com/video/BV14W411d7mz?spm_id_from=333.999.0.0)

###  1.139. <a name='ShortestPathtoGetAllKeys'></a>864. Shortest Path to Get All Keys

[花花酱](https://www.bilibili.com/video/BV1LW411d7th?spm_id_from=333.999.0.0)

###  1.140. <a name='ReorderedPowerof2'></a>869 Reordered Power of 2

[小明](https://www.bilibili.com/video/BV1M64y1D78v?spm_id_from=333.999.0.0)

###  1.141. <a name='SmallestSubtreewithalltheDeepestNodes'></a>865. Smallest Subtree with all the Deepest Nodes

[花花酱](https://www.bilibili.com/video/BV14W411d7ZR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1CV41187ZA?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def subtreeWithAllDeepest(self, root):
        # Tag each node with it's depth.
        depth = {None: -1}
        def dfs(node, parent = None):
            if node:
                depth[node] = depth[parent] + 1
                dfs(node.left, node)
                dfs(node.right, node)
        dfs(root)

        max_depth = max(depth.itervalues())

        def answer(node):
            # Return the answer for the subtree at node.
            if not node or depth.get(node, None) == max_depth:
                return node
            L, R = answer(node.left), answer(node.right)
            return node if L and R else L or R

        return answer(root)

作者：LeetCode
链接：https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/solution/ju-you-suo-you-zui-shen-jie-dian-de-zui-xiao-zi-sh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def subtreeWithAllDeepest(self, root):
        # The result of a subtree is:
        # Result.node: the largest depth node that is equal to or
        #              an ancestor of all the deepest nodes of this subtree.
        # Result.dist: the number of nodes in the path from the root
        #              of this subtree, to the deepest node in this subtree.
        Result = collections.namedtuple("Result", ("node", "dist"))
        def dfs(node):
            # Return the result of the subtree at this node.
            if not node: return Result(None, 0)
            L, R = dfs(node.left), dfs(node.right)
            if L.dist > R.dist: return Result(L.node, L.dist + 1)
            if L.dist < R.dist: return Result(R.node, R.dist + 1)
            return Result(node, L.dist + 1)

        return dfs(root).node

作者：LeetCode
链接：https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/solution/ju-you-suo-you-zui-shen-jie-dian-de-zui-xiao-zi-sh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
一趟dfs

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        def f(t):
            if not t:
                return t, 0
            else:
                x, m = f(t.left)
                y, n = f(t.right)
                if m > n:
                    return x, m + 1
                elif m < n:
                    return y, n + 1
                else:
                    return t, n + 1
        return f(root)[0]
单次dfs

class Solution:
    def dfs(self, root, level):
        if not root: return None, level
        left, llevel = self.dfs(root.left, level+1)
        right, rlevel = self.dfs(root.right, level+1)
        if llevel == rlevel:
            return root, llevel
        if llevel > rlevel:
            return left, llevel
        if llevel < rlevel:
            return right, rlevel


    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        if not root: return None
        ret, level = self.dfs(root, 0)
        return ret
python 比较直观的实现方法，判断节点的左右子树深度是否相同，相同的则为所求的字数：

class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        if not root: return root
        def dfs(root):
            if not root: return root
            l = self.max_depth(root.left)
            r = self.max_depth(root.right)
            if l == r: return root
            elif l > r: return dfs(root.left)
            else: return dfs(root.right)
        return dfs(root)
    def max_depth(self, root, layer=1):
        if not root: return layer-1
        return max(self.max_depth(root.left,layer+1), self.max_depth(root.right, layer+1))
```

###  1.142. <a name='MinimumNumberofRefuelingStops'></a>871. Minimum Number of Refueling Stops

[花花酱](https://www.bilibili.com/video/BV1JW411d7VK?spm_id_from=333.999.0.0)

###  1.143. <a name='LengthofLongestFibonacciSubsequence'></a>873. Length of Longest Fibonacci Subsequence

[花花酱](https://www.bilibili.com/video/BV1jW411d79H?spm_id_from=333.999.0.0)

[小梦想家](https://www.bilibili.com/video/BV1ab411i7wx?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def lenLongestFibSubseq(self, A):
        S = set(A)
        ans = 0
        for i in xrange(len(A)):
            for j in xrange(i+1, len(A)):
                """
                With the starting pair (A[i], A[j]),
                y represents the future expected value in
                the fibonacci subsequence, and x represents
                the most current value found.
                """
                x, y = A[j], A[i] + A[j]
                length = 2
                while y in S:
                    x, y = y, x + y
                    length += 1
                ans = max(ans, length)
        return ans if ans >= 3 else 0

作者：LeetCode
链接：https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-chang-du-by/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def lenLongestFibSubseq(self, A):
        index = {x: i for i, x in enumerate(A)}
        longest = collections.defaultdict(lambda: 2)

        ans = 0
        for k, z in enumerate(A):
            for j in xrange(k):
                i = index.get(z - A[j], None)
                if i is not None and i < j:
                    cand = longest[j, k] = longest[i, j] + 1
                    ans = max(ans, cand)

        return ans if ans >= 3 else 0

作者：LeetCode
链接：https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/solution/zui-chang-de-fei-bo-na-qi-zi-xu-lie-de-chang-du-by/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
def lenLongestFibSubseq(self, A):
    """
    :type A: List[int]
    :rtype: int
    """
    dic = {num:[] for num in A}
    head = [(2,num) for num in A]
    size = len(A)
    cnt = 0
    for i,num in enumerate(A):
        cur = dic[num]
        for l,last in head[:i]+cur:
            if l+size-i+1 <= cnt:
                continue
            new = last+num
            if new in dic:
                dic[new].append((l+1,num))
                cnt = max(cnt,l+1)
    return cnt if cnt > 2 else 0
思路：a[i][j]用于记录A[?]+A[i]是否能得到A[j]，如果从来都不行，然后第一次可以，就为3；否则则为a[i][j]+1

class Solution:
    def lenLongestFibSubseq(self, A: List[int]) -> int:
        n, res = len(A), 0
        a = [[0] * n for i in range(n)]
        for i in range(n):
            lo, hi, v = 0, i - 1, A[i]
            while lo < hi:
                if A[lo] + A[hi] < v:
                    lo += 1
                elif A[lo] + A[hi] > v:
                    hi -= 1
                else:
                    if a[lo][hi]:
                        a[hi][i] = a[lo][hi] + 1
                    else:
                        a[hi][i] = 3
                    res = max(a[hi][i], res)
                    lo += 1
                    hi -= 1
        return res
```

###  1.144. <a name='KokoEatingBananas'></a>875.Koko Eating Bananas科科吃香蕉

[图灵](https://www.bilibili.com/video/BV1iV411s7eU?spm_id_from=333.999.0.0)

###  1.145. <a name='MiddleoftheLinkedList'></a>876.Middle of the Linked List 链表的中间结点

[图灵](https://www.bilibili.com/video/BV1Kv411p7vf?spm_id_from=333.999.0.0)

[洛阳](https://www.bilibili.com/video/BV1Pz41187WS?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1aK411T74X?spm_id_from=333.999.0.0)

```py
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        A = [head]
        while A[-1].next:
            A.append(A[-1].next)
        return A[len(A) // 2]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        n, cur = 0, head
        while cur:
            n += 1
            cur = cur.next
        k, cur = 0, head
        while k < n // 2:
            k += 1
            cur = cur.next
        return cur

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

python 快慢双指针

class Solution(object):
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow


```

```py
第一种先计数再找中点，第二种快慢指针

class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        first = head
        count = 0
        while first != None:
            first = first.next
            count += 1
        second = head
        count = count//2
        while count > 0:
            second = second.next
            count -= 1
        return second
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        first = second = head
        while first != None and first.next != None:
            first = first.next.next
            second = second.next
        return second
```

###  1.146. <a name='StoneGame'></a>877 【二维动态🚀规划】Stone Game

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Hr?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1xq4y1Q7uL?spm_id_from=333.999.0.0)

一共有偶数堆石子，必然存在奇数堆大，or偶数堆大，只要找到其中的较大一半就行

```py
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        return True
```

递归，O(2^n)

记忆化递归(min-Max) O(n^2)

缺点是：
- 深度不能太深
- 不能降维

```py
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        @cache
        def helper(i, j):
            if i==j: return piles[i]
            return max(piles[i]-helper(i+1, j),
                       piles[j]-helper(i, j-1))
        return helper(0, len(piles)-1)>=0
```

动态🚀规划 O(n^2)

可以降维

```py

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        length = len(piles)
        dp = [[0] * length for _ in range(length)]
        for i, pile in enumerate(piles):
            dp[i][i] = pile
        for i in range(length - 2, -1, -1):
            for j in range(i + 1, length):
                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])
        return dp[0][length - 1] > 0

降维以后

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        length = len(piles)
        dp = [0] * length
        for i, pile in enumerate(piles):
            dp[i] = pile
        for i in range(length - 2, -1, -1):
            for j in range(i + 1, length):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[length - 1] > 0

区间DP，和上面更新的次序不同

把dp打印出来看看就懂了。

class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        N = len(piles)
        dp = [[0]*(N+1) for _ in range(N+1)] # 防止出界
        for gap in range(N):
            for i in range(N-gap):
                j = i+gap
                dp[i][j] = max(piles[i]-dp[i+1][j],
                              piles[j]-dp[i][j-1])
        return dp[0][N-1]>0
```



###  1.147. <a name='ProfitableSchemes'></a>879. Profitable Schemes

[花花酱](https://www.bilibili.com/video/BV1mW411Z7Jt?spm_id_from=333.999.0.0)

###  1.148. <a name='DecodedStringatIndex'></a>880 Decoded String at Index

[小明](https://www.bilibili.com/video/BV1Tt4y1k7GJ?spm_id_from=333.999.0.0)

###  1.149. <a name='BoatstoSavePeople'></a>881 Boats to Save People

[小明](https://www.bilibili.com/video/BV1MT4y1K7yq?spm_id_from=333.999.0.0)

###  1.150. <a name='ReachableNodesInSubdividedGraph'></a>882. Reachable Nodes In Subdivided Graph

[花花酱](https://www.bilibili.com/video/BV11W411Z71N?spm_id_from=333.999.0.0)

###  1.151. <a name='PossibleBipartition'></a>886. 【🍒并查集】Possible Bipartition

[花花酱](https://www.bilibili.com/video/BV1DW411Z7G6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1FT4y1g77u?spm_id_from=333.999.0.0)

```py
🍒并查集

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        teams = [0] * (n + 1)
        graph = collections.defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)
        # print(graph):
        # defaultdict(<class 'list'>, {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]})

        parent = list(range(n+1))
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            parent[find(x)] = parent[find(y)]

        for AA in range(1, n+1):
            for BB in graph[AA]: # AA 不能和 BB 在一起
                if find(AA) == find(BB): return False
                union(BB, graph[AA][0])
        return True
```

```py
class Solution(object):
    def possibleBipartition(self, N, dislikes):
        graph = collections.defaultdict(list)
        for u, v in dislikes:
            graph[u].append(v)
            graph[v].append(u)

        color = {}
        def dfs(node, c = 0):
            if node in color:
                return color[node] == c
            color[node] = c
            return all(dfs(nei, c ^ 1) for nei in graph[node])

        return all(dfs(node)
                   for node in range(1, N+1)
                   if node not in color)

python, 二刷, 图+dfs搜索, 缓存搜索中的分组号, 降低时间复杂度

class Solution:
    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:
        graph = collections.defaultdict(list)   # 刻画a, b两人的关系图, 无向图
        for s, e in dislikes:
            graph[s].append(e)
            graph[e].append(s)
        
        group = dict()

        @functools.lru_cache(None)               # 缓存dfs搜索中间结果, 下次i相同就相当于表查询, 时间复杂度为O(n)
        def dfs(i, g=1):
            if i in group:
                return group[i] == g            # i的组划分,已经判定在了group当中, 所以判断是否矛盾
            group[i] = g                        # 不矛盾的话, 判定给组g
            for con in graph[i]:                # 如果i的邻接节点,都能不矛盾地"安排", 返回true
                if not dfs(con, -1 * g):
                    return False
            return True
        
        for i in range(1, N + 1):
            if i not in group and not dfs(i):   # 此处必须强调i不在group, 因为前面搜索中可能将
                return False                    # i判定给了-1, 但是此时如果再次dfs搜索, 将其默认为1,会矛盾
        return True

DFS

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        color = [0] * n
        
        def dfs(node, c):
            if color[node] == -c: return False
            if color[node] == c: return True
            color[node] = c
            for neighbor in graph[node]:
                if not dfs(neighbor, -c):
                    return False
            return True
        
        for i in range(n):
            if color[i] == 0 and not dfs(i, 1):
                return False
        return True
BFS

class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        teams = [0] * (n + 1)
        graph = collections.defaultdict(list)
        for a, b in dislikes:
            graph[a].append(b)
            graph[b].append(a)

        for i in range(1, n+1):
            if teams[i] == 0:
                teams[i] = 1
                Q = collections.deque([i])
                while Q:
                    p = Q.popleft()
                    for neighbor in graph[p]:
                        if teams[neighbor] == teams[p]: return False
                        elif teams[neighbor] == 0:
                            teams[neighbor] = -teams[p]
                            Q.append(neighbor)
        return True


```

###  1.152. <a name='SuperEggDrop'></a>887. Super Egg Drop

[花花酱](https://www.bilibili.com/video/BV1Tv411i7cP?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1ri4y1t78d?spm_id_from=333.999.0.0)

<img src="https://raw.githubusercontent.com/YutingYao/DailyJupyter/main/imageSever/image.3ld2gccb6ey0.webp" width="30%">

```py
dp[k][m] 的含义是k个鸡蛋 移动m次最多能够确定多少楼层
这个角度思考
dp[k][m] 最多能够确定的楼层数为L

那么我选定第一个扔的楼层之后，我要么碎，要么不碎

这就是把L分成3段:
左边是碎的那段 长度是 dp[k][m - 1]
右边是没碎的那段 长度是 dp[k-1][m - 1] 因为已经碎了一个了
中间是我选定扔的楼层 是1

所以递推公式是:
dp[k][m] = dp[k - 1][m - 1] + dp[k][m - 1] + 1

根据递推公式 如果采用k倒着从大到小计算 就可以只存一行的dp[k] 直接原地更新dp[k] 不影响后续计算 

只需要O(K)空间复杂度 O(KlogN) 鸡蛋完全够用的时候 就是走LogN步 最差情况是1个鸡蛋走N步 O(KN)

class Solution:
    def superEggDrop(self, eggs: int, level: int) -> int:
            dp = [0] * (eggs + 1)
            m = 0
            while dp[eggs] < level:
                m += 1
                for gg in range(eggs, 0, -1):
                    # 鸡蛋碎了，剩下的鸡蛋可以遍历多少楼层，鸡蛋没碎，可以遍历的楼层数目
                    dp[gg] = dp[gg - 1] + dp[gg] + 1
            return m

if __name__ == "__main__":      
	s = Solution()
	print(s.superEggDrop(3,14))
    # print('移动次数:',m,'鸡蛋:', k)
# 移动次数: 1 鸡蛋0-3对应楼层: [0, 1, 1, 1]
# 移动次数: 2 鸡蛋0-3对应楼层: [0, 2, 3, 3]
# 移动次数: 3 鸡蛋0-3对应楼层: [0, 3, 6, 7]
# 移动次数: 4 鸡蛋0-3对应楼层: [0, 4, 10, 14]
```

```py
class Solution:
    def superEggDrop(self, eggs: int, levels: int) -> int:
        dp = list(range(levels + 1))
        dp2 = [0] * (levels + 1)
        for eggs in range(2, eggs + 1):
            x = 1
            for m in range(1, levels + 1):
                # max(dp[x-1], dp2[m-x]) > max(dp[x], dp2[m-x-1])
                # max(T1(x-1), T2(x-1)) > max(T1(x), T2(x)).
                while x < m and max(dp[x - 1], dp2[m - x]) >= max(dp[x], dp2[m - x - 1]):
                    x += 1
                # The final answer happens at this x.
                dp2[m] = 1 + max(dp[x - 1], dp2[m - x])

            dp = dp2[:]

        return dp[-1]


class Solution:
    def superEggDrop(self, eggs: int, level: int) -> int:
        if level == 1:
            return 1
        f = [[0] * (eggs + 1) for _ in range(level + 1)]
        for i in range(1, eggs + 1):
            f[1][i] = 1
        res = -1
        for i in range(2, level + 1):
            for j in range(1, eggs + 1):
                f[i][j] = 1 + f[i - 1][j - 1] + f[i - 1][j]
            if f[i][eggs] >= level:
                res = i
                break
        return res
```

###  1.153. <a name='ConstructBinaryTreefromPreorderandPostorder'></a>889. Construct Binary Tree from Preorder and Postorder

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Qi?spm_id_from=333.999.0.0)

###  1.154. <a name='SumofSubsequenceWidths'></a>891. Sum of Subsequence Widths

[花花酱](https://www.bilibili.com/video/BV1DW411Z7Yv?spm_id_from=333.999.0.0)

###  1.155. <a name='AllPossibleFullBinaryTrees'></a>894. All Possible Full Binary Trees

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Sb?spm_id_from=333.999.0.0)

###  1.156. <a name='MaximumFrequencyStack'></a>895. Maximum Frequency Stack

[花花酱](https://www.bilibili.com/video/BV1rW411Z7Hp?spm_id_from=333.999.0.0)

###  1.157. <a name='BitwiseORsofSubarrays'></a>898. Bitwise ORs of Subarrays

[花花酱](https://www.bilibili.com/video/BV1kW411Z7HV?spm_id_from=333.999.0.0)

###  1.158. <a name='OnlineStockSpan'></a>901. 【构造🏰】Online Stock Span

[花花酱](https://www.bilibili.com/video/BV1kW411k77K?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Jg4y1B74H?spm_id_from=333.999.0.0)

```py
class StockSpanner(object):
    def __init__(self):
        self.stack = []

    def next(self, price):
        weight = 1
        while self.stack and self.stack[-1][0] <= price:
            weight += self.stack.pop()[1]
        self.stack.append((price, weight))
        return weight

作者：LeetCode
链接：https://leetcode-cn.com/problems/online-stock-span/solution/gu-piao-jie-ge-kua-du-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class StockSpanner:

    def __init__(self):
        self.stack = [] # (price, span)

    def next(self, price: int) -> int:
        span = 1
        while self.stack and self.stack[-1][0] <= price:
            span += self.stack.pop()[1]
        self.stack.append((price, span))
        return span
```

```py
class StockSpanner:
    """
    用一个栈来存储过去股票的价格和对应的跨度，
    如果当天的股票价格大于栈顶的股票价格，则出栈，
    将对应的跨度加到今日股票价格的跨度上．
    直到栈顶的股票价格大于当日股票价格，然后将当日股票价格和对应的跨度入栈
    """
    def __init__(self):
        self.his_prices = [(-999, 0)]

    def next(self, price: int) -> int:
        span = 1
        while self.his_prices:
            if self.his_prices[-1][0] <= price:
                span += self.his_prices.pop()[1]
            else:
                break
        self.his_prices.append((price, span))
        return span
```

###  1.159. <a name='NumbersAtMostNGivenDigitSet'></a>902 Numbers At Most N Given Digit Set

[小明](https://www.bilibili.com/video/BV19A411j7Wf?spm_id_from=333.999.0.0)

###  1.160. <a name='-1'></a>904-水果成篮

[哈哈哈](https://www.bilibili.com/video/BV19i4y1M7Xn?spm_id_from=333.999.0.0)

###  1.161. <a name='SortArrayByParity'></a>905 Sort Array By Parity

[小明](https://www.bilibili.com/video/BV1Xk4y117rK?spm_id_from=333.999.0.0)

###  1.162. <a name='SuperPalindromes'></a>906 Super Palindromes

[小明](https://www.bilibili.com/video/BV1LA41157Wf?spm_id_from=333.999.0.0)

###  1.163. <a name='SnakesandLadders'></a>909. Snakes and Ladders

[小梦想家](https://www.bilibili.com/video/BV1cy4y1W7u9?spm_id_from=333.999.0.0)

###  1.164. <a name='SmallestRangeII'></a>910 Smallest Range II

[小明](https://www.bilibili.com/video/BV1p5411H7mS?spm_id_from=333.999.0.0)

###  1.165. <a name='WordSubsetse'></a>916 Word Subsetse

[小明](https://www.bilibili.com/video/BV1vh411S7r3?spm_id_from=333.999.0.0)

###  1.166. <a name='MaximumSumCircularSub'></a>918 Maximum Sum Circular Sub

[小明](https://www.bilibili.com/video/BV1c5411s7jZ?spm_id_from=333.999.0.0)

###  1.167. <a name='SumWithMultiplicity'></a>923. 3Sum With Multiplicity 

[花花酱](https://www.bilibili.com/video/BV14t411o7QT?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Pv41187sq?spm_id_from=333.999.0.0)

```py
def solve(A, target):
    # Assume A already sorted
    i, j = 0, len(A) - 1
    ans = 0
    while i < j:
        if A[i] + A[j] < target:
            i += 1
        elif A[i] + A[j] > target:
            j -= 1
        else:
            ans += 1
            i += 1
            j -= 1
    return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        ans = 0
        A.sort()

        for i, x in enumerate(A):
            # We'll try to find the number of i < j < k
            # with A[j] + A[k] == T, where T = target - A[i].

            # The below is a "two sum with multiplicity".
            T = target - A[i]
            j, k = i+1, len(A) - 1

            while j < k:
                # These steps proceed as in a typical two-sum.
                if A[j] + A[k] < T:
                    j += 1
                elif A[j] + A[k] > T:
                    k -= 1
                # These steps differ:
                elif A[j] != A[k]: # We have A[j] + A[k] == T.
                    # Let's count "left": the number of A[j] == A[j+1] == A[j+2] == ...
                    # And similarly for "right".
                    left = right = 1
                    while j + 1 < k and A[j] == A[j+1]:
                        left += 1
                        j += 1
                    while k - 1 > j and A[k] == A[k-1]:
                        right += 1
                        k -= 1

                    # We contributed left * right many pairs.
                    ans += left * right
                    ans %= MOD
                    j += 1
                    k -= 1

                else:
                    # M = k - j + 1
                    # We contributed M * (M-1) / 2 pairs.
                    ans += (k-j+1) * (k-j) / 2
                    ans %= MOD
                    break

        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        count = [0] * 101
        for x in A:
            count[x] += 1

        ans = 0

        # All different
        for x in xrange(101):
            for y in xrange(x+1, 101):
                z = target - x - y
                if y < z <= 100:
                    ans += count[x] * count[y] * count[z]
                    ans %= MOD

        # x == y
        for x in xrange(101):
            z = target - 2*x
            if x < z <= 100:
                ans += count[x] * (count[x] - 1) / 2 * count[z]
                ans %= MOD

        # y == z
        for x in xrange(101):
            if (target - x) % 2 == 0:
                y = (target - x) / 2
                if x < y <= 100:
                    ans += count[x] * count[y] * (count[y] - 1) / 2
                    ans %= MOD

        # x == y == z
        if target % 3 == 0:
            x = target / 3
            if 0 <= x <= 100:
                ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6
                ans %= MOD

        return ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

嗯……数学大法好

from collections import defaultdict
class Solution(object):
    def threeSumMulti(self, A, target):
        """
        :type A: List[int]
        :type target: int
        :rtype: int
        """
        mod = 1000000007
        
        counter = defaultdict(int)
        for n in A:
            counter[n] += 1
        
        ans = 0
        # x != y != z
        for x in xrange(101):
            for y in xrange(x+1, 101):
                z = target - x - y
                if z <= y:
                    continue
                ans += counter[x] * counter[y] * counter[z]
                ans %= mod 
                        
        # x == y != z
        for x in xrange(101):
            z = target - 2*x
            if z == x:
                continue
            ans += counter[x] * (counter[x]-1) * counter[z] / 2
            ans %= mod
            
        if target % 3 == 0:
            x = target / 3
            ans += counter[x] * (counter[x]-1) * (counter[x]-2) / 6
            ans %= mod
            
        return ans
python，数学方法，先把数组储存成字典，如果3个数相同，那么就是Cm3（m是该值的个数，数学里面的排列，不知道怎么调格式），如果有两个数一样，那么就是Cm2*Cn1，如果三个数均不同，那么就是Cm1*Cn1*Ck1


class Solution(object):
    def threeSumMulti(self, A, target):
        MOD = 10**9 + 7
        count = collections.Counter(A)
        keys = sorted(count)

        ans = 0

        # Now, let's do a 3sum on "keys", for i <= j <= k.
        # We will use count to add the correct contribution to ans.
        for i, x in enumerate(keys):
            T = target - x
            j, k = i, len(keys) - 1
            while j <= k:
                y, z = keys[j], keys[k]
                if y + z < T:
                    j += 1
                elif y + z > T:
                    k -= 1
                else: # x+y+z == T, now calculate the size of the contribution
                    if i < j < k:
                        ans += count[x] * count[y] * count[z]
                    elif i == j < k:
                        ans += count[x] * (count[x] - 1) / 2 * count[z]
                    elif i < j == k:
                        ans += count[x] * count[y] * (count[y] - 1) / 2
                    else:  # i == j == k
                        ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6

                    j += 1
                    k -= 1

        return ans % MOD

作者：LeetCode
链接：https://leetcode-cn.com/problems/3sum-with-multiplicity/solution/san-shu-zhi-he-de-duo-chong-ke-neng-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution:
    def threeSumMulti(self, A: List[int], target: int) -> int:
        ans = dict()  #数组转换成字典
        for i,num in enumerate(A):
            ans[num] = ans.get(num,0) + 1
        res = []  #target的可能分解结果
        for i in range(0,target//3+1):
            for j in range(i,target//2+1):
                k = target - i - j
                if k >= j:
                    res.append([i,j,k]) 
        total = 0
        for i,j,k in res:
            if i in ans and j in ans and k in ans:
                if i == j==k:
                    total += ans[i]*(ans[i]-1)*(ans[i]-2)//6
                elif i == j:
                    total += ans[i]*(ans[i]-1)*(ans[k])//2
                elif j == k:
                    total += ans[i]*(ans[j]-1)*ans[j]//2
                else:
                    total += ans[i]*ans[j]*ans[k]
        return total % (10**9+7)
```

###  1.168. <a name='FlipStringtoMonotoneIncreasing'></a>926. Flip String to Monotone Increasing

[花花酱](https://www.bilibili.com/video/BV1ft411R7qv?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Vh411i7Wg?spm_id_from=333.999.0.0)

```py
暴力求解：一行代码，但是会超时，存在大量重复计算
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        return min([s[:i].count('1') + s[i+1:].count('0') for i in range(len(s))])

一定要拿草稿纸写下来

class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        # 最后一位1肯定不需要反转
        dp1 = [0] * n
        for i in range(n-1): 
            dp1[i+1] = dp1[i]
            if s[i] == '1':
                dp1[i+1] += 1
        # 第一位0肯定不需要反转
        dp0 = [0] * n
        for i in range(n-1,0,-1): 
            dp0[i-1] = dp0[i]
            if s[i] == '0':
                dp0[i-1] += 1
        return min(x[0]+x[1] for x in zip(dp0,dp1))


class Solution(object):
    def minFlipsMonoIncr(self, S):
        m = S.count('0')   #分界点为0之前，统计之后的0
        res = [m]
        for x in S:
            if x == '1':   #如果是1，分界点之前1的个数+1，分界点之后0的个数不变
                m += 1
            else:       #如果是0，分界点之前1的个数不变，分界点之后0的个数减1
                m -= 1
            res.append(m)        
        return min(res)
```

###  1.169. <a name='-1'></a>930-【滑动窗口🔹 + 前缀和🎨】和相同的二元子数组

[哈哈哈](https://www.bilibili.com/video/BV1iy4y1T7M3?spm_id_from=333.999.0.0)

###  1.170. <a name='NumberofRecentCalls'></a>933 Number of Recent Calls

[小明](https://www.bilibili.com/video/BV1gA41177jm?spm_id_from=333.999.0.0)

###  1.171. <a name='ShortestBridge'></a>934. Shortest Bridge

[花花酱](https://www.bilibili.com/video/BV19t411y7rL?spm_id_from=333.999.0.0)

###  1.172. <a name='StampingTheSequence'></a>936 Stamping The Sequence

[小明](https://www.bilibili.com/video/BV1d64y1D7fq?spm_id_from=333.999.0.0)

###  1.173. <a name='RangeSumofBST'></a>938 Range Sum of BST

[小明](https://www.bilibili.com/video/BV1WV411a7VR?spm_id_from=333.999.0.0)

###  1.174. <a name='ValidMountainArray'></a>941 Valid Mountain Array

[小明](https://www.bilibili.com/video/BV1n5411G7qs?spm_id_from=333.999.0.0)

###  1.175. <a name='FindtheShortestSuperstring'></a>943. Find the Shortest Superstring

[花花酱](https://www.bilibili.com/video/BV1yt411171k?spm_id_from=333.999.0.0)

###  1.176. <a name='Python-'></a>946-Python-栈的压入、弹出序列

[哈哈哈](https://www.bilibili.com/video/BV1JD4y1o7ZD?spm_id_from=333.999.0.0)

###  1.177. <a name='ValidateStackSequences'></a>946 Validate Stack Sequences

[小明](https://www.bilibili.com/video/BV1fz4y1y7rS?spm_id_from=333.999.0.0)

###  1.178. <a name='MostStonesRemovedwithSame'></a>947. 【🍒并查集】移除最多的同行或同列石头 Most Stones Removed with Same

[官方](https://www.bilibili.com/video/BV1Nr4y1K7Gj?spm_id_from=333.999.0.0)

[郭郭](https://www.bilibili.com/video/BV1Tq4y157i8?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

```py
并查集，真好用，

一次AC不是梦！

我们全家都用它，

效果真是顶呱呱.

又好写来又好懂，

脑壳再也不会痛.

class UFS():
    def __init__(self, N):
        self.p = range(N)

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]
    
    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr

class Solution(object):
    def removeStones(self, stones):
        ufs = UFS(20000)
        for x,y in stones:
            ufs.union(x,y+10000)
        return len(stones)-len({ufs.find(x) for x,y in stones})
```

```py
class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        def union(x: int, y: int):
            parent[find(x)] = find(parent[y])

        def find(idx: int) -> int:
            if parent[idx] != idx:
                parent[idx] = find(parent[idx])
            return parent[idx]

        n = len(stones)
        parent = list(range(n))
        row_map, col_map = {}, {}
        for i in range(n):
            if stones[i][0] not in row_map:
                row_map[stones[i][0]] = i
            else:
                union(i, row_map[stones[i][0]])
            if stones[i][1] not in col_map:
                col_map[stones[i][1]] = i
            else:
                union(i, col_map[stones[i][1]])
        graph = set()
        for i in range(n):
            graph.add(find(i))
        return n - len(graph)
```

```py
并查集能想到，难的是想了半天怎么把每个点之间的连通的关系表示出来，一看题解好家伙+10000，太妙了

class DSU:
    def __init__(self,nodecount):
        self.node_relation_list=[-1]*nodecount
    def find(self,node):
        temp=node
        while self.node_relation_list[node]!=-1:
            node=self.node_relation_list[node]
        if temp!=node:
            self.node_relation_list[temp]=node
        return node
    def merge(self,node1,node2):
        node1boss=self.find(node1)
        node2boss=self.find(node2)
        if node1boss!=node2boss:
            self.node_relation_list[node1boss]=node2boss
        return 
class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        ufs = DSU(20000)
        for x,y in stones:
            ufs.merge(x,y+10000)#所有点按横坐标连通
        return len(stones)-len({ufs.find(x) for x,y in stones})#后者是算有几个集合

使用并查集。其实不需要像官方题解那样 +10000。 

由于题目没有直接给出石头的连接关系，可以记录两个dict。 

dict的key为石头的横/纵坐标，value是上一个相同横/纵坐标的石头的编号。 

这样遍历所有石头，每次从两个dict中取出上一个与该石头有相同横/纵坐标的石头，

把它们在并查集中连通即可。

    def removeStones(self, stones):
        father = range(len(stones))
        def find(x):
            if father[x] != x:
                father[x] = find(father[x])
            return father[x]
        
        def union(x, y):
            if y is not None:
                father[find(x)] = find(y)
        
        c_dict, r_dict = {}, {}
        for i in range(len(stones)):
            union(i, c_dict.get(stones[i][0]))
            c_dict[stones[i][0]] = i
            union(i, r_dict.get(stones[i][1]))
            r_dict[stones[i][1]] = i
        return len(stones) - len({find(x) for x in father})
```

```py
class DSU:
    def __init__(self,n: int):
        self.p = [i for i in range(n)]
    
    def find(self,x: int) -> int:
        if x != self.p[x]: self.p[x] = self.find(self.p[x])
        return self.p[x]
    
    def merge(self,x: int,y: int):
        rx , ry = self.find(x) , self.find(y)
        if rx == ry: return 
        self.p[rx] = ry
        return

class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        n = len(stones)
        dsu = DSU(n)
        for i in range(len(stones)):
            for j in range(i+1,len(stones)):
                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:
                    dsu.merge(i,j)
        cnt = 0
        for i in range(len(dsu.p)):
            if dsu.p[i] == i:
                cnt += 1
        return n - cnt
```

```py
贡献一个python3 80ms 97%

class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        dict_X = collections.defaultdict(list)
        dict_Y = collections.defaultdict(list)
        for x, y in stones:
            dict_X[x].append((x, y))
            dict_Y[y].append((x, y))
        visited = set()

        def dfs(node):
            if node in visited:
                return
            visited.add(node)
            x, y = node
            for i in dict_X[x]:
                dfs(i)
            for i in dict_Y[y]:
                dfs(i)
        
        ans = 0
        for i in stones:
            i = tuple(i)
            if i not in visited:
                ans += 1
                dfs(i)
        
        return len(stones) - ans
```

```py
贡献一个并查集 Python3 76ms 96%的代码。。。

class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        uf = UnionFindSet()
        for s in stones:
            x, y = s[0], s[1] + 10000
            # print('add:', x, y)
            uf.add(x)
            uf.add(y)
            uf.union(x, y)
        return len(stones) - uf.count()


class UnionFindSet:

    def __init__(self):
        self.dic_set = {}
        self.sets = set()

    def add(self, x):
        if x not in self.dic_set:
            s = {x}
            self.dic_set[x] = s
            self.sets.add(id(s))
    
    def find(self, x):
        if x not in self.dic_set:
            return None
        return self.dic_set[x]
    
    def union(self, x, y):
        x_set, y_set = self.find(x), self.find(y)
        if x_set is y_set:
            return
        
        if len(x_set) < len(y_set):
            x_set, y_set = y_set, x_set

        x_set |= y_set
        for item in y_set:
            self.dic_set[item] = x_set

        self.sets.remove(id(y_set))

    def is_connected(self, x, y):
        return self.find(x) is self.find(y)

    def count(self):
        return len(self.sets)

我原来尝试过在并查集里加上 add() 方法，

在 add() 方法里判断某个里在并查集里是不是存在。

后来感觉弄个 add() 方法让外部调用可能不太好。

但是每次在 find() 方法里面判断其实是比较不划算的。选择困难啊。

---------------------------------------

的确如此，我比较倾向于不给出 add()方法，

根据具体题目编写初始化函数或者 add()方法 ；

最初看你编写的并查集教程里头，就是疑惑如果元素不存在于并查集里怎么办，

dict[x]如果x不存在难道不异常么。。。结果清一色的，全是用数组初始化、或者字典初始化，

保证了x元素必然存在（同时self.parent[x]也必然存在），真是个大大的思维盲区。 

不过根据今天的题目，我总结了一下适合我理解的并查集模型，

给出add方法虽然初始化效率会低一些，但是代码逻辑比较统一，

集成了并查集+路径压缩+权重优化+结果集，执行效率会高一些，综合来看还是比较合适的。
```

###  1.179. <a name='BagofTokens'></a>948 Bag of Tokens

[小明](https://www.bilibili.com/video/BV1MK411P7K6?spm_id_from=333.999.0.0)

###  1.180. <a name='LargestTimeforGivenDigits'></a>949 Largest Time for Given Digits

[小明](https://www.bilibili.com/video/BV13v41117QS?spm_id_from=333.999.0.0)

###  1.181. <a name='LargestComponentSizebyCommo'></a>952 【🍒并查集】Largest Component Size by Commo

[小明](https://www.bilibili.com/video/BV1oK4y1h7Jt?spm_id_from=333.999.0.0)

[花花酱](https://www.bilibili.com/video/BV1at411D7gp?from=search&seid=1135814820928819139&spm_id_from=333.337.0.0)

###  1.182. <a name='VerifyinganAlienDictionary'></a>953 Verifying an Alien Dictionary

[小明](https://www.bilibili.com/video/BV1C64y1S7tT?spm_id_from=333.999.0.0)

###  1.183. <a name='ArrayofDoubledPairs'></a>954 Array of Doubled Pairs

[小明](https://www.bilibili.com/video/BV1Hq4y1S7xR?spm_id_from=333.999.0.0)

###  1.184. <a name='RegionsCutBySlashes'></a>959. 【🍒并查集】由斜杠划分区域 Regions Cut By Slashes

[官方](https://www.bilibili.com/video/BV1Ry4y117HD?spm_id_from=333.999.0.0)

[edo](https://www.bilibili.com/video/BV1fp4y1W7eR?from=search&seid=18400815010859255620&spm_id_from=333.337.0.0)

[花花酱](https://www.bilibili.com/video/BV14t411v7VX?from=search&seid=1135814820928819139&spm_id_from=333.337.0.0)

###  1.185. <a name='DijkstraLeastOperatorstoExpressNumber'></a>964. 【Dijkstra🚗】Least Operators to Express Number

[花花酱](https://www.bilibili.com/video/BV1Pt411k7qn?spm_id_from=333.999.0.0)

###  1.186. <a name='VowelSpellchecker'></a>966 Vowel Spellchecker

[小明](https://www.bilibili.com/video/BV1oK4y1T7kR?spm_id_from=333.999.0.0)

###  1.187. <a name='NumbersWithSameConsecutiveDifferences'></a>967. Numbers With Same Consecutive Differences

[花花酱](https://www.bilibili.com/video/BV1gt411B7oG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1f5411L7r4?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def numsSameConsecDiff(self, N, K):
        ans = {x for x in range(1, 10)}
        for _ in xrange(N-1):
            ans2 = set()
            for x in ans:
                d = x % 10
                if d - K >= 0:
                    ans2.add(10*x + d-K)
                if d + K <= 9:
                    ans2.add(10*x + d+K)
            ans = ans2

        if N == 1:
            ans.add(0)

        return list(ans)

作者：LeetCode
链接：https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences/solution/lian-xu-chai-xiang-tong-de-shu-zi-by-leetcode-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def numsSameConsecDiff(self, n: int, k: int):
        def temp_class(ret,N,K):
            temp = []
            #返回条件
            if N == 0:
                return [ret]
            #
            if ret%10 + K < 10:
                temp += temp_class(ret*10+ret%10+k,N-1,K)
            if ret%10 - K > -1 and K != 0:
                temp += temp_class(ret*10+ret%10-k,N-1,K)
            return temp
        #
        ret = []
        for i in range(1,10,1):
            if i + k < 10 or k - i < 10:
                ret += temp_class(i,n-1,k)
        return ret

def numsSameConsecDiff(self, N, K):
        """
        :type N: int
        :type K: int
        :rtype: List[int]
        """
        dp = set(range(10))
        for i in range(1, N):
            prev_dp = dp
            dp = set()
            for num in prev_dp:
                if num == 0:
                    continue
                left = num % 10
                if left >= K:
                    dp.add(num*10+left-K)
                if left + K <= 9:
                    dp.add(num*10+left+K)
        return sorted(list(dp))
```

```py

```

###  1.188. <a name='BinaryTreeCameras'></a>968 Binary Tree Cameras

[小明](https://www.bilibili.com/video/BV1Q5411u72B?spm_id_from=333.999.0.0)

###  1.189. <a name='PancakeSorting'></a>969 Pancake Sorting

[小明](https://www.bilibili.com/video/BV1hk4y127yJ?spm_id_from=333.999.0.0)

###  1.190. <a name='FlipBinaryTreeToMatchPreorder'></a>971 Flip Binary Tree To Match Preorder

[小明](https://www.bilibili.com/video/BV1NB4y1P7qL?spm_id_from=333.999.0.0)

###  1.191. <a name='KClosestPointstoOrigin'></a>973 K Closest Points to Origin

[小明](https://www.bilibili.com/video/BV1Vf4y1278J?spm_id_from=333.999.0.0)

###  1.192. <a name='KSubarraySumsDivisiblebyK'></a>974. 和可被 K 整除的子数组 Subarray Sums Divisible by K 

[官方](https://www.bilibili.com/video/BV19z4y1X79a?spm_id_from=333.999.0.0)

###  1.193. <a name='OddEvenJump'></a>975. Odd Even Jump

[花花酱](https://www.bilibili.com/video/BV1pt411p7M4?spm_id_from=333.999.0.0)

###  1.194. <a name='MiddleoftheLinkedList-1'></a>976 Middle of the Linked List

[小明](https://www.bilibili.com/video/BV1N5411t7Xm?spm_id_from=333.999.0.0)

###  1.195. <a name='SquaresofaSortedArray'></a>977 Squares of a Sorted Array

[小明](https://www.bilibili.com/video/BV1EX4y1u7Mb?spm_id_from=333.999.0.0)

###  1.196. <a name='LongestTurbulentSubarray'></a>978. 最长湍流子数组 Longest Turbulent Subarray 

[官方](https://www.bilibili.com/video/BV1PV411i73Y?spm_id_from=333.999.0.0)

###  1.197. <a name='UniquePathsIII'></a>980. Unique Paths III 

[花花酱](https://www.bilibili.com/video/BV1yt41187Si?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oK4y1a7Qp?spm_id_from=333.999.0.0)

```py
class Solution:
    def uniquePathsIII(self, grid):
        R, C = len(grid), len(grid[0])

        def nei***ors(r, c):
            for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):
                if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] % 2 == 0:
                    yield nr, nc

        todo = 0
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val != -1: todo += 1
                if val == 1: sr, sc = r, c
                if val == 2: tr, tc = r, c

        self.ans = 0
        def dfs(r, c, todo):
            todo -= 1
            if todo < 0: return
            if r == tr and c == tc:
                if todo == 0:
                    self.ans += 1
                return

            grid[r][c] = -1
            for nr, nc in nei***ors(r, c):
                dfs(nr, nc, todo)
            grid[r][c] = 0

        dfs(sr, sc, todo)
        return self.ans

作者：LeetCode
链接：https://leetcode-cn.com/problems/unique-paths-iii/solution/bu-tong-lu-jing-iii-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

from functools import lru_cache
class Solution:
    def uniquePathsIII(self, grid):
        R, C = len(grid), len(grid[0])

        def code(r, c):
            return 1 << (r * C + c)

        def nei***ors(r, c):
            for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)):
                if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] % 2 == 0:
                    yield nr, nc

        target = 0
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val % 2 == 0:
                    target |= code(r, c)

                if val == 1:
                    sr, sc = r, c
                if val == 2:
                    tr, tc = r, c

        @lru_cache(None)
        def dp(r, c, todo):
            if r == tr and c == tc:
                return +(todo == 0)

            ans = 0
            for nr, nc in nei***ors(r, c):
                if todo & code(nr, nc):
                    ans += dp(nr, nc, todo ^ code(nr, nc))
            return ans

        return dp(sr, sc, target)

作者：LeetCode
链接：https://leetcode-cn.com/problems/unique-paths-iii/solution/bu-tong-lu-jing-iii-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution:
正常backtracking加上累计0判断即可

    def uniquePathsIII(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        # 回溯方式
        m, n = len(grid), len(grid[0])
        # 所有0的个数
        cnt_0 = 0
        sx, sy = 0, 0
        self.ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    cnt_0 += 1
                elif grid[i][j] == 1:
                    sx, sy = i, j
        def backtracking(x, y, cum):
            # 终止条件，边界判断
            if x < 0 or x >= m or y < 0 or y >= n:
                return
            if grid[x][y] == -1 or grid[x][y] == 3:
                return
            # 终止条件
            # 所有0走过且到了2的位置
            if cum - 1 == cnt_0 and grid[x][y] == 2:
                self.ans += 1
                return

            # 所有可行的选择
            for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                nx, ny = x + dx, y + dy
                t = grid[x][y]
                # 访问过的格子修改为3
                grid[x][y] = 3
                backtracking(nx, ny, cum+1)
                grid[x][y] = t

        backtracking(sx, sy, 0)
        return self.ans

class Solution:
    def uniquePathsIII(self, grid: 'm * n grid') -> int:

        self.grid, self.paths = grid, 0
        self.reset()
        self.walk(1, self.start, grid)
        return self.paths

    def reset(self):

        self.m, self.n = len(self.grid), len(self.grid[0])
        self.spaces = 0
        for i in range(self.m):
            for j in range(self.n):
                if self.grid[i][j] == 1:
                    self.start = (i, j)
                elif self.grid[i][j] == 2:
                    self.end = (i, j)
                elif not self.grid[i][j]:
                    self.spaces += 1

    def walk(self, cur_filled: int, start: '(i, j)', cur_grid: 'grid'):

        if cur_filled < self.spaces:
            for i_next, j_next in self.neighbor(start, cur_grid):
                next_start = (i_next, j_next)
                next_grid = [line[:] for line in cur_grid]
                next_grid[i_next][j_next] = 1
                if self.neighbor(self.end, next_grid) and (
                    self.neighbor(next_start, next_grid)):
                    self.walk(cur_filled + 1, next_start, next_grid)
        elif cur_filled == self.spaces:
            self.paths += 1
        else:
            self.paths = int(self.start in self.neighbor(self.end))

    def neighbor(self, center: '(i, j)', cur_grid = None) -> 'list[(i, j)]':
        '''返回(i, j)的相邻为0的合法坐标'''
        i, j = center
        neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]
        if not i:
            neighbors.remove((i - 1, j))
        if i == self.m - 1:
            neighbors.remove((i + 1, j))
        if not j :
            neighbors.remove((i, j - 1))
        if j == self.n - 1:
            neighbors.remove((i, j + 1))

        if cur_grid:
        	neighbors = [(i, j) for i, j in neighbors if not cur_grid[i][j]]
        return neighbors
```

###  1.198. <a name='MinimumCostForTickets'></a>983 【动态🚀规划 + 背包 + 递归】Minimum Cost For Tickets

[小明](https://www.bilibili.com/video/BV1Wz4y1f7hG?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1WK4y1t7pP?spm_id_from=333.999.0.0)

```py
担心越界，可以这样写：

class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        max_day = days[-1]
        dp = [0 for _ in range(max_day + 1)]

        for i in range(max_day + 1):
            if i not in days:
                dp[i] = dp[i - 1]
            else:
                dp[i] = min(
                    dp[max(0, i - 1)] + costs[0],
                    dp[max(0, i - 7)] + costs[1],
                    dp[max(0, i - 30)] + costs[2],
                )
        return dp[-1]

虽然，i - 30 可能越界，但是没关系：

class Solution(object):
    def mincostTickets(self, days, costs):

        ans = [0]*(days[-1]+31)
        dayset = set(days)
       
        for i in range(1,len(ans)):
            if i not in dayset:
                ans[i] += ans[i-1]
            else:
                ans[i] = ans[i] = min(ans[i-1]+costs[0], ans[i-30]+costs[2],ans[i-7]+costs[1])
        return ans[-1]
```

递归法

```py
class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        dayset = set(days)
        N = max(days)
        durations = [1, 7, 30]

        @lru_cache(None)
        def dp(i):
            if i > N:
                return 0
            elif i in dayset:
                return min(dp(i + d) + c for c, d in zip(costs, durations))
            else:
                return dp(i + 1)

        return dp(1)

```


###  1.199. <a name='IntervalListIntersections'></a>986 Interval List Intersections

[小明](https://www.bilibili.com/video/BV1wg4y1z7Xz?spm_id_from=333.999.0.0)

###  1.200. <a name='VerticalOrderTraversalofaBinary'></a>987 Vertical Order Traversal of a Binary

[小明](https://www.bilibili.com/video/BV1yZ4y1M7CL?spm_id_from=333.999.0.0)

###  1.201. <a name='SatisfiabilityofEqualityEquations'></a>990. 【🍒并查集】等式方程的可满足性 Satisfiability of Equality Equations 

[官方](https://www.bilibili.com/video/BV1gz411i7kD?spm_id_from=333.999.0.0)

###  1.202. <a name='K'></a>992 【滑动窗口🔹】K 个不同整数的子数组

[哈哈哈](https://www.bilibili.com/video/BV1t44y1q7th?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1xy4y1Y7GL?spm_id_from=333.999.0.0)

```py
 一样的思路。hhh。 勉强能过。时间5%

class Solution:

def subarraysWithKDistinct(self, A: List[int], K: int) -> int:
    if len(set(A)) < K:
        return 0
    ret = 0
    for i in range(len(A) - K + 1):
        s = set(A[i:i+K])
        for j in range(i + K - 1, len(A)):
            if len(s) == K:
                ret += 1
            if j+1 < len(A):
                s.add(A[j+1])
            if len(s) > K:
                break
    return ret
最好理解的思路了，可惜45/55，一时半会优化不好

class Solution:
    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:
        cnt=0
        for i in range(len(A)):
            a=set()
            a.add(A[i])
            for j in range(i,len(A)):
                a.add(A[j])
                if len(a) == K:
                    cnt+=1
                elif len(a)>K:
                    break
        return(cnt)
```

```py
三指针(?) 遍历A以各个index作为左边界 每次贪婪+克制地寻找K个不同的数字 O(3n)->O(n)

#python3
from collections import defaultdict
class Solution:
	def subarraysWithKDistinct(self,A,K):
		size=len(A)
		cnt1,cnt2=[defaultdict(int) for _ in range(2)]
		n1=n2=ri1=ri2=ans=0 #n1表示[le,ri1)有多少个不同的数字 n2表示[le,ri2)有多少个不同的数字
		for le in A: #遍历A作为左边界
			while ri1<size and n1<K: #克制 找到K个不同的数字就立刻停下来
				v=A[ri1]
				cnt1[v]+=1
				if cnt1[v]==1:
					n1+=1
				ri1+=1
			while ri2<size and n2<=K: #贪婪 直到出现第K+1个不同的数字才停下
				v=A[ri2]
				if not cnt2[v]:
					if n2==K:
						break
					n2+=1
				cnt2[v]+=1
				ri2+=1
			ans+=(n1==K and ri2-ri1+1)
			cnt1[le]-=1 #下面就是调整了
			cnt2[le]-=1
			n1-=cnt1[le]==0
			n2-=cnt2[le]==0
		return ans
膜拜最高赞的slice111大佬！这个减法我自己是绝逼想不到的。

class Solution:
    def subarraysWithKDistinct(self, A: List[int], K: int) -> int:
        return self.f(A, K)-self.f(A, K-1)
    def f(self, n, k):
        l, r, res, c = 0, 0, 0, Counter()
        while r<len(n):
            c[n[r]] += 1
            r += 1
            while len(c)>k:
                c[n[l]] -= 1
                if c[n[l]] == 0: c.pop(n[l])
                l += 1
            res += r-l+1
        return res
参照题解写的python版本，加了一些自己的注释

class Solution:
	# 1. 先固定left，right指针向右试探
	# 2. 满足窗口时，记录结果，同时用temp指针从left向右试探，是否仍有满足条件的情况
	# 3. 大于窗口时，left指针右移，然后重复1
	
	def subarraysWithKDistinct(self, A, K: int) -> int:
		left, right = 0, 0
		res = 0
		l = len(A)

		from collections import defaultdict
		hash = defaultdict(int)  # 用于保留K个不重复数字的窗口
		while right < l:
			hash[A[right]] += 1
			right += 1

			# 1.当窗口大于K个不重复数字时，left指针右移，hash表更新
			while len(hash) > K:
				if hash[A[left]] > 1:
					hash[A[left]] -= 1
				else:
					hash.pop(A[left])
				left += 1

			temp = left
			# 2.正好有K个不重复数字时，记录结果
			#   同时用temp指针从left向右移动，看是否依旧满足，满足则res+1
			while len(hash) == K:
				res += 1
				if hash[A[temp]] > 1:
					hash[A[temp]] -= 1
				else:
					hash.pop(A[temp])
				temp += 1

			# 3.将hash表恢复成原样，以进一步向右移动right做准备
			while temp > left:
				hash[A[temp - 1]] += 1
				temp -= 1
		return res
参考 @Linder

class Solution:
    def subarraysWithKDistinct(self, A, K: int) -> int:
        left, right = 0, 0
        res = 0
        N = len(A)

        window = collections.defaultdict(int)  # 用于保留K个不重复数字的窗口
        count = 0   # 用于表示当前[left, right]有多少个不重复数字 

        while right < N:
            if window[A[right]] == 0:
                count += 1
            window[A[right]] += 1
            # 1.当窗口大于K个不重复数字时，left指针右移
            while count > K:
                window[A[left]] -= 1
                if window[A[left]] == 0:
                    count -= 1
                left += 1

            temp = left # 临时指针，这个记录一下对于同一个right，有多少个候选的left也满足条件
            # 2.正好有K个不重复数字时，记录结果
            #   同时用temp指针从left向右移动，看是否依旧满足，满足则res+1
            while count == K:
                res += 1
                window[A[temp]] -= 1
                if window[A[temp]] == 0:
                    count -= 1
                temp += 1

            # 3.将指针和window以及count恢复成原样，以进一步向右移动right做准备
            while temp > left:
                if window[A[temp - 1]] == 0:
                    count += 1
                window[A[temp - 1]] += 1
                temp -= 1
            
            right += 1

        return res
```

###  1.203. <a name='-1'></a>993. 二叉树的堂兄弟节点

[小明](https://www.bilibili.com/video/BV17t4y11725?spm_id_from=333.999.0.0)

###  1.204. <a name='-1'></a>994-腐烂的橘子

[哈哈哈](https://www.bilibili.com/video/BV1Yp4y1D7Kg?spm_id_from=333.999.0.0)

[图灵](https://www.bilibili.com/video/BV1bB4y1A7tG?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Qk4y1m7fz?spm_id_from=333.999.0.0)

```py
Python3:使用一个队列，先把腐烂的橘子（的坐标）依次入队，然后从队头开始，弹出一个腐烂的橘子，同时将其四周的好橘子腐蚀并入队，时间time+1，依次进行直到队空，最后如果grid中好有好橘子则返回-1，否则返回time

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        x,y,time = len(grid),len(grid[0]),0
        D,queue = [[-1,0],[0,-1],[0,1],[1,0]],[]  #四个方向的坐标和队列
        for i in range(x):
            for j in range(y):
                if grid[i][j] == 2:
                    queue.append((i,j,0))
        while queue:  
            i,j,time = queue.pop(0)
            for d in D:
                loc_i,loc_j = i+d[0],j+d[1]
                if 0 <=loc_i<x and 0<=loc_j<y and grid[loc_i][loc_j]==1:
                    grid[loc_i][loc_j] = 2
                    queue.append((loc_i,loc_j,time+1))
        for g in grid:  
            if 1 in g:
                return -1
        return time
思路： 这种需要一圈一圈往外传播的一般用BFS解， 先找到起始所有腐烂的橘子，然后循环处理，把新腐烂的橘子加入下一次循环的队列中， 当下一次循环的队列为空时，说明不能继续腐烂了， 判断一下还有没有新鲜的橘子，如果有，就返回-1，否则返回分钟数

class Solution(object):
    def orangesRotting(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        dx = [1, -1, 0, 0]
        dy = [0, 0, 1, -1]
        rotlist = list()
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 2:
                    rotlist.append([i, j])
        minute = 0
        while(rotlist): #BFS循环
            newrotlist = list()
            for rotnode in rotlist:
                x0 = rotnode[0]
                y0 = rotnode[1]
                
                for k in range(4):
                    x = x0 + dx[k]
                    y = y0 + dy[k]
                    
                    if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1:
                        grid[x][y] = 2
                        newrotlist.append([x,y])
            if not newrotlist:
                break
                
            rotlist = newrotlist[:]
            minute += 1
            
        for row in grid:
            for i in row:
                if i == 1:#还有新鲜的
                    return -1
        return minute
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        R, C = len(grid), len(grid[0])

        # queue - all starting cells with rotting oranges
        queue = collections.deque()
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == 2:
                    queue.append((r, c, 0))

        def neighbors(r, c) -> (int, int):
            for nr, nc in ((r - 1, c), (r, c - 1), (r + 1, c), (r, c + 1)):
                if 0 <= nr < R and 0 <= nc < C:
                    yield nr, nc

        d = 0
        while queue:
            r, c, d = queue.popleft()
            for nr, nc in neighbors(r, c):
                if grid[nr][nc] == 1:
                    grid[nr][nc] = 2
                    queue.append((nr, nc, d + 1))

        if any(1 in row for row in grid):
            return -1
        return d

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/rotting-oranges/solution/fu-lan-de-ju-zi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
简单题

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        ones = sum([1 for i in range(n) for j in range(m) if grid[i][j] == 1])
        twos = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 2]
        queue = deque(twos)
        visited = set(twos)
        ans = count = 0
        while queue:
            flag = 0
            for _ in range(len(queue)):
                x, y = queue.popleft()
                for new_x, new_y in [(x+1, y), (x-1, y), (x, y-1), (x, y+1)]:
                    if 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] == 1 and (new_x, new_y) not in visited:
                        if flag == 0: # 标记这轮有没有1变成2，如果有，ans+1
                            ans += 1
                            flag = 1
                        visited.add((new_x, new_y))
                        count += 1
                        queue.append((new_x, new_y))
        if count != ones: return -1
        else: return ans
题要有思路真的很容易 首先统计所有新鲜的橘子坐标为fresh列表，避免后续反复遍历整个矩阵。 对fresh列表进行判定是否符合腐烂条件，是的话加入rot列表，不是加入freshnew列表，当freshnew列表长度等于fresh列表的长度时，认为没用橘子进一步腐烂返回-1，否则freshnew为新的fresh列表

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        ischange = False
        fresh = []
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    fresh.append([i, j])
        loop = 0
        while len(fresh)>0:
            loop += 1
            fresh_new = []
            rot = []
            for i,j in fresh:
                if (i-1>=0 and grid[i-1][j] == 2) or (j-1>=0 and grid[i][j-1] == 2) or (j+1<len(grid[0]) and grid[i][j+1] == 2) or (i+1<len(grid) and grid[i+1][j] == 2):
                    rot.append([i, j])
                else:
                    fresh_new.append([i, j])
            if len(fresh_new) == len(fresh):
                return -1
            for i,j in rot:
                grid[i][j] = 2
            fresh = fresh_new
        return loop
```

###  1.205. <a name='-1'></a>993, 994, 995, 996

[花花酱](https://www.bilibili.com/video/BV1bb41117PB?spm_id_from=333.999.0.0)

###  1.206. <a name='FindtheTownJudge'></a>997 Find the Town Judge

[小明](https://www.bilibili.com/video/BV1Ka4y1i7Qt?spm_id_from=333.999.0.0)

###  1.207. <a name='MinimumCosttoMergeStones'></a>1000. Minimum Cost to Merge Stones

[花花酱](https://www.bilibili.com/video/BV1db411v7DG?spm_id_from=333.999.0.0)

###  1.208. <a name='GridIllumination'></a>1001 Grid Illumination

[小明](https://www.bilibili.com/video/BV1NT4y1V7Vk?spm_id_from=333.999.0.0)

###  1.209. <a name='III'></a>1004-最大连续1的个数 III

[哈哈哈](https://www.bilibili.com/video/BV1Zg411L7Qu?spm_id_from=333.999.0.0)

###  1.210. <a name='MinimumDominoRotationsForEq'></a>1007 Minimum Domino Rotations For Eq

[小明](https://www.bilibili.com/video/BV1br4y1w7TM?spm_id_from=333.999.0.0)

###  1.211. <a name='ConstructBinarySearchTreefrom'></a>1008 Construct Binary Search Tree from

[小明](https://www.bilibili.com/video/BV1yk4y1R7oF?spm_id_from=333.999.0.0)

###  1.212. <a name='ComplementofBase10Integer'></a>1009 Complement of Base 10 Integer

[小明](https://www.bilibili.com/video/BV1oK4y187ZM?spm_id_from=333.999.0.0)

###  1.213. <a name='PairsofSongsWithTotalDurations'></a>1010 Pairs of Songs With Total Durations 

[小明](https://www.bilibili.com/video/BV1t64y1f7hc?spm_id_from=333.999.0.0)

###  1.214. <a name='PartitionArrayIntoThreePartsWithEqu'></a>1013. 将数组分成和相等的三个部分 Partition Array Into Three Parts With Equ

[官方](https://www.bilibili.com/video/BV1ZK4y1t7Sf?spm_id_from=333.999.0.0)

###  1.215. <a name='SmallestIntegerDivisiblebyK'></a>1015 Smallest Integer Divisible by K

[小明](https://www.bilibili.com/video/BV1PZ4y1G7iU?spm_id_from=333.999.0.0)

###  1.216. <a name='NextGreaterNodeInLinkedList'></a>1019. Next Greater Node In Linked List

[花花酱](https://www.bilibili.com/video/BV12b411s77J?spm_id_from=333.999.0.0)

###  1.217. <a name='SumofRootToLeafBinaryNumbers'></a>1022 Sum of Root To Leaf Binary Numbers

[小明](https://www.bilibili.com/video/BV11A411E7AN?spm_id_from=333.999.0.0)

###  1.218. <a name='-1'></a>1025,1026,1027,1028

[花花酱](https://www.bilibili.com/video/BV1Nb411j7qr?spm_id_from=333.999.0.0)

###  1.219. <a name='VideoStitching'></a>1024. Video Stitching

[花花酱](https://www.bilibili.com/video/BV1kb411u7Qk?spm_id_from=333.999.0.0)

###  1.220. <a name='MaximumDifferenceBetweenNod'></a>1026 Maximum Difference Between Nod

[小明](https://www.bilibili.com/video/BV1fi4y157ZS?spm_id_from=333.999.0.0)

###  1.221. <a name='TwoCityScheduling'></a>1029 Two City Scheduling

[小明](https://www.bilibili.com/video/BV1t54y1Q7G8?spm_id_from=333.999.0.0)

###  1.222. <a name='StreamofCharacters'></a>1032 Stream of Characters

[小明](https://www.bilibili.com/video/BV15T4y1L7RG?spm_id_from=333.999.0.0)

###  1.223. <a name='UncrossedLines'></a>1035 Uncrossed Lines

[小明](https://www.bilibili.com/video/BV1si4y1s79e?spm_id_from=333.999.0.0)

###  1.224. <a name='RobotBoundedInCircle'></a>1041 Robot Bounded In Circle

[小明](https://www.bilibili.com/video/BV1dk4y1y7RH?spm_id_from=333.999.0.0)

###  1.225. <a name='PartitionArrayforMaximumSum'></a>1043. Partition Array for Maximum Sum

[花花酱](https://www.bilibili.com/video/BV154411J7so?spm_id_from=333.999.0.0)

###  1.226. <a name='LongestDuplicateSubstring'></a>1044 Longest Duplicate Substring

[小明](https://www.bilibili.com/video/BV1Kv411B7a3?spm_id_from=333.999.0.0)

###  1.227. <a name='LastStoneWeight'></a>1046 Last Stone Weight

[小明](https://www.bilibili.com/video/BV1w54y197Ln?spm_id_from=333.999.0.0)

###  1.228. <a name='LongestStringChain'></a>1048 Longest String Chain

[小明](https://www.bilibili.com/video/BV17K4y1G7et?spm_id_from=333.999.0.0)



###  1.229. <a name='ShortestWaytoFormString'></a>1055.Shortest Way to Form String 形成字符串的最短路径

[图灵](https://www.bilibili.com/video/BV1SZ4y1G7WX?spm_id_from=333.999.0.0)

###  1.230. <a name='-1'></a>1091-二进制矩阵中的最短路径

[哈哈哈](https://www.bilibili.com/video/BV17k4y1r7EP?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ro4y197kU?spm_id_from=333.999.0.0)

```py
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        l = len(grid)
        if grid[0][0] != 0 or grid[l-1][l-1] != 0:  #处理特殊情况
            return -1
        if l == 1:
            return 1

        visited = set((0,0)) #存放已遍历的位置的集合
        Q  = collections.deque([(0,0)])  #存放接下来一轮的地址
        Q2 = collections.deque([])       #在一轮中暂存所有的位置
        ans = 0

        while Q:
            ans += 1
            while Q:  #首先把此轮中Q内所有点的周围遍历过去，为了方便记录ans，每次都遍历完后，才把新的点重新加入
                i, j = Q.popleft()
                if i == l-1 and j == l-1:   #发现已经找到终点，那就可以直接返回了
                    return ans
                for (x, y) in [(i-1,j),(i+1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    if (x,y) not in visited and l>x>=0 and l>y>=0:
                        if grid[x][y] == 0:
                            visited.add((x,y))
                            Q2.append((x,y))
            while Q2:   #把Q2中的下一轮需要遍历的点加回到Q中
                Q.append(Q2.popleft())
        return -1   #遍历完了还没到达终点，说明根本无法过来

作者：bluegreenred
链接：https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/solution/1091-er-jin-zhi-ju-zhen-zhong-de-zui-dua-vgdw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

方法二：DFS
太慢了，无法AC


class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        l = len(grid)
        if grid[0][0] != 0 or grid[l-1][l-1]:
            return -1
        if len(grid) == 1 and len(grid[0]) == 1:
            return 1
        self.ans = len(grid) * len(grid)
        def dfs(i, j, visited, path):
            if i == len(grid) - 1 and j == len(grid) - 1:
                self.ans = min(self.ans, path)
            else:
                visited2 = deepcopy(visited)
                visited2.add((i,j))
                for (x, y) in [(i-1,j),(i+1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    if (x,y) not in visited and l>x>=0 and l>y>=0:
                        if grid[x][y] == 0:
                            dfs(x, y, visited2, path+1)

        v = set()
        dfs(0, 0, v, 1)
        return self.ans if self.ans != len(grid) * len(grid) else -1

作者：bluegreenred
链接：https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/solution/1091-er-jin-zhi-ju-zhen-zhong-de-zui-dua-vgdw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
方法一：BFS 首先处理一下特殊情况：（1）起点或终点不为0；（2）矩阵只有一个数

然后，用一个队列Q来存储当前步数时所有的点

然后遍历Q中所有的点，用Q2记录这些点附近的可以到达的点

当Q遍历完时把这些Q2的点重新加入进Q（为了方便记录ans）

当发现Q中的点已经有到达终点的时候，直接返回ans，这时的ans就是最短路径

如果遍历完发现还没有点到达终点，那就说明不存在这样的路径，返回-1

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        l = len(grid)
        if grid[0][0] != 0 or grid[l-1][l-1] != 0:  #处理特殊情况
            return -1
        if l == 1:
            return 1

        visited = set((0,0)) #存放已遍历的位置的集合
        Q  = collections.deque([(0,0)])  #存放接下来一轮的地址
        Q2 = collections.deque([])       #在一轮中暂存所有的位置
        ans = 0

        while Q:
            ans += 1
            while Q:  #首先把此轮中Q内所有点的周围遍历过去，为了方便记录ans，每次都遍历完后，才把新的点重新加入
                i, j = Q.popleft()
                if i == l-1 and j == l-1:   #发现已经找到终点，那就可以直接返回了
                    return ans
                for (x, y) in [(i-1,j),(i+1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    if (x,y) not in visited and l>x>=0 and l>y>=0:
                        if grid[x][y] == 0:
                            visited.add((x,y))
                            Q2.append((x,y))
            while Q2:   #把Q2中的下一轮需要遍历的点加回到Q中
                Q.append(Q2.popleft())
        return -1   #遍历完了还没到达终点，说明根本无法过来
方法二：DFS 也是不断深入去找，但是时间复杂度很高，无法AC

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        l = len(grid)
        if grid[0][0] != 0 or grid[l-1][l-1]:
            return -1
        if len(grid) == 1 and len(grid[0]) == 1:
            return 1
        self.ans = len(grid) * len(grid)
        def dfs(i, j, visited, path):
            if i == len(grid) - 1 and j == len(grid) - 1:
                self.ans = min(self.ans, path)
            else:
                visited2 = deepcopy(visited)
                visited2.add((i,j))
                for (x, y) in [(i-1,j),(i+1,j),(i,j+1),(i,j-1),(i+1,j+1),(i+1,j-1),(i-1,j+1),(i-1,j-1)]:
                    if (x,y) not in visited and l>x>=0 and l>y>=0:
                        if grid[x][y] == 0:
                            dfs(x, y, visited2, path+1)

        v = set()
        dfs(0, 0, v, 1)
        return self.ans if self.ans != len(grid) * len(grid) else -1

```

###  1.231. <a name='CarPooling'></a>1094 Car Pooling

[小明](https://www.bilibili.com/video/BV1Xk4y1k7UX?spm_id_from=333.999.0.0)

###  1.232. <a name='FindinMountainArray'></a>1095. Find in Mountain Array

[花花酱](https://www.bilibili.com/video/BV1m5411V7x7?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1GK4115778?spm_id_from=333.999.0.0)

```py
def binary_search(mountain, target, l, r, key=lambda x: x):
    target = key(target)
    while l <= r:
        mid = (l + r) // 2
        cur = key(mountain.get(mid))
        if cur == target:
            return mid
        elif cur < target:
            l = mid + 1
        else:
            r = mid - 1
    return -1

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        l, r = 0, mountain_arr.length() - 1
        while l < r:
            mid = (l + r) // 2
            if mountain_arr.get(mid) < mountain_arr.get(mid + 1):
                l = mid + 1
            else:
                r = mid
        peak = l
        index = binary_search(mountain_arr, target, 0, peak)
        if index != -1:
            return index
        index = binary_search(mountain_arr, target, peak + 1, mountain_arr.length() - 1, lambda x: -x)
        return index

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/find-in-mountain-array/solution/shan-mai-shu-zu-zhong-cha-zhao-mu-biao-zhi-by-leet/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
好孩子不要学

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        try:
            return mountain_arr._MountainArray__secret.index(target)
        except:
            return -1

class Solution:
    def findInMountainArray(self, target: int, mountain_arr: 'MountainArray') -> int:
        n = mountain_arr.length()
        l, r = 0, n - 1
        
        # 二分寻找山顶(162，寻找峰值)
        while(l < r):
            mid = (l + r + 1) >> 1
            # 左边有序， 可以排除 0 ~ i -1
            if mountain_arr.get(mid) > mountain_arr.get(mid - 1):
                l = mid
            else:
                r = mid - 1

        top_idx = l

        # # 在左边寻找 >= target 的左边界
        l, r = 0, top_idx
        while(l < r):
            mid = (l + r) >> 1
            if mountain_arr.get(mid) >= target:
                r = mid
            else:
                l = mid + 1

        # 刚好等于 target, 直接返回
        if (mountain_arr.get(l) == target):
            return l

        # 右边找 <= target 的左边界
        l, r = top_idx, n - 1
        while(l < r):
            mid = (l + r) >> 1 
            if mountain_arr.get(mid) <= target:
                r = mid
            else:
                l = mid + 1

        return l if mountain_arr.get(l) == target else -1
```

###  1.233. <a name='FillingBookcaseShelves'></a>1105. Filling Bookcase Shelves

[花花酱](https://www.bilibili.com/video/BV1Mx411X7Ks?spm_id_from=333.999.0.0)

###  1.234. <a name='ParsingABooleanExpression'></a>1106. Parsing A Boolean Expression

[花花酱](https://www.bilibili.com/video/BV1Cx411X7aF?spm_id_from=333.999.0.0)

###  1.235. <a name='DeleteNodesAndReturnForest'></a>1110. Delete Nodes And Return Forest

[花花酱](https://www.bilibili.com/video/BV1u4411977H?spm_id_from=333.999.0.0)

###  1.236. <a name='MaximumNestingDepthofTwoValidParentheses'></a>1111. 有效括号的嵌套深度 Maximum Nesting Depth of Two Valid Parentheses

[官方](https://www.bilibili.com/video/BV11a4y1v7Bb?spm_id_from=333.999.0.0)

###  1.237. <a name='threading'></a>1114 - 1115 - 1116 - 多线程 threading

[花花酱](https://www.bilibili.com/video/BV12t411P79a?spm_id_from=333.999.0.0)

###  1.238. <a name='LowestCommonAncestorofDeepestLeaves'></a>1123.Lowest Common Ancestor of Deepest Leaves最深叶节点的最近公共祖

[小明](https://www.bilibili.com/video/BV16f4y1q7eA?spm_id_from=333.999.0.0)

###  1.239. <a name='LongestWell-PerformingInterval'></a>1124. Longest Well-Performing Interval

[花花酱](https://www.bilibili.com/video/BV1Et41157Jw?spm_id_from=333.999.0.0)

###  1.240. <a name='SmallestSufficientTeam'></a>1125. Smallest Sufficient Team

[花花酱](https://www.bilibili.com/video/BV14t411G7WL?spm_id_from=333.999.0.0)

###  1.241. <a name='NumberofEquivalentDominoPairs'></a>1128. 等价多米诺骨牌对的数量 Number of Equivalent Domino Pairs

[官方](https://www.bilibili.com/video/BV1fV411q7ZY?spm_id_from=333.999.0.0)

###  1.242. <a name='ShortestPathwithAlternatingColors'></a>1129. Shortest Path with Alternating Colors

[花花酱](https://www.bilibili.com/video/BV1Et411J7Dh?spm_id_from=333.999.0.0)

###  1.243. <a name='N-thTribonacciNumber'></a>1137. N-th Tribonacci Number

[3:55 花花酱 DP](https://www.bilibili.com/video/BV1b34y1d7S8?spm_id_from=333.999.0.0)

###  1.244. <a name='StoneGameII'></a>1140. Stone Game II

[花花酱](https://www.bilibili.com/video/BV1Gt411c7hM?spm_id_from=333.999.0.0)

###  1.245. <a name='LongestCommonSubsequence'></a>1143 【二维动态🚀规划】Longest Common Subsequence

####  1.245.1. <a name='516'></a>类似题目：516最长回文子序列

[小明](https://www.bilibili.com/video/BV19Z4y1W7Xi?spm_id_from=333.999.0.0)

```py
做了几个dp的题之后，总结了dp需要注意的几个要素：

1、 明确dp二维数组表示的含义

2、 base case

3、 状态的转移：对于`回文/LCS`之类的问题则是考虑当前字串和已经计算过的子串之间的关系

4、 由`状态的转移`来确定 loop的边界

5、 由loop的边界`打出表格` 可得出最后一个dp的状态值，即结果。


class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        dp = [[0] * (len(text2)+1) for _ in range(len(text1)+1)]
        for i in range(1, len(text1)+1): 
            for j in range(1, len(text2)+1): 
                if text1[i-1] == text2[j-1]: 
                    dp[i][j] = dp[i-1][j-1] + 1 
                else: 
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]

python 一维数组， 求赞

class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n1, n2 = len(text1), len(text2)
        pre = [0 for _ in range(n2 + 1)]
        dp = [0 for _ in range(n2 + 1)]
        for i in range(n1):
            for j in range(1, n2 + 1):
                if text1[i] == text2[j-1]:
                    dp[j] = pre[j-1] + 1
                else:
                    dp[j] = max(pre[j], dp[j-1])
                pre[j-1] = dp[j-1]
                # 这里为什么不是直接pre[j] = dp[j]，而用了pre[j-1] = dp[j-1] 呢？谢谢
                # 明白了，因为求解dp[j]的时候需要用到pre[j-1]所以要推迟更新，提前更新就出错了。谢谢~
            pre[j] = dp[j]
        return dp[-1]
```



```scala


  object Solution {
    def longestCommonSubsequence(text1: String, text2: String): Int = {
      val m = text1.length
      val n = text2.length
      //val dp = Array.ofDim[Int](1001,1001)
      val dp = Array.fill(1001,1001)(0)
      for (i<- 1 to m) { // must have space?
        for (j<- 1 to n) {
          dp(i)(j) = if (text1(i-1)== text2(j-1)) dp(i-1)(j-1)+1 else Math.max(dp(i-1)(j),dp(i)(j-1))
        }
      }
      dp(m)(n)
    }
  }

  class Test extends BaseExtension {
    def init {
      println(Solution.longestCommonSubsequence("abcde", "ace") == 3)
    }
    val name = "1143 Longest common sequence"
  }

```

###  1.246. <a name='BinaryTreeColoringGame'></a>1145. Binary Tree Coloring Game

[花花酱](https://www.bilibili.com/video/BV1ft411K7Gf?spm_id_from=333.999.0.0)

###  1.247. <a name='NumberofDiceRollsWithTargetSum'></a>1155. Number of Dice Rolls With Target Sum

[花花酱](https://www.bilibili.com/video/BV1t4411Q7JN?spm_id_from=333.999.0.0)

###  1.248. <a name='FindWordsThatCanBeFormedbyCharacters'></a>1160. 拼写单词 Find Words That Can Be Formed by Characters 

[官方](https://www.bilibili.com/video/BV1Lt4y1Q7Yx?spm_id_from=333.999.0.0)

###  1.249. <a name='DinnerPlateStacks'></a>1172. Dinner Plate Stacks

[花花酱](https://www.bilibili.com/video/BV1E4411z7xb?spm_id_from=333.999.0.0)

###  1.250. <a name='NumberofValidWordsforEachPuzzle'></a>1178. Number of Valid Words for Each Puzzle

[花花酱](https://www.bilibili.com/video/BV1x441117vz?spm_id_from=333.999.0.0)

###  1.251. <a name='MakeArrayStrictlyIncreasing'></a>1187. Make Array Strictly Increasing

[花花酱](https://www.bilibili.com/video/BV1sJ411N7jD?spm_id_from=333.999.0.0)

###  1.252. <a name='K-ConcatenationMaximumSum'></a>1191. K-Concatenation Maximum Sum

[花花酱](https://www.bilibili.com/video/BV1AJ411w756?spm_id_from=333.999.0.0)

###  1.253. <a name='UglyNumberIII'></a>1201. Ugly Number III

[花花酱](https://www.bilibili.com/video/BV1QJ411M7Jx?spm_id_from=333.999.0.0)

###  1.254. <a name='SmallestStringWithSwaps'></a>1202. 【🍒并查集】Smallest String With Swaps

[花花酱](https://www.bilibili.com/video/BV1PJ411T7Wq?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Yh41127VH?spm_id_from=333.999.0.0)

```py
class UF:
    def __init__(self, n): self.p = list(range(n))
    def union(self, x, y): self.p[self.find(x)] = self.find(y)
    def find(self, x):
        if x != self.p[x]: self.p[x] = self.find(self.p[x])
        return self.p[x]
```

```py
来个python版本的，第三步的分组排序不同，我用的是O(N)的基数排序

def find(u, parents):
    if parents[u] == u:
        return u
    parents[u] = find(parents[u], parents) # 路径压缩
    return parents[u]
def union(u, v, ranks, parents):
    pu, pv = find(u, parents), find(v, parents)
    if pu == pv:
        return False
    ru, rv = ranks[pu], ranks[pv] # 按秩合并
    if ru > rv:
        parents[pv] = pu
    elif rv > ru:
        parents[pu] = pv
    else:
        parents[pv] = pu
        ranks[pu] += 1
    return True

class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        parents = [i for i in range(len(s))]
        ranks = [0] * len(s)

        for u, v in pairs:
            union(u, v, ranks, parents)  # 合并

        groups = {}
        for i in range(len(s)):
            groups.setdefault(find(i, parents), [0]*26)[ord(s[i])-ord('a')] += 1    # 分组，每个集合的代表作为字典的key，组员放在列表中，第0个位置代表’a'，值为1表示有一个'a'，以此类推

        res = [None] * len(s)
        for index, boss in enumerate(parents):
            for i in range(26):
                if groups[boss][i] > 0:
                    tmp = chr(i+97)
                    res[index] = tmp
                    groups[boss][i] -= 1
                    break

        return "".join(res)
```

```py
说明之前的合并导致索引1,2单独成为集合，后续将1与其他分组合并，更新了1，但是没有再遇到索引2的值，因此2没有被更新，依旧指向1


class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
        n = len(s)
        ls = [i for i in range(n)]
        def find(x):
            if ls[x] == x:
                return x
            ls[x] = find(ls[x])
            return ls[x]
        def merge(a, b):
            a = find(a)
            b = find(b)
            if a != b:
                ls[b] = a
        for par in pairs:
            merge(par[0], par[1])
        dirs = {}
        for i in range(n):
            find(i)
            index = ls[i]
            qs = dirs.get(index, False)
            if qs:
                qs.append(s[i])
            else:
                qs = [s[i]]
            dirs[index] = qs
        for k in dirs.keys():
            dirs[k].sort()
        res = []
        for i in range(n):
            index = ls[i]
            res.append(dirs[index].pop(0))
        return "".join(res)
python🍒并查集

class Solution:
    def smallestStringWithSwaps(self, s: str, pairs: [int]) -> str:
        p = {i:i for i in range(len(s))}  
        def f(x):
            if x != p[x]:
                p[x] = f(p[x])
            return p[x]

        for i, j in pairs:
            p[f(j)] = f(i)   
        
        d = collections.defaultdict(list)
        for i, j in enumerate(map(f, p)):
            d[j].append(i)

        ans = list(s)
        for q in d.values():
            t = sorted(ans[i] for i in q)
            for i, c in zip(sorted(q), t):
                ans[i] = c
        return ''.join(ans)
```

###  1.255. <a name='SortItemsbyGroupsRespectingDependencies'></a>1203. 项目管理 Sort Items by Groups Respecting Dependencies

[官方](https://www.bilibili.com/video/BV1iy4y1m7ye?spm_id_from=333.999.0.0)

###  1.256. <a name='DesignSkiplist'></a>1206. Design Skiplist 

[花花酱](https://www.bilibili.com/video/BV1kT4y1F7Nr?spm_id_from=333.999.0.0)

###  1.257. <a name='RemoveAllAdjacentDuplicatesin'></a>1209 Remove All Adjacent Duplicates in 

[小明](https://www.bilibili.com/video/BV1qA411L7z9?spm_id_from=333.999.0.0)

###  1.258. <a name='MinimumCosttoMoveChips'></a>1217 Minimum Cost to Move Chips

[小明](https://www.bilibili.com/video/BV1zt4y1e7fK?spm_id_from=333.999.0.0)

###  1.259. <a name='LongestArithmeticSubsequenceofGivenDifference'></a>1218. Longest Arithmetic Subsequence of Given Difference

[花花酱](https://www.bilibili.com/video/BV1tE411f73y?spm_id_from=333.999.0.0)

###  1.260. <a name='CountVowelsPermutation'></a>1220. Count Vowels Permutation

[花花酱](https://www.bilibili.com/video/BV1FJ411c7pT?spm_id_from=333.999.0.0)

###  1.261. <a name='DiceRollSimulation'></a>1223 Dice Roll Simulation

[花花酱](https://www.bilibili.com/video/BV17E411k7PR?spm_id_from=333.999.0.0)

###  1.262. <a name='TilingaRectanglewiththeFewestSquares'></a>1240 Tiling a Rectangle with the Fewest Squares

[花花酱](https://www.bilibili.com/video/BV1UE411t7Gb?spm_id_from=333.999.0.0)

###  1.263. <a name='-1'></a>1248-统计「优美子数组」

[哈哈哈](https://www.bilibili.com/video/BV1FU4y1H76T?spm_id_from=333.999.0.0)

[官方](https://www.bilibili.com/video/BV1Wk4y1r7t7?spm_id_from=333.999.0.0)

```py
class Solution(object):
    def numberOfSubarrays(self, nums, k):
        tmp = [] # 存连续偶数个数的子序列
        n = 1 # 从1开始计数，将来计算的时候就不用加1了
        for i in nums:
            if i % 2 == 0:
                n += 1
            else: # 发现一个奇数就存入连续偶数的个数
                tmp.append(n)
                n = 1
        tmp.append(n) # 循环结束后还要把最后一个n加进来
        if len(tmp) < k+1: # k个奇数，tmp里至少要有k+1个元素
            return 0 # 凑不够k个奇数返回0
        res = 0
        for i in range(k, len(tmp)): # 将k个奇数两侧的偶数数量相乘，加在一起
            res += tmp[i] * tmp[i-k]
        return res

Py3 哈希

class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        res, tmp, dic = 0, 0, {0: 1}
        for num in nums:
            if num & 1:
                tmp += 1
                dic[tmp] = 1
            else:
                dic[tmp] += 1
            res += dic.get(tmp-k, 0)
        return res
先把奇数的索引列出来放进p ∑(p[i]-p[i-1])*(p[i+k]-p[i+k-1])就是结果

class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        p=[-1]+[i for i,v in enumerate(nums) if v&1]+[len(nums)]
        return sum((p[i]-p[i-1])*(p[i+k]-p[i+k-1]) for i in range(1,len(p)-k))
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        cnt = [0] * (len(nums) + 1)
        cnt[0] = 1
        odd, ans = 0, 0
        for num in nums:
            if num % 2 == 1:
                odd += 1
            if odd >= k:
                ans += cnt[odd - k]
            cnt[odd] += 1
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/tong-ji-you-mei-zi-shu-zu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        n = len(nums)
        odd = [-1]
        ans = 0
        for i in range(n):
            if nums[i] % 2 == 1:
                odd.append(i)
        odd.append(n)
        print(odd)
        for i in range(1, len(odd) - k):
            ans += (odd[i] - odd[i - 1]) * (odd[i + k] - odd[i + k - 1])
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/tong-ji-you-mei-zi-shu-zu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
分享一个笨办法（大佬勿喷），只会求 k 长度两个奇数端点，然后乘法。 先求出所有奇数下标，然后滑动窗口进行计算。

~~~~start-----end~~~~

求出 start 左边偶数个数，得到左侧 left_rest
求出 end 右侧偶数个数，得到右侧 right_rest
一个 K 长度就有组合：
~~~~start-----end：有 left_rest 个
start-----end：有 1 个
~~~~start-----end~~~~：有 left_rest * right_rest 个
start-----end~~~~：有 right_rest 个
所以一个 【K】长度就有 left_rest + right_rest + left_rest * right_rest + 1 个。

那么一共有 多少个长度为 【K】的奇数序列呢？就是 len(odd) - k 条。

class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        size = len(nums)
        if size < k:
            return 0
        
        odd = [i for i in range(size) if nums[i] & 1]
        odd_size = len(odd)
        if odd_size < k:
            return 0
        res = 0
        for i in range(odd_size - k + 1):
            start, end = odd[i], odd[i+k-1]
            if i > 0:
                left_rest = start - odd[i-1] - 1  # 两个奇数之间的距离（偶数个数）
            else:
                left_rest = start  # 两个奇数之间的距离（偶数个数）
            if i+k-1 < odd_size - 1:  # 非最后一个
                right_rest = odd[i+k] - end - 1 # 右侧两个奇数间距离
            else:
                right_rest = size - 1 - end  # 右侧可能没有 [1,2,1,2,2]
            res += left_rest + right_rest + left_rest * right_rest + 1
        return res
细品官方的题解一、发现是对边界的处理，怎么说呢？ 将上面的式子合并同类项，left_rest + right_rest + left_rest * right_rest + 1就是 (left_rest + 1) * (right_rest + 1)，很明显这就是前后两个奇数的**索引差**相乘结果。

唯一官方巧妙的地方就是，在处理左右边界不像上面一样 if-else，而是在 odd[0]=-1 和 odd[-1]=len(nums)，简直绝了！这两个处理很妙。同时官方的滑动窗口个人认为是 k+2 更好理解。

nums=[1,1,2,1,1], k=2 奇数索引：[0,1,3,4]，然后现在通过上面式子知道，就是求两个奇数索引差，预处理头加上 -1 和尾部加上 len(nums) 得到 odd = [-1, 0, 1, 3, 4, 5]

以 k + 2 长度为滑动窗口进行求解，那么共进行 len(odd) - (k + 2) 次（即这里共2次）。

第一轮：[-1, 0, 1, 3, 4] ：实际滑动窗口 [0, 1, 3]。

第一个奇数端点为 0, 其减去左侧奇数索引差为 0 - (-1) = 1（left_res + 1)

第 k 个奇数端点为 3, 其右侧奇数索引(4)减去自身为 4 - 3 = 1 （right_res + 1）

--------------------------------------------------------------------------------------------------

第二轮：[0, 1, 3, 4, 5] ：实际滑动窗口 [1, 3, 4]。

第一个奇数端点为 1, 其减去左侧奇数索引差为 1 -0 = 1（left_res + 1)

第 k 个奇数端点为 4, 其右侧奇数索引(5)减去自身为 5 - 4 = 1 （right_res + 1）

这是我对公式的结果理解，代码就是官方的那样
```

###  1.264. <a name='MinimumRemovetoMakeValidPare'></a>1249 Minimum Remove to Make Valid Pare

[小明](https://www.bilibili.com/video/BV1wK4y1X7G7?spm_id_from=333.999.0.0)

###  1.265. <a name='-1'></a>1252 1253 1254 1255

[花花酱](https://www.bilibili.com/video/BV1kE411Y7rg?spm_id_from=333.999.0.0)

###  1.266. <a name='MinimumMovestoMoveaBoxtoTheirTarget'></a>1263. Minimum Moves to Move a Box to Their Target

[花花酱](https://www.bilibili.com/video/BV1AJ411Q7B6?spm_id_from=333.999.0.0)

###  1.267. <a name='-1'></a>1277. 【二维动态🚀规划】统计全为1的正方形子矩阵

[哈哈哈](https://www.bilibili.com/video/BV1nk4y1k7vi?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1Kp4y1X7n4?spm_id_from=333.999.0.0)

```py
class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        m,n = len(matrix), len(matrix[0])
        res = 0

        for i in range(m):
            for j in range(n):
                if i>0 and j>0 and matrix[i][j]:
                    a, b, c = matrix[i-1][j], matrix[i-1][j-1], matrix[i][j-1]
                    matrix[i][j] = min(a, b, c) + 1
                
                res += matrix[i][j]
        
        return res

class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        if len(matrix) == 0:
            return sum(matrix)
        rows, cols = len(matrix), len(matrix[0])
        dp = [[0]*cols for _ in range(rows)]
        ans = 0
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j] == 0:
                    continue
                if i == 0 or j == 0:
                    dp[i][j] = matrix[i][j]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1
                ans += dp[i][j]
        return ans
```

###  1.268. <a name='PalindromePartitioningIII'></a>1278. Palindrome Partitioning III

[花花酱](https://www.bilibili.com/video/BV1HJ411q7nc?spm_id_from=333.999.0.0)

###  1.269. <a name='FindtheSmallestDivisorGivena'></a>1283 Find the Smallest Divisor Given a

[小明](https://www.bilibili.com/video/BV1Fv411r7Nw?spm_id_from=333.999.0.0)

###  1.270. <a name='MinimumNumberofFlipstoConvertBinaryMatrix'></a>1284. Minimum Number of Flips to Convert Binary Matrix

[花花酱](https://www.bilibili.com/video/BV1nJ411y7m1?spm_id_from=333.999.0.0)

###  1.271. <a name='ConvertBinaryNumberinaLinkedList'></a>1290. 二进制链表转整数 (Convert Binary Number in a Linked List

[洛阳](https://www.bilibili.com/video/BV1kc411h7Rs?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1nD4y1R7QH?spm_id_from=333.999.0.0)

```py
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        cur = head
        ans = 0
        while cur:
            ans = ans * 2 + cur.val
            cur = cur.next
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution/er-jin-zhi-lian-biao-zhuan-zheng-shu-by-leetcode-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
class Solution(object):
    def getDecimalValue(self, head):
        """
        :type head: ListNode
        :rtype: int
        """
        res = 0
        while head:
            res = res * 2 + head.val
            head = head.next 
        return res
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        ret = ''
        while head:
            ret += str(head.val)
            head = head.next
        return int(ret,2)
class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
        ret = str(head)
        bei = ''
        for i in ret:
            if i.isdigit():
                bei += i
        return int(bei,2)
```

###  1.272. <a name='SequentialDigits'></a>1291 Sequential Digits

[小明](https://www.bilibili.com/video/BV11v411C7so?spm_id_from=333.999.0.0)

###  1.273. <a name='ShortestPathinaGridwithObstaclesElimination'></a>1293. Shortest Path in a Grid with Obstacles Elimination

[花花酱](https://www.bilibili.com/video/BV1VJ411k72A?spm_id_from=333.999.0.0)

###  1.274. <a name='DivideArrayinSetsofKConsecutiveNumbers'></a>1296. Divide Array in Sets of K Consecutive Numbers

[花花酱](https://www.bilibili.com/video/BV1gJ411e7cS?spm_id_from=333.999.0.0)

###  1.275. <a name='NumberofPathswithMaxScore'></a>1301. Number of Paths with Max Score

[花花酱](https://www.bilibili.com/video/BV1pJ411a7ry?spm_id_from=333.999.0.0)

###  1.276. <a name='DeepestLeavesSum'></a>1302 Deepest Leaves Sum

[小明](https://www.bilibili.com/video/BV1Bb4y1D7Cp?spm_id_from=333.999.0.0)

###  1.277. <a name='AllElementsinTwoBinarySearch'></a>1305 All Elements in Two Binary Search

[小明](https://www.bilibili.com/video/BV1kK411N7az?spm_id_from=333.999.0.0)

###  1.278. <a name='JumpGameIII'></a>1306 Jump Game III

[小明](https://www.bilibili.com/video/BV13y4y1q7Gi?spm_id_from=333.999.0.0)

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start] == 0:
            return True

        n = len(arr)
        used = {start}
        q = collections.deque([start])

        while len(q) > 0:
            u = q.popleft()
            for v in [u + arr[u], u - arr[u]]:
                if 0 <= v < n and v not in used:
                    if arr[v] == 0:
                        return True
                    q.append(v)
                    used.add(v)
        
        return False

```

```py
class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(site, n):
            if flag[0]:
                return
            if arr[site] == 0:
                flag[0] = True
                return
            see[site] = True
            for next_site in (site+arr[site], site-arr[site]):
                if 0 <= next_site < n and see[next_site] == False:
                    dfs(next_site, n)
        n = len(arr)
        flag = [False]
        see = [False] * n
        dfs(start, n)
        return flag[0]
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()

        def dfs(index):
            if index in seen:
                return False

            seen.add(index)
            if index < 0 or index >= len(arr):
                return False

            if arr[index] == 0:
                return True

            return dfs(index + arr[index]) or dfs(index - arr[index])

        return dfs(start)
```

```py
from typing import List


class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:

        seen = set()
        queue = [(start, 0)]

        while queue:
            index, step = queue.pop(0)

            if index in seen:
                continue

            seen.add(index)

            if index < 0 or index >= len(arr):
                continue

            if arr[index] == 0:
                return True

            queue.extend([(index + arr[index], step+1), (index - arr[index], step+1)])

        return False

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        def dfs(index,d):
            if index<0 or index>=len(arr) or len(d)!=len(set(d)):return False
            if arr[index]==0:return True
            return dfs(index+arr[index],d+[index+arr[index]]) or  dfs(index-arr[index],d+[index-arr[index]])
        return dfs(start,[start])

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        if arr[start]==0:return True
        q=collections.deque([start])
        visited={start}
        while q:
            node=q.popleft()
            for n in [node+arr[node],node-arr[node]]:
                if 0<=n<len(arr) and n not in visited:
                    if arr[n]==0:return True
                    q.append(n)
                    visited.add(n)
        return False

bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        q, v, n = [start], {start}, len(arr)
        while q:
            p = []
            for i in q:
                if not arr[i]:
                    return True
                for j in i - arr[i], i + arr[i]:
                    if 0 <= j < n and j not in v:
                        p.append(j)
                        v.add(j)
            q = p
        return False
dfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        n, v = len(arr), set()
        def f(i):
            if not arr[i]:
                return True
            elif i not in v:
                v.add(i)
                return 0 <= i - arr[i] < n and f(i - arr[i]) or 0 <= i + arr[i] < n and f(i + arr[i])
        return f(start)

python bfs

class Solution:
    def canReach(self, arr: List[int], start: int) -> bool:
        l, mark, queue= len(arr), [1 for i in range(len(arr))], [start]
        while len(queue)!=0:
            n = len(queue)
            for i in range(n):
                tmp = queue.pop()
                if arr[tmp]==0:
                    return True
                mark[tmp] = 0
                for cur in tmp+arr[tmp], tmp-arr[tmp]:
                    if 0<=cur<l and mark[cur]:
                        queue.insert(0, cur)
        return False
```

###  1.279. <a name='XORQueriesofaSubarray'></a>1310. XOR Queries of a Subarray

[花花酱](https://www.bilibili.com/video/BV1oJ411L78Y?spm_id_from=333.999.0.0)

###  1.280. <a name='MinimumInsertionStepstoMakeaStringPalindrom'></a>1312. Minimum Insertion Steps to Make a String Palindrom

[花花酱](https://www.bilibili.com/video/BV1HJ411L7b2?spm_id_from=333.999.0.0)

###  1.281. <a name='NumberofOperationstoMakeNetworkConnected'></a>1319. 【🍒并查集】Number of Operations to Make Network Connected

[花花酱](https://www.bilibili.com/video/BV1jJ411n7dc?from=search&seid=16576806175247069118&spm_id_from=333.337.0.0)

```py

```

###  1.282. <a name='MinimumDistancetoTypeaWordUsingTwoFinger'></a>1320. Minimum Distance to Type a Word Using Two Finger

[花花酱](https://www.bilibili.com/video/BV11J411n7fN?spm_id_from=333.999.0.0)

###  1.283. <a name='SorttheMatrixDiagonally'></a>1329 Sort the Matrix Diagonally

[小明](https://www.bilibili.com/video/BV1hU4y147b1?spm_id_from=333.999.0.0)

###  1.284. <a name='RemovePalindromicSubsequences'></a>1332 Remove Palindromic Subsequences

[小明](https://www.bilibili.com/video/BV1tK4y1D7aV?spm_id_from=333.999.0.0)

###  1.285. <a name='DijkstraFindtheCityWithSmallestNumberofNeighbors'></a>1334. 【Dijkstra🚗】Find the City With Smallest Number of Neighbors

[花花酱](https://www.bilibili.com/video/BV1b7411z7Tb?spm_id_from=333.999.0.0)

###  1.286. <a name='MinimumDifficultyofaJobSchedule'></a>1335. Minimum Difficulty of a Job Schedule

[花花酱](https://www.bilibili.com/video/BV1K7411r7xj?spm_id_from=333.999.0.0)

###  1.287. <a name='TheKWeakestRowsinaMatrix'></a>1337 The K Weakest Rows in a Matrix

[小明](https://www.bilibili.com/video/BV1bX4y157ju?spm_id_from=333.999.0.0)

###  1.288. <a name='MaximumProductofSplitt'></a>1339 Maximum Product of Splitt

[小明](https://www.bilibili.com/video/BV1Ch411i7yS?spm_id_from=333.999.0.0)

###  1.289. <a name='JumpGameV'></a>1340. 【动态🚀规划】Jump Game V

[花花酱](https://www.bilibili.com/video/BV1h7411W7wS?spm_id_from=333.999.0.0)

```py
记忆化 DFS + 递归

class Solution:
    def maxJumps(self, arr: List[int], step: int) -> int:
        n = len(arr)
        
        @lru_cache(None)
        def dfs(i):
            res = 0
            for j in range(i + 1, i + step + 1):
                if j >= n or arr[j] >= arr[i]:
                    break
                res = max(res, dfs(j))
            for j in range(i - 1, i - step - 1, -1):
                if j < 0 or arr[j] >= arr[i]:
                    break
                res = max(res, dfs(j))
            return res + 1
        
        return max(dfs(i) for i in range(n))

等效于：

class Solution:
    def maxJumps(self, arr: List[int], step: int) -> int:
        visited = {}
        l = len(arr)
        def dfs(n):
            
            if n in visited:
                return visited[n]
            
            t = 1
            
            for i in range(1, step + 1):
                if n + i >= l or arr[n] <= arr[n + i]:
                    break
                t = max(t, 1 + dfs(n + i))
                
            for i in range(1, step + 1):
                if n - i < 0 or arr[n] <= arr[n - i]:
                    break
                t = max(t, 1 + dfs(n - i))
                
            visited[n] = t
            return t
        
        return max(dfs(i) for i in range(l))

等效于：

class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        visited = dict()

        def dfs(pos):
            if pos in visited:
                return
            visited[pos] = 1

            i = pos - 1
            while i >= 0 and pos - i <= d and arr[pos] > arr[i]:
                dfs(i)
                visited[pos] = max(visited[pos], visited[i] + 1)
                i -= 1
            i = pos + 1
            while i < len(arr) and i - pos <= d and arr[pos] > arr[i]:
                dfs(i)
                visited[pos] = max(visited[pos], visited[i] + 1)
                i += 1

        for i in range(len(arr)):
            dfs(i)
        print(visited)
        return max(visited.values())
```

动态🚀规划

```py
排序之后对向两边进行拓展

class Solution:
    def maxJumps(self, arr: List[int], step: int) -> int:
        n = len(arr)
        # 先按照高度排序
        height = [(jump,i) for i, jump in enumerate(arr)]
        height = sorted(height, key=lambda x: x[0])
        dp = [1 for _ in range(n)]
        
        
        for jump, i in height:
            cur = 1
            for j in range(i-1, max(-1, i - step) - 1, -1): # 向左跳
                if arr[j] >= jump: break
                cur = max(dp[j] + 1,cur)

            for j in range(i + 1, min(n, i + step + 1)):
                if arr[j] >= jump: break
                cur = max(dp[j] + 1, cur)
            # 根据 jump 的大小，动态🚀规划，求dp
            dp[i] = cur
        return max(dp)

```

###  1.290. <a name='MaximumStudentsTakingExam'></a>1349. Maximum Students Taking Exam

[花花酱](https://www.bilibili.com/video/BV1w7411V7eC?spm_id_from=333.999.0.0)

###  1.291. <a name='MaximumNumberofEventsThatCanBeAttended'></a>1353. Maximum Number of Events That Can Be Attended 

[花花酱](https://www.bilibili.com/video/BV1C7411j7YJ?spm_id_from=333.999.0.0)

###  1.292. <a name='ConstructTargetArrayWithMultipleSums'></a>1354. Construct Target Array With Multiple Sums

[花花酱](https://www.bilibili.com/video/BV1g7411c793?spm_id_from=333.999.0.0)

###  1.293. <a name='DijkstraMinimumCosttoMakeatLeastOneValidPath'></a>1368. 【Dijkstra🚗】Minimum Cost to Make at Least One Valid Path

[花花酱](https://www.bilibili.com/video/BV1oE411E74t?spm_id_from=333.999.0.0)

###  1.294. <a name='FindtheLongestSubstringContainingVowelsinEve'></a>1371. Find the Longest Substring Containing Vowels in Eve

[花花酱](https://www.bilibili.com/video/BV1CE411K7hb?spm_id_from=333.999.0.0)

###  1.295. <a name='MaximumSumBSTinBinaryTree'></a>1373. Maximum Sum BST in Binary Tree

[花花酱](https://www.bilibili.com/video/BV17E411u797?spm_id_from=333.999.0.0)

###  1.296. <a name='FrogPositionAfterTSeconds'></a>1377. Frog Position After T Seconds

[花花酱](https://www.bilibili.com/video/BV1mE411K7vc?spm_id_from=333.999.0.0)

###  1.297. <a name='FindCorrespondingNodeofBinaryTreeinaClone'></a>1379 Find Corresponding Node of Binary Tree in a Clone

[小明](https://www.bilibili.com/video/BV1A54y147HN?spm_id_from=333.999.0.0)

###  1.298. <a name='BalanceaBinarySearchTree'></a>1382. Balance a Binary Search Tree

[花花酱](https://www.bilibili.com/video/BV1y7411f7v2?spm_id_from=333.999.0.0)

###  1.299. <a name='CountNumberofTeams'></a>1395. Count Number of Teams

[花花酱](https://www.bilibili.com/video/BV1cc411h73E?spm_id_from=333.999.0.0)

###  1.300. <a name='DesignUndergroundSystem'></a>1396 Design Underground System

[小明](https://www.bilibili.com/video/BV1uA411N7q6?spm_id_from=333.999.0.0)

###  1.301. <a name='StoneGameIII'></a>1406. Stone Game III

[花花酱](https://www.bilibili.com/video/BV1zT4y1G7Tb?spm_id_from=333.999.0.0)

###  1.302. <a name='QueriesonaPermutationWithKey'></a>1409. Queries on a Permutation With Key

[花花酱](https://www.bilibili.com/video/BV1mz411b7Uw?spm_id_from=333.999.0.0)

###  1.303. <a name='RestoreTheArray'></a>1416. Restore The Array

[花花酱](https://www.bilibili.com/video/BV1gK4y1k7Rv?spm_id_from=333.999.0.0)

###  1.304. <a name='DiagonalTraverseII'></a>1424. Diagonal Traverse II

[花花酱](https://www.bilibili.com/video/BV1r5411x7Tm?spm_id_from=333.999.0.0)

###  1.305. <a name='ConstrainedSubsetSum'></a>1425. Constrained Subset Sum

[花花酱](https://www.bilibili.com/video/BV13t4y1m7fD?spm_id_from=333.999.0.0)

###  1.306. <a name='CountingElements'></a>1426  Counting Elements

[小明](https://www.bilibili.com/video/BV1Eg4y187vx?spm_id_from=333.999.0.0)

###  1.307. <a name='KidsWiththeGreatestNumberofCandie'></a>1431. 拥有最多糖果的孩子 Kids With the Greatest Number of Candie

[官方](https://www.bilibili.com/video/BV1vD4y1D7yo?spm_id_from=333.999.0.0)

###  1.308. <a name='CheckIfAll1sAreatLeastLength'></a>1437 Check If All 1's Are at Least Length

[小明](https://www.bilibili.com/video/BV1Yo4y1R78P?spm_id_from=333.999.0.0)

###  1.309. <a name='LongestContinuousSubarrayWithAbsolute'></a>1438. Longest Continuous Subarray With Absolute

[花花酱](https://www.bilibili.com/video/BV1Cf4y1m7aN?spm_id_from=333.999.0.0)

###  1.310. <a name='BuildanArrayWithStackOperations'></a>1441 Build an Array With Stack Operations

[小明](https://www.bilibili.com/video/BV1Gg4y167ZD?spm_id_from=333.999.0.0)

###  1.311. <a name='CountTripletsThatCanFormTwoArraysofEqual'></a>1442. Count Triplets That Can Form Two Arrays of Equal

[花花酱](https://www.bilibili.com/video/BV17g4y1B7yo?spm_id_from=333.999.0.0)

###  1.312. <a name='MinimumTimetoCollectAllApplesinaTree'></a>1443. Minimum Time to Collect All Apples in a Tree

[花花酱](https://www.bilibili.com/video/BV1e541147oZ?spm_id_from=333.999.0.0)

###  1.313. <a name='NumberofWaysofCuttingaPizza'></a>1444. 【二维动态🚀规划 + 前缀和🎨 + 递归】Number of Ways of Cutting a Pizza

[花花酱](https://www.bilibili.com/video/BV1CK411W7nR?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1gg4y1B7zS?spm_id_from=333.999.0.0)

递归法

```py
class Solution:

    def ways(self, pizza: List[str], k: int) -> int:
        dicDP = {}
        MOD = 10 **9 + 7
        
        @cache
        def dp(i, j, numK):
            # 递归结束：
            if (i, j, numK) in dicDP:
                return dicDP[(i, j, numK)]
            if numK == 1:
                isCut = False
                for upRemove in range(i, len(pizza)):
                    for leftRemove in range(j, len(pizza[0])):
                        isCut = isCut or pizza[upRemove][leftRemove] == 'A'
                return 1 if isCut else 0
            
            # 递归开始
            isCut = False
            res = 0
            for upRemove in range(i, len(pizza)):
                isCut = isCut or any([pizza[upRemove][c] == 'A' for c in range(j, len(pizza[0]))])
                if isCut:
                    res += dp(upRemove + 1, j, numK - 1)
                    
            isCut = False
            for leftRemove in range(j, len(pizza[0])):
                isCut = isCut or any([pizza[r][leftRemove] == 'A' for r in range(i, len(pizza))])
                if isCut:
                    res += dp(i, leftRemove + 1, numK - 1)
                    
            dicDP[(i, j, numK)] = res % MOD
            return res % MOD
        
        return dp(0, 0, k) % MOD

暴力深搜+记忆化

class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        
        rows, cols = len(pizza), len(pizza[0])
        
        @functools.lru_cache(None)
        def dp(x,y,k):
            if not k:
                return any('A' in p[y:cols] for p in pizza[x:rows])
            res=0
            
            for upCut in range(x+1,rows):
                if any('A' in p[y:cols] for p in pizza[x:upCut]):
                    res += dp(upCut,y,k-1)
                    
            for leftCut in range(y+1,cols):
                if any('A' in p[y:leftCut] for p in pizza[x:rows]):
                    res += dp(x,leftCut,k-1)
                    
            return res
        
        return dp(0,0,k-1) % 1000000007

前缀和：
class Solution:
    def ways(self, pizza: List[str], k: int) -> int:
        
        rows, cols = len(pizza), len(pizza[0])
        
        pref = [[0]* (cols+1) for _ in range(rows+1)]
        # 前缀和，有多少个苹果
        for i in range(rows):
            for j in range(cols):
                pref[i+1][j+1] = pref[i][j+1] + pref[i+1][j] - pref[i][j] + (1 if pizza[i][j] == 'A' else 0)
                
        @lru_cache(None)
        def f(x, y, k):
            
            # 结束递归：
            if not k:
                return pref[rows][cols] - pref[x][cols] - pref[rows][y] + pref[x][y] > 0
            res = 0
            
            # 开始递归：
            for upCut in range(x+1, rows):
                if pref[upCut][cols] - pref[x][cols] - pref[upCut][y] + pref[x][y] > 0:
                    res += f(upCut, y, k-1)
                    
            for leftCut in range(y+1, cols):
                if pref[rows][leftCut] - pref[x][leftCut] - pref[rows][y] + pref[x][y] > 0:
                    res += f(x, leftCut, k-1)
            return res
        
        return f(0, 0, k-1) % (10**9+7)
```

动态🚀规划：好难啊

```py
class Solution:
	def ways(self,pizza,k):
		row, col = len(pizza),len(pizza[0])
		pref, dp= [[0]*(col+1) for _ in range(row+1)], [[0]*col for _ in range(row)]
  
		for x in range(row-1,-1,-1):
			for y in range(col-1,-1,-1):
				pref[x][y] = pref[x+1][y] + pref[x][y+1] - pref[x+1][y+1] + (pizza[x][y] == "A")
				dp[x][y] += pref[x][y] != 0
    
		for turn in range(2,k+1):
			new_dp = [[0]*col for _ in range(row)]
			for x in range(row-1,-1,-1):
				for y in range(col-1,-1,-1):
					if row + col - x - y -1 >= turn:
						part1 = sum(dp[upCut][y] for upCut in range(x+1,row) if pref[x][y] - pref[upCut][y] > 0)
						part2 = sum(dp[x][leCut] for leCut in range(y+1,col) if pref[x][y] - pref[x][leCut] > 0)
						new_dp[x][y] = part1 + part2
			dp=new_dp
		return dp[0][0]%int(1e9+7)
```

```scala
object Solution {
  val M = 1000000007L

  def ways(pizza: Array[String], k: Int): Int = {
    val arr = Array.fill(pizza.length + 1, pizza(0).length + 1)(0)
    val dp = Array.fill(pizza.length + 1, pizza(0).length + 1, k)(0L)
    (1 to pizza.length).foreach(r => (1 to pizza(0).length).foreach(c => arr(r)(c) = arr(r - 1)(c) + arr(r)(c - 1) - arr(r - 1)(c - 1) + (if (pizza(pizza.length - r)(pizza(0).length - c) == 'A') 1 else 0)))
    (0 to pizza.length).foreach(r => (0 to pizza(0).length).foreach(c => dp(r)(c)(0) = if (arr(r)(c) > 0) 1 else 0))
    (1 until k).foreach(cuts => (1 to pizza.length).foreach(r => (1 to pizza(0).length).foreach(c => {
      (1 until r).withFilter(cr => arr(r)(c) - arr(r - cr)(c) > 0).foreach(cr => {
        dp(r)(c)(cuts) += dp(r - cr)(c)(cuts - 1)
        dp(r)(c)(cuts) %= M
      })
      (1 until c).withFilter(cc => arr(r)(c) - arr(r)(c - cc) > 0).foreach(cc => {
        dp(r)(c)(cuts) += dp(r)(c - cc)(cuts - 1)
        dp(r)(c)(cuts) %= M
      })
    })))
    (dp(pizza.length)(pizza(0).length)(k - 1) % M).toInt
  }
}
```

###  1.314. <a name='ConsecutiveCharacters'></a>1446 Consecutive Characters

[小明](https://www.bilibili.com/video/BV1QA411j7Qt?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1pp4y1Q7Rh?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxPower(self, s: str) -> int:
        return max(map(lambda x:len(list(x[1])),groupby(s)))
class Solution:
    def maxPower(self, s: str) -> int:
        return max(map(lambda x:len(list(x[1])),groupby(s)))
class Solution:
    def maxPower(self, s: str) -> int:
        ans, cnt = 1, 1
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                cnt += 1
                ans = max(ans, cnt)
            else:
                cnt = 1
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/consecutive-characters/solution/lian-xu-zi-fu-by-leetcode-solution-lctm/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
偷懒的两种方法 1.itertools.groupby 2.re

#python3
from itertools import groupby
class Solution:
	def maxPower(self,s):
		return max(len(list(j)) for _,j in groupby(s))
#python3
from re import compile
from string import ascii_lowercase
class Solution:
	def maxPower(self,s):
		pattern=compile("{1,}|".join(ascii_lowercase+" ")[:-2])
		return max(map(len,(pattern.findall(s))))
```

###  1.315. <a name='CountGoodNodesinBinaryTree'></a>1448 Count Good Nodes in Binary Tree

[小明](https://www.bilibili.com/video/BV1Zg4y1q7kc?spm_id_from=333.999.0.0)

###  1.316. <a name='FormLargestIntegerWithDigitsThatAdd'></a>1449. 【背包 + 动态🚀规划】Form Largest Integer With Digits That Add

[花花酱](https://www.bilibili.com/video/BV19Q4y1A7Rf?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1j54y1D7vf?spm_id_from=333.999.0.0)

```py
# from 
# print(dp)
# [0, -1, -1, -1, -1, -1, -1, -1, -1, -1]
# [0, -1, 7, -1, -1, -1, -1, -1, -1, -1]
# [0, -1, 7, 2, -1, -1, -1, -1, -1, -1]
# [0, -1, 7, 2, 77, -1, -1, -1, -1, -1]
# [0, -1, 7, 2, 77, 72, -1, -1, -1, -1]
# [0, -1, 7, 2, 77, 72, 777, -1, -1, -1]
# [0, -1, 7, 2, 77, 72, 777, 772, -1, -1]
# [0, -1, 7, 2, 77, 72, 777, 772, 7777, -1]
# [0, -1, 7, 2, 77, 72, 777, 772, 7777, 7772]
class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [0] + [-1] * target
        for t in range(1, target + 1):
            for n, c in enumerate(cost,1):
                if c <= t:
                    dp[t] = max(dp[t], dp[t-c] * 10 + n)
        return str(max(dp[target], 0))

剪枝一下：是错误❌的

class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [0] + [-1] * target
        for t in range(cost[0], target + 1):
            for n, c in enumerate(cost,1):
                if c <= t:
                    dp[t] = max(dp[t], dp[t-c] * 10 + n)
        return str(max(dp[target], 0))

输入：
[4,3,2,5,6,7,2,5,5]
9
输出：
"977"
预期结果：
"7772"

class Solution:
    def largestNumber(self, cost: List[int], target: int) -> str:
        dp = [0] + [-1] * target # 易错点： 😁-1 也可以写成 float('-inf')，但是不可以是 0
        
        for n, c in reversed(list(enumerate(cost, 1))): # 正着和反着，都一样reversed(list(enumerate(cost, 1))):
            for t in range(c, target+1):
                dp[t] = max([dp[t], dp[t-c] * 10 + n])
                
        return str(max(dp[-1],0)) 
```


```scala
偷懒使用了字符串比较：

object P1449 {
  def largestNumber(costs: Array[Int], target: Int): String = {
    val dp = new Array[Boolean](target + 1)
    val nums = Array.fill(target + 1)("")
    dp(0) = true
    costs.indices.reverse.foreach { i =>
      val num = i + 1
      val cost = costs(i)
      (cost to target).foreach { j =>
        if (dp(j - cost)) {
          dp(j) = true
          val newStr = nums(j - cost) + num
          if (newStr.length > nums(j).length || (newStr.length == nums(j).length && newStr > nums(j))) {
            nums(j) = newStr
          }
        }
      }
    }

    if (nums(target) == "") "0" else nums(target)
  }
}
```

###  1.317. <a name='RearrangeWordsinaSentence'></a>1451 Rearrange Words in a Sentence

[小明](https://www.bilibili.com/video/BV1UA411t7Eg?spm_id_from=333.999.0.0)

###  1.318. <a name='MaximumNumberofDartsInsideofaCircularDartb'></a>1453 Maximum Number of Darts Inside of a Circular Dartb

[小明](https://www.bilibili.com/video/BV1Ut4y117jp?spm_id_from=333.999.0.0)

###  1.319. <a name='Pseudo-PalindromicPathsinaBin'></a>1457 Pseudo-Palindromic Paths in a Bin

[小明](https://www.bilibili.com/video/BV1t54y1t7KK?spm_id_from=333.999.0.0)

###  1.320. <a name='CheckIfaStringContainsAllBinar'></a>1461 Check If a String Contains All Binar

[小明](https://www.bilibili.com/video/BV13Z4y1w7K9?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1oU4y1p7Tr?spm_id_from=333.999.0.0)

```py
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        for i in range(2 ** k):
            c = bin(i)[2:]
            c = '0' * (k - len(c)) + c
            if c not in s:
                return False
        return True
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        rec = set()
        for i in range(len(s)-k+1):
            rec.add(s[i:i+k])
        return len(rec) == 2**k
来个暴力! 7420ms ，居然过了？？？

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        from itertools import product
        for i in map(lambda x: ''.join(x), product('01', repeat=k)):
            if i not in s:
                return False
        return True
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        def gen_subs(choices, k, cur):
            if k == 0:
                yield cur
                return 
            for c in choices:
                yield from gen_subs(choices, k-1, cur+c)
        
        sets = set()

        for i in range(len(s) -k +1):
            sets.add(s[i: i+k])
        
        return all(sub in sets for sub in gen_subs('01', k, ''))
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        for i in range(2**k):
            if '0'*(k-len(bin(i)[2:]))+bin(i)[2:] not in s:
                return False
        return True

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        if len(s) < (1 << k) + k - 1:
            return False
        
        exists = set(s[i:i+k] for i in range(len(s) - k + 1))
        return len(exists) == (1 << k)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/solution/jian-cha-yi-ge-zi-fu-chuan-shi-fou-bao-h-1no1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        if len(s) < (1 << k) + k - 1:
            return False
        
        num = int(s[:k], base=2)
        exists = set([num])

        for i in range(1, len(s) - k + 1):
            num = (num - ((ord(s[i - 1]) - 48) << (k - 1))) * 2 + (ord(s[i + k - 1]) - 48)
            exists.add(num)
        
        return len(exists) == (1 << k)

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/solution/jian-cha-yi-ge-zi-fu-chuan-shi-fou-bao-h-1no1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        return len(s) >= (1 << k) + k - 1 and len(set([s[i:i+k] for i in range(len(s)-k+1)])) == 1<<k 
```

```py

```

###  1.321. <a name='CherryPickupII'></a>1463 Cherry Pickup II

[小明](https://www.bilibili.com/video/BV1AA411s7Tc?spm_id_from=333.999.0.0)

###  1.322. <a name='PaintHouseIII'></a>1473. Paint House III

[花花酱](https://www.bilibili.com/video/BV15K411p7nT?spm_id_from=333.999.0.0)

###  1.323. <a name='FinalPricesWithaSpecialDiscountinaSho'></a>1475. Final Prices With a Special Discount in a Sho

[花花酱](https://www.bilibili.com/video/BV1na4y1Y7VU?spm_id_from=333.999.0.0)

###  1.324. <a name='KthAncestorofaTreeNode'></a>1483. Kth Ancestor of a Tree Node

[花花酱](https://www.bilibili.com/video/BV1kt4y1X7fk?spm_id_from=333.999.0.0)

###  1.325. <a name='AvoidFloodinTheCity'></a>1488. Avoid Flood in The City

[花花酱](https://www.bilibili.com/video/BV1af4y1y7uW?spm_id_from=333.999.0.0)

###  1.326. <a name='FindCriticalandPseudo-CriticalEdgesin'></a>1489. 【🍒并查集】Find Critical and Pseudo-Critical Edges in

[花花酱](https://www.bilibili.com/video/BV1cV41167oi?spm_id_from=333.999.0.0)

###  1.327. <a name='ThekthFactorofn'></a>1492 The kth Factor of n

[小明](https://www.bilibili.com/video/BV1ha4y1H7vz?spm_id_from=333.999.0.0)

###  1.328. <a name='LongestSubarrayof1sAfterDeletingOne'></a>1493. Longest Subarray of 1's After Deleting One

[花花酱](https://www.bilibili.com/video/BV1rC4y18751?spm_id_from=333.999.0.0)

###  1.329. <a name='MaxValueofEquation'></a>1499. Max Value of Equation

[花花酱](https://www.bilibili.com/video/BV1VK411H7zy?spm_id_from=333.999.0.0)

###  1.330. <a name='CanMakeArithmeticProgressionFromSequence'></a>1502 Can Make Arithmetic Progression From Sequence

[小明](https://www.bilibili.com/video/BV12T4y177vU?spm_id_from=333.999.0.0)

###  1.331. <a name='LastMomentBeforeAllAntsFallOutofaPlank'></a>1503 Last Moment Before All Ants Fall Out of a Plank

[小明](https://www.bilibili.com/video/BV1Fg4y1i7na?spm_id_from=333.999.0.0)

###  1.332. <a name='MinimumPossibleIntegerAfteratMostKAdjacent'></a>1505. Minimum Possible Integer After at Most K Adjacent

[花花酱](https://www.bilibili.com/video/BV1YD4y1S7BQ?spm_id_from=333.999.0.0)

###  1.333. <a name='RangeSumofSortedSubarraySums'></a>1508. Range Sum of Sorted Subarray Sums

[花花酱](https://www.bilibili.com/video/BV1fg4y1v7qe?spm_id_from=333.999.0.0)

###  1.334. <a name='StoneGameIV'></a>1510 Stone Game IV

[小明](https://www.bilibili.com/video/BV1pr4y1w7ao?spm_id_from=333.999.0.0)

###  1.335. <a name='DijkstraPathwithMaximumProbability'></a>1514 【Dijkstra🚗】Path with Maximum Probability

[小明](https://www.bilibili.com/video/BV1Ak4y1B7yR?spm_id_from=333.999.0.0)

###  1.336. <a name='BestPositionforaServiceCentre'></a>1515 Best Position for a Service Centre

[小明](https://www.bilibili.com/video/BV1UA411e7PC?spm_id_from=333.999.0.0)

###  1.337. <a name='MaximumNumberofNon-OverlappingSubstrings'></a>1520. Maximum Number of Non-Overlapping Substrings

[花花酱](https://www.bilibili.com/video/BV1yz4y1D7p3?spm_id_from=333.999.0.0)

###  1.338. <a name='NumberofGoodLeafNodesPairs'></a>1530. Number of Good Leaf Nodes Pairs

[花花酱](https://www.bilibili.com/video/BV1bv411q7SD?spm_id_from=333.999.0.0)

###  1.339. <a name='StringCompressionII'></a>1531. String Compression II

[花花酱](https://www.bilibili.com/video/BV1aK4y1v7B9?spm_id_from=333.999.0.0)

###  1.340. <a name='CountGoodTriplets'></a>1534 Count Good Triplets

[小明](https://www.bilibili.com/video/BV11k4y1m7rV?spm_id_from=333.999.0.0)

###  1.341. <a name='FindtheWinnerofanArrayGame'></a>1535 Find the Winner of an Array Game

[小明](https://www.bilibili.com/video/BV1Xp4y1i7ey?spm_id_from=333.999.0.0)

###  1.342. <a name='GettheMaximumScore'></a>1537. Get the Maximum Score

[小梦想家](https://www.bilibili.com/video/BV1KC4y1t7P8?spm_id_from=333.999.0.0)

###  1.343. <a name='KthMissingPositiveNumber'></a>1539. Kth Missing Positive Number

[小梦想家](https://www.bilibili.com/video/BV1SC4y147Eo?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1QK4y1p7E3?spm_id_from=333.999.0.0)

```py
class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        missCount = 0
        lastMiss = -1
        current = 1
        ptr = 0

        while missCount < k:
            if current == arr[ptr]:
                if ptr + 1 < len(arr):
                    ptr += 1
            else:
                missCount += 1
                lastMiss = current
            current += 1
        
        return lastMiss

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/kth-missing-positive-number/solution/di-k-ge-que-shi-de-zheng-zheng-shu-by-leetcode-sol/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        if arr[0] > k:
            return k
        
        l, r = 0, len(arr)
        while l < r:
            mid = (l + r) >> 1
            x = arr[mid] if mid < len(arr) else 10**9
            if x - mid - 1 >= k:
                r = mid
            else:
                l = mid + 1

        return k - (arr[l - 1] - (l - 1) - 1) + arr[l - 1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/kth-missing-positive-number/solution/di-k-ge-que-shi-de-zheng-zheng-shu-by-leetcode-sol/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        pos = 0
        cnt = 0
        for i in arr:
            cnt+=i-pos-1
            if cnt>=k:
                return i-(cnt-k)-1
            pos = i
        return arr[-1]+k-cnt
class Solution:
    def findKthPositive(self, arr, k):
        for i in range(len(arr)):
            if arr[i] - i > k:
                return i + k
            if len(arr) + k > arr[-1]:
                return len(arr) + k
```

```py
Python 1行:

class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        return list(set(range(2001)) - set(arr))[k]
```

###  1.344. <a name='FindLongestAwesomeSubstring'></a>1542. Find Longest Awesome Substring

[花花酱](https://www.bilibili.com/video/BV1ZD4y1U79Y?spm_id_from=333.999.0.0)

###  1.345. <a name='MaximumNumberofNon-OverlappingSubarraysWithSum'></a>1546. Maximum Number of Non-Overlapping Subarrays With Sum

[小梦想家](https://www.bilibili.com/video/BV1LA411n7L8?spm_id_from=333.999.0.0)

###  1.346. <a name='ThreeConsecutiveOdds'></a>1550. Three Consecutive Odds

[小梦想家](https://www.bilibili.com/video/BV1aV411m7fy?spm_id_from=333.999.0.0)

###  1.347. <a name='MinimumOperationstoMakeArray'></a>1551 Minimum Operations to Make Array

[小明](https://www.bilibili.com/video/BV1u64y1S7fx?spm_id_from=333.999.0.0)

###  1.348. <a name='MinimumNumberofDaystoEatNOranges'></a>1553. Minimum Number of Days to Eat N Oranges

[花花酱](https://www.bilibili.com/video/BV1Qf4y197Zk?spm_id_from=333.999.0.0)

###  1.349. <a name='ThousandSeparator'></a>1556. Thousand Separator

[小梦想家](https://www.bilibili.com/video/BV1Ka4y177HV?spm_id_from=333.999.0.0)

###  1.350. <a name='MinimumNumbersofFunctionCallstoMakeTarget'></a>1558. Minimum Numbers of Function Calls to Make Target

[花花酱](https://www.bilibili.com/video/BV1xC4y1t7Q3?spm_id_from=333.999.0.0)

###  1.351. <a name='StoneGameV'></a>1563. Stone Game V 

[花花酱](https://www.bilibili.com/video/BV1B54y1U77f?spm_id_from=333.999.0.0)

###  1.352. <a name='NumberofWaystoReorderArraytoGetSa'></a>1569. Number of Ways to Reorder Array to Get Sa

[花花酱](https://www.bilibili.com/video/BV1pZ4y1T7TY?spm_id_from=333.999.0.0)

###  1.353. <a name='NumberofWaystoSplitaString'></a>1573. Number of Ways to Split a String

[花花酱](https://www.bilibili.com/video/BV1bi4y1u7c3?spm_id_from=333.999.0.0)

###  1.354. <a name='CheckIfStringIsTransformableWith'></a>1585. Check If String Is Transformable With

[花花酱](https://www.bilibili.com/video/BV1a54y1m75Y?spm_id_from=333.999.0.0)

###  1.355. <a name='SplitaStringIntotheMaxNumberofUniqueSubstri'></a>1593. Split a String Into the Max Number of Unique Substri

[花花酱](https://www.bilibili.com/video/BV14y4y1k77x?spm_id_from=333.999.0.0) 

###  1.356. <a name='MinimumCosttoConnectTwoGroupsofPoints'></a>1595. Minimum Cost to Connect Two Groups of Points

[花花酱](https://www.bilibili.com/video/BV1Xf4y1D7SW?spm_id_from=333.999.0.0)

###  1.357. <a name='NumberofSetsofKNon-OverlappingLine'></a>1621. Number of Sets of K Non-Overlapping Line

[花花酱](https://www.bilibili.com/video/BV1JV411y7eK?spm_id_from=333.999.0.0)

###  1.358. <a name='DijkstraPathWithMinimumEffort'></a>1631. 【Dijkstra🚗 + 最小堆🌵】Path With Minimum Effort

[花花酱](https://www.bilibili.com/video/BV1tr4y1w725?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV1ft4y1z71X?spm_id_from=333.999.0.0)

```py
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        left, right, ans = 0, 10**6 - 1, 0

        while left <= right:
            mid = (left + right) // 2
            q = collections.deque([(0, 0)])
            seen = {(0, 0)}
            
            while q:
                x, y = q.popleft()
                for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                    if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in seen and abs(heights[x][y] - heights[nx][ny]) <= mid:
                        q.append((nx, ny))
                        seen.add((nx, ny))
            
            if (m - 1, n - 1) in seen:
                ans = mid
                right = mid - 1
            else:
                left = mid + 1
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 🍒并查集模板
class UnionFind:
    def __init__(self, n: int):
        self.parent = list(range(n))
        self.size = [1] * n
        self.n = n
        # 当前连通分量数目
        self.setCount = n
    
    def findset(self, x: int) -> int:
        if self.parent[x] == x:
            return x
        self.parent[x] = self.findset(self.parent[x])
        return self.parent[x]
    
    def unite(self, x: int, y: int) -> bool:
        x, y = self.findset(x), self.findset(y)
        if x == y:
            return False
        if self.size[x] < self.size[y]:
            x, y = y, x

        self.parent[y] = x
        self.size[x] += self.size[y]
        self.setCount -= 1
        return True
    
    def connected(self, x: int, y: int) -> bool:
        x, y = self.findset(x), self.findset(y)
        return x == y

class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        edges = list()
        for i in range(m):
            for j in range(n):
                iden = i * n + j
                if i > 0:
                    edges.append((iden - n, iden, abs(heights[i][j] - heights[i - 1][j])))
                if j > 0:
                    edges.append((iden - 1, iden, abs(heights[i][j] - heights[i][j - 1])))
        
        edges.sort(key=lambda e: e[2])

        uf = UnionFind(m * n)
        ans = 0
        for x, y, v in edges:
            uf.unite(x, y)
            if uf.connected(0, m * n - 1):
                ans = v
                break
        
        return ans

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```py
这个月已经熟练掌握🍒并查集了 python

class UF():
    def __init__(self, M):
        self.parent = {}
        for i in range(M):
            self.parent[i] = i

    def find(self, p):
        while p != self.parent[p]:
            p = self.parent[p]
        return p

    def connected(self, p, q):
        return self.find(p) == self.find(q)

    def union(self, p, q):
        if self.connected(p, q): return 
        leader_p = self.find(p)
        leader_q = self.find(q)
        self.parent[leader_q] = leader_p



class Solution(object):
    def minimumEffortPath(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: int
        """
        value_list = []
        m = len(heights)
        n = len(heights[0])
        if m*n == 1:
            return 0
        else:
            for i in range(m):
                for j in range(n):
                    num1 = i * n + j
                    if i + 1 < m:
                        num2 = num1 + n
                        value = abs(heights[i][j]-heights[i+1][j])
                        value_list.append((value, num1, num2))
                    if j + 1 < n:
                        num2 = num1 + 1
                        value = abs(heights[i][j]-heights[i][j+1])
                        value_list.append((value, num1, num2))
            value_list.sort()
            # print(value_list)
            uf = UF(m*n)
            for i in range(len(value_list)):
                value, num1, num2 = value_list[i]
                uf.union(num1, num2)
                if uf.connected(0, m*n-1):
                    return value

class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        q = [(0, 0, 0)]
        dist = [0] + [float("inf")] * (m * n - 1)
        seen = set()

        while q:
            d, x, y = heapq.heappop(q)
            iden = x * n + y
            if iden in seen:
                continue
            if (x, y) == (m - 1, n - 1):
                break
            
            seen.add(iden)
            for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= nx < m and 0 <= ny < n and max(d, abs(heights[x][y] - heights[nx][ny])) <= dist[nx * n + ny]:
                    dist[nx * n + ny] = max(d, abs(heights[x][y] - heights[nx][ny]))
                    heapq.heappush(q, (dist[nx * n + ny], nx, ny))
        
        return dist[m * n - 1]

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/path-with-minimum-effort/solution/zui-xiao-ti-li-xiao-hao-lu-jing-by-leetc-3q2j/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

🍒并查集

1.先构建各点之间的边列表edges。 其中由edge=[x,y,d]组成，d为点x与y差的绝对值

2.根据边列表中的 各点差的绝对值 从小到大排序

3.依次遍历edges， 并将各点进行连通， 当最左上与最左下 第一次连通时结束，并输出 所遍历过edges中的最大d

class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        m = len(heights)
        n = len(heights[0])
        parent = list(range(m*n))
        edges =[]
        def find(index):
            if parent[index]!=index:
                parent[index] = find(parent[index])
            return parent[index]
        def union(index1, index2):
            u = find(index1)
            v = find(index2)
            parent[u] = v
            
        def is_valid(x,y):
            # 判断 节点是否合理
            return 0<=x<m and 0<=y<n

        # 构建 edges 列表
        # edge 为三元组[x,y,d] ，其中d为 x与y 差的绝对值
        for i in range(m):
            for j in range(n):
                nx = i+1
                ny = j
                if is_valid(nx,ny):
                    d = abs(heights[i][j]-heights[nx][ny])
                    edges.append([i*n+j,nx*n+ny,d])
                nx= i
                ny = j+1
                if is_valid(nx,ny):
                    d = abs(heights[i][j] - heights[nx][ny])
                    edges.append([i*n+j,nx*n+ny,d])
        # 将 边 根据绝对差值 d 进行从小到大排序
        edges = sorted(edges, key=lambda x:x[-1])

        # 依次遍历 edges 并依次连通所遍历的节点，当左上与左下连通时，结束，输出所遍历过的最大 d
        cost = 0
        for edge in edges:
            if find(0)==find(m*n-1):
                break
            x,y,d = edge
            if find(x)!=find(y):
                union(x,y)
                cost=max(cost,d)
        return cost
```

###  1.359. <a name='RankTransformofaMatrix'></a>1632 Rank Transform of a Matrix

[小明](https://www.bilibili.com/video/BV1KX4y1F7UA?spm_id_from=333.999.0.0)

###  1.360. <a name='CheckArrayFormationThrough'></a>1640 Check Array Formation Through

[小明](https://www.bilibili.com/video/BV1uh411274P?spm_id_from=333.999.0.0)

###  1.361. <a name='CountSortedVowelStrings'></a>1641 Count Sorted Vowel Strings

[小明](https://www.bilibili.com/video/BV1jf4y1k7bJ?spm_id_from=333.999.0.0)

###  1.362. <a name='FurthestBuildingYouCanReach'></a>1642. Furthest Building You Can Reach

[花花酱](https://www.bilibili.com/video/BV1az4y1C7Pk?spm_id_from=333.999.0.0)

###  1.363. <a name='GetMaximuminGeneratedArray'></a>1646 Get Maximum in Generated Array

[小明](https://www.bilibili.com/video/BV1W54y1s7mg?spm_id_from=333.999.0.0)

###  1.364. <a name='SellDiminishing-ValuedColoredBalls'></a>1648. Sell Diminishing-Valued Colored Balls

[花花酱](https://www.bilibili.com/video/BV11z4y1C7PC?spm_id_from=333.999.0.0)

###  1.365. <a name='CreateSortedArraythroughInstru'></a>1649 Create Sorted Array through Instru

[小明](https://www.bilibili.com/video/BV1ua4y1H7KK?spm_id_from=333.999.0.0)

###  1.366. <a name='DistributeRepeatingIntegers'></a>1655. Distribute Repeating Integers

[花花酱](https://www.bilibili.com/video/BV1qt4y1a7Lm?spm_id_from=333.999.0.0)

###  1.367. <a name='DetermineifTwoStringsAreClose'></a>1657 Determine if Two Strings Are Close

[小明](https://www.bilibili.com/video/BV18z4y1S779?spm_id_from=333.999.0.0)

###  1.368. <a name='MinimumOperationstoReduceX'></a>1658 Minimum Operations to Reduce X

[小明](https://www.bilibili.com/video/BV18t4y1z7Hq?spm_id_from=333.999.0.0)

###  1.369. <a name='MaximizeGridHappiness'></a>1659. Maximize Grid Happiness

[花花酱](https://www.bilibili.com/video/BV1kf4y1v7Js?spm_id_from=333.999.0.0)

###  1.370. <a name='CheckIfTwoStringArraysareEqui'></a>1662 Check If Two String Arrays are Equi

[小明](https://www.bilibili.com/video/BV1LV411t7v4?spm_id_from=333.999.0.0)

###  1.371. <a name='SmallestStringWithAGivenNumer'></a>1663 Smallest String With A Given Numer

[小明](https://www.bilibili.com/video/BV1gv411e7Ly?spm_id_from=333.999.0.0)

###  1.372. <a name='FindtheMostCompetitiveSubseq'></a>1673 Find the Most Competitive Subseq

[小明](https://www.bilibili.com/video/BV1yK4y1H7ni?spm_id_from=333.999.0.0)

###  1.373. <a name='MinimumMovestoMakeArrayComplement'></a>1674. Minimum Moves to Make Array Complement

[花花酱](https://www.bilibili.com/video/BV1qz4y1k7Cm?spm_id_from=333.999.0.0)

###  1.374. <a name='MinimizeDeviationinArray'></a>1675. Minimize Deviation in Array

[花花酱](https://www.bilibili.com/video/BV15541157p6?spm_id_from=333.999.0.0)

[小明](https://www.bilibili.com/video/BV16f4y167uf?spm_id_from=333.999.0.0)

```py
今天做一回搬运工，参考大佬的

from sortedcontainers import SortedList
class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        ls = SortedList([val<<1 if val&1 else val for val in nums])
        ans = ls[-1] - ls[0]
        while not ls[-1] & 1:
            ls.add(ls.pop()>>1)
            ans = min(ans, ls[-1] - ls[0])            
        return ans
先循环处理最小的奇数，然后再循环处理最大的偶数

from sortedcontainers import SortedList
class Solution:
    def minimumDeviation(self, nums: List[int]) -> int:
        st = SortedList(nums)
        ans = st[-1] - st[0]
        while st[0] & 1:
            n = st[0]
            st.discard(n)
            st.add(n << 1)
            ans = min(ans, st[-1] - st[0])
        while st[-1] & 1 == 0:
            n = st[-1]
            st.discard(n)
            st.add(n >> 1)
            ans = min(ans, st[-1] - st[0])
        return ans
```

```py

```

###  1.375. <a name='MaxNumberofK-SumPairs'></a>1679 Max Number of K-Sum Pairs】

[小明](https://www.bilibili.com/video/BV16t4y1z7kY?spm_id_from=333.999.0.0)

###  1.376. <a name='ConcatenationofConsecutiveBina'></a>1680 Concatenation of Consecutive Bina

[小明](https://www.bilibili.com/video/BV1Py4y117o5?spm_id_from=333.999.0.0)

###  1.377. <a name='MinimumIncompatibility'></a>1681. Minimum Incompatibility

[花花酱](https://www.bilibili.com/video/BV16p4y1z79z?spm_id_from=333.999.0.0)

###  1.378. <a name='StoneGameVII'></a>1690. Stone Game VII

[花花酱](https://www.bilibili.com/video/BV1wf4y1e7xH?spm_id_from=333.999.0.0)

###  1.379. <a name='On-kO1JumpGameVI'></a>1696. 【动态🚀规划 O(n-k) * 优先队列 O(1) + 最小堆🌵】 Jump Game VI

[花花酱](https://www.bilibili.com/video/BV1554y1t7Tz?spm_id_from=333.999.0.0)

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        # 暴力求解法的时间复杂度：O(k*(n-k))
        # dp[i] = nums[i] + max(dp[步长中间的元素]) for 步长中间的元素 in range(i - 最大步长, i)
        # 每一次, i进一位的时候, max(dp[步长中间的元素])也会变化, 相当于一个滑动窗口
        
        dp = [0] * len(nums)
        dp[0] = nums[0]
        
        que = [0]
        for i in range(1, len(nums)):
            # 维护滑动窗口的宽度: 当步长超过了k，则弹出
            while que and i - que[0] > k:
                que.pop(0)
            dp[i] = dp[que[0]] + nums[i]
            # 维护滑动窗口的最大值: 队列的最后一个元素始终是最大值
            while que and dp[que[-1]] <= dp[i]:
                que.pop(-1)
            que.append(i)     
            print(que)
            # [0, 1]
            # [0, 1, 2]
            # [3]
            # [3, 4]
            # [5]
        return dp[-1]

if __name__ == "__main__":      
	s = Solution()
	print(s.maxResult(nums = [10,-5,-2,4,0,3], k = 3))
```


```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        # 维护当前最大值方法
        # 1：最大堆方法
        # 2: 单调递减队列（队首）
        n = len(nums)
        maxHeap = []
        heapq.heapify(maxHeap)
        heapq.heappush(maxHeap, (-nums[0], 0))
        res = nums[0]

        for i in range(1, n):
            while maxHeap and i - maxHeap[0][1] > k:    #index的距离太大(> k)，以后i越来越大，top()就没用了
                heapq.heappop(maxHeap)
            res = -maxHeap[0][0] + nums[i]
            heapq.heappush(maxHeap, (-res, i) )         #dp的思想
            # print(maxHeap): [1,-1,-2,4,-7,3]
            # [(-1, 0), (0, 1)]
            # [(-1, 0), (0, 1), (1, 2)]
            # [(-4, 3), (1, 2), (0, 1)]
            # [(-4, 3), (1, 2), (0, 1), (3, 4)]
            # [(-7, 5), (-4, 3), (0, 1), (3, 4), (1, 2)]
        return res
```

PriorityQueue，没有索引，最好还是用heap

```py
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
        from queue import PriorityQueue
        res, maxHeap = nums[0], PriorityQueue()
        maxHeap.put([-nums[0], 0])
        for i in range(1, len(nums)):
            while maxHeap:
                top = maxHeap.get()
                if i - top[-1] <= k:
                    maxHeap.put(top)
                    break
            res = -top[0] + nums[i]
            maxHeap.put([-res, i])
        return res
```

###  1.380. <a name='DetermineifStringHalvesAreAlike'></a>1704 Determine if String Halves Are Alike

[小明](https://www.bilibili.com/video/BV1WA41157sf?spm_id_from=333.999.0.0)

###  1.381. <a name='MaximumXORWithanElementFromArray'></a>1707. Maximum XOR With an Element From Array

[花花酱](https://www.bilibili.com/video/BV13v411t742?spm_id_from=333.999.0.0)

###  1.382. <a name='MinimumOperationstoMakeaSubsequence'></a>1713. Minimum Operations to Make a Subsequence

[花花酱](https://www.bilibili.com/video/BV1Yy4y127DQ?spm_id_from=333.999.0.0)

###  1.383. <a name='SwappingNodesinaLinkedList'></a>1721 Swapping Nodes in a Linked List

[小明](https://www.bilibili.com/video/BV1Ji4y1P7Xc?spm_id_from=333.999.0.0)

###  1.384. <a name='LargestSubmatrixWithRearrangements'></a>1727. Largest Submatrix With Rearrangements

[花花酱](https://www.bilibili.com/video/BV1XT4y1N7gy?spm_id_from=333.999.0.0)

###  1.385. <a name='PalindromePartitioningIV'></a>1745. Palindrome Partitioning IV

[花花酱](https://www.bilibili.com/video/BV1yo4y1R75T?spm_id_from=333.999.0.0)

###  1.386. <a name='MinimumLimitofBallsinaBag'></a>1760. Minimum Limit of Balls in a Bag

[花花酱](https://www.bilibili.com/video/BV1bK4y1H7Ly?spm_id_from=333.999.0.0)

###  1.387. <a name='MaximumScorefromPerformingMultiplication'></a>1770. Maximum Score from Performing Multiplication

[花花酱](https://www.bilibili.com/video/BV1Li4y1T7j6?spm_id_from=333.999.0.0)

###  1.388. <a name='MaximizePalindromeLengthFromSubsequences'></a>1771. Maximize Palindrome Length From Subsequences

[花花酱](https://www.bilibili.com/video/BV1Cp4y1H7Xq?spm_id_from=333.999.0.0)

###  1.389. <a name='EqualSumArraysWithMinimumNumberofOperatio'></a>1775. Equal Sum Arrays With Minimum Number of Operatio

[花花酱](https://www.bilibili.com/video/BV1Di4y1T7nF?spm_id_from=333.999.0.0)

###  1.390. <a name='DijkstraNumberofRestrictedPathsFromFirsttoLastNode'></a>1786. 【Dijkstra🚗】 Number of Restricted Paths From First to Last Node

[花花酱](https://www.bilibili.com/video/BV1Df4y147TB?spm_id_from=333.999.0.0)

###  1.391. <a name='MaximumAveragePassRatio'></a>1792. Maximum Average Pass Ratio

[花花酱](https://www.bilibili.com/video/BV1qb4y197zc?spm_id_from=333.999.0.0)

###  1.392. <a name='MaximizeScoreAfterNOperations'></a>1799. Maximize Score After N Operations

[花花酱](https://www.bilibili.com/video/BV1Sf4y1x7Cy?spm_id_from=333.999.0.0)

###  1.393. <a name='MaximumNumberofGroupsGettingFreshDonuts'></a>1815. Maximum Number of Groups Getting Fresh Donuts

[花花酱](https://www.bilibili.com/video/BV1CU4y187tk?spm_id_from=333.999.0.0)

###  1.394. <a name='FrequencyoftheMostFrequentElement'></a>1838. Frequency of the Most Frequent Element

[花花酱](https://www.bilibili.com/video/BV1Ai4y1P7Yt?spm_id_from=333.999.0.0)

###  1.395. <a name='ClosestRoom'></a>1847. Closest Room

[花花酱](https://www.bilibili.com/video/BV1cy4y1x7sz?spm_id_from=333.999.0.0)

###  1.396. <a name='StoneGameVIII'></a>1872. Stone Game VIII

[花花酱](https://www.bilibili.com/video/BV1vb4y1z7wx?spm_id_from=333.999.0.0)

###  1.397. <a name='1976.Dijkstra'></a> 1976. 【Dijkstra🚗】到达目的地的方案数

https://cloud.tencent.com/developer/article/1873122

```py
迪杰斯特拉 最短路径，优先队列
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        from queue import PriorityQueue
        q = PriorityQueue()
        g = [[] for _ in range(n)]
        for r in roads:
            g[r[0]].append((r[1], r[2]))
            g[r[1]].append((r[0], r[2]))
        time_roadnums = [[int(1e15), 0] for _ in range(n)]
        # 存储 【最短时间，方案数】
        time_roadnums[0][0] = 0
        time_roadnums[0][1] = 1
        q.put([0, 0]) # [时间，id] 第一个参数小的优先
        while not q.empty():
            t, id = q.get()
            for it in g[id]:
                nid, times = it
                if time_roadnums[nid][0] > t+times: # 更短时间
                    time_roadnums[nid][0] = t+times
                    time_roadnums[nid][1] = time_roadnums[id][1] # 方案数清空，换成当前的
                    q.put([t+times, nid])
                elif time_roadnums[nid][0] == t+times: # 相同时间
                    time_roadnums[nid][1] += time_roadnums[id][1]  # 方案数累加             
        return time_roadnums[n-1][1]%int(1e9+7)
```
