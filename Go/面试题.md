<https://golang.design/go-questions/slice/vs-array/>

<https://space.bilibili.com/396637753>

<https://space.bilibili.com/490799619>

<https://space.bilibili.com/567195437>

<https://space.bilibili.com/497224134>

<https://www.bilibili.com/video/BV1hv411x7we>

<https://www.bilibili.com/video/BV1EL4y1P7hh>

<https://space.bilibili.com/401571418>

<https://www.bilibili.com/video/BV1Ju41167BL>

<https://space.bilibili.com/1897036286/channel/collectiondetail?sid=569368>

<https://github.com/aceld/golang>

<https://github.com/xiaobaiTech/golangFamily>

[为什么大公司一定要使用DevOps?](https://www.bilibili.com/video/BV1Ra41127ko)

## ★ 对go语言认识？为什么学go？用go做过什么？

部署起来极其方便

go build server.go

静态语言，在【编译的时候】检查出大多数问题

语言层面的并发

有强大的标准库：

1. 高效的 runtime 系统调度机制
2. 高效的 垃圾回收
3. 丰富的 标准库：包括【网络通信、socket、RPC协议、同步机制、进程、线程、Goroutine、channel】等一些【并发操作】

简单易学

1. 25个关键字
2. 内嵌C语言
3. 面向对象(继承、多态、封装)
4. 跨平台

大厂领军

1. google做的
2. kubernetes、docker
3. facebook
4. tencent腾讯
5. 百度

编译和执行速度都名列前茅

应用场景：云计算平台、数据库、微服务、区块链

缺点：

1. 【包管理】不完善，第三库，都托管在github上，对代码稳定性有很大风险
2. 没有 Exception 只有 Error

## ★ Go main函数的特点？

函数名的【花括号】和 main 在【同一行】

## golang 基础 interface 等基本原理搞清楚，gmp goorutine 基本原理，】

## 关于go写的网站，用过框架吗（没有

## golang 代码，分析一段调用了多次defer XXX的函数输出结果

### 1. 下面这段代码的输出什么?

```go
func Test1(t *testing.T) {
 defer func() { fmt.Println("打印前") }()
 defer func() { fmt.Println("打印中") }()
 defer func() { fmt.Println("打印后") }()
 panic("触发异常")
 // 出现panic语句的时候，会先按照 `defer` 的后进先出顺序执行，最后才会执行panic。
}
```

输出

>打印后
>
>打印中
>
>打印前
>
>panic: 触发异常

### 22. 下列代码输出什么？

```go
func f(i int) {
 fmt.Println(i)
}
func Test22(t *testing.T) {
 i := 5
 defer f(i)
 i = i + 10
}
```

输出

> 5
>
> f() 函数的参数在执行 defer 语句的时候会保存一份副本，
> 在实际调用 f() 函数时用，所以是 5.

### 31. 下面代码输出什么？

```go
type Person struct {
 age int
}

func Test31(t *testing.T) {
 person := &Person{28}
 // 1. person.age 此时是将 28 当做 [defer 函数] 的 [参数]，
 // 会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，
 // 即输出 28；
 defer fmt.Println(person.age)
 
 
 // 2. defer 缓存的是结构体 Person{28} 的地址，
 // 最终 Person{28} 的 age 被重新赋值为 29，
 // 所以 defer 语句最后执行的时候，
 // 依靠缓存的地址取出的 age 便是 29，即输出 29；
 defer func(p *Person) {
  fmt.Println(p.age)
 }(person)
 
 // 3. 闭包引用，输出 29；
 defer func() {
  fmt.Println(person.age)
 }()
 
 person.age = 29
}
```

输出

> 29 29 28

### 82. 下列代码输出什么?

```go
func Test82(t *testing.T) {
 defer func() {
  fmt.Println(recover())
 }()
 defer func() {
  // recover() 必须在 defer函数体内使用才有效
  defer fmt.Println(recover())
  panic(1)
 }()
 // 所以 defer recover() 是无效的
 defer recover()
 panic(2)
}
```

答案

> 2 1, 

### 85. 下列代码有什么问题?

```go
func main() {
    f, err := os.Open("file")
    defer f.Close()
    if err != nil {
        return
    }

    b, err := ioutil.ReadAll(f)
    println(string(b))
}
```

答案

> 应该先判断 err, 再用defer 关闭文件句柄

## 28. 下面属于关键字的是（）

* A. `func`
* B. `struct`
* C. class
* D. `defer`

**答：A、B、D**Z

## 1 Golang中除了加【Mutex锁】以外还有哪些方式安全读写【共享变量】

| 方法  | 并发原语  |  备注  |
|---|---|---|
| 不修改  | `Sync.Once`  | 变量只初始化一次  |
| 允许1个goroutine访问变量  | `Channel`  | 不通过【共享变量】来通信，通过channel来【共享变量】  |
| 允许n个goroutine访问变量，but同一时间只允许1个goroutine访问变量  | `sync.Mutex`、`sync.RWMutex`、`原子操作` | 锁机制  |


## ★ 【无缓冲Channel】的发送和接收是否同步

## ★ go有缓冲与无缓冲的channel区别，在一个已经关闭了的channel发送&接受数据会发生什么

## ★ 【Golang并发机制】以及它所使用的【CSP并发模型】

## ★ Golang中常用的【并发模型】

1. 【共享内存】并发模型：需要获得该资源的【互斥锁】
   - 高耦合
2. 【CSP】并发模型：channel传递goroutine之间的信息
   - 松耦合，生产者消费者模型

## ★ Go中对nil的Slice和【空Slice】的处理是一致的吗

## ★ go的slice和array什么区别？传参的区别呢？

- slice是基于array实现的，它的底层是array，
- 它自己本身非常小，可以理解为对底层array的抽象。
- 因为基于array实现，所以它的底层的内存是连续分配的，
- 效率非常高，还可以通过【索引】获得【数据】。
- slice本身并不是动态array或者array【指针】。
- 它内部实现的数据结构通过【指针】引用底层array，设定相关属性将数据读写操作限定在指定的区域内。
- slice本身是一个只读对象，其工作机制类似array【指针】的一种封装。
- slice对象非常小，是因为它是只有 3 个字段的数据结构：
  1. 指向底层array的【指针】
  2. slice的长度
  3. slice的容量

## [3]int 和 [4]int 是同一个类型吗？

不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。

## slice 的底层

slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。

数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。

而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。

数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。

```go
// runtime/slice.go
type slice struct {
 array unsafe.Pointer // 元素指针
 len   int // 长度 
 cap   int // 容量
}
```

## 为什么 slice 元素是可寻址的？

因为 slice 底层结构其实是一个匿名array，既然array的元素是可寻址的，那slice的元素自然也可以寻址。

## ★【协程、线程、进程】的区别？延申讲到Go语言实现协程？线程独占哪些资源？

## ★ 如果一个【线程】卡住了，【进程】会不会卡住？

## ★ 如果一个【协程】卡住了，【线程】会不会卡住？

## ★ go协程交替打印奇数偶数

## ★ Golang的【内存模型】中为什么【小对象】多了会造成【GC压力】

## 8 Go中【数据竞争】问题怎么解决

【数据竞争】的发生条件：

1. 只要有2个以上goroutine并发访问【同一变量】
2. 其中1个是【写操作】

比如：

```go
package main

import "fmt"

func main() {
  i := 0
  go func() {
    i++ // 写
  }()

  fmt.Println(i) //读
}
```

排查方式：

【go命令行】有个【参数race】可以检测代码中的【数据竞争】

```s
go run -race main.go
```





## 9 什么是channel，为什么它可以做到【线程安全】

## ★ Golang垃圾回收算法

分代收集：java

标记-清除：Golang（三色标记法 + 混合写屏障技术）

## ★ GC的触发条件

1. 主动触发：
   - 调用runtime.GC()，触发GC

2. 被动触发：
   - 定时触发：默认2分钟，由 runtime.forcegcperiod 控制
   - 内存分配：当前【heap内存占用】是【上次GC结束】后【占用内存的2倍】时，触发GC，由GOGC控制

## ★ go gc过程

1. 标记准备：
   - stop the world 暂停程序
   - 启动【marker worker goroutine 标记工作协程】
   - 启动【写屏障】
   - 将【root对象】放入【标记队列】
   - start the world 取消程序暂停

2. 标记开始：
   - 从【标记队列】取出对象，标记为【黑色】
   - 找到可以达到的对象，放入【标记队列】
   - 重复上述过程，直到【标记队列】为空
   - 在扫描过程中，如果程序【新建or修改】了对象，就会触发【写屏障】，将对象放入单独的【marking队列】，也就是标记为【灰色】

3. 标记终止：
   - stop the world 暂停程序
   - rescan：处理【写屏障】产生的【marking队列】
   - 关闭【写屏障】
   - start the world 取消程序暂停

4. 清理：白色对象

-----------------------

三色标记法：

1. 灰色：对象在【标记队列】中等待
2. 黑色：对象已被标记，gcmarkBit对应位为 1
3. 白色：对象未被标记，gcmarkBit对应位为 0

step1：创建、灰黑白，3个集合

step2：将所有对象放入【白色集合】中

step3：遍历所有root对象，把【遍历】到的对象从【白色集合】放入【灰色集合】

step4：遍历【灰色集合】，将【灰色对象】从【白色集合】放入【灰色集合】，并且【自身】标记为【黑色】

step5：重复 step4，直到【灰色集合】中无任何对象

step6：收集所有【白色对象】

其中用到2个机制：

1. **写屏障**：
   - 该技术，可以让 goroutine 与 GC 同时运行。
   - 从而，大大减少STW的时间。
   - 【写屏障】在GC特定的时间开启：开启后，【指针传递】时会把【指针标记】，即【本轮不回收】，下次GC时再决定
2. **辅助GC**：
   - 该技术，【辅助GC】做一部分工作。
   - 在GC过程中，【mutator线程】会【并发运行】

root对象包括：

1. 全局变量：【编译期】就能确定那些存在于程序【整个生命周期】的变量
2. 执行栈：每个goroutine都包含自己的【执行栈】，这些【执行栈】指向【堆内存】
3. 寄存器：【寄存器】的值【参与计算】，可能表示一个指针，指向【堆内存】

## GC如何调优？

1. 增大`GOGC`的值，从而减低GC频率
2. 限制【`Goroutine`的数量】，从而控制【内存分配速度】

代码层面：

1. 少量使用 + 来连接 `string`
2. `slice`提前分配内存，来降低【扩容】带来的copy
3. 避免`map` key 过多，导致【扫描时间】增加
4. 变量复用，减少【对象分配】，例如，使用`sync.Pool`来复用需要频繁创建的对象

## 12 Go的GPM如何调度

## ★ 【并发编程】概念是什么

## 14 Go语言的【栈空间管理】是怎么样的

## 15 Goroutine和Channel的作用分别是什么

## 16 怎么查看【Goroutine的数量】

## ★ Go中的锁有哪些

## ★ 用Go锁怎么解决缓存击穿的问题

## 18 怎么限制【Goroutine的数量】

## 19 Channel是同步的，还是异步的

## 20 【Goroutine和线程】的区别

## 21 Go的Struct能不能比较

## 22 Go的【defer原理】是什么

## 23 Go的select可以用于什么

## ★ Go的【Context包】的用途是什么

## 25 【Go主协程】如何等其余协程完再操作

## ★ Go的Slice如何扩容

<https://www.bilibili.com/video/BV1JP4y1g7kw>

<https://golang.design/go-questions/slice/grow/>

在1.18版本之前：

在原来的slice容量oldcap小于1024的时候，新 slice 的容量newcap的确是oldcap的2倍。

但是，当oldcap大于等于 1024 的时候，情况就有变化了。当向 slice 中添加元素 1280 的时候，原来的slice 的容量为 1280，之后newcap变成了 1696，两者并不是 1.25 倍的关系（1696/1280=1.325）。添加完 1696 后，新的容量 2304 当然也不是 1696 的 1.25 倍。

在1.18版本之后：

在原来的slice 容量oldcap小于256的时候，新 slice 的容量newcap的确是oldcap 的2倍。

但是，当oldcap容量大于等于 256 的时候，情况就有变化了。当向 slice 中添加元素 512 的时候，老 slice 的容量为 512，之后变成了 848，两者并没有符合newcap = oldcap+(oldcap+3*256)/4 的策略（512+（512+3*256）/4）=832。添加完 848 后，新的容量 1280 当然也不是 按照之前策略所计算出的的1252。

难道现在网上各种文章中的扩容策略并不是正确的吗。我们直接搬出源码：源码面前，了无秘密。

从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 growslice 函数，所以我们直接看它的代码。

假设现在有一个长度为 2 的slice，对其进行扩容，增加三个元素

```go
sli := []int{1,2}
sli = append(sli, 3, 4, 5)
```

对于扩容后的slice，长度为 5，这一点没有任何争议。

但容量呢？难道也是 5？

经过运行验证，实际的容量为 6 。

什么情况？这 6 是如何计算出来的呢？



元素类型为 int 的slice，每个 int 占用为 8 个字节，由于我们计算出的 newcap 为 5，因此新的slice，最少最少要占用 5*8 = 40 个字节。

如果是 32 byte，就是不够用了，

因此 只能选择 48 这个档位去分配内存。

有了实际分配的内存，再反回去计算容量，就是扩容后真实的slice容量，也就是 48/8 = 6

## Go 中切片扩容的策略是这样的

⚫ 首先判断，如果【新申请容量】大于 2 倍的旧容量，最终容量就是【新申请容量】
⚫ 否则判断，如果【旧切片长度】小于 1024，则最终容量就是旧容量的两倍
⚫ 否则判断，如果【旧切片长度】大于等于 1024，则最终容量从旧容量开始循环
增加原来的 1/4, 直到最终容量大于等于新申请的容量
⚫ 如果最终容量计算值溢出，则最终容量就是【新申请容量】

## ★ Go中的map如何实现【顺序读取】

## ★ go的map怎么实现的，Map底层介绍？出现【哈希碰撞】的情况下，Map底层会发生什么？Map删除一个数据，底层会发生什么

## ★ Map多个协程去写有什么问题，怎么解决

## ★ 写代码：用waitGroup控制多协程去读map

WaitGroup 有 3 个方法：

1. WaitGroup.Add()：【增减】请求的【goroutine数量】，add(n) 将导致 counter += n
2. WaitGroup.Done()：相对于 Add(-1)，将导致 counter -= 1，当 counter 为 0 时，通过【信号量】唤醒【waiter线程】
3. WaitGroup.Wait()：会将 Waiter++，同时通过【信号量】阻塞当前的goroutine

```go
import (
	"sync"
)

func main() {
	var wg sync.WaitGroup
	for i := 1; i <= 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			println("hello")
		}()
	}
	wg.Wait()
}
```

```go
import (
	"fmt"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(i int) {
			fmt.Printf("i:%d\n", i)
			wg.Done()
		}(i)
	}

	wg.Wait()
	//i:4
	//i:0
	//i:1
	//i:2
	//i:3
}

```

### 86. 下列代码有什么问题?

```go
func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        fmt.Println("1")
        wg.Done()
        wg.Add(1)
    }()
    wg.Wait()
}
```

答案

> 协程里面，使用 wg.Add(1) 但是没有 wg.Done()，导致 panic()。

### 90. 下列代码有什么问题?

```go
func main() {

    wg := sync.WaitGroup{}

    for i := 0; i < 5; i++ {
        go func(wg sync.WaitGroup, i int) {
            wg.Add(1)
            fmt.Printf("i:%d\n", i)
            wg.Done()
        }(wg, i)
    }

    wg.Wait()

    fmt.Println("exit")
}
```

答案
>
> 1. 在协程中使用了 `wg.Add(1)`
>
> 2. 使用了 sync.WaitGroup 副本

修复

```go
func main() {

    wg := sync.WaitGroup{}

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(i int) {
            fmt.Printf("i:%d\n", i)
            wg.Done()
        }(i)
    }

    wg.Wait()

    fmt.Println("exit")
}
```

## ★ 写代码：用两个【协程】和【锁】去写map

## ★ map怎么实现【并发安全】。读写锁

## ★ sync包中map（没使用过

## 28 Go中CAS是怎么回事

## 29 Go中的【逃逸分析】是什么

## 30 Go【值接收者】和【【指针】接收者】的区别

## spanClass

`Go 的内存分配规律`

go 有 68 种不同大小的 spanClass，用于【小对象】的分配

```s
//   class   bytes/obj  bytes/span  objects  tail waste  max waste
//     ID    class字节数 页数*页大小  对象个数  tail waste  内存碎片
//     1          8        8192     1024           0     87.50%
//     2         16        8192      512           0     43.75%
//     3         32        8192      256           0     46.88%
//     4         48        8192      170          32     31.52%
...
//    17        256        8192       32           0      5.86%
//    18        288        8192       28         128     12.16%
//    19        320        8192       25         192     11.80%
//    20        352        8192       23          96      9.88%
//    21        384        8192       21         128      9.51%
//    22        416        8192       19         288     10.71%
//    23        448        8192       18         128      8.37%
//    24        480        8192       17          32      6.82%
//    25        512        8192       16           0      6.05%
...
//    66      32768       32768        1           0     12.50%

从上面这个表格中，可以总结出一些规律。

在小于16字节时，每次以8个字节增加

当大于16小于2^8时，每次以16字节增加

当大于28小于29时以32字节增加
```

## 31 Go的【对象】在【内存】中是怎样分配的

分配对象：

- 微对象(0, 16B)：
  1. 先使用【线程缓存】上的【微型分配器】，再 → 
  2. 【线程缓存】
  3. 【中心缓存】
  4. 【页堆】
- 小对象[16b,32kB]：
  1. 【线程缓存】
  2. 【中心缓存】
  3. 【页堆】
- 大对象[32kb,+无穷大]
  1. 【页堆】


## 32 栈的【内存】是怎么分配的

## 33 【堆内存】管理怎么分配的

分配组件：

- **mspan**：【内存管理】的【基本单元】，每个mspan都管理大小为 8kb 的 page，npages
  1. npages 不是【操作系统】的【内存页】，是【操作系统】【内存页】的【整数倍】
  2. npages：【内存存储】的【基本单元】，对象放在 npages 中

- **mcache：线程缓存** - 管理线程的mspan

每个goroutine绑定的p都有一个mcache字段

- **mcentral：全局缓存** - 管理全局的mspan

- **mheap：页堆** - 管理所有的【动态分配内存】

----------------------------------

分配流程:

1. 首先，计算对象的【大小】
2. 使用 mcache 中【对应大小规格的块】
3. 如果 mcache 中没有可用的块，则向 mcentral 申请
4. 如果 mcentral 中没有可用的块，则向 mheap 申请，
5. 并根据算法找到【最合适的 mspan】
6. 如果申请到的 mspan 超出【对象大小】，则会根据【需求】进行切分，以返回用户所需的【页数】，
7. 剩下的【页】构成一个新的 mspan 放回 mheap 的【空闲列表】
8. 如果mheap中没有可用的span，则向操作系统申请一系列新的page。

## 35 在Go函数中为什么会发生【内存泄露】

## ★ Go中new和make的区别

## 37 G0的作用

## 41 Go中的http包的实现原理

## 42 Goroutine发生了【泄漏】如何检测

## 43 Go函数返回【局部变量】的【指针】是否安全

## 44 Go中两个Nil可能不相等吗

## 46 为何【GPM调度】要有P
